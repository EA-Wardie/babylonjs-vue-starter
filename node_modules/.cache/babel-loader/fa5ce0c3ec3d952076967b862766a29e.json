{"ast":null,"code":"import \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { GPUParticleSystem } from \"./gpuParticleSystem.js\";\nimport { ParticleSystemSet } from \"./particleSystemSet.js\";\nimport { ParticleSystem } from \"./particleSystem.js\";\nimport { WebRequest } from \"../Misc/webRequest.js\";\n/**\n * This class is made for on one-liner static method to help creating particle system set.\n */\n\nvar ParticleHelper =\n/** @class */\nfunction () {\n  function ParticleHelper() {}\n  /**\n   * Create a default particle system that you can tweak\n   * @param emitter defines the emitter to use\n   * @param capacity defines the system capacity (default is 500 particles)\n   * @param scene defines the hosting scene\n   * @param useGPU defines if a GPUParticleSystem must be created (default is false)\n   * @returns the new Particle system\n   */\n\n\n  ParticleHelper.CreateDefault = function (emitter, capacity, scene, useGPU) {\n    if (capacity === void 0) {\n      capacity = 500;\n    }\n\n    if (useGPU === void 0) {\n      useGPU = false;\n    }\n\n    var system;\n\n    if (useGPU) {\n      system = new GPUParticleSystem(\"default system\", {\n        capacity: capacity\n      }, scene);\n    } else {\n      system = new ParticleSystem(\"default system\", capacity, scene);\n    }\n\n    system.emitter = emitter;\n    system.particleTexture = new Texture(\"https://www.babylonjs.com/assets/Flare.png\", system.getScene());\n    system.createConeEmitter(0.1, Math.PI / 4); // Particle color\n\n    system.color1 = new Color4(1.0, 1.0, 1.0, 1.0);\n    system.color2 = new Color4(1.0, 1.0, 1.0, 1.0);\n    system.colorDead = new Color4(1.0, 1.0, 1.0, 0.0); // Particle Size\n\n    system.minSize = 0.1;\n    system.maxSize = 0.1; // Emission speed\n\n    system.minEmitPower = 2;\n    system.maxEmitPower = 2; // Update speed\n\n    system.updateSpeed = 1 / 60;\n    system.emitRate = 30;\n    return system;\n  };\n  /**\n   * This is the main static method (one-liner) of this helper to create different particle systems\n   * @param type This string represents the type to the particle system to create\n   * @param scene The scene where the particle system should live\n   * @param gpu If the system will use gpu\n   * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n   * @returns the ParticleSystemSet created\n   */\n\n\n  ParticleHelper.CreateAsync = function (type, scene, gpu, capacity) {\n    if (gpu === void 0) {\n      gpu = false;\n    }\n\n    if (!scene) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    var token = {};\n\n    scene._addPendingData(token);\n\n    return new Promise(function (resolve, reject) {\n      if (gpu && !GPUParticleSystem.IsSupported) {\n        scene._removePendingData(token);\n\n        return reject(\"Particle system with GPU is not supported.\");\n      }\n\n      Tools.LoadFile(\"\".concat(ParticleHelper.BaseAssetsUrl, \"/systems/\").concat(type, \".json\"), function (data) {\n        scene._removePendingData(token);\n\n        var newData = JSON.parse(data.toString());\n        return resolve(ParticleSystemSet.Parse(newData, scene, gpu, capacity));\n      }, undefined, undefined, undefined, function () {\n        scene._removePendingData(token);\n\n        return reject(\"An error occurred with the creation of your particle system. Check if your type '\".concat(type, \"' exists.\"));\n      });\n    });\n  };\n  /**\n   * Static function used to export a particle system to a ParticleSystemSet variable.\n   * Please note that the emitter shape is not exported\n   * @param systems defines the particle systems to export\n   * @returns the created particle system set\n   */\n\n\n  ParticleHelper.ExportSet = function (systems) {\n    var set = new ParticleSystemSet();\n\n    for (var _i = 0, systems_1 = systems; _i < systems_1.length; _i++) {\n      var system = systems_1[_i];\n      set.systems.push(system);\n    }\n\n    return set;\n  };\n  /**\n   * Creates a particle system from a snippet saved in a remote file\n   * @param name defines the name of the particle system to create (can be null or empty to use the one from the json data)\n   * @param url defines the url to load from\n   * @param scene defines the hosting scene\n   * @param gpu If the system will use gpu\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n   * @returns a promise that will resolve to the new particle system\n   */\n\n\n  ParticleHelper.ParseFromFileAsync = function (name, url, scene, gpu, rootUrl, capacity) {\n    if (gpu === void 0) {\n      gpu = false;\n    }\n\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    return new Promise(function (resolve, reject) {\n      var request = new WebRequest();\n      request.addEventListener(\"readystatechange\", function () {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            var serializationObject = JSON.parse(request.responseText);\n            var output = void 0;\n\n            if (gpu) {\n              output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\n            } else {\n              output = ParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\n            }\n\n            if (name) {\n              output.name = name;\n            }\n\n            resolve(output);\n          } else {\n            reject(\"Unable to load the particle system\");\n          }\n        }\n      });\n      request.open(\"GET\", url);\n      request.send();\n    });\n  };\n  /**\n   * Creates a particle system from a snippet saved by the particle system editor\n   * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\n   * @param scene defines the hosting scene\n   * @param gpu If the system will use gpu\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n   * @returns a promise that will resolve to the new particle system\n   */\n\n\n  ParticleHelper.CreateFromSnippetAsync = function (snippetId, scene, gpu, rootUrl, capacity) {\n    var _this = this;\n\n    if (gpu === void 0) {\n      gpu = false;\n    }\n\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    if (snippetId === \"_BLANK\") {\n      var system = this.CreateDefault(null);\n      system.start();\n      return Promise.resolve(system);\n    }\n\n    return new Promise(function (resolve, reject) {\n      var request = new WebRequest();\n      request.addEventListener(\"readystatechange\", function () {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            var serializationObject = JSON.parse(snippet.particleSystem);\n            var output = void 0;\n\n            if (gpu) {\n              output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\n            } else {\n              output = ParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\n            }\n\n            output.snippetId = snippetId;\n            resolve(output);\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", _this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  };\n  /**\n   * Gets or sets base Assets URL\n   */\n\n\n  ParticleHelper.BaseAssetsUrl = ParticleSystemSet.BaseAssetsUrl;\n  /** Define the Url to load snippets */\n\n  ParticleHelper.SnippetUrl = \"https://snippet.babylonjs.com\";\n  return ParticleHelper;\n}();\n\nexport { ParticleHelper };","map":{"version":3,"mappings":"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","names":["Tools","Color4","Texture","EngineStore","GPUParticleSystem","ParticleSystemSet","ParticleSystem","WebRequest","ParticleHelper","emitter","capacity","scene","useGPU","system","particleTexture","getScene","createConeEmitter","Math","PI","color1","color2","colorDead","minSize","maxSize","minEmitPower","maxEmitPower","updateSpeed","emitRate","type","gpu","LastCreatedScene","token","_addPendingData","Promise","resolve","reject","IsSupported","_removePendingData","LoadFile","BaseAssetsUrl","concat","data","newData","JSON","parse","toString","Parse","undefined","systems","set","_i","push","name","url","rootUrl","request","addEventListener","readyState","status","serializationObject","responseText","output","open","send","snippetId","CreateDefault","start","snippet","jsonPayload","particleSystem","_this","SnippetUrl","replace"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Particles/particleHelper.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { IParticleSystem } from \"./IParticleSystem\";\r\nimport { GPUParticleSystem } from \"./gpuParticleSystem\";\r\nimport { ParticleSystemSet } from \"./particleSystemSet\";\r\nimport { ParticleSystem } from \"./particleSystem\";\r\nimport { WebRequest } from \"../Misc/webRequest\";\r\n/**\r\n * This class is made for on one-liner static method to help creating particle system set.\r\n */\r\nexport class ParticleHelper {\r\n    /**\r\n     * Gets or sets base Assets URL\r\n     */\r\n    public static BaseAssetsUrl = ParticleSystemSet.BaseAssetsUrl;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = \"https://snippet.babylonjs.com\";\r\n\r\n    /**\r\n     * Create a default particle system that you can tweak\r\n     * @param emitter defines the emitter to use\r\n     * @param capacity defines the system capacity (default is 500 particles)\r\n     * @param scene defines the hosting scene\r\n     * @param useGPU defines if a GPUParticleSystem must be created (default is false)\r\n     * @returns the new Particle system\r\n     */\r\n    public static CreateDefault(emitter: Nullable<AbstractMesh | Vector3>, capacity = 500, scene?: Scene, useGPU = false): IParticleSystem {\r\n        let system: IParticleSystem;\r\n\r\n        if (useGPU) {\r\n            system = new GPUParticleSystem(\"default system\", { capacity: capacity }, scene!);\r\n        } else {\r\n            system = new ParticleSystem(\"default system\", capacity, scene!);\r\n        }\r\n\r\n        system.emitter = emitter;\r\n        system.particleTexture = new Texture(\"https://www.babylonjs.com/assets/Flare.png\", system.getScene());\r\n        system.createConeEmitter(0.1, Math.PI / 4);\r\n\r\n        // Particle color\r\n        system.color1 = new Color4(1.0, 1.0, 1.0, 1.0);\r\n        system.color2 = new Color4(1.0, 1.0, 1.0, 1.0);\r\n        system.colorDead = new Color4(1.0, 1.0, 1.0, 0.0);\r\n\r\n        // Particle Size\r\n        system.minSize = 0.1;\r\n        system.maxSize = 0.1;\r\n\r\n        // Emission speed\r\n        system.minEmitPower = 2;\r\n        system.maxEmitPower = 2;\r\n\r\n        // Update speed\r\n        system.updateSpeed = 1 / 60;\r\n\r\n        system.emitRate = 30;\r\n\r\n        return system;\r\n    }\r\n\r\n    /**\r\n     * This is the main static method (one-liner) of this helper to create different particle systems\r\n     * @param type This string represents the type to the particle system to create\r\n     * @param scene The scene where the particle system should live\r\n     * @param gpu If the system will use gpu\r\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\r\n     * @returns the ParticleSystemSet created\r\n     */\r\n    public static CreateAsync(type: string, scene: Nullable<Scene>, gpu: boolean = false, capacity?: number): Promise<ParticleSystemSet> {\r\n        if (!scene) {\r\n            scene = EngineStore.LastCreatedScene;\r\n        }\r\n\r\n        const token = {};\r\n\r\n        scene!._addPendingData(token);\r\n\r\n        return new Promise((resolve, reject) => {\r\n            if (gpu && !GPUParticleSystem.IsSupported) {\r\n                scene!._removePendingData(token);\r\n                return reject(\"Particle system with GPU is not supported.\");\r\n            }\r\n\r\n            Tools.LoadFile(\r\n                `${ParticleHelper.BaseAssetsUrl}/systems/${type}.json`,\r\n                (data) => {\r\n                    scene!._removePendingData(token);\r\n                    const newData = JSON.parse(data.toString());\r\n                    return resolve(ParticleSystemSet.Parse(newData, scene!, gpu, capacity));\r\n                },\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                () => {\r\n                    scene!._removePendingData(token);\r\n                    return reject(`An error occurred with the creation of your particle system. Check if your type '${type}' exists.`);\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Static function used to export a particle system to a ParticleSystemSet variable.\r\n     * Please note that the emitter shape is not exported\r\n     * @param systems defines the particle systems to export\r\n     * @returns the created particle system set\r\n     */\r\n    public static ExportSet(systems: IParticleSystem[]): ParticleSystemSet {\r\n        const set = new ParticleSystemSet();\r\n\r\n        for (const system of systems) {\r\n            set.systems.push(system);\r\n        }\r\n\r\n        return set;\r\n    }\r\n\r\n    /**\r\n     * Creates a particle system from a snippet saved in a remote file\r\n     * @param name defines the name of the particle system to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @param gpu If the system will use gpu\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\r\n     * @returns a promise that will resolve to the new particle system\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string, scene: Scene, gpu: boolean = false, rootUrl: string = \"\", capacity?: number): Promise<IParticleSystem> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const serializationObject = JSON.parse(request.responseText);\r\n                        let output: IParticleSystem;\r\n\r\n                        if (gpu) {\r\n                            output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\r\n                        } else {\r\n                            output = ParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\r\n                        }\r\n\r\n                        if (name) {\r\n                            output.name = name;\r\n                        }\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the particle system\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a particle system from a snippet saved by the particle system editor\r\n     * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\r\n     * @param scene defines the hosting scene\r\n     * @param gpu If the system will use gpu\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\r\n     * @returns a promise that will resolve to the new particle system\r\n     */\r\n    public static CreateFromSnippetAsync(snippetId: string, scene: Scene, gpu: boolean = false, rootUrl: string = \"\", capacity?: number): Promise<IParticleSystem> {\r\n        if (snippetId === \"_BLANK\") {\r\n            const system = this.CreateDefault(null);\r\n            system.start();\r\n            return Promise.resolve(system);\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        const serializationObject = JSON.parse(snippet.particleSystem);\r\n                        let output: IParticleSystem;\r\n\r\n                        if (gpu) {\r\n                            output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\r\n                        } else {\r\n                            output = ParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\r\n                        }\r\n                        output.snippetId = snippetId;\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}