{"ast":null,"code":"import \"core-js/modules/es.array.concat.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\n/**\n * Creates the VertexData for a tiled plane\n * @see https://doc.babylonjs.com/divingDeeper/mesh/creation/set/tiled_plane\n * @param options an object used to set the following optional parameters for the tiled plane, required but can be empty\n * * pattern a limited pattern arrangement depending on the number\n * * size of the box\n * * width of the box, overwrites size\n * * height of the box, overwrites size\n * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\n * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\n * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\n * * alignVertical places whole tiles aligned to the center, left or right of a column\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * @param options.pattern\n * @param options.tileSize\n * @param options.tileWidth\n * @param options.tileHeight\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.alignHorizontal\n * @param options.alignVertical\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @returns the VertexData of the tiled plane\n */\n\nexport function CreateTiledPlaneVertexData(options) {\n  var flipTile = options.pattern || Mesh.NO_FLIP;\n  var tileWidth = options.tileWidth || options.tileSize || 1;\n  var tileHeight = options.tileHeight || options.tileSize || 1;\n  var alignH = options.alignHorizontal || 0;\n  var alignV = options.alignVertical || 0;\n  var width = options.width || options.size || 1;\n  var tilesX = Math.floor(width / tileWidth);\n  var offsetX = width - tilesX * tileWidth;\n  var height = options.height || options.size || 1;\n  var tilesY = Math.floor(height / tileHeight);\n  var offsetY = height - tilesY * tileHeight;\n  var halfWidth = tileWidth * tilesX / 2;\n  var halfHeight = tileHeight * tilesY / 2;\n  var adjustX = 0;\n  var adjustY = 0;\n  var startX = 0;\n  var startY = 0;\n  var endX = 0;\n  var endY = 0; //Part Tiles\n\n  if (offsetX > 0 || offsetY > 0) {\n    startX = -halfWidth;\n    startY = -halfHeight;\n    endX = halfWidth;\n    endY = halfHeight;\n\n    switch (alignH) {\n      case Mesh.CENTER:\n        offsetX /= 2;\n        startX -= offsetX;\n        endX += offsetX;\n        break;\n\n      case Mesh.LEFT:\n        endX += offsetX;\n        adjustX = -offsetX / 2;\n        break;\n\n      case Mesh.RIGHT:\n        startX -= offsetX;\n        adjustX = offsetX / 2;\n        break;\n    }\n\n    switch (alignV) {\n      case Mesh.CENTER:\n        offsetY /= 2;\n        startY -= offsetY;\n        endY += offsetY;\n        break;\n\n      case Mesh.BOTTOM:\n        endY += offsetY;\n        adjustY = -offsetY / 2;\n        break;\n\n      case Mesh.TOP:\n        startY -= offsetY;\n        adjustY = offsetY / 2;\n        break;\n    }\n  }\n\n  var positions = [];\n  var normals = [];\n  var uvBase = [];\n  uvBase[0] = [0, 0, 1, 0, 1, 1, 0, 1];\n  uvBase[1] = [0, 0, 1, 0, 1, 1, 0, 1];\n\n  if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n    uvBase[1] = [1, 1, 0, 1, 0, 0, 1, 0];\n  }\n\n  if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n    uvBase[1] = [1, 0, 0, 0, 0, 1, 1, 1];\n  }\n\n  if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n    uvBase[1] = [0, 1, 1, 1, 1, 0, 0, 0];\n  }\n\n  var uvs = [];\n  var colors = [];\n  var indices = [];\n  var index = 0;\n\n  for (var y = 0; y < tilesY; y++) {\n    for (var x = 0; x < tilesX; x++) {\n      positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n      positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n      positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n      positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n\n      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n        uvs = uvs.concat(uvBase[(x % 2 + y % 2) % 2]);\n      } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvs = uvs.concat(uvBase[y % 2]);\n      } else {\n        uvs = uvs.concat(uvBase[0]);\n      }\n\n      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n      index += 4;\n    }\n  } //Part Tiles\n\n\n  if (offsetX > 0 || offsetY > 0) {\n    var partialBottomRow = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.TOP);\n    var partialTopRow = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.BOTTOM);\n    var partialLeftCol = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.RIGHT);\n    var partialRightCol = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.LEFT);\n    var uvPart = [];\n    var a = void 0,\n        b = void 0,\n        c = void 0,\n        d = void 0; //corners\n\n    if (partialBottomRow && partialLeftCol) {\n      //bottom left corner\n      positions.push(startX + adjustX, startY + adjustY, 0);\n      positions.push(-halfWidth + adjustX, startY + adjustY, 0);\n      positions.push(-halfWidth + adjustX, startY + offsetY + adjustY, 0);\n      positions.push(startX + adjustX, startY + offsetY + adjustY, 0);\n      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n      index += 4;\n      a = 1 - offsetX / tileWidth;\n      b = 1 - offsetY / tileHeight;\n      c = 1;\n      d = 1;\n      uvPart = [a, b, c, b, c, d, a, d];\n\n      if (flipTile === Mesh.ROTATE_ROW) {\n        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n\n      if (flipTile === Mesh.FLIP_ROW) {\n        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n\n      if (flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n\n      uvs = uvs.concat(uvPart);\n      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n    }\n\n    if (partialBottomRow && partialRightCol) {\n      //bottom right corner\n      positions.push(halfWidth + adjustX, startY + adjustY, 0);\n      positions.push(endX + adjustX, startY + adjustY, 0);\n      positions.push(endX + adjustX, startY + offsetY + adjustY, 0);\n      positions.push(halfWidth + adjustX, startY + offsetY + adjustY, 0);\n      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n      index += 4;\n      a = 0;\n      b = 1 - offsetY / tileHeight;\n      c = offsetX / tileWidth;\n      d = 1;\n      uvPart = [a, b, c, b, c, d, a, d];\n\n      if (flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.ROTATE_TILE && tilesX % 2 === 0) {\n        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n\n      if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.FLIP_TILE && tilesX % 2 === 0) {\n        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n\n      if (flipTile === Mesh.FLIP_N_ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesX % 2 === 0) {\n        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n\n      uvs = uvs.concat(uvPart);\n      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n    }\n\n    if (partialTopRow && partialLeftCol) {\n      //top left corner\n      positions.push(startX + adjustX, halfHeight + adjustY, 0);\n      positions.push(-halfWidth + adjustX, halfHeight + adjustY, 0);\n      positions.push(-halfWidth + adjustX, endY + adjustY, 0);\n      positions.push(startX + adjustX, endY + adjustY, 0);\n      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n      index += 4;\n      a = 1 - offsetX / tileWidth;\n      b = 0;\n      c = 1;\n      d = offsetY / tileHeight;\n      uvPart = [a, b, c, b, c, d, a, d];\n\n      if (flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.ROTATE_TILE && tilesY % 1 === 0) {\n        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n\n      if (flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_TILE && tilesY % 2 === 0) {\n        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n\n      if (flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesY % 2 === 0) {\n        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n\n      uvs = uvs.concat(uvPart);\n      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n    }\n\n    if (partialTopRow && partialRightCol) {\n      //top right corner\n      positions.push(halfWidth + adjustX, halfHeight + adjustY, 0);\n      positions.push(endX + adjustX, halfHeight + adjustY, 0);\n      positions.push(endX + adjustX, endY + adjustY, 0);\n      positions.push(halfWidth + adjustX, endY + adjustY, 0);\n      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n      index += 4;\n      a = 0;\n      b = 0;\n      c = offsetX / tileWidth;\n      d = offsetY / tileHeight;\n      uvPart = [a, b, c, b, c, d, a, d];\n\n      if (flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.ROTATE_TILE && (tilesY + tilesX) % 2 === 1) {\n        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n\n      if (flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_TILE && (tilesY + tilesX) % 2 === 1) {\n        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n\n      if (flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_N_ROTATE_TILE && (tilesY + tilesX) % 2 === 1) {\n        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n\n      uvs = uvs.concat(uvPart);\n      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n    } //part rows\n\n\n    if (partialBottomRow) {\n      var uvBaseBR = [];\n      a = 0;\n      b = 1 - offsetY / tileHeight;\n      c = 1;\n      d = 1;\n      uvBaseBR[0] = [a, b, c, b, c, d, a, d];\n      uvBaseBR[1] = [a, b, c, b, c, d, a, d];\n\n      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n        uvBaseBR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n\n      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n        uvBaseBR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n\n      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvBaseBR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n\n      for (var x = 0; x < tilesX; x++) {\n        positions.push(-halfWidth + x * tileWidth + adjustX, startY + adjustY, 0);\n        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + adjustY, 0);\n        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + offsetY + adjustY, 0);\n        positions.push(-halfWidth + x * tileWidth + adjustX, startY + offsetY + adjustY, 0);\n        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n        index += 4;\n\n        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n          uvs = uvs.concat(uvBaseBR[(x + 1) % 2]);\n        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n          uvs = uvs.concat(uvBaseBR[1]);\n        } else {\n          uvs = uvs.concat(uvBaseBR[0]);\n        }\n\n        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n      }\n    }\n\n    if (partialTopRow) {\n      var uvBaseTR = [];\n      a = 0;\n      b = 0;\n      c = 1;\n      d = offsetY / tileHeight;\n      uvBaseTR[0] = [a, b, c, b, c, d, a, d];\n      uvBaseTR[1] = [a, b, c, b, c, d, a, d];\n\n      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n        uvBaseTR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n\n      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n        uvBaseTR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n\n      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvBaseTR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n\n      for (var x = 0; x < tilesX; x++) {\n        positions.push(-halfWidth + x * tileWidth + adjustX, endY - offsetY + adjustY, 0);\n        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY - offsetY + adjustY, 0);\n        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY + adjustY, 0);\n        positions.push(-halfWidth + x * tileWidth + adjustX, endY + adjustY, 0);\n        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n        index += 4;\n\n        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n          uvs = uvs.concat(uvBaseTR[(x + tilesY) % 2]);\n        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n          uvs = uvs.concat(uvBaseTR[tilesY % 2]);\n        } else {\n          uvs = uvs.concat(uvBaseTR[0]);\n        }\n\n        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n      }\n    }\n\n    if (partialLeftCol) {\n      var uvBaseLC = [];\n      a = 1 - offsetX / tileWidth;\n      b = 0;\n      c = 1;\n      d = 1;\n      uvBaseLC[0] = [a, b, c, b, c, d, a, d];\n      uvBaseLC[1] = [a, b, c, b, c, d, a, d];\n\n      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n        uvBaseLC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n\n      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n        uvBaseLC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n\n      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvBaseLC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n\n      for (var y = 0; y < tilesY; y++) {\n        positions.push(startX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n        positions.push(startX + offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n        positions.push(startX + offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n        positions.push(startX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n        index += 4;\n\n        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n          uvs = uvs.concat(uvBaseLC[(y + 1) % 2]);\n        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n          uvs = uvs.concat(uvBaseLC[y % 2]);\n        } else {\n          uvs = uvs.concat(uvBaseLC[0]);\n        }\n\n        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n      }\n    }\n\n    if (partialRightCol) {\n      var uvBaseRC = [];\n      a = 0;\n      b = 0;\n      c = offsetX / tileHeight;\n      d = 1;\n      uvBaseRC[0] = [a, b, c, b, c, d, a, d];\n      uvBaseRC[1] = [a, b, c, b, c, d, a, d];\n\n      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n        uvBaseRC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n\n      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n        uvBaseRC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n\n      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvBaseRC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n\n      for (var y = 0; y < tilesY; y++) {\n        positions.push(endX - offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n        positions.push(endX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n        positions.push(endX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n        positions.push(endX - offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n        index += 4;\n\n        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n          uvs = uvs.concat(uvBaseRC[(y + tilesX) % 2]);\n        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n          uvs = uvs.concat(uvBaseRC[y % 2]);\n        } else {\n          uvs = uvs.concat(uvBaseRC[0]);\n        }\n\n        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n      }\n    }\n  }\n\n  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE; // sides\n\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs); // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  var totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n  vertexData.colors = totalColors;\n  return vertexData;\n}\n/**\n * Creates a tiled plane mesh\n * @see https://doc.babylonjs.com/divingDeeper/mesh/creation/set/tiled_plane\n * @param name defines the name of the mesh\n * @param options an object used to set the following optional parameters for the tiled plane, required but can be empty\n * * pattern a limited pattern arrangement depending on the number\n * * size of the box\n * * width of the box, overwrites size\n * * height of the box, overwrites size\n * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\n * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\n * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\n * * alignVertical places whole tiles aligned to the center, left or right of a column\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.pattern\n * @param options.tileSize\n * @param options.tileWidth\n * @param options.tileHeight\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.alignHorizontal\n * @param options.alignVertical\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the box mesh\n */\n\nexport function CreateTiledPlane(name, options, scene) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  var plane = new Mesh(name, scene);\n  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  plane._originalBuilderSideOrientation = options.sideOrientation;\n  var vertexData = CreateTiledPlaneVertexData(options);\n  vertexData.applyToMesh(plane, options.updatable);\n  return plane;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateTiledPlane instead\n */\n\nexport var TiledPlaneBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateTiledPlane: CreateTiledPlane\n};\nVertexData.CreateTiledPlane = CreateTiledPlaneVertexData;","map":{"version":3,"mappings":"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","names":["Mesh","VertexData","CreateTiledPlaneVertexData","options","flipTile","pattern","NO_FLIP","tileWidth","tileSize","tileHeight","alignH","alignHorizontal","alignV","alignVertical","width","size","tilesX","Math","floor","offsetX","height","tilesY","offsetY","halfWidth","halfHeight","adjustX","adjustY","startX","startY","endX","endY","CENTER","LEFT","RIGHT","BOTTOM","TOP","positions","normals","uvBase","ROTATE_TILE","ROTATE_ROW","FLIP_TILE","FLIP_ROW","FLIP_N_ROTATE_TILE","FLIP_N_ROTATE_ROW","uvs","colors","indices","index","y","x","push","concat","partialBottomRow","partialTopRow","partialLeftCol","partialRightCol","uvPart","a","b","c","d","uvBaseBR","uvBaseTR","uvBaseLC","uvBaseRC","sideOrientation","DEFAULTSIDE","_ComputeSides","frontUVs","backUVs","vertexData","totalColors","DOUBLESIDE","CreateTiledPlane","name","scene","plane","_GetDefaultSideOrientation","_originalBuilderSideOrientation","applyToMesh","updatable","TiledPlaneBuilder"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Meshes/Builders/tiledPlaneBuilder.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\n\r\n/**\r\n * Creates the VertexData for a tiled plane\r\n * @see https://doc.babylonjs.com/divingDeeper/mesh/creation/set/tiled_plane\r\n * @param options an object used to set the following optional parameters for the tiled plane, required but can be empty\r\n * * pattern a limited pattern arrangement depending on the number\r\n * * size of the box\r\n * * width of the box, overwrites size\r\n * * height of the box, overwrites size\r\n * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\r\n * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\r\n * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\r\n * * alignVertical places whole tiles aligned to the center, left or right of a column\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.pattern\r\n * @param options.tileSize\r\n * @param options.tileWidth\r\n * @param options.tileHeight\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.alignHorizontal\r\n * @param options.alignVertical\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @returns the VertexData of the tiled plane\r\n */\r\nexport function CreateTiledPlaneVertexData(options: {\r\n    pattern?: number;\r\n    tileSize?: number;\r\n    tileWidth?: number;\r\n    tileHeight?: number;\r\n    size?: number;\r\n    width?: number;\r\n    height?: number;\r\n    alignHorizontal?: number;\r\n    alignVertical?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const flipTile = options.pattern || Mesh.NO_FLIP;\r\n    const tileWidth = options.tileWidth || options.tileSize || 1;\r\n    const tileHeight = options.tileHeight || options.tileSize || 1;\r\n    const alignH = options.alignHorizontal || 0;\r\n    const alignV = options.alignVertical || 0;\r\n\r\n    const width = options.width || options.size || 1;\r\n    const tilesX = Math.floor(width / tileWidth);\r\n    let offsetX = width - tilesX * tileWidth;\r\n\r\n    const height = options.height || options.size || 1;\r\n    const tilesY = Math.floor(height / tileHeight);\r\n    let offsetY = height - tilesY * tileHeight;\r\n\r\n    const halfWidth = (tileWidth * tilesX) / 2;\r\n    const halfHeight = (tileHeight * tilesY) / 2;\r\n\r\n    let adjustX = 0;\r\n    let adjustY = 0;\r\n    let startX = 0;\r\n    let startY = 0;\r\n    let endX = 0;\r\n    let endY = 0;\r\n\r\n    //Part Tiles\r\n    if (offsetX > 0 || offsetY > 0) {\r\n        startX = -halfWidth;\r\n        startY = -halfHeight;\r\n        endX = halfWidth;\r\n        endY = halfHeight;\r\n\r\n        switch (alignH) {\r\n            case Mesh.CENTER:\r\n                offsetX /= 2;\r\n                startX -= offsetX;\r\n                endX += offsetX;\r\n                break;\r\n            case Mesh.LEFT:\r\n                endX += offsetX;\r\n                adjustX = -offsetX / 2;\r\n                break;\r\n            case Mesh.RIGHT:\r\n                startX -= offsetX;\r\n                adjustX = offsetX / 2;\r\n                break;\r\n        }\r\n\r\n        switch (alignV) {\r\n            case Mesh.CENTER:\r\n                offsetY /= 2;\r\n                startY -= offsetY;\r\n                endY += offsetY;\r\n                break;\r\n            case Mesh.BOTTOM:\r\n                endY += offsetY;\r\n                adjustY = -offsetY / 2;\r\n                break;\r\n            case Mesh.TOP:\r\n                startY -= offsetY;\r\n                adjustY = offsetY / 2;\r\n                break;\r\n        }\r\n    }\r\n\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvBase = [];\r\n    uvBase[0] = [0, 0, 1, 0, 1, 1, 0, 1];\r\n    uvBase[1] = [0, 0, 1, 0, 1, 1, 0, 1];\r\n    if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n        uvBase[1] = [1, 1, 0, 1, 0, 0, 1, 0];\r\n    }\r\n    if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n        uvBase[1] = [1, 0, 0, 0, 0, 1, 1, 1];\r\n    }\r\n    if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n        uvBase[1] = [0, 1, 1, 1, 1, 0, 0, 0];\r\n    }\r\n    let uvs: Array<number> = [];\r\n    const colors = [];\r\n    const indices = [];\r\n    let index = 0;\r\n    for (let y = 0; y < tilesY; y++) {\r\n        for (let x = 0; x < tilesX; x++) {\r\n            positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n            positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n            positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n            positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                uvs = uvs.concat(uvBase[((x % 2) + (y % 2)) % 2]);\r\n            } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvs = uvs.concat(uvBase[y % 2]);\r\n            } else {\r\n                uvs = uvs.concat(uvBase[0]);\r\n            }\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            index += 4;\r\n        }\r\n    }\r\n\r\n    //Part Tiles\r\n    if (offsetX > 0 || offsetY > 0) {\r\n        const partialBottomRow: boolean = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.TOP);\r\n        const partialTopRow: boolean = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.BOTTOM);\r\n        const partialLeftCol: boolean = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.RIGHT);\r\n        const partialRightCol: boolean = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.LEFT);\r\n        let uvPart: Array<number> = [];\r\n        let a, b, c, d: number;\r\n\r\n        //corners\r\n        if (partialBottomRow && partialLeftCol) {\r\n            //bottom left corner\r\n            positions.push(startX + adjustX, startY + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, startY + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, startY + offsetY + adjustY, 0);\r\n            positions.push(startX + adjustX, startY + offsetY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 1 - offsetX / tileWidth;\r\n            b = 1 - offsetY / tileHeight;\r\n            c = 1;\r\n            d = 1;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_ROW) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_ROW) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        if (partialBottomRow && partialRightCol) {\r\n            //bottom right corner\r\n            positions.push(halfWidth + adjustX, startY + adjustY, 0);\r\n            positions.push(endX + adjustX, startY + adjustY, 0);\r\n            positions.push(endX + adjustX, startY + offsetY + adjustY, 0);\r\n            positions.push(halfWidth + adjustX, startY + offsetY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 0;\r\n            b = 1 - offsetY / tileHeight;\r\n            c = offsetX / tileWidth;\r\n            d = 1;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_ROW || (flipTile === Mesh.ROTATE_TILE && tilesX % 2 === 0)) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_ROW || (flipTile === Mesh.FLIP_TILE && tilesX % 2 === 0)) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_ROW || (flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesX % 2 === 0)) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        if (partialTopRow && partialLeftCol) {\r\n            //top left corner\r\n            positions.push(startX + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, endY + adjustY, 0);\r\n            positions.push(startX + adjustX, endY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 1 - offsetX / tileWidth;\r\n            b = 0;\r\n            c = 1;\r\n            d = offsetY / tileHeight;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if ((flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.ROTATE_TILE && tilesY % 1 === 0)) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_TILE && tilesY % 2 === 0)) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesY % 2 === 0)) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        if (partialTopRow && partialRightCol) {\r\n            //top right corner\r\n            positions.push(halfWidth + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(endX + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(endX + adjustX, endY + adjustY, 0);\r\n            positions.push(halfWidth + adjustX, endY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 0;\r\n            b = 0;\r\n            c = offsetX / tileWidth;\r\n            d = offsetY / tileHeight;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if ((flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.ROTATE_TILE && (tilesY + tilesX) % 2 === 1)) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_TILE && (tilesY + tilesX) % 2 === 1)) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_N_ROTATE_TILE && (tilesY + tilesX) % 2 === 1)) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        //part rows\r\n        if (partialBottomRow) {\r\n            const uvBaseBR = [];\r\n            a = 0;\r\n            b = 1 - offsetY / tileHeight;\r\n            c = 1;\r\n            d = 1;\r\n            uvBaseBR[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseBR[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseBR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseBR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseBR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (let x = 0; x < tilesX; x++) {\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, startY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + offsetY + adjustY, 0);\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, startY + offsetY + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseBR[(x + 1) % 2]);\r\n                } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseBR[1]);\r\n                } else {\r\n                    uvs = uvs.concat(uvBaseBR[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n\r\n        if (partialTopRow) {\r\n            const uvBaseTR = [];\r\n            a = 0;\r\n            b = 0;\r\n            c = 1;\r\n            d = offsetY / tileHeight;\r\n            uvBaseTR[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseTR[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseTR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseTR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseTR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (let x = 0; x < tilesX; x++) {\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, endY - offsetY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY - offsetY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY + adjustY, 0);\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, endY + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseTR[(x + tilesY) % 2]);\r\n                } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseTR[tilesY % 2]);\r\n                } else {\r\n                    uvs = uvs.concat(uvBaseTR[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n\r\n        if (partialLeftCol) {\r\n            const uvBaseLC = [];\r\n            a = 1 - offsetX / tileWidth;\r\n            b = 0;\r\n            c = 1;\r\n            d = 1;\r\n            uvBaseLC[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseLC[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseLC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseLC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseLC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (let y = 0; y < tilesY; y++) {\r\n                positions.push(startX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(startX + offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(startX + offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                positions.push(startX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseLC[(y + 1) % 2]);\r\n                } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseLC[y % 2]);\r\n                } else {\r\n                    uvs = uvs.concat(uvBaseLC[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n\r\n        if (partialRightCol) {\r\n            const uvBaseRC = [];\r\n            a = 0;\r\n            b = 0;\r\n            c = offsetX / tileHeight;\r\n            d = 1;\r\n            uvBaseRC[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseRC[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseRC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseRC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseRC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (let y = 0; y < tilesY; y++) {\r\n                positions.push(endX - offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(endX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(endX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                positions.push(endX - offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseRC[(y + tilesX) % 2]);\r\n                } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseRC[y % 2]);\r\n                } else {\r\n                    uvs = uvs.concat(uvBaseRC[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n    }\r\n\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\r\n    vertexData.colors = totalColors;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a tiled plane mesh\r\n * @see https://doc.babylonjs.com/divingDeeper/mesh/creation/set/tiled_plane\r\n * @param name defines the name of the mesh\r\n * @param options an object used to set the following optional parameters for the tiled plane, required but can be empty\r\n * * pattern a limited pattern arrangement depending on the number\r\n * * size of the box\r\n * * width of the box, overwrites size\r\n * * height of the box, overwrites size\r\n * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\r\n * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\r\n * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\r\n * * alignVertical places whole tiles aligned to the center, left or right of a column\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.pattern\r\n * @param options.tileSize\r\n * @param options.tileWidth\r\n * @param options.tileHeight\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.alignHorizontal\r\n * @param options.alignVertical\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the box mesh\r\n */\r\nexport function CreateTiledPlane(\r\n    name: string,\r\n    options: {\r\n        pattern?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        updatable?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const plane = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    plane._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateTiledPlaneVertexData(options);\r\n\r\n    vertexData.applyToMesh(plane, options.updatable);\r\n\r\n    return plane;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTiledPlane instead\r\n */\r\nexport const TiledPlaneBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTiledPlane,\r\n};\r\n\r\nVertexData.CreateTiledPlane = CreateTiledPlaneVertexData;\r\n"]},"metadata":{},"sourceType":"module"}