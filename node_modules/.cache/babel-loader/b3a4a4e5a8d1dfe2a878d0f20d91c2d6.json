{"ast":null,"code":"import \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture.js\";\nimport { WebGPUEngine } from \"../../webgpuEngine.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\n\nWebGPUEngine.prototype.createRawTexture = function (data, width, height, format, generateMipMaps, invertY, samplingMode, compression, type, creationFlags) {\n  if (compression === void 0) {\n    compression = null;\n  }\n\n  if (type === void 0) {\n    type = 0;\n  }\n\n  if (creationFlags === void 0) {\n    creationFlags = 0;\n  }\n\n  var texture = new InternalTexture(this, InternalTextureSource.Raw);\n  texture.baseWidth = width;\n  texture.baseHeight = height;\n  texture.width = width;\n  texture.height = height;\n  texture.format = format;\n  texture.generateMipMaps = generateMipMaps;\n  texture.samplingMode = samplingMode;\n  texture.invertY = invertY;\n  texture._compression = compression;\n  texture.type = type;\n\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = data;\n  }\n\n  this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, undefined, creationFlags);\n\n  this.updateRawTexture(texture, data, format, invertY, compression, type);\n\n  this._internalTexturesCache.push(texture);\n\n  return texture;\n};\n\nWebGPUEngine.prototype.updateRawTexture = function (texture, bufferView, format, invertY, compression, type) {\n  if (compression === void 0) {\n    compression = null;\n  }\n\n  if (type === void 0) {\n    type = 0;\n  }\n\n  if (!texture) {\n    return;\n  }\n\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = bufferView;\n    texture.invertY = invertY;\n    texture._compression = compression;\n  }\n\n  if (bufferView) {\n    var gpuTextureWrapper = texture._hardwareTexture;\n    var needConversion = format === 4;\n\n    if (needConversion) {\n      bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, type);\n    }\n\n    var data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n\n    this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\n\n    if (texture.generateMipMaps) {\n      this._generateMipmaps(texture, this._uploadEncoder);\n    }\n  }\n\n  texture.isReady = true;\n};\n\nWebGPUEngine.prototype.createRawCubeTexture = function (data, size, format, type, generateMipMaps, invertY, samplingMode, compression) {\n  if (compression === void 0) {\n    compression = null;\n  }\n\n  var texture = new InternalTexture(this, InternalTextureSource.CubeRaw);\n\n  if (type === 1 && !this._caps.textureFloatLinearFiltering) {\n    generateMipMaps = false;\n    samplingMode = 1;\n    Logger.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\n  } else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n    generateMipMaps = false;\n    samplingMode = 1;\n    Logger.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\n  } else if (type === 1 && !this._caps.textureFloatRender) {\n    generateMipMaps = false;\n    Logger.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\");\n  } else if (type === 2 && !this._caps.colorBufferFloat) {\n    generateMipMaps = false;\n    Logger.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\");\n  }\n\n  texture.isCube = true;\n  texture.format = format === 4 ? 5 : format;\n  texture.type = type;\n  texture.generateMipMaps = generateMipMaps;\n  texture.width = size;\n  texture.height = size;\n  texture.samplingMode = samplingMode;\n\n  if (!this._doNotHandleContextLost) {\n    texture._bufferViewArray = data;\n  }\n\n  texture._cachedWrapU = 0;\n  texture._cachedWrapV = 0;\n\n  this._textureHelper.createGPUTextureForInternalTexture(texture);\n\n  if (data) {\n    this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\n  }\n\n  return texture;\n};\n\nWebGPUEngine.prototype.updateRawCubeTexture = function (texture, bufferView, format, type, invertY, compression) {\n  if (compression === void 0) {\n    compression = null;\n  }\n\n  texture._bufferViewArray = bufferView;\n  texture.invertY = invertY;\n  texture._compression = compression;\n  var gpuTextureWrapper = texture._hardwareTexture;\n  var needConversion = format === 4;\n  var data = [];\n\n  for (var i = 0; i < bufferView.length; ++i) {\n    var faceData = bufferView[i];\n\n    if (needConversion) {\n      faceData = _convertRGBtoRGBATextureData(bufferView[i], texture.width, texture.height, type);\n    }\n\n    data.push(new Uint8Array(faceData.buffer, faceData.byteOffset, faceData.byteLength));\n  }\n\n  this._textureHelper.updateCubeTextures(data, gpuTextureWrapper.underlyingResource, texture.width, texture.height, gpuTextureWrapper.format, invertY, false, 0, 0);\n\n  if (texture.generateMipMaps) {\n    this._generateMipmaps(texture, this._uploadEncoder);\n  }\n\n  texture.isReady = true;\n};\n\nWebGPUEngine.prototype.createRawCubeTextureFromUrl = function (url, scene, size, format, type, noMipmap, callback, mipmapGenerator, onLoad, onError, samplingMode, invertY) {\n  var _this = this;\n\n  if (onLoad === void 0) {\n    onLoad = null;\n  }\n\n  if (onError === void 0) {\n    onError = null;\n  }\n\n  if (samplingMode === void 0) {\n    samplingMode = 3;\n  }\n\n  if (invertY === void 0) {\n    invertY = false;\n  }\n\n  var texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);\n  scene === null || scene === void 0 ? void 0 : scene._addPendingData(texture);\n  texture.url = url;\n\n  this._internalTexturesCache.push(texture);\n\n  var onerror = function onerror(request, exception) {\n    scene === null || scene === void 0 ? void 0 : scene._removePendingData(texture);\n\n    if (onError && request) {\n      onError(request.status + \" \" + request.statusText, exception);\n    }\n  };\n\n  var internalCallback = function internalCallback(data) {\n    var width = texture.width;\n    var faceDataArrays = callback(data);\n\n    if (!faceDataArrays) {\n      return;\n    }\n\n    var faces = [0, 2, 4, 1, 3, 5];\n\n    if (mipmapGenerator) {\n      var needConversion = format === 4;\n      var mipData = mipmapGenerator(faceDataArrays);\n      var gpuTextureWrapper = texture._hardwareTexture;\n      var faces_1 = [0, 1, 2, 3, 4, 5];\n\n      for (var level = 0; level < mipData.length; level++) {\n        var mipSize = width >> level;\n        var allFaces = [];\n\n        for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\n          var mipFaceData = mipData[level][faces_1[faceIndex]];\n\n          if (needConversion) {\n            mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\n          }\n\n          allFaces.push(new Uint8Array(mipFaceData.buffer, mipFaceData.byteOffset, mipFaceData.byteLength));\n        }\n\n        _this._textureHelper.updateCubeTextures(allFaces, gpuTextureWrapper.underlyingResource, mipSize, mipSize, gpuTextureWrapper.format, invertY, false, 0, 0);\n      }\n    } else {\n      var allFaces = [];\n\n      for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\n        allFaces.push(faceDataArrays[faces[faceIndex]]);\n      }\n\n      _this.updateRawCubeTexture(texture, allFaces, format, type, invertY);\n    }\n\n    texture.isReady = true;\n    scene === null || scene === void 0 ? void 0 : scene._removePendingData(texture);\n\n    if (onLoad) {\n      onLoad();\n    }\n  };\n\n  this._loadFile(url, function (data) {\n    internalCallback(data);\n  }, undefined, scene === null || scene === void 0 ? void 0 : scene.offlineProvider, true, onerror);\n\n  return texture;\n};\n\nWebGPUEngine.prototype.createRawTexture3D = function (data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression, textureType, creationFlags) {\n  if (compression === void 0) {\n    compression = null;\n  }\n\n  if (textureType === void 0) {\n    textureType = 0;\n  }\n\n  if (creationFlags === void 0) {\n    creationFlags = 0;\n  }\n\n  var source = InternalTextureSource.Raw3D;\n  var texture = new InternalTexture(this, source);\n  texture.baseWidth = width;\n  texture.baseHeight = height;\n  texture.baseDepth = depth;\n  texture.width = width;\n  texture.height = height;\n  texture.depth = depth;\n  texture.format = format;\n  texture.type = textureType;\n  texture.generateMipMaps = generateMipMaps;\n  texture.samplingMode = samplingMode;\n  texture.is3D = true;\n\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = data;\n  }\n\n  this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, undefined, creationFlags);\n\n  this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);\n\n  this._internalTexturesCache.push(texture);\n\n  return texture;\n};\n\nWebGPUEngine.prototype.updateRawTexture3D = function (texture, bufferView, format, invertY, compression, textureType) {\n  if (compression === void 0) {\n    compression = null;\n  }\n\n  if (textureType === void 0) {\n    textureType = 0;\n  }\n\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = bufferView;\n    texture.format = format;\n    texture.invertY = invertY;\n    texture._compression = compression;\n  }\n\n  if (bufferView) {\n    var gpuTextureWrapper = texture._hardwareTexture;\n    var needConversion = format === 4;\n\n    if (needConversion) {\n      bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, textureType);\n    }\n\n    var data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n\n    this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\n\n    if (texture.generateMipMaps) {\n      this._generateMipmaps(texture, this._uploadEncoder);\n    }\n  }\n\n  texture.isReady = true;\n};\n\nWebGPUEngine.prototype.createRawTexture2DArray = function (data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression, textureType, creationFlags) {\n  if (compression === void 0) {\n    compression = null;\n  }\n\n  if (textureType === void 0) {\n    textureType = 0;\n  }\n\n  if (creationFlags === void 0) {\n    creationFlags = 0;\n  }\n\n  var source = InternalTextureSource.Raw2DArray;\n  var texture = new InternalTexture(this, source);\n  texture.baseWidth = width;\n  texture.baseHeight = height;\n  texture.baseDepth = depth;\n  texture.width = width;\n  texture.height = height;\n  texture.depth = depth;\n  texture.format = format;\n  texture.type = textureType;\n  texture.generateMipMaps = generateMipMaps;\n  texture.samplingMode = samplingMode;\n  texture.is2DArray = true;\n\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = data;\n  }\n\n  this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, depth, creationFlags);\n\n  this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);\n\n  this._internalTexturesCache.push(texture);\n\n  return texture;\n};\n\nWebGPUEngine.prototype.updateRawTexture2DArray = function (texture, bufferView, format, invertY, compression, textureType) {\n  if (compression === void 0) {\n    compression = null;\n  }\n\n  if (textureType === void 0) {\n    textureType = 0;\n  }\n\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = bufferView;\n    texture.format = format;\n    texture.invertY = invertY;\n    texture._compression = compression;\n  }\n\n  if (bufferView) {\n    var gpuTextureWrapper = texture._hardwareTexture;\n    var needConversion = format === 4;\n\n    if (needConversion) {\n      bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, textureType);\n    }\n\n    var data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n\n    this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\n\n    if (texture.generateMipMaps) {\n      this._generateMipmaps(texture, this._uploadEncoder);\n    }\n  }\n\n  texture.isReady = true;\n};\n/**\n * @param rgbData\n * @param width\n * @param height\n * @param textureType\n * @hidden\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\n\nfunction _convertRGBtoRGBATextureData(rgbData, width, height, textureType) {\n  // Create new RGBA data container.\n  var rgbaData;\n  var val1 = 1;\n\n  if (textureType === 1) {\n    rgbaData = new Float32Array(width * height * 4);\n  } else if (textureType === 2) {\n    rgbaData = new Uint16Array(width * height * 4);\n    val1 = 15360; // 15360 is the encoding of 1 in half float\n  } else if (textureType === 7) {\n    rgbaData = new Uint32Array(width * height * 4);\n  } else {\n    rgbaData = new Uint8Array(width * height * 4);\n  } // Convert each pixel.\n\n\n  for (var x = 0; x < width; x++) {\n    for (var y = 0; y < height; y++) {\n      var index = (y * width + x) * 3;\n      var newIndex = (y * width + x) * 4; // Map Old Value to new value.\n\n      rgbaData[newIndex + 0] = rgbData[index + 0];\n      rgbaData[newIndex + 1] = rgbData[index + 1];\n      rgbaData[newIndex + 2] = rgbData[index + 2]; // Add fully opaque alpha channel.\n\n      rgbaData[newIndex + 3] = val1;\n    }\n  }\n\n  return rgbaData;\n}","map":{"version":3,"mappings":"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","names":["InternalTexture","InternalTextureSource","WebGPUEngine","Logger","prototype","createRawTexture","data","width","height","format","generateMipMaps","invertY","samplingMode","compression","type","creationFlags","texture","Raw","baseWidth","baseHeight","_compression","_doNotHandleContextLost","_bufferView","_textureHelper","createGPUTextureForInternalTexture","undefined","updateRawTexture","_internalTexturesCache","push","bufferView","gpuTextureWrapper","_hardwareTexture","needConversion","_convertRGBtoRGBATextureData","Uint8Array","buffer","byteOffset","byteLength","updateTexture","depth","_generateMipmaps","_uploadEncoder","isReady","createRawCubeTexture","size","CubeRaw","_caps","textureFloatLinearFiltering","Warn","textureHalfFloatLinearFiltering","textureFloatRender","colorBufferFloat","isCube","_bufferViewArray","_cachedWrapU","_cachedWrapV","updateRawCubeTexture","i","length","faceData","updateCubeTextures","underlyingResource","createRawCubeTextureFromUrl","url","scene","noMipmap","callback","mipmapGenerator","onLoad","onError","_addPendingData","onerror","request","exception","_removePendingData","status","statusText","internalCallback","faceDataArrays","faces","mipData","faces_1","level","mipSize","allFaces","faceIndex","mipFaceData","_this","_loadFile","offlineProvider","createRawTexture3D","textureType","source","Raw3D","baseDepth","is3D","updateRawTexture3D","createRawTexture2DArray","Raw2DArray","is2DArray","updateRawTexture2DArray","rgbData","rgbaData","val1","Float32Array","Uint16Array","Uint32Array","x","y","index","newIndex"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Engines/WebGPU/Extensions/engine.rawTexture.ts"],"sourcesContent":["import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IWebRequest } from \"../../../Misc/interfaces/iWebRequest\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\n\r\ndeclare type Scene = import(\"../../../scene\").Scene;\r\n\r\nWebGPUEngine.prototype.createRawTexture = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    creationFlags: number = 0\r\n): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.Raw);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.format = format;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n    texture.type = type;\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, undefined, creationFlags);\r\n\r\n    this.updateRawTexture(texture, data, format, invertY, compression, type);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nWebGPUEngine.prototype.updateRawTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    bufferView: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = bufferView;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n    }\r\n\r\n    if (bufferView) {\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n\r\n        if (needConversion) {\r\n            bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, type);\r\n        }\r\n\r\n        const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\r\n        if (texture.generateMipMaps) {\r\n            this._generateMipmaps(texture, this._uploadEncoder);\r\n        }\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\nWebGPUEngine.prototype.createRawCubeTexture = function (\r\n    data: Nullable<ArrayBufferView[]>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null\r\n): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.CubeRaw);\r\n\r\n    if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatRender) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\");\r\n    } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.colorBufferFloat) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\");\r\n    }\r\n\r\n    texture.isCube = true;\r\n    texture.format = format === Constants.TEXTUREFORMAT_RGB ? Constants.TEXTUREFORMAT_RGBA : format;\r\n    texture.type = type;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.width = size;\r\n    texture.height = size;\r\n    texture.samplingMode = samplingMode;\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferViewArray = data;\r\n    }\r\n    texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n\r\n    if (data) {\r\n        this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\r\n    }\r\n\r\n    return texture;\r\n};\r\n\r\nWebGPUEngine.prototype.updateRawCubeTexture = function (\r\n    texture: InternalTexture,\r\n    bufferView: ArrayBufferView[],\r\n    format: number,\r\n    type: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null\r\n): void {\r\n    texture._bufferViewArray = bufferView;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n\r\n    const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n    const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n\r\n    const data = [];\r\n    for (let i = 0; i < bufferView.length; ++i) {\r\n        let faceData = bufferView[i];\r\n        if (needConversion) {\r\n            faceData = _convertRGBtoRGBATextureData(bufferView[i], texture.width, texture.height, type);\r\n        }\r\n        data.push(new Uint8Array(faceData.buffer, faceData.byteOffset, faceData.byteLength));\r\n    }\r\n\r\n    this._textureHelper.updateCubeTextures(data, gpuTextureWrapper.underlyingResource!, texture.width, texture.height, gpuTextureWrapper.format, invertY, false, 0, 0);\r\n    if (texture.generateMipMaps) {\r\n        this._generateMipmaps(texture, this._uploadEncoder);\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\nWebGPUEngine.prototype.createRawCubeTextureFromUrl = function (\r\n    url: string,\r\n    scene: Nullable<Scene>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    noMipmap: boolean,\r\n    callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n    mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n    onLoad: Nullable<() => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n    invertY: boolean = false\r\n): InternalTexture {\r\n    const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);\r\n    scene?._addPendingData(texture);\r\n    texture.url = url;\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    const onerror = (request?: IWebRequest, exception?: any) => {\r\n        scene?._removePendingData(texture);\r\n        if (onError && request) {\r\n            onError(request.status + \" \" + request.statusText, exception);\r\n        }\r\n    };\r\n\r\n    const internalCallback = (data: any) => {\r\n        const width = texture.width;\r\n        const faceDataArrays = callback(data);\r\n\r\n        if (!faceDataArrays) {\r\n            return;\r\n        }\r\n\r\n        const faces = [0, 2, 4, 1, 3, 5];\r\n\r\n        if (mipmapGenerator) {\r\n            const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n            const mipData = mipmapGenerator(faceDataArrays);\r\n            const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n            const faces = [0, 1, 2, 3, 4, 5];\r\n            for (let level = 0; level < mipData.length; level++) {\r\n                const mipSize = width >> level;\r\n                const allFaces = [];\r\n                for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n                    let mipFaceData = mipData[level][faces[faceIndex]];\r\n                    if (needConversion) {\r\n                        mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\r\n                    }\r\n                    allFaces.push(new Uint8Array(mipFaceData.buffer, mipFaceData.byteOffset, mipFaceData.byteLength));\r\n                }\r\n                this._textureHelper.updateCubeTextures(allFaces, gpuTextureWrapper.underlyingResource!, mipSize, mipSize, gpuTextureWrapper.format, invertY, false, 0, 0);\r\n            }\r\n        } else {\r\n            const allFaces = [];\r\n            for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n                allFaces.push(faceDataArrays[faces[faceIndex]]);\r\n            }\r\n            this.updateRawCubeTexture(texture, allFaces, format, type, invertY);\r\n        }\r\n\r\n        texture.isReady = true;\r\n        scene?._removePendingData(texture);\r\n\r\n        if (onLoad) {\r\n            onLoad();\r\n        }\r\n    };\r\n\r\n    this._loadFile(\r\n        url,\r\n        (data) => {\r\n            internalCallback(data);\r\n        },\r\n        undefined,\r\n        scene?.offlineProvider,\r\n        true,\r\n        onerror\r\n    );\r\n\r\n    return texture;\r\n};\r\n\r\nWebGPUEngine.prototype.createRawTexture3D = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    depth: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    creationFlags: number = 0\r\n): InternalTexture {\r\n    const source = InternalTextureSource.Raw3D;\r\n    const texture = new InternalTexture(this, source);\r\n\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.baseDepth = depth;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.depth = depth;\r\n    texture.format = format;\r\n    texture.type = textureType;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.is3D = true;\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, undefined, creationFlags);\r\n\r\n    this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nWebGPUEngine.prototype.updateRawTexture3D = function (\r\n    texture: InternalTexture,\r\n    bufferView: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n): void {\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = bufferView;\r\n        texture.format = format;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n    }\r\n\r\n    if (bufferView) {\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n\r\n        if (needConversion) {\r\n            bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, textureType);\r\n        }\r\n\r\n        const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\r\n        if (texture.generateMipMaps) {\r\n            this._generateMipmaps(texture, this._uploadEncoder);\r\n        }\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\nWebGPUEngine.prototype.createRawTexture2DArray = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    depth: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    creationFlags: number = 0\r\n): InternalTexture {\r\n    const source = InternalTextureSource.Raw2DArray;\r\n    const texture = new InternalTexture(this, source);\r\n\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.baseDepth = depth;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.depth = depth;\r\n    texture.format = format;\r\n    texture.type = textureType;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.is2DArray = true;\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, depth, creationFlags);\r\n\r\n    this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nWebGPUEngine.prototype.updateRawTexture2DArray = function (\r\n    texture: InternalTexture,\r\n    bufferView: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n): void {\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = bufferView;\r\n        texture.format = format;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n    }\r\n\r\n    if (bufferView) {\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n\r\n        if (needConversion) {\r\n            bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, textureType);\r\n        }\r\n\r\n        const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\r\n        if (texture.generateMipMaps) {\r\n            this._generateMipmaps(texture, this._uploadEncoder);\r\n        }\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\n/**\r\n * @param rgbData\r\n * @param width\r\n * @param height\r\n * @param textureType\r\n * @hidden\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _convertRGBtoRGBATextureData(rgbData: any, width: number, height: number, textureType: number): ArrayBufferView {\r\n    // Create new RGBA data container.\r\n    let rgbaData: any;\r\n    let val1 = 1;\r\n    if (textureType === Constants.TEXTURETYPE_FLOAT) {\r\n        rgbaData = new Float32Array(width * height * 4);\r\n    } else if (textureType === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n        rgbaData = new Uint16Array(width * height * 4);\r\n        val1 = 15360; // 15360 is the encoding of 1 in half float\r\n    } else if (textureType === Constants.TEXTURETYPE_UNSIGNED_INTEGER) {\r\n        rgbaData = new Uint32Array(width * height * 4);\r\n    } else {\r\n        rgbaData = new Uint8Array(width * height * 4);\r\n    }\r\n\r\n    // Convert each pixel.\r\n    for (let x = 0; x < width; x++) {\r\n        for (let y = 0; y < height; y++) {\r\n            const index = (y * width + x) * 3;\r\n            const newIndex = (y * width + x) * 4;\r\n\r\n            // Map Old Value to new value.\r\n            rgbaData[newIndex + 0] = rgbData[index + 0];\r\n            rgbaData[newIndex + 1] = rgbData[index + 1];\r\n            rgbaData[newIndex + 2] = rgbData[index + 2];\r\n\r\n            // Add fully opaque alpha channel.\r\n            rgbaData[newIndex + 3] = val1;\r\n        }\r\n    }\r\n\r\n    return rgbaData;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}