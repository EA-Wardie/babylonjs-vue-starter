{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport { __decorate, __extends } from \"tslib\";\nimport { serialize, serializeAsTexture, expandToProperty, serializeAsColor3 } from \"../../Misc/decorators.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { MaterialFlags } from \"../materialFlags.js\";\nimport { MaterialHelper } from \"../../Materials/materialHelper.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { TmpVectors } from \"../../Maths/math.vector.js\";\nimport { MaterialPluginBase } from \"../materialPluginBase.js\";\nimport { MaterialDefines } from \"../materialDefines.js\";\n/**\n * @hidden\n */\n\nvar MaterialSubSurfaceDefines =\n/** @class */\nfunction (_super) {\n  __extends(MaterialSubSurfaceDefines, _super);\n\n  function MaterialSubSurfaceDefines() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.SUBSURFACE = false;\n    _this.SS_REFRACTION = false;\n    _this.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\n    _this.SS_TRANSLUCENCY = false;\n    _this.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\n    _this.SS_SCATTERING = false;\n    _this.SS_THICKNESSANDMASK_TEXTURE = false;\n    _this.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;\n    _this.SS_HAS_THICKNESS = false;\n    _this.SS_REFRACTIONINTENSITY_TEXTURE = false;\n    _this.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;\n    _this.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\n    _this.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;\n    _this.SS_REFRACTIONMAP_3D = false;\n    _this.SS_REFRACTIONMAP_OPPOSITEZ = false;\n    _this.SS_LODINREFRACTIONALPHA = false;\n    _this.SS_GAMMAREFRACTION = false;\n    _this.SS_RGBDREFRACTION = false;\n    _this.SS_LINEARSPECULARREFRACTION = false;\n    _this.SS_LINKREFRACTIONTOTRANSPARENCY = false;\n    _this.SS_ALBEDOFORREFRACTIONTINT = false;\n    _this.SS_ALBEDOFORTRANSLUCENCYTINT = false;\n    _this.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\n    _this.SS_USE_THICKNESS_AS_DEPTH = false;\n    _this.SS_MASK_FROM_THICKNESS_TEXTURE = false;\n    _this.SS_USE_GLTF_TEXTURES = false;\n    return _this;\n  }\n\n  return MaterialSubSurfaceDefines;\n}(MaterialDefines);\n\nexport { MaterialSubSurfaceDefines };\n/**\n * Plugin that implements the sub surface component of the PBR material\n */\n\nvar PBRSubSurfaceConfiguration =\n/** @class */\nfunction (_super) {\n  __extends(PBRSubSurfaceConfiguration, _super);\n\n  function PBRSubSurfaceConfiguration(material, addToPluginList) {\n    if (addToPluginList === void 0) {\n      addToPluginList = true;\n    }\n\n    var _this = _super.call(this, material, \"PBRSubSurface\", 130, new MaterialSubSurfaceDefines(), addToPluginList) || this;\n\n    _this._isRefractionEnabled = false;\n    /**\n     * Defines if the refraction is enabled in the material.\n     */\n\n    _this.isRefractionEnabled = false;\n    _this._isTranslucencyEnabled = false;\n    /**\n     * Defines if the translucency is enabled in the material.\n     */\n\n    _this.isTranslucencyEnabled = false;\n    _this._isScatteringEnabled = false;\n    /**\n     * Defines if the sub surface scattering is enabled in the material.\n     */\n\n    _this.isScatteringEnabled = false;\n    _this._scatteringDiffusionProfileIndex = 0;\n    /**\n     * Defines the refraction intensity of the material.\n     * The refraction when enabled replaces the Diffuse part of the material.\n     * The intensity helps transitioning between diffuse and refraction.\n     */\n\n    _this.refractionIntensity = 1;\n    /**\n     * Defines the translucency intensity of the material.\n     * When translucency has been enabled, this defines how much of the \"translucency\"\n     * is added to the diffuse part of the material.\n     */\n\n    _this.translucencyIntensity = 1;\n    /**\n     * When enabled, transparent surfaces will be tinted with the albedo colour (independent of thickness)\n     */\n\n    _this.useAlbedoToTintRefraction = false;\n    /**\n     * When enabled, translucent surfaces will be tinted with the albedo colour (independent of thickness)\n     */\n\n    _this.useAlbedoToTintTranslucency = false;\n    _this._thicknessTexture = null;\n    /**\n     * Stores the average thickness of a mesh in a texture (The texture is holding the values linearly).\n     * The red (or green if useGltfStyleTextures=true) channel of the texture should contain the thickness remapped between 0 and 1.\n     * 0 would mean minimumThickness\n     * 1 would mean maximumThickness\n     * The other channels might be use as a mask to vary the different effects intensity.\n     */\n\n    _this.thicknessTexture = null;\n    _this._refractionTexture = null;\n    /**\n     * Defines the texture to use for refraction.\n     */\n\n    _this.refractionTexture = null;\n    /** @hidden */\n\n    _this._indexOfRefraction = 1.5;\n    /**\n     * Index of refraction of the material base layer.\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\n     *\n     * This does not only impact refraction but also the Base F0 of Dielectric Materials.\n     *\n     * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))\n     */\n\n    _this.indexOfRefraction = 1.5;\n    _this._volumeIndexOfRefraction = -1.0;\n    _this._invertRefractionY = false;\n    /**\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\n     */\n\n    _this.invertRefractionY = false;\n    /** @hidden */\n\n    _this._linkRefractionWithTransparency = false;\n    /**\n     * This parameters will make the material used its opacity to control how much it is refracting against not.\n     * Materials half opaque for instance using refraction could benefit from this control.\n     */\n\n    _this.linkRefractionWithTransparency = false;\n    /**\n     * Defines the minimum thickness stored in the thickness map.\n     * If no thickness map is defined, this value will be used to simulate thickness.\n     */\n\n    _this.minimumThickness = 0;\n    /**\n     * Defines the maximum thickness stored in the thickness map.\n     */\n\n    _this.maximumThickness = 1;\n    /**\n     * Defines that the thickness should be used as a measure of the depth volume.\n     */\n\n    _this.useThicknessAsDepth = false;\n    /**\n     * Defines the volume tint of the material.\n     * This is used for both translucency and scattering.\n     */\n\n    _this.tintColor = Color3.White();\n    /**\n     * Defines the distance at which the tint color should be found in the media.\n     * This is used for refraction only.\n     */\n\n    _this.tintColorAtDistance = 1;\n    /**\n     * Defines how far each channel transmit through the media.\n     * It is defined as a color to simplify it selection.\n     */\n\n    _this.diffusionDistance = Color3.White();\n    _this._useMaskFromThicknessTexture = false;\n    /**\n     * Stores the intensity of the different subsurface effects in the thickness texture.\n     * Note that if refractionIntensityTexture and/or translucencyIntensityTexture is provided it takes precedence over thicknessTexture + useMaskFromThicknessTexture\n     * * the green (red if useGltfStyleTextures = true) channel is the refraction intensity.\n     * * the blue channel is the translucency intensity.\n     */\n\n    _this.useMaskFromThicknessTexture = false;\n    _this._refractionIntensityTexture = null;\n    /**\n     * Stores the intensity of the refraction. If provided, it takes precedence over thicknessTexture + useMaskFromThicknessTexture\n     * * the green (red if useGltfStyleTextures = true) channel is the refraction intensity.\n     */\n\n    _this.refractionIntensityTexture = null;\n    _this._translucencyIntensityTexture = null;\n    /**\n     * Stores the intensity of the translucency. If provided, it takes precedence over thicknessTexture + useMaskFromThicknessTexture\n     * * the blue channel is the translucency intensity.\n     */\n\n    _this.translucencyIntensityTexture = null;\n    _this._useGltfStyleTextures = false;\n    /**\n     * Use channels layout used by glTF:\n     * * thicknessTexture: the green (instead of red) channel is the thickness\n     * * thicknessTexture/refractionIntensityTexture: the red (instead of green) channel is the refraction intensity\n     * * thicknessTexture/translucencyIntensityTexture: no change, use the blue channel for the translucency intensity\n     */\n\n    _this.useGltfStyleTextures = false;\n    _this._scene = material.getScene();\n    _this.registerForExtraEvents = true;\n    _this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];\n    _this._internalMarkScenePrePassDirty = material._dirtyCallbacks[32];\n    return _this;\n  }\n\n  Object.defineProperty(PBRSubSurfaceConfiguration.prototype, \"scatteringDiffusionProfile\", {\n    /**\n     * Diffusion profile for subsurface scattering.\n     * Useful for better scattering in the skins or foliages.\n     */\n    get: function get() {\n      if (!this._scene.subSurfaceConfiguration) {\n        return null;\n      }\n\n      return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];\n    },\n    set: function set(c) {\n      if (!this._scene.enableSubSurfaceForPrePass()) {\n        // Not supported\n        return;\n      } // addDiffusionProfile automatically checks for doubles\n\n\n      if (c) {\n        this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration.addDiffusionProfile(c);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PBRSubSurfaceConfiguration.prototype, \"volumeIndexOfRefraction\", {\n    /**\n     * Index of refraction of the material's volume.\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\n     *\n     * This ONLY impacts refraction. If not provided or given a non-valid value,\n     * the volume will use the same IOR as the surface.\n     */\n    get: function get() {\n      if (this._volumeIndexOfRefraction >= 1.0) {\n        return this._volumeIndexOfRefraction;\n      }\n\n      return this._indexOfRefraction;\n    },\n    set: function set(value) {\n      if (value >= 1.0) {\n        this._volumeIndexOfRefraction = value;\n      } else {\n        this._volumeIndexOfRefraction = -1.0;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  PBRSubSurfaceConfiguration.prototype._markAllSubMeshesAsTexturesDirty = function () {\n    this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);\n\n    this._internalMarkAllSubMeshesAsTexturesDirty();\n  };\n  /** @hidden */\n\n\n  PBRSubSurfaceConfiguration.prototype._markScenePrePassDirty = function () {\n    this._internalMarkAllSubMeshesAsTexturesDirty();\n\n    this._internalMarkScenePrePassDirty();\n  };\n\n  PBRSubSurfaceConfiguration.prototype.isReadyForSubMesh = function (defines, scene) {\n    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\n      return true;\n    }\n\n    if (defines._areTexturesDirty) {\n      if (scene.texturesEnabled) {\n        if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n          if (!this._thicknessTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n\n        var refractionTexture = this._getRefractionTexture(scene);\n\n        if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n          if (!refractionTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  PBRSubSurfaceConfiguration.prototype.prepareDefines = function (defines, scene) {\n    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\n      defines.SUBSURFACE = false;\n      defines.SS_TRANSLUCENCY = false;\n      defines.SS_SCATTERING = false;\n      defines.SS_REFRACTION = false;\n      return;\n    }\n\n    if (defines._areTexturesDirty) {\n      defines.SUBSURFACE = true;\n      defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;\n      defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\n      defines.SS_SCATTERING = this._isScatteringEnabled;\n      defines.SS_THICKNESSANDMASK_TEXTURE = false;\n      defines.SS_REFRACTIONINTENSITY_TEXTURE = false;\n      defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\n      defines.SS_HAS_THICKNESS = false;\n      defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;\n      defines.SS_USE_GLTF_TEXTURES = false;\n      defines.SS_REFRACTION = false;\n      defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\n      defines.SS_REFRACTIONMAP_3D = false;\n      defines.SS_GAMMAREFRACTION = false;\n      defines.SS_RGBDREFRACTION = false;\n      defines.SS_LINEARSPECULARREFRACTION = false;\n      defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\n      defines.SS_LODINREFRACTIONALPHA = false;\n      defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\n      defines.SS_ALBEDOFORREFRACTIONTINT = false;\n      defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;\n      defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\n      defines.SS_USE_THICKNESS_AS_DEPTH = false;\n\n      var refractionIntensityTextureIsThicknessTexture = !!this._thicknessTexture && !!this._refractionIntensityTexture && this._refractionIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) && this._refractionIntensityTexture._texture === this._thicknessTexture._texture;\n\n      var translucencyIntensityTextureIsThicknessTexture = !!this._thicknessTexture && !!this._translucencyIntensityTexture && this._translucencyIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) && this._translucencyIntensityTexture._texture === this._thicknessTexture._texture; // if true, it means the refraction/translucency textures are the same than the thickness texture so there's no need to pass them to the shader, only thicknessTexture\n\n\n      var useOnlyThicknessTexture = (refractionIntensityTextureIsThicknessTexture || !this._refractionIntensityTexture) && (translucencyIntensityTextureIsThicknessTexture || !this._translucencyIntensityTexture);\n\n      if (defines._areTexturesDirty) {\n        if (scene.texturesEnabled) {\n          if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n            MaterialHelper.PrepareDefinesForMergedUV(this._thicknessTexture, defines, \"SS_THICKNESSANDMASK_TEXTURE\");\n          }\n\n          if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && !useOnlyThicknessTexture) {\n            MaterialHelper.PrepareDefinesForMergedUV(this._refractionIntensityTexture, defines, \"SS_REFRACTIONINTENSITY_TEXTURE\");\n          }\n\n          if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && !useOnlyThicknessTexture) {\n            MaterialHelper.PrepareDefinesForMergedUV(this._translucencyIntensityTexture, defines, \"SS_TRANSLUCENCYINTENSITY_TEXTURE\");\n          }\n        }\n      }\n\n      defines.SS_HAS_THICKNESS = this.maximumThickness - this.minimumThickness !== 0.0;\n      defines.SS_MASK_FROM_THICKNESS_TEXTURE = (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;\n      defines.SS_USE_GLTF_TEXTURES = this._useGltfStyleTextures;\n      defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture) && useOnlyThicknessTexture;\n      defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;\n\n      if (this._isRefractionEnabled) {\n        if (scene.texturesEnabled) {\n          var refractionTexture = this._getRefractionTexture(scene);\n\n          if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n            defines.SS_REFRACTION = true;\n            defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;\n            defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;\n            defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;\n            defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;\n            defines.SS_REFRACTIONMAP_OPPOSITEZ = refractionTexture.invertZ;\n            defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;\n            defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;\n            defines.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction;\n            defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = refractionTexture.isCube && refractionTexture.boundingBoxSize;\n            defines.SS_USE_THICKNESS_AS_DEPTH = this.useThicknessAsDepth;\n          }\n        }\n      }\n\n      if (this._isTranslucencyEnabled) {\n        defines.SS_ALBEDOFORTRANSLUCENCYTINT = this.useAlbedoToTintTranslucency;\n      }\n    }\n  };\n  /**\n   * Binds the material data (this function is called even if mustRebind() returns false)\n   * @param uniformBuffer defines the Uniform buffer to fill in.\n   * @param scene defines the scene the material belongs to.\n   * @param engine defines the engine the material belongs to.\n   * @param subMesh the submesh to bind data for\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.hardBindForSubMesh = function (uniformBuffer, scene, engine, subMesh) {\n    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\n      return;\n    }\n\n    subMesh.getRenderingMesh().getWorldMatrix().decompose(TmpVectors.Vector3[0]);\n    var thicknessScale = Math.max(Math.abs(TmpVectors.Vector3[0].x), Math.abs(TmpVectors.Vector3[0].y), Math.abs(TmpVectors.Vector3[0].z));\n    uniformBuffer.updateFloat2(\"vThicknessParam\", this.minimumThickness * thicknessScale, (this.maximumThickness - this.minimumThickness) * thicknessScale);\n  };\n\n  PBRSubSurfaceConfiguration.prototype.bindForSubMesh = function (uniformBuffer, scene, engine, subMesh) {\n    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\n      return;\n    }\n\n    var defines = subMesh.materialDefines;\n    var isFrozen = this._material.isFrozen;\n    var realTimeFiltering = this._material.realTimeFiltering;\n    var lodBasedMicrosurface = defines.LODBASEDMICROSFURACE;\n\n    var refractionTexture = this._getRefractionTexture(scene);\n\n    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\n      if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n        uniformBuffer.updateFloat2(\"vThicknessInfos\", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);\n        MaterialHelper.BindTextureMatrix(this._thicknessTexture, uniformBuffer, \"thickness\");\n      }\n\n      if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {\n        uniformBuffer.updateFloat2(\"vRefractionIntensityInfos\", this._refractionIntensityTexture.coordinatesIndex, this._refractionIntensityTexture.level);\n        MaterialHelper.BindTextureMatrix(this._refractionIntensityTexture, uniformBuffer, \"refractionIntensity\");\n      }\n\n      if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {\n        uniformBuffer.updateFloat2(\"vTranslucencyIntensityInfos\", this._translucencyIntensityTexture.coordinatesIndex, this._translucencyIntensityTexture.level);\n        MaterialHelper.BindTextureMatrix(this._translucencyIntensityTexture, uniformBuffer, \"translucencyIntensity\");\n      }\n\n      if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n        uniformBuffer.updateMatrix(\"refractionMatrix\", refractionTexture.getReflectionTextureMatrix());\n        var depth = 1.0;\n\n        if (!refractionTexture.isCube) {\n          if (refractionTexture.depth) {\n            depth = refractionTexture.depth;\n          }\n        }\n\n        var width = refractionTexture.getSize().width;\n        var refractionIor = this.volumeIndexOfRefraction;\n        uniformBuffer.updateFloat4(\"vRefractionInfos\", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);\n        uniformBuffer.updateFloat4(\"vRefractionMicrosurfaceInfos\", width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset, 1.0 / this.indexOfRefraction);\n\n        if (realTimeFiltering) {\n          uniformBuffer.updateFloat2(\"vRefractionFilteringInfo\", width, Scalar.Log2(width));\n        }\n\n        if (refractionTexture.boundingBoxSize) {\n          var cubeTexture = refractionTexture;\n          uniformBuffer.updateVector3(\"vRefractionPosition\", cubeTexture.boundingBoxPosition);\n          uniformBuffer.updateVector3(\"vRefractionSize\", cubeTexture.boundingBoxSize);\n        }\n      }\n\n      if (this._isScatteringEnabled) {\n        uniformBuffer.updateFloat(\"scatteringDiffusionProfile\", this._scatteringDiffusionProfileIndex);\n      }\n\n      uniformBuffer.updateColor3(\"vDiffusionDistance\", this.diffusionDistance);\n      uniformBuffer.updateFloat4(\"vTintColor\", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(0.00001, this.tintColorAtDistance));\n      uniformBuffer.updateFloat3(\"vSubSurfaceIntensity\", this.refractionIntensity, this.translucencyIntensity, 0);\n    } // Textures\n\n\n    if (scene.texturesEnabled) {\n      if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n        uniformBuffer.setTexture(\"thicknessSampler\", this._thicknessTexture);\n      }\n\n      if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {\n        uniformBuffer.setTexture(\"refractionIntensitySampler\", this._refractionIntensityTexture);\n      }\n\n      if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {\n        uniformBuffer.setTexture(\"translucencyIntensitySampler\", this._translucencyIntensityTexture);\n      }\n\n      if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n        if (lodBasedMicrosurface) {\n          uniformBuffer.setTexture(\"refractionSampler\", refractionTexture);\n        } else {\n          uniformBuffer.setTexture(\"refractionSampler\", refractionTexture._lodTextureMid || refractionTexture);\n          uniformBuffer.setTexture(\"refractionSamplerLow\", refractionTexture._lodTextureLow || refractionTexture);\n          uniformBuffer.setTexture(\"refractionSamplerHigh\", refractionTexture._lodTextureHigh || refractionTexture);\n        }\n      }\n    }\n  };\n  /**\n   * Returns the texture used for refraction or null if none is used.\n   * @param scene defines the scene the material belongs to.\n   * @returns - Refraction texture if present.  If no refraction texture and refraction\n   * is linked with transparency, returns environment texture.  Otherwise, returns null.\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype._getRefractionTexture = function (scene) {\n    if (this._refractionTexture) {\n      return this._refractionTexture;\n    }\n\n    if (this._isRefractionEnabled) {\n      return scene.environmentTexture;\n    }\n\n    return null;\n  };\n\n  Object.defineProperty(PBRSubSurfaceConfiguration.prototype, \"disableAlphaBlending\", {\n    /**\n     * Returns true if alpha blending should be disabled.\n     */\n    get: function get() {\n      return this._isRefractionEnabled && this._linkRefractionWithTransparency;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Fills the list of render target textures.\n   * @param renderTargets the list of render targets to update\n   */\n\n  PBRSubSurfaceConfiguration.prototype.fillRenderTargetTextures = function (renderTargets) {\n    if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\n      renderTargets.push(this._refractionTexture);\n    }\n  };\n\n  PBRSubSurfaceConfiguration.prototype.hasTexture = function (texture) {\n    if (this._thicknessTexture === texture) {\n      return true;\n    }\n\n    if (this._refractionTexture === texture) {\n      return true;\n    }\n\n    return false;\n  };\n\n  PBRSubSurfaceConfiguration.prototype.hasRenderTargetTextures = function () {\n    if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\n      return true;\n    }\n\n    return false;\n  };\n\n  PBRSubSurfaceConfiguration.prototype.getActiveTextures = function (activeTextures) {\n    if (this._thicknessTexture) {\n      activeTextures.push(this._thicknessTexture);\n    }\n\n    if (this._refractionTexture) {\n      activeTextures.push(this._refractionTexture);\n    }\n  };\n\n  PBRSubSurfaceConfiguration.prototype.getAnimatables = function (animatables) {\n    if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {\n      animatables.push(this._thicknessTexture);\n    }\n\n    if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\n      animatables.push(this._refractionTexture);\n    }\n  };\n\n  PBRSubSurfaceConfiguration.prototype.dispose = function (forceDisposeTextures) {\n    if (forceDisposeTextures) {\n      if (this._thicknessTexture) {\n        this._thicknessTexture.dispose();\n      }\n\n      if (this._refractionTexture) {\n        this._refractionTexture.dispose();\n      }\n    }\n  };\n\n  PBRSubSurfaceConfiguration.prototype.getClassName = function () {\n    return \"PBRSubSurfaceConfiguration\";\n  };\n\n  PBRSubSurfaceConfiguration.prototype.addFallbacks = function (defines, fallbacks, currentRank) {\n    if (defines.SS_SCATTERING) {\n      fallbacks.addFallback(currentRank++, \"SS_SCATTERING\");\n    }\n\n    if (defines.SS_TRANSLUCENCY) {\n      fallbacks.addFallback(currentRank++, \"SS_TRANSLUCENCY\");\n    }\n\n    return currentRank;\n  };\n\n  PBRSubSurfaceConfiguration.prototype.getSamplers = function (samplers) {\n    samplers.push(\"thicknessSampler\", \"refractionIntensitySampler\", \"translucencyIntensitySampler\", \"refractionSampler\", \"refractionSamplerLow\", \"refractionSamplerHigh\");\n  };\n\n  PBRSubSurfaceConfiguration.prototype.getUniforms = function () {\n    return {\n      ubo: [{\n        name: \"vRefractionMicrosurfaceInfos\",\n        size: 4,\n        type: \"vec4\"\n      }, {\n        name: \"vRefractionFilteringInfo\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"vTranslucencyIntensityInfos\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"vRefractionInfos\",\n        size: 4,\n        type: \"vec4\"\n      }, {\n        name: \"refractionMatrix\",\n        size: 16,\n        type: \"mat4\"\n      }, {\n        name: \"vThicknessInfos\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"vRefractionIntensityInfos\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"thicknessMatrix\",\n        size: 16,\n        type: \"mat4\"\n      }, {\n        name: \"refractionIntensityMatrix\",\n        size: 16,\n        type: \"mat4\"\n      }, {\n        name: \"translucencyIntensityMatrix\",\n        size: 16,\n        type: \"mat4\"\n      }, {\n        name: \"vThicknessParam\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"vDiffusionDistance\",\n        size: 3,\n        type: \"vec3\"\n      }, {\n        name: \"vTintColor\",\n        size: 4,\n        type: \"vec4\"\n      }, {\n        name: \"vSubSurfaceIntensity\",\n        size: 3,\n        type: \"vec3\"\n      }, {\n        name: \"vRefractionPosition\",\n        size: 3,\n        type: \"vec3\"\n      }, {\n        name: \"vRefractionSize\",\n        size: 3,\n        type: \"vec3\"\n      }, {\n        name: \"scatteringDiffusionProfile\",\n        size: 1,\n        type: \"float\"\n      }]\n    };\n  };\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"isRefractionEnabled\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"isTranslucencyEnabled\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markScenePrePassDirty\")], PBRSubSurfaceConfiguration.prototype, \"isScatteringEnabled\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"_scatteringDiffusionProfileIndex\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"refractionIntensity\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"translucencyIntensity\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"useAlbedoToTintRefraction\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"useAlbedoToTintTranslucency\", void 0);\n\n  __decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"thicknessTexture\", void 0);\n\n  __decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"refractionTexture\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"indexOfRefraction\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"_volumeIndexOfRefraction\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"volumeIndexOfRefraction\", null);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"invertRefractionY\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"linkRefractionWithTransparency\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"minimumThickness\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"maximumThickness\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"useThicknessAsDepth\", void 0);\n\n  __decorate([serializeAsColor3()], PBRSubSurfaceConfiguration.prototype, \"tintColor\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"tintColorAtDistance\", void 0);\n\n  __decorate([serializeAsColor3()], PBRSubSurfaceConfiguration.prototype, \"diffusionDistance\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"useMaskFromThicknessTexture\", void 0);\n\n  __decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"refractionIntensityTexture\", void 0);\n\n  __decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"translucencyIntensityTexture\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"useGltfStyleTextures\", void 0);\n\n  return PBRSubSurfaceConfiguration;\n}(MaterialPluginBase);\n\nexport { PBRSubSurfaceConfiguration };","map":{"version":3,"mappings":"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","names":["serialize","serializeAsTexture","expandToProperty","serializeAsColor3","Color3","MaterialFlags","MaterialHelper","Scalar","TmpVectors","MaterialPluginBase","MaterialDefines","__extends","_this","material","addToPluginList","_super","MaterialSubSurfaceDefines","White","_scene","getScene","registerForExtraEvents","_internalMarkAllSubMeshesAsTexturesDirty","_dirtyCallbacks","_internalMarkScenePrePassDirty","Object","PBRSubSurfaceConfiguration","subSurfaceConfiguration","ssDiffusionProfileColors","_scatteringDiffusionProfileIndex","c","enableSubSurfaceForPrePass","addDiffusionProfile","_volumeIndexOfRefraction","_indexOfRefraction","value","_enable","_isRefractionEnabled","_isTranslucencyEnabled","_isScatteringEnabled","defines","scene","_areTexturesDirty","texturesEnabled","_thicknessTexture","ThicknessTextureEnabled","isReadyOrNotBlocking","refractionTexture","_getRefractionTexture","RefractionTextureEnabled","SUBSURFACE","SS_TRANSLUCENCY","SS_SCATTERING","SS_REFRACTION","SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE","SS_THICKNESSANDMASK_TEXTURE","SS_REFRACTIONINTENSITY_TEXTURE","SS_TRANSLUCENCYINTENSITY_TEXTURE","SS_HAS_THICKNESS","SS_MASK_FROM_THICKNESS_TEXTURE","SS_USE_GLTF_TEXTURES","SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE","SS_REFRACTIONMAP_3D","SS_GAMMAREFRACTION","SS_RGBDREFRACTION","SS_LINEARSPECULARREFRACTION","SS_REFRACTIONMAP_OPPOSITEZ","SS_LODINREFRACTIONALPHA","SS_LINKREFRACTIONTOTRANSPARENCY","SS_ALBEDOFORREFRACTIONTINT","SS_ALBEDOFORTRANSLUCENCYTINT","SS_USE_LOCAL_REFRACTIONMAP_CUBIC","SS_USE_THICKNESS_AS_DEPTH","refractionIntensityTextureIsThicknessTexture","_refractionIntensityTexture","checkTransformsAreIdentical","_texture","translucencyIntensityTextureIsThicknessTexture","_translucencyIntensityTexture","useOnlyThicknessTexture","PrepareDefinesForMergedUV","RefractionIntensityTextureEnabled","TranslucencyIntensityTextureEnabled","maximumThickness","minimumThickness","_useMaskFromThicknessTexture","_useGltfStyleTextures","isCube","gammaSpace","isRGBD","linearSpecularLOD","invertZ","lodLevelInAlpha","_linkRefractionWithTransparency","useAlbedoToTintRefraction","boundingBoxSize","useThicknessAsDepth","useAlbedoToTintTranslucency","uniformBuffer","engine","subMesh","getRenderingMesh","getWorldMatrix","decompose","Vector3","thicknessScale","Math","max","abs","x","y","z","updateFloat2","materialDefines","isFrozen","_material","realTimeFiltering","lodBasedMicrosurface","LODBASEDMICROSFURACE","useUbo","isSync","coordinatesIndex","level","BindTextureMatrix","updateMatrix","getReflectionTextureMatrix","depth","width","getSize","refractionIor","volumeIndexOfRefraction","updateFloat4","_invertRefractionY","lodGenerationScale","lodGenerationOffset","indexOfRefraction","Log2","cubeTexture","updateVector3","boundingBoxPosition","updateFloat","updateColor3","diffusionDistance","tintColor","r","g","b","tintColorAtDistance","updateFloat3","refractionIntensity","translucencyIntensity","setTexture","_lodTextureMid","_lodTextureLow","_lodTextureHigh","_refractionTexture","environmentTexture","renderTargets","isRenderTarget","push","texture","activeTextures","animatables","animations","length","forceDisposeTextures","dispose","fallbacks","currentRank","addFallback","samplers","ubo","name","size","type","__decorate"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/PBR/pbrSubSurfaceConfiguration.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport { serialize, serializeAsTexture, expandToProperty, serializeAsColor3 } from \"../../Misc/decorators\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport type { SmartArray } from \"../../Misc/smartArray\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { MaterialFlags } from \"../materialFlags\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { CubeTexture } from \"../Textures/cubeTexture\";\r\nimport { TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\n\r\ndeclare type Engine = import(\"../../Engines/engine\").Engine;\r\ndeclare type Scene = import(\"../../scene\").Scene;\r\ndeclare type PBRBaseMaterial = import(\"./pbrBaseMaterial\").PBRBaseMaterial;\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class MaterialSubSurfaceDefines extends MaterialDefines {\r\n    public SUBSURFACE = false;\r\n\r\n    public SS_REFRACTION = false;\r\n    public SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\r\n    public SS_TRANSLUCENCY = false;\r\n    public SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\r\n    public SS_SCATTERING = false;\r\n\r\n    public SS_THICKNESSANDMASK_TEXTURE = false;\r\n    public SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;\r\n    public SS_HAS_THICKNESS = false;\r\n    public SS_REFRACTIONINTENSITY_TEXTURE = false;\r\n    public SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;\r\n    public SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\r\n    public SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;\r\n\r\n    public SS_REFRACTIONMAP_3D = false;\r\n    public SS_REFRACTIONMAP_OPPOSITEZ = false;\r\n    public SS_LODINREFRACTIONALPHA = false;\r\n    public SS_GAMMAREFRACTION = false;\r\n    public SS_RGBDREFRACTION = false;\r\n    public SS_LINEARSPECULARREFRACTION = false;\r\n    public SS_LINKREFRACTIONTOTRANSPARENCY = false;\r\n    public SS_ALBEDOFORREFRACTIONTINT = false;\r\n    public SS_ALBEDOFORTRANSLUCENCYTINT = false;\r\n    public SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\r\n    public SS_USE_THICKNESS_AS_DEPTH = false;\r\n\r\n    public SS_MASK_FROM_THICKNESS_TEXTURE = false;\r\n    public SS_USE_GLTF_TEXTURES = false;\r\n}\r\n\r\n/**\r\n * Plugin that implements the sub surface component of the PBR material\r\n */\r\nexport class PBRSubSurfaceConfiguration extends MaterialPluginBase {\r\n    protected _material: PBRBaseMaterial;\r\n\r\n    private _isRefractionEnabled = false;\r\n    /**\r\n     * Defines if the refraction is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isRefractionEnabled = false;\r\n\r\n    private _isTranslucencyEnabled = false;\r\n    /**\r\n     * Defines if the translucency is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isTranslucencyEnabled = false;\r\n\r\n    private _isScatteringEnabled = false;\r\n    /**\r\n     * Defines if the sub surface scattering is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markScenePrePassDirty\")\r\n    public isScatteringEnabled = false;\r\n\r\n    @serialize()\r\n    private _scatteringDiffusionProfileIndex = 0;\r\n\r\n    /**\r\n     * Diffusion profile for subsurface scattering.\r\n     * Useful for better scattering in the skins or foliages.\r\n     */\r\n    public get scatteringDiffusionProfile(): Nullable<Color3> {\r\n        if (!this._scene.subSurfaceConfiguration) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];\r\n    }\r\n\r\n    public set scatteringDiffusionProfile(c: Nullable<Color3>) {\r\n        if (!this._scene.enableSubSurfaceForPrePass()) {\r\n            // Not supported\r\n            return;\r\n        }\r\n\r\n        // addDiffusionProfile automatically checks for doubles\r\n        if (c) {\r\n            this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration!.addDiffusionProfile(c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the refraction intensity of the material.\r\n     * The refraction when enabled replaces the Diffuse part of the material.\r\n     * The intensity helps transitioning between diffuse and refraction.\r\n     */\r\n    @serialize()\r\n    public refractionIntensity: number = 1;\r\n\r\n    /**\r\n     * Defines the translucency intensity of the material.\r\n     * When translucency has been enabled, this defines how much of the \"translucency\"\r\n     * is added to the diffuse part of the material.\r\n     */\r\n    @serialize()\r\n    public translucencyIntensity: number = 1;\r\n\r\n    /**\r\n     * When enabled, transparent surfaces will be tinted with the albedo colour (independent of thickness)\r\n     */\r\n    @serialize()\r\n    public useAlbedoToTintRefraction: boolean = false;\r\n\r\n    /**\r\n     * When enabled, translucent surfaces will be tinted with the albedo colour (independent of thickness)\r\n     */\r\n    @serialize()\r\n    public useAlbedoToTintTranslucency: boolean = false;\r\n\r\n    private _thicknessTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the average thickness of a mesh in a texture (The texture is holding the values linearly).\r\n     * The red (or green if useGltfStyleTextures=true) channel of the texture should contain the thickness remapped between 0 and 1.\r\n     * 0 would mean minimumThickness\r\n     * 1 would mean maximumThickness\r\n     * The other channels might be use as a mask to vary the different effects intensity.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public thicknessTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _refractionTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Defines the texture to use for refraction.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public refractionTexture: Nullable<BaseTexture> = null;\r\n\r\n    /** @hidden */\r\n    public _indexOfRefraction = 1.5;\r\n    /**\r\n     * Index of refraction of the material base layer.\r\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\r\n     *\r\n     * This does not only impact refraction but also the Base F0 of Dielectric Materials.\r\n     *\r\n     * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public indexOfRefraction = 1.5;\r\n\r\n    @serialize()\r\n    private _volumeIndexOfRefraction = -1.0;\r\n\r\n    /**\r\n     * Index of refraction of the material's volume.\r\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\r\n     *\r\n     * This ONLY impacts refraction. If not provided or given a non-valid value,\r\n     * the volume will use the same IOR as the surface.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public get volumeIndexOfRefraction(): number {\r\n        if (this._volumeIndexOfRefraction >= 1.0) {\r\n            return this._volumeIndexOfRefraction;\r\n        }\r\n        return this._indexOfRefraction;\r\n    }\r\n    public set volumeIndexOfRefraction(value: number) {\r\n        if (value >= 1.0) {\r\n            this._volumeIndexOfRefraction = value;\r\n        } else {\r\n            this._volumeIndexOfRefraction = -1.0;\r\n        }\r\n    }\r\n\r\n    private _invertRefractionY = false;\r\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertRefractionY = false;\r\n\r\n    /** @hidden */\r\n    public _linkRefractionWithTransparency = false;\r\n    /**\r\n     * This parameters will make the material used its opacity to control how much it is refracting against not.\r\n     * Materials half opaque for instance using refraction could benefit from this control.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public linkRefractionWithTransparency = false;\r\n\r\n    /**\r\n     * Defines the minimum thickness stored in the thickness map.\r\n     * If no thickness map is defined, this value will be used to simulate thickness.\r\n     */\r\n    @serialize()\r\n    public minimumThickness: number = 0;\r\n\r\n    /**\r\n     * Defines the maximum thickness stored in the thickness map.\r\n     */\r\n    @serialize()\r\n    public maximumThickness: number = 1;\r\n\r\n    /**\r\n     * Defines that the thickness should be used as a measure of the depth volume.\r\n     */\r\n    @serialize()\r\n    public useThicknessAsDepth = false;\r\n\r\n    /**\r\n     * Defines the volume tint of the material.\r\n     * This is used for both translucency and scattering.\r\n     */\r\n    @serializeAsColor3()\r\n    public tintColor = Color3.White();\r\n\r\n    /**\r\n     * Defines the distance at which the tint color should be found in the media.\r\n     * This is used for refraction only.\r\n     */\r\n    @serialize()\r\n    public tintColorAtDistance = 1;\r\n\r\n    /**\r\n     * Defines how far each channel transmit through the media.\r\n     * It is defined as a color to simplify it selection.\r\n     */\r\n    @serializeAsColor3()\r\n    public diffusionDistance = Color3.White();\r\n\r\n    private _useMaskFromThicknessTexture = false;\r\n    /**\r\n     * Stores the intensity of the different subsurface effects in the thickness texture.\r\n     * Note that if refractionIntensityTexture and/or translucencyIntensityTexture is provided it takes precedence over thicknessTexture + useMaskFromThicknessTexture\r\n     * * the green (red if useGltfStyleTextures = true) channel is the refraction intensity.\r\n     * * the blue channel is the translucency intensity.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useMaskFromThicknessTexture: boolean = false;\r\n\r\n    private _refractionIntensityTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the intensity of the refraction. If provided, it takes precedence over thicknessTexture + useMaskFromThicknessTexture\r\n     * * the green (red if useGltfStyleTextures = true) channel is the refraction intensity.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public refractionIntensityTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _translucencyIntensityTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the intensity of the translucency. If provided, it takes precedence over thicknessTexture + useMaskFromThicknessTexture\r\n     * * the blue channel is the translucency intensity.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public translucencyIntensityTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _scene: Scene;\r\n    private _useGltfStyleTextures = false;\r\n    /**\r\n     * Use channels layout used by glTF:\r\n     * * thicknessTexture: the green (instead of red) channel is the thickness\r\n     * * thicknessTexture/refractionIntensityTexture: the red (instead of green) channel is the refraction intensity\r\n     * * thicknessTexture/translucencyIntensityTexture: no change, use the blue channel for the translucency intensity\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useGltfStyleTextures: boolean = false;\r\n\r\n    /** @hidden */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n    private _internalMarkScenePrePassDirty: () => void;\r\n\r\n    /** @hidden */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n    /** @hidden */\r\n    public _markScenePrePassDirty(): void {\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n        this._internalMarkScenePrePassDirty();\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"PBRSubSurface\", 130, new MaterialSubSurfaceDefines(), addToPluginList);\r\n\r\n        this._scene = material.getScene();\r\n        this.registerForExtraEvents = true;\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n        this._internalMarkScenePrePassDirty = material._dirtyCallbacks[Constants.MATERIAL_PrePassDirtyFlag];\r\n    }\r\n\r\n    public isReadyForSubMesh(defines: MaterialSubSurfaceDefines, scene: Scene): boolean {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            return true;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                    if (!this._thicknessTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                const refractionTexture = this._getRefractionTexture(scene);\r\n                if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                    if (!refractionTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public prepareDefines(defines: MaterialSubSurfaceDefines, scene: Scene): void {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            defines.SUBSURFACE = false;\r\n            defines.SS_TRANSLUCENCY = false;\r\n            defines.SS_SCATTERING = false;\r\n            defines.SS_REFRACTION = false;\r\n            return;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            defines.SUBSURFACE = true;\r\n\r\n            defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;\r\n            defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\r\n            defines.SS_SCATTERING = this._isScatteringEnabled;\r\n            defines.SS_THICKNESSANDMASK_TEXTURE = false;\r\n            defines.SS_REFRACTIONINTENSITY_TEXTURE = false;\r\n            defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\r\n            defines.SS_HAS_THICKNESS = false;\r\n            defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;\r\n            defines.SS_USE_GLTF_TEXTURES = false;\r\n            defines.SS_REFRACTION = false;\r\n            defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\r\n            defines.SS_REFRACTIONMAP_3D = false;\r\n            defines.SS_GAMMAREFRACTION = false;\r\n            defines.SS_RGBDREFRACTION = false;\r\n            defines.SS_LINEARSPECULARREFRACTION = false;\r\n            defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\r\n            defines.SS_LODINREFRACTIONALPHA = false;\r\n            defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\r\n            defines.SS_ALBEDOFORREFRACTIONTINT = false;\r\n            defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;\r\n            defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\r\n            defines.SS_USE_THICKNESS_AS_DEPTH = false;\r\n\r\n            const refractionIntensityTextureIsThicknessTexture =\r\n                !!this._thicknessTexture &&\r\n                !!this._refractionIntensityTexture &&\r\n                this._refractionIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) &&\r\n                this._refractionIntensityTexture._texture === this._thicknessTexture._texture;\r\n\r\n            const translucencyIntensityTextureIsThicknessTexture =\r\n                !!this._thicknessTexture &&\r\n                !!this._translucencyIntensityTexture &&\r\n                this._translucencyIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) &&\r\n                this._translucencyIntensityTexture._texture === this._thicknessTexture._texture;\r\n\r\n            // if true, it means the refraction/translucency textures are the same than the thickness texture so there's no need to pass them to the shader, only thicknessTexture\r\n            const useOnlyThicknessTexture =\r\n                (refractionIntensityTextureIsThicknessTexture || !this._refractionIntensityTexture) &&\r\n                (translucencyIntensityTextureIsThicknessTexture || !this._translucencyIntensityTexture);\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (scene.texturesEnabled) {\r\n                    if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._thicknessTexture, defines, \"SS_THICKNESSANDMASK_TEXTURE\");\r\n                    }\r\n\r\n                    if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && !useOnlyThicknessTexture) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._refractionIntensityTexture, defines, \"SS_REFRACTIONINTENSITY_TEXTURE\");\r\n                    }\r\n\r\n                    if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && !useOnlyThicknessTexture) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._translucencyIntensityTexture, defines, \"SS_TRANSLUCENCYINTENSITY_TEXTURE\");\r\n                    }\r\n                }\r\n            }\r\n\r\n            defines.SS_HAS_THICKNESS = this.maximumThickness - this.minimumThickness !== 0.0;\r\n            defines.SS_MASK_FROM_THICKNESS_TEXTURE =\r\n                (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;\r\n            defines.SS_USE_GLTF_TEXTURES = this._useGltfStyleTextures;\r\n            defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture) && useOnlyThicknessTexture;\r\n            defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;\r\n\r\n            if (this._isRefractionEnabled) {\r\n                if (scene.texturesEnabled) {\r\n                    const refractionTexture = this._getRefractionTexture(scene);\r\n                    if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                        defines.SS_REFRACTION = true;\r\n                        defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;\r\n                        defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;\r\n                        defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;\r\n                        defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;\r\n                        defines.SS_REFRACTIONMAP_OPPOSITEZ = refractionTexture.invertZ;\r\n                        defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;\r\n                        defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;\r\n                        defines.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction;\r\n                        defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = refractionTexture.isCube && (<any>refractionTexture).boundingBoxSize;\r\n                        defines.SS_USE_THICKNESS_AS_DEPTH = this.useThicknessAsDepth;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this._isTranslucencyEnabled) {\r\n                defines.SS_ALBEDOFORTRANSLUCENCYTINT = this.useAlbedoToTintTranslucency;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the material data (this function is called even if mustRebind() returns false)\r\n     * @param uniformBuffer defines the Uniform buffer to fill in.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param engine defines the engine the material belongs to.\r\n     * @param subMesh the submesh to bind data for\r\n     */\r\n    public hardBindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, subMesh: SubMesh): void {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            return;\r\n        }\r\n\r\n        subMesh.getRenderingMesh().getWorldMatrix().decompose(TmpVectors.Vector3[0]);\r\n\r\n        const thicknessScale = Math.max(Math.abs(TmpVectors.Vector3[0].x), Math.abs(TmpVectors.Vector3[0].y), Math.abs(TmpVectors.Vector3[0].z));\r\n\r\n        uniformBuffer.updateFloat2(\"vThicknessParam\", this.minimumThickness * thicknessScale, (this.maximumThickness - this.minimumThickness) * thicknessScale);\r\n    }\r\n\r\n    public bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, subMesh: SubMesh): void {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            return;\r\n        }\r\n\r\n        const defines = subMesh!.materialDefines as unknown as MaterialSubSurfaceDefines;\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n        const realTimeFiltering = this._material.realTimeFiltering;\r\n        const lodBasedMicrosurface = defines.LODBASEDMICROSFURACE;\r\n\r\n        const refractionTexture = this._getRefractionTexture(scene);\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                uniformBuffer.updateFloat2(\"vThicknessInfos\", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);\r\n                MaterialHelper.BindTextureMatrix(this._thicknessTexture, uniformBuffer, \"thickness\");\r\n            }\r\n\r\n            if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {\r\n                uniformBuffer.updateFloat2(\"vRefractionIntensityInfos\", this._refractionIntensityTexture.coordinatesIndex, this._refractionIntensityTexture.level);\r\n                MaterialHelper.BindTextureMatrix(this._refractionIntensityTexture, uniformBuffer, \"refractionIntensity\");\r\n            }\r\n\r\n            if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {\r\n                uniformBuffer.updateFloat2(\"vTranslucencyIntensityInfos\", this._translucencyIntensityTexture.coordinatesIndex, this._translucencyIntensityTexture.level);\r\n                MaterialHelper.BindTextureMatrix(this._translucencyIntensityTexture, uniformBuffer, \"translucencyIntensity\");\r\n            }\r\n\r\n            if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                uniformBuffer.updateMatrix(\"refractionMatrix\", refractionTexture.getReflectionTextureMatrix());\r\n\r\n                let depth = 1.0;\r\n                if (!refractionTexture.isCube) {\r\n                    if ((<any>refractionTexture).depth) {\r\n                        depth = (<any>refractionTexture).depth;\r\n                    }\r\n                }\r\n\r\n                const width = refractionTexture.getSize().width;\r\n                const refractionIor = this.volumeIndexOfRefraction;\r\n                uniformBuffer.updateFloat4(\"vRefractionInfos\", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);\r\n                uniformBuffer.updateFloat4(\r\n                    \"vRefractionMicrosurfaceInfos\",\r\n                    width,\r\n                    refractionTexture.lodGenerationScale,\r\n                    refractionTexture.lodGenerationOffset,\r\n                    1.0 / this.indexOfRefraction\r\n                );\r\n\r\n                if (realTimeFiltering) {\r\n                    uniformBuffer.updateFloat2(\"vRefractionFilteringInfo\", width, Scalar.Log2(width));\r\n                }\r\n\r\n                if ((<any>refractionTexture).boundingBoxSize) {\r\n                    const cubeTexture = <CubeTexture>refractionTexture;\r\n\r\n                    uniformBuffer.updateVector3(\"vRefractionPosition\", cubeTexture.boundingBoxPosition);\r\n                    uniformBuffer.updateVector3(\"vRefractionSize\", cubeTexture.boundingBoxSize);\r\n                }\r\n            }\r\n\r\n            if (this._isScatteringEnabled) {\r\n                uniformBuffer.updateFloat(\"scatteringDiffusionProfile\", this._scatteringDiffusionProfileIndex);\r\n            }\r\n            uniformBuffer.updateColor3(\"vDiffusionDistance\", this.diffusionDistance);\r\n\r\n            uniformBuffer.updateFloat4(\"vTintColor\", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(0.00001, this.tintColorAtDistance));\r\n\r\n            uniformBuffer.updateFloat3(\"vSubSurfaceIntensity\", this.refractionIntensity, this.translucencyIntensity, 0);\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                uniformBuffer.setTexture(\"thicknessSampler\", this._thicknessTexture);\r\n            }\r\n\r\n            if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {\r\n                uniformBuffer.setTexture(\"refractionIntensitySampler\", this._refractionIntensityTexture);\r\n            }\r\n\r\n            if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {\r\n                uniformBuffer.setTexture(\"translucencyIntensitySampler\", this._translucencyIntensityTexture);\r\n            }\r\n\r\n            if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                if (lodBasedMicrosurface) {\r\n                    uniformBuffer.setTexture(\"refractionSampler\", refractionTexture);\r\n                } else {\r\n                    uniformBuffer.setTexture(\"refractionSampler\", refractionTexture._lodTextureMid || refractionTexture);\r\n                    uniformBuffer.setTexture(\"refractionSamplerLow\", refractionTexture._lodTextureLow || refractionTexture);\r\n                    uniformBuffer.setTexture(\"refractionSamplerHigh\", refractionTexture._lodTextureHigh || refractionTexture);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the texture used for refraction or null if none is used.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @returns - Refraction texture if present.  If no refraction texture and refraction\r\n     * is linked with transparency, returns environment texture.  Otherwise, returns null.\r\n     */\r\n    private _getRefractionTexture(scene: Scene): Nullable<BaseTexture> {\r\n        if (this._refractionTexture) {\r\n            return this._refractionTexture;\r\n        }\r\n\r\n        if (this._isRefractionEnabled) {\r\n            return scene.environmentTexture;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\r\n    public get disableAlphaBlending(): boolean {\r\n        return this._isRefractionEnabled && this._linkRefractionWithTransparency;\r\n    }\r\n\r\n    /**\r\n     * Fills the list of render target textures.\r\n     * @param renderTargets the list of render targets to update\r\n     */\r\n    public fillRenderTargetTextures(renderTargets: SmartArray<RenderTargetTexture>): void {\r\n        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n            renderTargets.push(<RenderTargetTexture>this._refractionTexture);\r\n        }\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (this._thicknessTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._refractionTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public hasRenderTargetTextures(): boolean {\r\n        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._thicknessTexture) {\r\n            activeTextures.push(this._thicknessTexture);\r\n        }\r\n\r\n        if (this._refractionTexture) {\r\n            activeTextures.push(this._refractionTexture);\r\n        }\r\n    }\r\n\r\n    public getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {\r\n            animatables.push(this._thicknessTexture);\r\n        }\r\n\r\n        if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\r\n            animatables.push(this._refractionTexture);\r\n        }\r\n    }\r\n\r\n    public dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            if (this._thicknessTexture) {\r\n                this._thicknessTexture.dispose();\r\n            }\r\n\r\n            if (this._refractionTexture) {\r\n                this._refractionTexture.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"PBRSubSurfaceConfiguration\";\r\n    }\r\n\r\n    public addFallbacks(defines: MaterialSubSurfaceDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.SS_SCATTERING) {\r\n            fallbacks.addFallback(currentRank++, \"SS_SCATTERING\");\r\n        }\r\n        if (defines.SS_TRANSLUCENCY) {\r\n            fallbacks.addFallback(currentRank++, \"SS_TRANSLUCENCY\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    public getSamplers(samplers: string[]): void {\r\n        samplers.push(\"thicknessSampler\", \"refractionIntensitySampler\", \"translucencyIntensitySampler\", \"refractionSampler\", \"refractionSamplerLow\", \"refractionSamplerHigh\");\r\n    }\r\n\r\n    public getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vRefractionMicrosurfaceInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"vRefractionFilteringInfo\", size: 2, type: \"vec2\" },\r\n                { name: \"vTranslucencyIntensityInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"vRefractionInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"refractionMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"vThicknessInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"vRefractionIntensityInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"thicknessMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"refractionIntensityMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"translucencyIntensityMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"vThicknessParam\", size: 2, type: \"vec2\" },\r\n                { name: \"vDiffusionDistance\", size: 3, type: \"vec3\" },\r\n                { name: \"vTintColor\", size: 4, type: \"vec4\" },\r\n                { name: \"vSubSurfaceIntensity\", size: 3, type: \"vec3\" },\r\n                { name: \"vRefractionPosition\", size: 3, type: \"vec3\" },\r\n                { name: \"vRefractionSize\", size: 3, type: \"vec3\" },\r\n                { name: \"scatteringDiffusionProfile\", size: 1, type: \"float\" },\r\n            ],\r\n        };\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}