{"ast":null,"code":"import \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport { __decorate, __extends } from \"tslib\";\nimport { serialize } from \"../Misc/decorators.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Node } from \"../node.js\";\nimport { Light } from \"./light.js\";\nimport { ShadowLight } from \"./shadowLight.js\";\nNode.AddNodeConstructor(\"Light_Type_1\", function (name, scene) {\n  return function () {\n    return new DirectionalLight(name, Vector3.Zero(), scene);\n  };\n});\n/**\n * A directional light is defined by a direction (what a surprise!).\n * The light is emitted from everywhere in the specified direction, and has an infinite range.\n * An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.\n * Documentation: https://doc.babylonjs.com/babylon101/lights\n */\n\nvar DirectionalLight =\n/** @class */\nfunction (_super) {\n  __extends(DirectionalLight, _super);\n  /**\n   * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).\n   * The directional light is emitted from everywhere in the given direction.\n   * It can cast shadows.\n   * Documentation : https://doc.babylonjs.com/babylon101/lights\n   * @param name The friendly name of the light\n   * @param direction The direction of the light\n   * @param scene The scene the light belongs to\n   */\n\n\n  function DirectionalLight(name, direction, scene) {\n    var _this = _super.call(this, name, scene) || this;\n\n    _this._shadowFrustumSize = 0;\n    _this._shadowOrthoScale = 0.1;\n    /**\n     * Automatically compute the projection matrix to best fit (including all the casters)\n     * on each frame.\n     */\n\n    _this.autoUpdateExtends = true;\n    /**\n     * Automatically compute the shadowMinZ and shadowMaxZ for the projection matrix to best fit (including all the casters)\n     * on each frame. autoUpdateExtends must be set to true for this to work\n     */\n\n    _this.autoCalcShadowZBounds = false; // Cache\n\n    _this._orthoLeft = Number.MAX_VALUE;\n    _this._orthoRight = Number.MIN_VALUE;\n    _this._orthoTop = Number.MIN_VALUE;\n    _this._orthoBottom = Number.MAX_VALUE;\n    _this.position = direction.scale(-1.0);\n    _this.direction = direction;\n    return _this;\n  }\n\n  Object.defineProperty(DirectionalLight.prototype, \"shadowFrustumSize\", {\n    /**\n     * Fix frustum size for the shadow generation. This is disabled if the value is 0.\n     */\n    get: function get() {\n      return this._shadowFrustumSize;\n    },\n\n    /**\n     * Specifies a fix frustum size for the shadow generation.\n     */\n    set: function set(value) {\n      this._shadowFrustumSize = value;\n      this.forceProjectionMatrixCompute();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DirectionalLight.prototype, \"shadowOrthoScale\", {\n    /**\n     * Gets the shadow projection scale against the optimal computed one.\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\n     */\n    get: function get() {\n      return this._shadowOrthoScale;\n    },\n\n    /**\n     * Sets the shadow projection scale against the optimal computed one.\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\n     */\n    set: function set(value) {\n      this._shadowOrthoScale = value;\n      this.forceProjectionMatrixCompute();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DirectionalLight.prototype, \"orthoLeft\", {\n    /**\n     * Gets or sets the orthoLeft property used to build the light frustum\n     */\n    get: function get() {\n      return this._orthoLeft;\n    },\n    set: function set(left) {\n      this._orthoLeft = left;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DirectionalLight.prototype, \"orthoRight\", {\n    /**\n     * Gets or sets the orthoRight property used to build the light frustum\n     */\n    get: function get() {\n      return this._orthoRight;\n    },\n    set: function set(right) {\n      this._orthoRight = right;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DirectionalLight.prototype, \"orthoTop\", {\n    /**\n     * Gets or sets the orthoTop property used to build the light frustum\n     */\n    get: function get() {\n      return this._orthoTop;\n    },\n    set: function set(top) {\n      this._orthoTop = top;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DirectionalLight.prototype, \"orthoBottom\", {\n    /**\n     * Gets or sets the orthoBottom property used to build the light frustum\n     */\n    get: function get() {\n      return this._orthoBottom;\n    },\n    set: function set(bottom) {\n      this._orthoBottom = bottom;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Returns the string \"DirectionalLight\".\n   * @return The class name\n   */\n\n  DirectionalLight.prototype.getClassName = function () {\n    return \"DirectionalLight\";\n  };\n  /**\n   * Returns the integer 1.\n   * @return The light Type id as a constant defines in Light.LIGHTTYPEID_x\n   */\n\n\n  DirectionalLight.prototype.getTypeID = function () {\n    return Light.LIGHTTYPEID_DIRECTIONALLIGHT;\n  };\n  /**\n   * Sets the passed matrix \"matrix\" as projection matrix for the shadows cast by the light according to the passed view matrix.\n   * Returns the DirectionalLight Shadow projection matrix.\n   * @param matrix\n   * @param viewMatrix\n   * @param renderList\n   */\n\n\n  DirectionalLight.prototype._setDefaultShadowProjectionMatrix = function (matrix, viewMatrix, renderList) {\n    if (this.shadowFrustumSize > 0) {\n      this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);\n    } else {\n      this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);\n    }\n  };\n  /**\n   * Sets the passed matrix \"matrix\" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.\n   * Returns the DirectionalLight Shadow projection matrix.\n   * @param matrix\n   */\n\n\n  DirectionalLight.prototype._setDefaultFixedFrustumShadowProjectionMatrix = function (matrix) {\n    var activeCamera = this.getScene().activeCamera;\n\n    if (!activeCamera) {\n      return;\n    }\n\n    Matrix.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);\n  };\n  /**\n   * Sets the passed matrix \"matrix\" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.\n   * Returns the DirectionalLight Shadow projection matrix.\n   * @param matrix\n   * @param viewMatrix\n   * @param renderList\n   */\n\n\n  DirectionalLight.prototype._setDefaultAutoExtendShadowProjectionMatrix = function (matrix, viewMatrix, renderList) {\n    var activeCamera = this.getScene().activeCamera;\n\n    if (!activeCamera) {\n      return;\n    } // Check extends\n\n\n    if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {\n      var tempVector3 = Vector3.Zero();\n      this._orthoLeft = Number.MAX_VALUE;\n      this._orthoRight = Number.MIN_VALUE;\n      this._orthoTop = Number.MIN_VALUE;\n      this._orthoBottom = Number.MAX_VALUE;\n      var shadowMinZ = Number.MAX_VALUE;\n      var shadowMaxZ = Number.MIN_VALUE;\n\n      for (var meshIndex = 0; meshIndex < renderList.length; meshIndex++) {\n        var mesh = renderList[meshIndex];\n\n        if (!mesh) {\n          continue;\n        }\n\n        var boundingInfo = mesh.getBoundingInfo();\n        var boundingBox = boundingInfo.boundingBox;\n\n        for (var index = 0; index < boundingBox.vectorsWorld.length; index++) {\n          Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);\n\n          if (tempVector3.x < this._orthoLeft) {\n            this._orthoLeft = tempVector3.x;\n          }\n\n          if (tempVector3.y < this._orthoBottom) {\n            this._orthoBottom = tempVector3.y;\n          }\n\n          if (tempVector3.x > this._orthoRight) {\n            this._orthoRight = tempVector3.x;\n          }\n\n          if (tempVector3.y > this._orthoTop) {\n            this._orthoTop = tempVector3.y;\n          }\n\n          if (this.autoCalcShadowZBounds) {\n            if (tempVector3.z < shadowMinZ) {\n              shadowMinZ = tempVector3.z;\n            }\n\n            if (tempVector3.z > shadowMaxZ) {\n              shadowMaxZ = tempVector3.z;\n            }\n          }\n        }\n      }\n\n      if (this.autoCalcShadowZBounds) {\n        this._shadowMinZ = shadowMinZ;\n        this._shadowMaxZ = shadowMaxZ;\n      }\n    }\n\n    var xOffset = this._orthoRight - this._orthoLeft;\n    var yOffset = this._orthoTop - this._orthoBottom;\n    var minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\n    var maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\n    var useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\n    Matrix.OrthoOffCenterLHToRef(this._orthoLeft - xOffset * this.shadowOrthoScale, this._orthoRight + xOffset * this.shadowOrthoScale, this._orthoBottom - yOffset * this.shadowOrthoScale, this._orthoTop + yOffset * this.shadowOrthoScale, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);\n  };\n\n  DirectionalLight.prototype._buildUniformLayout = function () {\n    this._uniformBuffer.addUniform(\"vLightData\", 4);\n\n    this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n\n    this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n\n    this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n\n    this._uniformBuffer.addUniform(\"depthValues\", 2);\n\n    this._uniformBuffer.create();\n  };\n  /**\n   * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.\n   * @param effect The effect to update\n   * @param lightIndex The index of the light in the effect to update\n   * @returns The directional light\n   */\n\n\n  DirectionalLight.prototype.transferToEffect = function (effect, lightIndex) {\n    if (this.computeTransformedInformation()) {\n      this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);\n\n      return this;\n    }\n\n    this._uniformBuffer.updateFloat4(\"vLightData\", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);\n\n    return this;\n  };\n\n  DirectionalLight.prototype.transferToNodeMaterialEffect = function (effect, lightDataUniformName) {\n    if (this.computeTransformedInformation()) {\n      effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);\n      return this;\n    }\n\n    effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);\n    return this;\n  };\n  /**\n   * Gets the minZ used for shadow according to both the scene and the light.\n   *\n   * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\n   * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\n   * (when not using reverse depth buffer / NDC half Z range)\n   * @param activeCamera The camera we are returning the min for\n   * @returns the depth min z\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  DirectionalLight.prototype.getDepthMinZ = function (activeCamera) {\n    var engine = this._scene.getEngine();\n\n    return !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n  };\n  /**\n   * Gets the maxZ used for shadow according to both the scene and the light.\n   *\n   * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\n   * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\n   * (when not using reverse depth buffer / NDC half Z range)\n   * @param activeCamera The camera we are returning the max for\n   * @returns the depth max z\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  DirectionalLight.prototype.getDepthMaxZ = function (activeCamera) {\n    var engine = this._scene.getEngine();\n\n    return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n  };\n  /**\n   * Prepares the list of defines specific to the light type.\n   * @param defines the list of defines\n   * @param lightIndex defines the index of the light for the effect\n   */\n\n\n  DirectionalLight.prototype.prepareLightSpecificDefines = function (defines, lightIndex) {\n    defines[\"DIRLIGHT\" + lightIndex] = true;\n  };\n\n  __decorate([serialize()], DirectionalLight.prototype, \"shadowFrustumSize\", null);\n\n  __decorate([serialize()], DirectionalLight.prototype, \"shadowOrthoScale\", null);\n\n  __decorate([serialize()], DirectionalLight.prototype, \"autoUpdateExtends\", void 0);\n\n  __decorate([serialize()], DirectionalLight.prototype, \"autoCalcShadowZBounds\", void 0);\n\n  __decorate([serialize(\"orthoLeft\")], DirectionalLight.prototype, \"_orthoLeft\", void 0);\n\n  __decorate([serialize(\"orthoRight\")], DirectionalLight.prototype, \"_orthoRight\", void 0);\n\n  __decorate([serialize(\"orthoTop\")], DirectionalLight.prototype, \"_orthoTop\", void 0);\n\n  __decorate([serialize(\"orthoBottom\")], DirectionalLight.prototype, \"_orthoBottom\", void 0);\n\n  return DirectionalLight;\n}(ShadowLight);\n\nexport { DirectionalLight };","map":{"version":3,"mappings":"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","names":["serialize","Matrix","Vector3","Node","Light","ShadowLight","AddNodeConstructor","name","scene","DirectionalLight","Zero","__extends","direction","_super","_this","Number","MAX_VALUE","MIN_VALUE","position","scale","Object","_shadowFrustumSize","value","forceProjectionMatrixCompute","_shadowOrthoScale","_orthoLeft","left","_orthoRight","right","_orthoTop","top","_orthoBottom","bottom","LIGHTTYPEID_DIRECTIONALLIGHT","matrix","viewMatrix","renderList","shadowFrustumSize","_setDefaultFixedFrustumShadowProjectionMatrix","_setDefaultAutoExtendShadowProjectionMatrix","activeCamera","getScene","OrthoLHToRef","shadowMinZ","undefined","minZ","shadowMaxZ","maxZ","getEngine","isNDCHalfZRange","autoUpdateExtends","tempVector3","meshIndex","length","mesh","boundingInfo","getBoundingInfo","boundingBox","index","vectorsWorld","TransformCoordinatesToRef","x","y","autoCalcShadowZBounds","z","_shadowMinZ","_shadowMaxZ","xOffset","yOffset","useReverseDepthBuffer","OrthoOffCenterLHToRef","shadowOrthoScale","_uniformBuffer","addUniform","create","effect","lightIndex","computeTransformedInformation","updateFloat4","transformedDirection","lightDataUniformName","setFloat3","engine","_scene","defines","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Lights/directionalLight.ts"],"sourcesContent":["import { serialize } from \"../Misc/decorators\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Light } from \"./light\";\r\nimport { ShadowLight } from \"./shadowLight\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nNode.AddNodeConstructor(\"Light_Type_1\", (name, scene) => {\r\n    return () => new DirectionalLight(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * A directional light is defined by a direction (what a surprise!).\r\n * The light is emitted from everywhere in the specified direction, and has an infinite range.\r\n * An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.\r\n * Documentation: https://doc.babylonjs.com/babylon101/lights\r\n */\r\nexport class DirectionalLight extends ShadowLight {\r\n    private _shadowFrustumSize = 0;\r\n    /**\r\n     * Fix frustum size for the shadow generation. This is disabled if the value is 0.\r\n     */\r\n    @serialize()\r\n    public get shadowFrustumSize(): number {\r\n        return this._shadowFrustumSize;\r\n    }\r\n    /**\r\n     * Specifies a fix frustum size for the shadow generation.\r\n     */\r\n    public set shadowFrustumSize(value: number) {\r\n        this._shadowFrustumSize = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    private _shadowOrthoScale = 0.1;\r\n    /**\r\n     * Gets the shadow projection scale against the optimal computed one.\r\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\r\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\r\n     */\r\n    @serialize()\r\n    public get shadowOrthoScale(): number {\r\n        return this._shadowOrthoScale;\r\n    }\r\n    /**\r\n     * Sets the shadow projection scale against the optimal computed one.\r\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\r\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\r\n     */\r\n    public set shadowOrthoScale(value: number) {\r\n        this._shadowOrthoScale = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    /**\r\n     * Automatically compute the projection matrix to best fit (including all the casters)\r\n     * on each frame.\r\n     */\r\n    @serialize()\r\n    public autoUpdateExtends = true;\r\n\r\n    /**\r\n     * Automatically compute the shadowMinZ and shadowMaxZ for the projection matrix to best fit (including all the casters)\r\n     * on each frame. autoUpdateExtends must be set to true for this to work\r\n     */\r\n    @serialize()\r\n    public autoCalcShadowZBounds = false;\r\n\r\n    // Cache\r\n    @serialize(\"orthoLeft\")\r\n    private _orthoLeft = Number.MAX_VALUE;\r\n    @serialize(\"orthoRight\")\r\n    private _orthoRight = Number.MIN_VALUE;\r\n    @serialize(\"orthoTop\")\r\n    private _orthoTop = Number.MIN_VALUE;\r\n    @serialize(\"orthoBottom\")\r\n    private _orthoBottom = Number.MAX_VALUE;\r\n\r\n    /**\r\n     * Gets or sets the orthoLeft property used to build the light frustum\r\n     */\r\n    public get orthoLeft(): number {\r\n        return this._orthoLeft;\r\n    }\r\n\r\n    public set orthoLeft(left: number) {\r\n        this._orthoLeft = left;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the orthoRight property used to build the light frustum\r\n     */\r\n    public get orthoRight(): number {\r\n        return this._orthoRight;\r\n    }\r\n\r\n    public set orthoRight(right: number) {\r\n        this._orthoRight = right;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the orthoTop property used to build the light frustum\r\n     */\r\n    public get orthoTop(): number {\r\n        return this._orthoTop;\r\n    }\r\n\r\n    public set orthoTop(top: number) {\r\n        this._orthoTop = top;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the orthoBottom property used to build the light frustum\r\n     */\r\n    public get orthoBottom(): number {\r\n        return this._orthoBottom;\r\n    }\r\n\r\n    public set orthoBottom(bottom: number) {\r\n        this._orthoBottom = bottom;\r\n    }\r\n\r\n    /**\r\n     * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).\r\n     * The directional light is emitted from everywhere in the given direction.\r\n     * It can cast shadows.\r\n     * Documentation : https://doc.babylonjs.com/babylon101/lights\r\n     * @param name The friendly name of the light\r\n     * @param direction The direction of the light\r\n     * @param scene The scene the light belongs to\r\n     */\r\n    constructor(name: string, direction: Vector3, scene: Scene) {\r\n        super(name, scene);\r\n        this.position = direction.scale(-1.0);\r\n        this.direction = direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"DirectionalLight\".\r\n     * @return The class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"DirectionalLight\";\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 1.\r\n     * @return The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return Light.LIGHTTYPEID_DIRECTIONALLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     * @param matrix\r\n     * @param viewMatrix\r\n     * @param renderList\r\n     */\r\n    protected _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void {\r\n        if (this.shadowFrustumSize > 0) {\r\n            this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);\r\n        } else {\r\n            this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     * @param matrix\r\n     */\r\n    protected _setDefaultFixedFrustumShadowProjectionMatrix(matrix: Matrix): void {\r\n        const activeCamera = this.getScene().activeCamera;\r\n\r\n        if (!activeCamera) {\r\n            return;\r\n        }\r\n\r\n        Matrix.OrthoLHToRef(\r\n            this.shadowFrustumSize,\r\n            this.shadowFrustumSize,\r\n            this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ,\r\n            this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ,\r\n            matrix,\r\n            this.getScene().getEngine().isNDCHalfZRange\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     * @param matrix\r\n     * @param viewMatrix\r\n     * @param renderList\r\n     */\r\n    protected _setDefaultAutoExtendShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void {\r\n        const activeCamera = this.getScene().activeCamera;\r\n\r\n        if (!activeCamera) {\r\n            return;\r\n        }\r\n\r\n        // Check extends\r\n        if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {\r\n            const tempVector3 = Vector3.Zero();\r\n\r\n            this._orthoLeft = Number.MAX_VALUE;\r\n            this._orthoRight = Number.MIN_VALUE;\r\n            this._orthoTop = Number.MIN_VALUE;\r\n            this._orthoBottom = Number.MAX_VALUE;\r\n\r\n            let shadowMinZ = Number.MAX_VALUE;\r\n            let shadowMaxZ = Number.MIN_VALUE;\r\n\r\n            for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {\r\n                const mesh = renderList[meshIndex];\r\n\r\n                if (!mesh) {\r\n                    continue;\r\n                }\r\n\r\n                const boundingInfo = mesh.getBoundingInfo();\r\n                const boundingBox = boundingInfo.boundingBox;\r\n\r\n                for (let index = 0; index < boundingBox.vectorsWorld.length; index++) {\r\n                    Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);\r\n\r\n                    if (tempVector3.x < this._orthoLeft) {\r\n                        this._orthoLeft = tempVector3.x;\r\n                    }\r\n                    if (tempVector3.y < this._orthoBottom) {\r\n                        this._orthoBottom = tempVector3.y;\r\n                    }\r\n\r\n                    if (tempVector3.x > this._orthoRight) {\r\n                        this._orthoRight = tempVector3.x;\r\n                    }\r\n                    if (tempVector3.y > this._orthoTop) {\r\n                        this._orthoTop = tempVector3.y;\r\n                    }\r\n                    if (this.autoCalcShadowZBounds) {\r\n                        if (tempVector3.z < shadowMinZ) {\r\n                            shadowMinZ = tempVector3.z;\r\n                        }\r\n                        if (tempVector3.z > shadowMaxZ) {\r\n                            shadowMaxZ = tempVector3.z;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.autoCalcShadowZBounds) {\r\n                this._shadowMinZ = shadowMinZ;\r\n                this._shadowMaxZ = shadowMaxZ;\r\n            }\r\n        }\r\n\r\n        const xOffset = this._orthoRight - this._orthoLeft;\r\n        const yOffset = this._orthoTop - this._orthoBottom;\r\n\r\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\r\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\r\n\r\n        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\r\n\r\n        Matrix.OrthoOffCenterLHToRef(\r\n            this._orthoLeft - xOffset * this.shadowOrthoScale,\r\n            this._orthoRight + xOffset * this.shadowOrthoScale,\r\n            this._orthoBottom - yOffset * this.shadowOrthoScale,\r\n            this._orthoTop + yOffset * this.shadowOrthoScale,\r\n            useReverseDepthBuffer ? maxZ : minZ,\r\n            useReverseDepthBuffer ? minZ : maxZ,\r\n            matrix,\r\n            this.getScene().getEngine().isNDCHalfZRange\r\n        );\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The directional light\r\n     */\r\n    public transferToEffect(effect: Effect, lightIndex: string): DirectionalLight {\r\n        if (this.computeTransformedInformation()) {\r\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);\r\n            return this;\r\n        }\r\n        this._uniformBuffer.updateFloat4(\"vLightData\", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): Light {\r\n        if (this.computeTransformedInformation()) {\r\n            effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);\r\n            return this;\r\n        }\r\n\r\n        effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the minZ used for shadow according to both the scene and the light.\r\n     *\r\n     * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\r\n     * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\r\n     * (when not using reverse depth buffer / NDC half Z range)\r\n     * @param activeCamera The camera we are returning the min for\r\n     * @returns the depth min z\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getDepthMinZ(activeCamera: Camera): number {\r\n        const engine = this._scene.getEngine();\r\n        return !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\r\n    }\r\n\r\n    /**\r\n     * Gets the maxZ used for shadow according to both the scene and the light.\r\n     *\r\n     * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\r\n     * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\r\n     * (when not using reverse depth buffer / NDC half Z range)\r\n     * @param activeCamera The camera we are returning the max for\r\n     * @returns the depth max z\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getDepthMaxZ(activeCamera: Camera): number {\r\n        const engine = this._scene.getEngine();\r\n        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"DIRLIGHT\" + lightIndex] = true;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}