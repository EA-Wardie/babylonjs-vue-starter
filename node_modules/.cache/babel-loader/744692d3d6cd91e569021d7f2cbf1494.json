{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\n\n/**\n * PostProcessRenderPipelineManager class\n * @see https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline\n */\nvar PostProcessRenderPipelineManager =\n/** @class */\nfunction () {\n  /**\n   * Initializes a PostProcessRenderPipelineManager\n   * @see https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline\n   */\n  function PostProcessRenderPipelineManager() {\n    this._renderPipelines = {};\n  }\n\n  Object.defineProperty(PostProcessRenderPipelineManager.prototype, \"supportedPipelines\", {\n    /**\n     * Gets the list of supported render pipelines\n     */\n    get: function get() {\n      var result = [];\n\n      for (var renderPipelineName in this._renderPipelines) {\n        if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\n          var pipeline = this._renderPipelines[renderPipelineName];\n\n          if (pipeline.isSupported) {\n            result.push(pipeline);\n          }\n        }\n      }\n\n      return result;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Adds a pipeline to the manager\n   * @param renderPipeline The pipeline to add\n   */\n\n  PostProcessRenderPipelineManager.prototype.addPipeline = function (renderPipeline) {\n    this._renderPipelines[renderPipeline._name] = renderPipeline;\n  };\n  /**\n   * Attaches a camera to the pipeline\n   * @param renderPipelineName The name of the pipeline to attach to\n   * @param cameras the camera to attach\n   * @param unique if the camera can be attached multiple times to the pipeline\n   */\n\n\n  PostProcessRenderPipelineManager.prototype.attachCamerasToRenderPipeline = function (renderPipelineName, cameras, unique) {\n    if (unique === void 0) {\n      unique = false;\n    }\n\n    var renderPipeline = this._renderPipelines[renderPipelineName];\n\n    if (!renderPipeline) {\n      return;\n    }\n\n    renderPipeline._attachCameras(cameras, unique);\n  };\n  /**\n   * Detaches a camera from the pipeline\n   * @param renderPipelineName The name of the pipeline to detach from\n   * @param cameras the camera to detach\n   */\n\n\n  PostProcessRenderPipelineManager.prototype.detachCamerasFromRenderPipeline = function (renderPipelineName, cameras) {\n    var renderPipeline = this._renderPipelines[renderPipelineName];\n\n    if (!renderPipeline) {\n      return;\n    }\n\n    renderPipeline._detachCameras(cameras);\n  };\n  /**\n   * Enables an effect by name on a pipeline\n   * @param renderPipelineName the name of the pipeline to enable the effect in\n   * @param renderEffectName the name of the effect to enable\n   * @param cameras the cameras that the effect should be enabled on\n   */\n\n\n  PostProcessRenderPipelineManager.prototype.enableEffectInPipeline = function (renderPipelineName, renderEffectName, cameras) {\n    var renderPipeline = this._renderPipelines[renderPipelineName];\n\n    if (!renderPipeline) {\n      return;\n    }\n\n    renderPipeline._enableEffect(renderEffectName, cameras);\n  };\n  /**\n   * Disables an effect by name on a pipeline\n   * @param renderPipelineName the name of the pipeline to disable the effect in\n   * @param renderEffectName the name of the effect to disable\n   * @param cameras the cameras that the effect should be disabled on\n   */\n\n\n  PostProcessRenderPipelineManager.prototype.disableEffectInPipeline = function (renderPipelineName, renderEffectName, cameras) {\n    var renderPipeline = this._renderPipelines[renderPipelineName];\n\n    if (!renderPipeline) {\n      return;\n    }\n\n    renderPipeline._disableEffect(renderEffectName, cameras);\n  };\n  /**\n   * Updates the state of all contained render pipelines and disposes of any non supported pipelines\n   */\n\n\n  PostProcessRenderPipelineManager.prototype.update = function () {\n    for (var renderPipelineName in this._renderPipelines) {\n      if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\n        var pipeline = this._renderPipelines[renderPipelineName];\n\n        if (!pipeline.isSupported) {\n          pipeline.dispose();\n          delete this._renderPipelines[renderPipelineName];\n        } else {\n          pipeline._update();\n        }\n      }\n    }\n  };\n  /** @hidden */\n\n\n  PostProcessRenderPipelineManager.prototype._rebuild = function () {\n    for (var renderPipelineName in this._renderPipelines) {\n      if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\n        var pipeline = this._renderPipelines[renderPipelineName];\n\n        pipeline._rebuild();\n      }\n    }\n  };\n  /**\n   * Disposes of the manager and pipelines\n   */\n\n\n  PostProcessRenderPipelineManager.prototype.dispose = function () {\n    for (var renderPipelineName in this._renderPipelines) {\n      if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\n        var pipeline = this._renderPipelines[renderPipelineName];\n        pipeline.dispose();\n      }\n    }\n  };\n\n  return PostProcessRenderPipelineManager;\n}();\n\nexport { PostProcessRenderPipelineManager };","map":{"version":3,"mappings":"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","names":["_renderPipelines","Object","PostProcessRenderPipelineManager","result","renderPipelineName","prototype","hasOwnProperty","call","pipeline","isSupported","push","renderPipeline","_name","cameras","unique","_attachCameras","_detachCameras","renderEffectName","_enableEffect","_disableEffect","dispose","_update","_rebuild"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/PostProcesses/RenderPipeline/postProcessRenderPipelineManager.ts"],"sourcesContent":["import type { Camera } from \"../../Cameras/camera\";\r\nimport type { PostProcessRenderPipeline } from \"./postProcessRenderPipeline\";\r\n/**\r\n * PostProcessRenderPipelineManager class\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline\r\n */\r\nexport class PostProcessRenderPipelineManager {\r\n    private _renderPipelines: { [Key: string]: PostProcessRenderPipeline };\r\n\r\n    /**\r\n     * Initializes a PostProcessRenderPipelineManager\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline\r\n     */\r\n    constructor() {\r\n        this._renderPipelines = {};\r\n    }\r\n\r\n    /**\r\n     * Gets the list of supported render pipelines\r\n     */\r\n    public get supportedPipelines(): PostProcessRenderPipeline[] {\r\n        const result = [];\r\n\r\n        for (const renderPipelineName in this._renderPipelines) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\r\n                const pipeline = this._renderPipelines[renderPipelineName];\r\n                if (pipeline.isSupported) {\r\n                    result.push(pipeline);\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Adds a pipeline to the manager\r\n     * @param renderPipeline The pipeline to add\r\n     */\r\n    public addPipeline(renderPipeline: PostProcessRenderPipeline): void {\r\n        this._renderPipelines[renderPipeline._name] = renderPipeline;\r\n    }\r\n\r\n    /**\r\n     * Attaches a camera to the pipeline\r\n     * @param renderPipelineName The name of the pipeline to attach to\r\n     * @param cameras the camera to attach\r\n     * @param unique if the camera can be attached multiple times to the pipeline\r\n     */\r\n    public attachCamerasToRenderPipeline(renderPipelineName: string, cameras: any | Camera[] | Camera, unique: boolean = false): void {\r\n        const renderPipeline: PostProcessRenderPipeline = this._renderPipelines[renderPipelineName];\r\n\r\n        if (!renderPipeline) {\r\n            return;\r\n        }\r\n\r\n        renderPipeline._attachCameras(cameras, unique);\r\n    }\r\n\r\n    /**\r\n     * Detaches a camera from the pipeline\r\n     * @param renderPipelineName The name of the pipeline to detach from\r\n     * @param cameras the camera to detach\r\n     */\r\n    public detachCamerasFromRenderPipeline(renderPipelineName: string, cameras: any | Camera[] | Camera): void {\r\n        const renderPipeline: PostProcessRenderPipeline = this._renderPipelines[renderPipelineName];\r\n\r\n        if (!renderPipeline) {\r\n            return;\r\n        }\r\n\r\n        renderPipeline._detachCameras(cameras);\r\n    }\r\n\r\n    /**\r\n     * Enables an effect by name on a pipeline\r\n     * @param renderPipelineName the name of the pipeline to enable the effect in\r\n     * @param renderEffectName the name of the effect to enable\r\n     * @param cameras the cameras that the effect should be enabled on\r\n     */\r\n    public enableEffectInPipeline(renderPipelineName: string, renderEffectName: string, cameras: any | Camera[] | Camera): void {\r\n        const renderPipeline: PostProcessRenderPipeline = this._renderPipelines[renderPipelineName];\r\n\r\n        if (!renderPipeline) {\r\n            return;\r\n        }\r\n\r\n        renderPipeline._enableEffect(renderEffectName, cameras);\r\n    }\r\n\r\n    /**\r\n     * Disables an effect by name on a pipeline\r\n     * @param renderPipelineName the name of the pipeline to disable the effect in\r\n     * @param renderEffectName the name of the effect to disable\r\n     * @param cameras the cameras that the effect should be disabled on\r\n     */\r\n    public disableEffectInPipeline(renderPipelineName: string, renderEffectName: string, cameras: any | Camera[] | Camera): void {\r\n        const renderPipeline: PostProcessRenderPipeline = this._renderPipelines[renderPipelineName];\r\n\r\n        if (!renderPipeline) {\r\n            return;\r\n        }\r\n\r\n        renderPipeline._disableEffect(renderEffectName, cameras);\r\n    }\r\n\r\n    /**\r\n     * Updates the state of all contained render pipelines and disposes of any non supported pipelines\r\n     */\r\n    public update(): void {\r\n        for (const renderPipelineName in this._renderPipelines) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\r\n                const pipeline = this._renderPipelines[renderPipelineName];\r\n                if (!pipeline.isSupported) {\r\n                    pipeline.dispose();\r\n                    delete this._renderPipelines[renderPipelineName];\r\n                } else {\r\n                    pipeline._update();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        for (const renderPipelineName in this._renderPipelines) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\r\n                const pipeline = this._renderPipelines[renderPipelineName];\r\n                pipeline._rebuild();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the manager and pipelines\r\n     */\r\n    public dispose(): void {\r\n        for (const renderPipelineName in this._renderPipelines) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\r\n                const pipeline = this._renderPipelines[renderPipelineName];\r\n                pipeline.dispose();\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}