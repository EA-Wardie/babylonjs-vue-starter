{"ast":null,"code":"import \"core-js/modules/es.number.constructor.js\";\nimport { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\n/**\n * Class used to store bounding box information\n */\n\nvar BoundingBox =\n/** @class */\nfunction () {\n  /**\n   * Creates a new bounding box\n   * @param min defines the minimum vector (in local space)\n   * @param max defines the maximum vector (in local space)\n   * @param worldMatrix defines the new world matrix\n   */\n  function BoundingBox(min, max, worldMatrix) {\n    /**\n     * Gets the 8 vectors representing the bounding box in local space\n     */\n    this.vectors = ArrayTools.BuildArray(8, Vector3.Zero);\n    /**\n     * Gets the center of the bounding box in local space\n     */\n\n    this.center = Vector3.Zero();\n    /**\n     * Gets the center of the bounding box in world space\n     */\n\n    this.centerWorld = Vector3.Zero();\n    /**\n     * Gets the extend size in local space\n     */\n\n    this.extendSize = Vector3.Zero();\n    /**\n     * Gets the extend size in world space\n     */\n\n    this.extendSizeWorld = Vector3.Zero();\n    /**\n     * Gets the OBB (object bounding box) directions\n     */\n\n    this.directions = ArrayTools.BuildArray(3, Vector3.Zero);\n    /**\n     * Gets the 8 vectors representing the bounding box in world space\n     */\n\n    this.vectorsWorld = ArrayTools.BuildArray(8, Vector3.Zero);\n    /**\n     * Gets the minimum vector in world space\n     */\n\n    this.minimumWorld = Vector3.Zero();\n    /**\n     * Gets the maximum vector in world space\n     */\n\n    this.maximumWorld = Vector3.Zero();\n    /**\n     * Gets the minimum vector in local space\n     */\n\n    this.minimum = Vector3.Zero();\n    /**\n     * Gets the maximum vector in local space\n     */\n\n    this.maximum = Vector3.Zero();\n    /** @hidden */\n\n    this._drawWrapperFront = null;\n    /** @hidden */\n\n    this._drawWrapperBack = null;\n    this.reConstruct(min, max, worldMatrix);\n  } // Methods\n\n  /**\n   * Recreates the entire bounding box from scratch as if we call the constructor in place\n   * @param min defines the new minimum vector (in local space)\n   * @param max defines the new maximum vector (in local space)\n   * @param worldMatrix defines the new world matrix\n   */\n\n\n  BoundingBox.prototype.reConstruct = function (min, max, worldMatrix) {\n    var minX = min.x,\n        minY = min.y,\n        minZ = min.z,\n        maxX = max.x,\n        maxY = max.y,\n        maxZ = max.z;\n    var vectors = this.vectors;\n    this.minimum.copyFromFloats(minX, minY, minZ);\n    this.maximum.copyFromFloats(maxX, maxY, maxZ);\n    vectors[0].copyFromFloats(minX, minY, minZ);\n    vectors[1].copyFromFloats(maxX, maxY, maxZ);\n    vectors[2].copyFromFloats(maxX, minY, minZ);\n    vectors[3].copyFromFloats(minX, maxY, minZ);\n    vectors[4].copyFromFloats(minX, minY, maxZ);\n    vectors[5].copyFromFloats(maxX, maxY, minZ);\n    vectors[6].copyFromFloats(minX, maxY, maxZ);\n    vectors[7].copyFromFloats(maxX, minY, maxZ); // OBB\n\n    max.addToRef(min, this.center).scaleInPlace(0.5);\n    max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);\n    this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;\n\n    this._update(this._worldMatrix);\n  };\n  /**\n   * Scale the current bounding box by applying a scale factor\n   * @param factor defines the scale factor to apply\n   * @returns the current bounding box\n   */\n\n\n  BoundingBox.prototype.scale = function (factor) {\n    var tmpVectors = BoundingBox._TmpVector3;\n    var diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);\n    var len = diff.length();\n    diff.normalizeFromLength(len);\n    var distance = len * factor;\n    var newRadius = diff.scaleInPlace(distance * 0.5);\n    var min = this.center.subtractToRef(newRadius, tmpVectors[1]);\n    var max = this.center.addToRef(newRadius, tmpVectors[2]);\n    this.reConstruct(min, max, this._worldMatrix);\n    return this;\n  };\n  /**\n   * Gets the world matrix of the bounding box\n   * @returns a matrix\n   */\n\n\n  BoundingBox.prototype.getWorldMatrix = function () {\n    return this._worldMatrix;\n  };\n  /**\n   * @param world\n   * @hidden\n   */\n\n\n  BoundingBox.prototype._update = function (world) {\n    var minWorld = this.minimumWorld;\n    var maxWorld = this.maximumWorld;\n    var directions = this.directions;\n    var vectorsWorld = this.vectorsWorld;\n    var vectors = this.vectors;\n\n    if (!world.isIdentity()) {\n      minWorld.setAll(Number.MAX_VALUE);\n      maxWorld.setAll(-Number.MAX_VALUE);\n\n      for (var index = 0; index < 8; ++index) {\n        var v = vectorsWorld[index];\n        Vector3.TransformCoordinatesToRef(vectors[index], world, v);\n        minWorld.minimizeInPlace(v);\n        maxWorld.maximizeInPlace(v);\n      } // Extend\n\n\n      maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);\n      maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);\n    } else {\n      minWorld.copyFrom(this.minimum);\n      maxWorld.copyFrom(this.maximum);\n\n      for (var index = 0; index < 8; ++index) {\n        vectorsWorld[index].copyFrom(vectors[index]);\n      } // Extend\n\n\n      this.extendSizeWorld.copyFrom(this.extendSize);\n      this.centerWorld.copyFrom(this.center);\n    }\n\n    Vector3.FromArrayToRef(world.m, 0, directions[0]);\n    Vector3.FromArrayToRef(world.m, 4, directions[1]);\n    Vector3.FromArrayToRef(world.m, 8, directions[2]);\n    this._worldMatrix = world;\n  };\n  /**\n   * Tests if the bounding box is intersecting the frustum planes\n   * @param frustumPlanes defines the frustum planes to test\n   * @returns true if there is an intersection\n   */\n\n\n  BoundingBox.prototype.isInFrustum = function (frustumPlanes) {\n    return BoundingBox.IsInFrustum(this.vectorsWorld, frustumPlanes);\n  };\n  /**\n   * Tests if the bounding box is entirely inside the frustum planes\n   * @param frustumPlanes defines the frustum planes to test\n   * @returns true if there is an inclusion\n   */\n\n\n  BoundingBox.prototype.isCompletelyInFrustum = function (frustumPlanes) {\n    return BoundingBox.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);\n  };\n  /**\n   * Tests if a point is inside the bounding box\n   * @param point defines the point to test\n   * @returns true if the point is inside the bounding box\n   */\n\n\n  BoundingBox.prototype.intersectsPoint = function (point) {\n    var min = this.minimumWorld;\n    var max = this.maximumWorld;\n    var minX = min.x,\n        minY = min.y,\n        minZ = min.z,\n        maxX = max.x,\n        maxY = max.y,\n        maxZ = max.z;\n    var pointX = point.x,\n        pointY = point.y,\n        pointZ = point.z;\n    var delta = -Epsilon;\n\n    if (maxX - pointX < delta || delta > pointX - minX) {\n      return false;\n    }\n\n    if (maxY - pointY < delta || delta > pointY - minY) {\n      return false;\n    }\n\n    if (maxZ - pointZ < delta || delta > pointZ - minZ) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Tests if the bounding box intersects with a bounding sphere\n   * @param sphere defines the sphere to test\n   * @returns true if there is an intersection\n   */\n\n\n  BoundingBox.prototype.intersectsSphere = function (sphere) {\n    return BoundingBox.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);\n  };\n  /**\n   * Tests if the bounding box intersects with a box defined by a min and max vectors\n   * @param min defines the min vector to use\n   * @param max defines the max vector to use\n   * @returns true if there is an intersection\n   */\n\n\n  BoundingBox.prototype.intersectsMinMax = function (min, max) {\n    var myMin = this.minimumWorld;\n    var myMax = this.maximumWorld;\n    var myMinX = myMin.x,\n        myMinY = myMin.y,\n        myMinZ = myMin.z,\n        myMaxX = myMax.x,\n        myMaxY = myMax.y,\n        myMaxZ = myMax.z;\n    var minX = min.x,\n        minY = min.y,\n        minZ = min.z,\n        maxX = max.x,\n        maxY = max.y,\n        maxZ = max.z;\n\n    if (myMaxX < minX || myMinX > maxX) {\n      return false;\n    }\n\n    if (myMaxY < minY || myMinY > maxY) {\n      return false;\n    }\n\n    if (myMaxZ < minZ || myMinZ > maxZ) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Disposes the resources of the class\n   */\n\n\n  BoundingBox.prototype.dispose = function () {\n    var _a, _b;\n\n    (_a = this._drawWrapperFront) === null || _a === void 0 ? void 0 : _a.dispose();\n    (_b = this._drawWrapperBack) === null || _b === void 0 ? void 0 : _b.dispose();\n  }; // Statics\n\n  /**\n   * Tests if two bounding boxes are intersections\n   * @param box0 defines the first box to test\n   * @param box1 defines the second box to test\n   * @returns true if there is an intersection\n   */\n\n\n  BoundingBox.Intersects = function (box0, box1) {\n    return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);\n  };\n  /**\n   * Tests if a bounding box defines by a min/max vectors intersects a sphere\n   * @param minPoint defines the minimum vector of the bounding box\n   * @param maxPoint defines the maximum vector of the bounding box\n   * @param sphereCenter defines the sphere center\n   * @param sphereRadius defines the sphere radius\n   * @returns true if there is an intersection\n   */\n\n\n  BoundingBox.IntersectsSphere = function (minPoint, maxPoint, sphereCenter, sphereRadius) {\n    var vector = BoundingBox._TmpVector3[0];\n    Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);\n    var num = Vector3.DistanceSquared(sphereCenter, vector);\n    return num <= sphereRadius * sphereRadius;\n  };\n  /**\n   * Tests if a bounding box defined with 8 vectors is entirely inside frustum planes\n   * @param boundingVectors defines an array of 8 vectors representing a bounding box\n   * @param frustumPlanes defines the frustum planes to test\n   * @return true if there is an inclusion\n   */\n\n\n  BoundingBox.IsCompletelyInFrustum = function (boundingVectors, frustumPlanes) {\n    for (var p = 0; p < 6; ++p) {\n      var frustumPlane = frustumPlanes[p];\n\n      for (var i = 0; i < 8; ++i) {\n        if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\n   * Tests if a bounding box defined with 8 vectors intersects frustum planes\n   * @param boundingVectors defines an array of 8 vectors representing a bounding box\n   * @param frustumPlanes defines the frustum planes to test\n   * @return true if there is an intersection\n   */\n\n\n  BoundingBox.IsInFrustum = function (boundingVectors, frustumPlanes) {\n    for (var p = 0; p < 6; ++p) {\n      var canReturnFalse = true;\n      var frustumPlane = frustumPlanes[p];\n\n      for (var i = 0; i < 8; ++i) {\n        if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {\n          canReturnFalse = false;\n          break;\n        }\n      }\n\n      if (canReturnFalse) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  BoundingBox._TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);\n  return BoundingBox;\n}();\n\nexport { BoundingBox };","map":{"version":3,"mappings":"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","names":["ArrayTools","Matrix","Vector3","Epsilon","min","max","worldMatrix","BuildArray","Zero","reConstruct","BoundingBox","minX","x","minY","y","minZ","z","maxX","maxY","maxZ","vectors","minimum","copyFromFloats","maximum","addToRef","center","scaleInPlace","subtractToRef","extendSize","_worldMatrix","IdentityReadOnly","_update","factor","tmpVectors","_TmpVector3","diff","len","length","normalizeFromLength","distance","newRadius","world","minWorld","minimumWorld","maxWorld","maximumWorld","directions","vectorsWorld","isIdentity","setAll","Number","MAX_VALUE","index","v","TransformCoordinatesToRef","minimizeInPlace","maximizeInPlace","extendSizeWorld","centerWorld","copyFrom","FromArrayToRef","m","frustumPlanes","IsInFrustum","IsCompletelyInFrustum","point","pointX","pointY","pointZ","delta","sphere","IntersectsSphere","radiusWorld","myMin","myMax","myMinX","myMinY","myMinZ","myMaxX","myMaxY","myMaxZ","_drawWrapperFront","_a","dispose","_drawWrapperBack","_b","box0","box1","intersectsMinMax","minPoint","maxPoint","sphereCenter","sphereRadius","vector","ClampToRef","num","DistanceSquared","boundingVectors","p","frustumPlane","i","dotCoordinate","canReturnFalse"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Culling/boundingBox.ts"],"sourcesContent":["import type { DeepImmutable, Nullable } from \"../types\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { BoundingSphere } from \"../Culling/boundingSphere\";\r\n\r\nimport type { ICullable } from \"./boundingInfo\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\ndeclare type DrawWrapper = import(\"../Materials/drawWrapper\").DrawWrapper;\r\n\r\n/**\r\n * Class used to store bounding box information\r\n */\r\nexport class BoundingBox implements ICullable {\r\n    /**\r\n     * Gets the 8 vectors representing the bounding box in local space\r\n     */\r\n    public readonly vectors: Vector3[] = ArrayTools.BuildArray(8, Vector3.Zero);\r\n    /**\r\n     * Gets the center of the bounding box in local space\r\n     */\r\n    public readonly center: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the center of the bounding box in world space\r\n     */\r\n    public readonly centerWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the extend size in local space\r\n     */\r\n    public readonly extendSize: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the extend size in world space\r\n     */\r\n    public readonly extendSizeWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the OBB (object bounding box) directions\r\n     */\r\n    public readonly directions: Vector3[] = ArrayTools.BuildArray(3, Vector3.Zero);\r\n    /**\r\n     * Gets the 8 vectors representing the bounding box in world space\r\n     */\r\n    public readonly vectorsWorld: Vector3[] = ArrayTools.BuildArray(8, Vector3.Zero);\r\n    /**\r\n     * Gets the minimum vector in world space\r\n     */\r\n    public readonly minimumWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in world space\r\n     */\r\n    public readonly maximumWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the minimum vector in local space\r\n     */\r\n    public readonly minimum: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in local space\r\n     */\r\n    public readonly maximum: Vector3 = Vector3.Zero();\r\n\r\n    private _worldMatrix: DeepImmutable<Matrix>;\r\n    private static readonly _TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _tag: number;\r\n\r\n    /** @hidden */\r\n    public _drawWrapperFront: Nullable<DrawWrapper> = null;\r\n    /** @hidden */\r\n    public _drawWrapperBack: Nullable<DrawWrapper> = null;\r\n\r\n    /**\r\n     * Creates a new bounding box\r\n     * @param min defines the minimum vector (in local space)\r\n     * @param max defines the maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Recreates the entire bounding box from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        const vectors = this.vectors;\r\n\r\n        this.minimum.copyFromFloats(minX, minY, minZ);\r\n        this.maximum.copyFromFloats(maxX, maxY, maxZ);\r\n        vectors[0].copyFromFloats(minX, minY, minZ);\r\n        vectors[1].copyFromFloats(maxX, maxY, maxZ);\r\n        vectors[2].copyFromFloats(maxX, minY, minZ);\r\n        vectors[3].copyFromFloats(minX, maxY, minZ);\r\n        vectors[4].copyFromFloats(minX, minY, maxZ);\r\n        vectors[5].copyFromFloats(maxX, maxY, minZ);\r\n        vectors[6].copyFromFloats(minX, maxY, maxZ);\r\n        vectors[7].copyFromFloats(maxX, minY, maxZ);\r\n\r\n        // OBB\r\n        max.addToRef(min, this.center).scaleInPlace(0.5);\r\n        max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);\r\n\r\n        this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;\r\n\r\n        this._update(this._worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding box by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding box\r\n     */\r\n    public scale(factor: number): BoundingBox {\r\n        const tmpVectors = BoundingBox._TmpVector3;\r\n        const diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);\r\n        const len = diff.length();\r\n        diff.normalizeFromLength(len);\r\n        const distance = len * factor;\r\n        const newRadius = diff.scaleInPlace(distance * 0.5);\r\n\r\n        const min = this.center.subtractToRef(newRadius, tmpVectors[1]);\r\n        const max = this.center.addToRef(newRadius, tmpVectors[2]);\r\n\r\n        this.reConstruct(min, max, this._worldMatrix);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the world matrix of the bounding box\r\n     * @returns a matrix\r\n     */\r\n    public getWorldMatrix(): DeepImmutable<Matrix> {\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * @param world\r\n     * @hidden\r\n     */\r\n    public _update(world: DeepImmutable<Matrix>): void {\r\n        const minWorld = this.minimumWorld;\r\n        const maxWorld = this.maximumWorld;\r\n        const directions = this.directions;\r\n        const vectorsWorld = this.vectorsWorld;\r\n        const vectors = this.vectors;\r\n\r\n        if (!world.isIdentity()) {\r\n            minWorld.setAll(Number.MAX_VALUE);\r\n            maxWorld.setAll(-Number.MAX_VALUE);\r\n\r\n            for (let index = 0; index < 8; ++index) {\r\n                const v = vectorsWorld[index];\r\n                Vector3.TransformCoordinatesToRef(vectors[index], world, v);\r\n                minWorld.minimizeInPlace(v);\r\n                maxWorld.maximizeInPlace(v);\r\n            }\r\n\r\n            // Extend\r\n            maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);\r\n            maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);\r\n        } else {\r\n            minWorld.copyFrom(this.minimum);\r\n            maxWorld.copyFrom(this.maximum);\r\n            for (let index = 0; index < 8; ++index) {\r\n                vectorsWorld[index].copyFrom(vectors[index]);\r\n            }\r\n\r\n            // Extend\r\n            this.extendSizeWorld.copyFrom(this.extendSize);\r\n            this.centerWorld.copyFrom(this.center);\r\n        }\r\n\r\n        Vector3.FromArrayToRef(world.m, 0, directions[0]);\r\n        Vector3.FromArrayToRef(world.m, 4, directions[1]);\r\n        Vector3.FromArrayToRef(world.m, 8, directions[2]);\r\n\r\n        this._worldMatrix = world;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box is intersecting the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return BoundingBox.IsInFrustum(this.vectorsWorld, frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box is entirely inside the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an inclusion\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return BoundingBox.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Tests if a point is inside the bounding box\r\n     * @param point defines the point to test\r\n     * @returns true if the point is inside the bounding box\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        const min = this.minimumWorld;\r\n        const max = this.maximumWorld;\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        const pointX = point.x,\r\n            pointY = point.y,\r\n            pointZ = point.z;\r\n        const delta = -Epsilon;\r\n\r\n        if (maxX - pointX < delta || delta > pointX - minX) {\r\n            return false;\r\n        }\r\n\r\n        if (maxY - pointY < delta || delta > pointY - minY) {\r\n            return false;\r\n        }\r\n\r\n        if (maxZ - pointZ < delta || delta > pointZ - minZ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box intersects with a bounding sphere\r\n     * @param sphere defines the sphere to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsSphere(sphere: DeepImmutable<BoundingSphere>): boolean {\r\n        return BoundingBox.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box intersects with a box defined by a min and max vectors\r\n     * @param min defines the min vector to use\r\n     * @param max defines the max vector to use\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsMinMax(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>): boolean {\r\n        const myMin = this.minimumWorld;\r\n        const myMax = this.maximumWorld;\r\n        const myMinX = myMin.x,\r\n            myMinY = myMin.y,\r\n            myMinZ = myMin.z,\r\n            myMaxX = myMax.x,\r\n            myMaxY = myMax.y,\r\n            myMaxZ = myMax.z;\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        if (myMaxX < minX || myMinX > maxX) {\r\n            return false;\r\n        }\r\n\r\n        if (myMaxY < minY || myMinY > maxY) {\r\n            return false;\r\n        }\r\n\r\n        if (myMaxZ < minZ || myMinZ > maxZ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Disposes the resources of the class\r\n     */\r\n    public dispose(): void {\r\n        this._drawWrapperFront?.dispose();\r\n        this._drawWrapperBack?.dispose();\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Tests if two bounding boxes are intersections\r\n     * @param box0 defines the first box to test\r\n     * @param box1 defines the second box to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static Intersects(box0: DeepImmutable<BoundingBox>, box1: DeepImmutable<BoundingBox>): boolean {\r\n        return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defines by a min/max vectors intersects a sphere\r\n     * @param minPoint defines the minimum vector of the bounding box\r\n     * @param maxPoint defines the maximum vector of the bounding box\r\n     * @param sphereCenter defines the sphere center\r\n     * @param sphereRadius defines the sphere radius\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static IntersectsSphere(minPoint: DeepImmutable<Vector3>, maxPoint: DeepImmutable<Vector3>, sphereCenter: DeepImmutable<Vector3>, sphereRadius: number): boolean {\r\n        const vector = BoundingBox._TmpVector3[0];\r\n        Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);\r\n        const num = Vector3.DistanceSquared(sphereCenter, vector);\r\n        return num <= sphereRadius * sphereRadius;\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defined with 8 vectors is entirely inside frustum planes\r\n     * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @return true if there is an inclusion\r\n     */\r\n    public static IsCompletelyInFrustum(boundingVectors: Array<DeepImmutable<Vector3>>, frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        for (let p = 0; p < 6; ++p) {\r\n            const frustumPlane = frustumPlanes[p];\r\n            for (let i = 0; i < 8; ++i) {\r\n                if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defined with 8 vectors intersects frustum planes\r\n     * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @return true if there is an intersection\r\n     */\r\n    public static IsInFrustum(boundingVectors: Array<DeepImmutable<Vector3>>, frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        for (let p = 0; p < 6; ++p) {\r\n            let canReturnFalse = true;\r\n            const frustumPlane = frustumPlanes[p];\r\n            for (let i = 0; i < 8; ++i) {\r\n                if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {\r\n                    canReturnFalse = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (canReturnFalse) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}