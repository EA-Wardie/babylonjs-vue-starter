{"ast":null,"code":"import \"core-js/modules/es.object.to-string.js\";\nimport { Vector3 } from \"../../../Maths/math.js\";\nimport { Scalar } from \"../../../Maths/math.scalar.js\";\nimport { EffectWrapper, EffectRenderer } from \"../../../Materials/effectRenderer.js\";\nimport \"../../../Shaders/hdrFiltering.vertex.js\";\nimport \"../../../Shaders/hdrFiltering.fragment.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\n/**\n * Filters HDR maps to get correct renderings of PBR reflections\n */\n\nvar HDRFiltering =\n/** @class */\nfunction () {\n  /**\n   * Instantiates HDR filter for reflection maps\n   *\n   * @param engine Thin engine\n   * @param options Options\n   */\n  function HDRFiltering(engine, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this._lodGenerationOffset = 0;\n    this._lodGenerationScale = 0.8;\n    /**\n     * Quality switch for prefiltering. Should be set to `4096` unless\n     * you care about baking speed.\n     */\n\n    this.quality = 4096;\n    /**\n     * Scales pixel intensity for the input HDR map.\n     */\n\n    this.hdrScale = 1; // pass\n\n    this._engine = engine;\n    this.hdrScale = options.hdrScale || this.hdrScale;\n    this.quality = options.quality || this.quality;\n  }\n\n  HDRFiltering.prototype._createRenderTarget = function (size) {\n    var textureType = 0;\n\n    if (this._engine.getCaps().textureHalfFloatRender) {\n      textureType = 2;\n    } else if (this._engine.getCaps().textureFloatRender) {\n      textureType = 1;\n    }\n\n    var rtWrapper = this._engine.createRenderTargetCubeTexture(size, {\n      format: 5,\n      type: textureType,\n      createMipMaps: true,\n      generateMipMaps: false,\n      generateDepthBuffer: false,\n      generateStencilBuffer: false,\n      samplingMode: 1\n    });\n\n    this._engine.updateTextureWrappingMode(rtWrapper.texture, 0, 0, 0);\n\n    this._engine.updateTextureSamplingMode(3, rtWrapper.texture, true);\n\n    return rtWrapper;\n  };\n\n  HDRFiltering.prototype._prefilterInternal = function (texture) {\n    var width = texture.getSize().width;\n    var mipmapsCount = Scalar.ILog2(width) + 1;\n    var effect = this._effectWrapper.effect;\n\n    var outputTexture = this._createRenderTarget(width);\n\n    this._effectRenderer.setViewport();\n\n    var intTexture = texture.getInternalTexture();\n\n    if (intTexture) {\n      // Just in case generate fresh clean mips.\n      this._engine.updateTextureSamplingMode(3, intTexture, true);\n    }\n\n    this._effectRenderer.applyEffectWrapper(this._effectWrapper);\n\n    var directions = [[new Vector3(0, 0, -1), new Vector3(0, -1, 0), new Vector3(1, 0, 0)], [new Vector3(0, 0, 1), new Vector3(0, -1, 0), new Vector3(-1, 0, 0)], [new Vector3(1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 1, 0)], [new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)], [new Vector3(1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, 1)], [new Vector3(-1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, -1)] // NegativeZ\n    ];\n    effect.setFloat(\"hdrScale\", this.hdrScale);\n    effect.setFloat2(\"vFilteringInfo\", texture.getSize().width, mipmapsCount);\n    effect.setTexture(\"inputTexture\", texture);\n\n    for (var face = 0; face < 6; face++) {\n      effect.setVector3(\"up\", directions[face][0]);\n      effect.setVector3(\"right\", directions[face][1]);\n      effect.setVector3(\"front\", directions[face][2]);\n\n      for (var lod = 0; lod < mipmapsCount; lod++) {\n        this._engine.bindFramebuffer(outputTexture, face, undefined, undefined, true, lod);\n\n        this._effectRenderer.applyEffectWrapper(this._effectWrapper);\n\n        var alpha = Math.pow(2, (lod - this._lodGenerationOffset) / this._lodGenerationScale) / width;\n\n        if (lod === 0) {\n          alpha = 0;\n        }\n\n        effect.setFloat(\"alphaG\", alpha);\n\n        this._effectRenderer.draw();\n      }\n    } // Cleanup\n\n\n    this._effectRenderer.restoreStates();\n\n    this._engine.restoreDefaultFramebuffer();\n\n    this._engine._releaseTexture(texture._texture); // Internal Swap\n\n\n    outputTexture._swapAndDie(texture._texture);\n\n    texture._prefiltered = true;\n    return texture;\n  };\n\n  HDRFiltering.prototype._createEffect = function (texture, onCompiled) {\n    var defines = [];\n\n    if (texture.gammaSpace) {\n      defines.push(\"#define GAMMA_INPUT\");\n    }\n\n    defines.push(\"#define NUM_SAMPLES \" + this.quality + \"u\"); // unsigned int\n\n    var effectWrapper = new EffectWrapper({\n      engine: this._engine,\n      name: \"hdrFiltering\",\n      vertexShader: \"hdrFiltering\",\n      fragmentShader: \"hdrFiltering\",\n      samplerNames: [\"inputTexture\"],\n      uniformNames: [\"vSampleDirections\", \"vWeights\", \"up\", \"right\", \"front\", \"vFilteringInfo\", \"hdrScale\", \"alphaG\"],\n      useShaderStore: true,\n      defines: defines,\n      onCompiled: onCompiled\n    });\n    return effectWrapper;\n  };\n  /**\n   * Get a value indicating if the filter is ready to be used\n   * @param texture Texture to filter\n   * @returns true if the filter is ready\n   */\n\n\n  HDRFiltering.prototype.isReady = function (texture) {\n    return texture.isReady() && this._effectWrapper.effect.isReady();\n  };\n  /**\n   * Prefilters a cube texture to have mipmap levels representing roughness values.\n   * Prefiltering will be invoked at the end of next rendering pass.\n   * This has to be done once the map is loaded, and has not been prefiltered by a third party software.\n   * See http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf for more information\n   * @param texture Texture to filter\n   * @param onFinished Callback when filtering is done\n   * @return Promise called when prefiltering is done\n   */\n\n\n  HDRFiltering.prototype.prefilter = function (texture, onFinished) {\n    var _this = this;\n\n    if (onFinished === void 0) {\n      onFinished = null;\n    }\n\n    if (!this._engine._features.allowTexturePrefiltering) {\n      Logger.Warn(\"HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.\");\n      return Promise.reject(\"HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.\");\n    }\n\n    return new Promise(function (resolve) {\n      _this._effectRenderer = new EffectRenderer(_this._engine);\n      _this._effectWrapper = _this._createEffect(texture);\n\n      _this._effectWrapper.effect.executeWhenCompiled(function () {\n        _this._prefilterInternal(texture);\n\n        _this._effectRenderer.dispose();\n\n        _this._effectWrapper.dispose();\n\n        resolve();\n\n        if (onFinished) {\n          onFinished();\n        }\n      });\n    });\n  };\n\n  return HDRFiltering;\n}();\n\nexport { HDRFiltering };","map":{"version":3,"mappings":"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","names":["Vector3","Scalar","EffectWrapper","EffectRenderer","Logger","engine","options","_engine","hdrScale","quality","HDRFiltering","size","textureType","getCaps","textureHalfFloatRender","textureFloatRender","rtWrapper","createRenderTargetCubeTexture","format","type","createMipMaps","generateMipMaps","generateDepthBuffer","generateStencilBuffer","samplingMode","updateTextureWrappingMode","texture","updateTextureSamplingMode","width","getSize","mipmapsCount","ILog2","effect","_effectWrapper","outputTexture","_createRenderTarget","_effectRenderer","setViewport","intTexture","getInternalTexture","applyEffectWrapper","directions","setFloat","setFloat2","setTexture","face","setVector3","lod","bindFramebuffer","undefined","alpha","Math","pow","_lodGenerationOffset","_lodGenerationScale","draw","restoreStates","restoreDefaultFramebuffer","_releaseTexture","_texture","_swapAndDie","_prefiltered","onCompiled","defines","gammaSpace","push","effectWrapper","name","vertexShader","fragmentShader","samplerNames","uniformNames","useShaderStore","isReady","onFinished","_features","allowTexturePrefiltering","Warn","Promise","reject","resolve","_this","_createEffect","executeWhenCompiled","_prefilterInternal","dispose"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Materials/Textures/Filtering/hdrFiltering.ts"],"sourcesContent":["import { Vector3 } from \"../../../Maths/math\";\r\nimport { Scalar } from \"../../../Maths/math.scalar\";\r\nimport type { BaseTexture } from \"../baseTexture\";\r\nimport type { ThinEngine } from \"../../../Engines/thinEngine\";\r\nimport type { Effect } from \"../../../Materials/effect\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport { EffectWrapper, EffectRenderer } from \"../../../Materials/effectRenderer\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { RenderTargetWrapper } from \"../../../Engines/renderTargetWrapper\";\r\n\r\nimport \"../../../Shaders/hdrFiltering.vertex\";\r\nimport \"../../../Shaders/hdrFiltering.fragment\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\n\r\n/**\r\n * Options for texture filtering\r\n */\r\ninterface IHDRFilteringOptions {\r\n    /**\r\n     * Scales pixel intensity for the input HDR map.\r\n     */\r\n    hdrScale?: number;\r\n\r\n    /**\r\n     * Quality of the filter. Should be `Constants.TEXTURE_FILTERING_QUALITY_OFFLINE` for prefiltering\r\n     */\r\n    quality?: number;\r\n}\r\n\r\n/**\r\n * Filters HDR maps to get correct renderings of PBR reflections\r\n */\r\nexport class HDRFiltering {\r\n    private _engine: ThinEngine;\r\n    private _effectRenderer: EffectRenderer;\r\n    private _effectWrapper: EffectWrapper;\r\n\r\n    private _lodGenerationOffset: number = 0;\r\n    private _lodGenerationScale: number = 0.8;\r\n\r\n    /**\r\n     * Quality switch for prefiltering. Should be set to `Constants.TEXTURE_FILTERING_QUALITY_OFFLINE` unless\r\n     * you care about baking speed.\r\n     */\r\n    public quality: number = Constants.TEXTURE_FILTERING_QUALITY_OFFLINE;\r\n\r\n    /**\r\n     * Scales pixel intensity for the input HDR map.\r\n     */\r\n    public hdrScale: number = 1;\r\n\r\n    /**\r\n     * Instantiates HDR filter for reflection maps\r\n     *\r\n     * @param engine Thin engine\r\n     * @param options Options\r\n     */\r\n    constructor(engine: ThinEngine, options: IHDRFilteringOptions = {}) {\r\n        // pass\r\n        this._engine = engine;\r\n        this.hdrScale = options.hdrScale || this.hdrScale;\r\n        this.quality = options.quality || this.quality;\r\n    }\r\n\r\n    private _createRenderTarget(size: number): RenderTargetWrapper {\r\n        let textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        if (this._engine.getCaps().textureHalfFloatRender) {\r\n            textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        } else if (this._engine.getCaps().textureFloatRender) {\r\n            textureType = Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        const rtWrapper = this._engine.createRenderTargetCubeTexture(size, {\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n            type: textureType,\r\n            createMipMaps: true,\r\n            generateMipMaps: false,\r\n            generateDepthBuffer: false,\r\n            generateStencilBuffer: false,\r\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n        });\r\n        this._engine.updateTextureWrappingMode(rtWrapper.texture!, Constants.TEXTURE_CLAMP_ADDRESSMODE, Constants.TEXTURE_CLAMP_ADDRESSMODE, Constants.TEXTURE_CLAMP_ADDRESSMODE);\r\n\r\n        this._engine.updateTextureSamplingMode(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, rtWrapper.texture!, true);\r\n\r\n        return rtWrapper;\r\n    }\r\n\r\n    private _prefilterInternal(texture: BaseTexture): BaseTexture {\r\n        const width = texture.getSize().width;\r\n        const mipmapsCount = Scalar.ILog2(width) + 1;\r\n\r\n        const effect = this._effectWrapper.effect;\r\n        const outputTexture = this._createRenderTarget(width);\r\n        this._effectRenderer.setViewport();\r\n\r\n        const intTexture = texture.getInternalTexture();\r\n        if (intTexture) {\r\n            // Just in case generate fresh clean mips.\r\n            this._engine.updateTextureSamplingMode(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, intTexture, true);\r\n        }\r\n\r\n        this._effectRenderer.applyEffectWrapper(this._effectWrapper);\r\n\r\n        const directions = [\r\n            [new Vector3(0, 0, -1), new Vector3(0, -1, 0), new Vector3(1, 0, 0)], // PositiveX\r\n            [new Vector3(0, 0, 1), new Vector3(0, -1, 0), new Vector3(-1, 0, 0)], // NegativeX\r\n            [new Vector3(1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 1, 0)], // PositiveY\r\n            [new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)], // NegativeY\r\n            [new Vector3(1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, 1)], // PositiveZ\r\n            [new Vector3(-1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, -1)], // NegativeZ\r\n        ];\r\n\r\n        effect.setFloat(\"hdrScale\", this.hdrScale);\r\n        effect.setFloat2(\"vFilteringInfo\", texture.getSize().width, mipmapsCount);\r\n        effect.setTexture(\"inputTexture\", texture);\r\n\r\n        for (let face = 0; face < 6; face++) {\r\n            effect.setVector3(\"up\", directions[face][0]);\r\n            effect.setVector3(\"right\", directions[face][1]);\r\n            effect.setVector3(\"front\", directions[face][2]);\r\n\r\n            for (let lod = 0; lod < mipmapsCount; lod++) {\r\n                this._engine.bindFramebuffer(outputTexture, face, undefined, undefined, true, lod);\r\n                this._effectRenderer.applyEffectWrapper(this._effectWrapper);\r\n\r\n                let alpha = Math.pow(2, (lod - this._lodGenerationOffset) / this._lodGenerationScale) / width;\r\n                if (lod === 0) {\r\n                    alpha = 0;\r\n                }\r\n\r\n                effect.setFloat(\"alphaG\", alpha);\r\n\r\n                this._effectRenderer.draw();\r\n            }\r\n        }\r\n\r\n        // Cleanup\r\n        this._effectRenderer.restoreStates();\r\n        this._engine.restoreDefaultFramebuffer();\r\n        this._engine._releaseTexture(texture._texture!);\r\n\r\n        // Internal Swap\r\n        outputTexture._swapAndDie(texture._texture!);\r\n\r\n        texture._prefiltered = true;\r\n\r\n        return texture;\r\n    }\r\n\r\n    private _createEffect(texture: BaseTexture, onCompiled?: Nullable<(effect: Effect) => void>): EffectWrapper {\r\n        const defines = [];\r\n        if (texture.gammaSpace) {\r\n            defines.push(\"#define GAMMA_INPUT\");\r\n        }\r\n\r\n        defines.push(\"#define NUM_SAMPLES \" + this.quality + \"u\"); // unsigned int\r\n\r\n        const effectWrapper = new EffectWrapper({\r\n            engine: this._engine,\r\n            name: \"hdrFiltering\",\r\n            vertexShader: \"hdrFiltering\",\r\n            fragmentShader: \"hdrFiltering\",\r\n            samplerNames: [\"inputTexture\"],\r\n            uniformNames: [\"vSampleDirections\", \"vWeights\", \"up\", \"right\", \"front\", \"vFilteringInfo\", \"hdrScale\", \"alphaG\"],\r\n            useShaderStore: true,\r\n            defines,\r\n            onCompiled: onCompiled,\r\n        });\r\n\r\n        return effectWrapper;\r\n    }\r\n\r\n    /**\r\n     * Get a value indicating if the filter is ready to be used\r\n     * @param texture Texture to filter\r\n     * @returns true if the filter is ready\r\n     */\r\n    public isReady(texture: BaseTexture) {\r\n        return texture.isReady() && this._effectWrapper.effect.isReady();\r\n    }\r\n\r\n    /**\r\n     * Prefilters a cube texture to have mipmap levels representing roughness values.\r\n     * Prefiltering will be invoked at the end of next rendering pass.\r\n     * This has to be done once the map is loaded, and has not been prefiltered by a third party software.\r\n     * See http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf for more information\r\n     * @param texture Texture to filter\r\n     * @param onFinished Callback when filtering is done\r\n     * @return Promise called when prefiltering is done\r\n     */\r\n    public prefilter(texture: BaseTexture, onFinished: Nullable<() => void> = null): Promise<void> {\r\n        if (!this._engine._features.allowTexturePrefiltering) {\r\n            Logger.Warn(\"HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.\");\r\n            return Promise.reject(\"HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.\");\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            this._effectRenderer = new EffectRenderer(this._engine);\r\n            this._effectWrapper = this._createEffect(texture);\r\n            this._effectWrapper.effect.executeWhenCompiled(() => {\r\n                this._prefilterInternal(texture);\r\n                this._effectRenderer.dispose();\r\n                this._effectWrapper.dispose();\r\n                resolve();\r\n                if (onFinished) {\r\n                    onFinished();\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}