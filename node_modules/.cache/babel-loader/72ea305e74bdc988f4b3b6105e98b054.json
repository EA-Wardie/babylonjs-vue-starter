{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector.js\";\n/**\n * @hidden\n */\n\nvar FaceDirectionInfo =\n/** @class */\nfunction () {\n  function FaceDirectionInfo(direction, rotatedDirection, diff, ignore) {\n    if (rotatedDirection === void 0) {\n      rotatedDirection = new Vector3();\n    }\n\n    if (diff === void 0) {\n      diff = 0;\n    }\n\n    if (ignore === void 0) {\n      ignore = false;\n    }\n\n    this.direction = direction;\n    this.rotatedDirection = rotatedDirection;\n    this.diff = diff;\n    this.ignore = ignore;\n  }\n\n  return FaceDirectionInfo;\n}();\n/**\n * A behavior that when attached to a mesh will will place a specified node on the meshes face pointing towards the camera\n */\n\n\nvar AttachToBoxBehavior =\n/** @class */\nfunction () {\n  /**\n   * Creates the AttachToBoxBehavior, used to attach UI to the closest face of the box to a camera\n   * @param _ui The transform node that should be attached to the mesh\n   */\n  function AttachToBoxBehavior(_ui) {\n    this._ui = _ui;\n    /**\n     *  The name of the behavior\n     */\n\n    this.name = \"AttachToBoxBehavior\";\n    /**\n     * The distance away from the face of the mesh that the UI should be attached to (default: 0.15)\n     */\n\n    this.distanceAwayFromFace = 0.15;\n    /**\n     * The distance from the bottom of the face that the UI should be attached to (default: 0.15)\n     */\n\n    this.distanceAwayFromBottomOfFace = 0.15;\n    this._faceVectors = [new FaceDirectionInfo(Vector3.Up()), new FaceDirectionInfo(Vector3.Down()), new FaceDirectionInfo(Vector3.Left()), new FaceDirectionInfo(Vector3.Right()), new FaceDirectionInfo(Vector3.Forward()), new FaceDirectionInfo(Vector3.Forward().scaleInPlace(-1))];\n    this._tmpMatrix = new Matrix();\n    this._tmpVector = new Vector3();\n    this._zeroVector = Vector3.Zero();\n    this._lookAtTmpMatrix = new Matrix();\n    /* Does nothing */\n  }\n  /**\n   *  Initializes the behavior\n   */\n\n\n  AttachToBoxBehavior.prototype.init = function () {\n    /* Does nothing */\n  };\n\n  AttachToBoxBehavior.prototype._closestFace = function (targetDirection) {\n    var _this = this; // Go over each face and calculate the angle between the face's normal and targetDirection\n\n\n    this._faceVectors.forEach(function (v) {\n      if (!_this._target.rotationQuaternion) {\n        _this._target.rotationQuaternion = Quaternion.RotationYawPitchRoll(_this._target.rotation.y, _this._target.rotation.x, _this._target.rotation.z);\n      }\n\n      _this._target.rotationQuaternion.toRotationMatrix(_this._tmpMatrix);\n\n      Vector3.TransformCoordinatesToRef(v.direction, _this._tmpMatrix, v.rotatedDirection);\n      v.diff = Vector3.GetAngleBetweenVectors(v.rotatedDirection, targetDirection, Vector3.Cross(v.rotatedDirection, targetDirection));\n    }); // Return the face information of the one with the normal closest to target direction\n\n\n    return this._faceVectors.reduce(function (min, p) {\n      if (min.ignore) {\n        return p;\n      } else if (p.ignore) {\n        return min;\n      } else {\n        return min.diff < p.diff ? min : p;\n      }\n    }, this._faceVectors[0]);\n  };\n\n  AttachToBoxBehavior.prototype._lookAtToRef = function (pos, up, ref) {\n    if (up === void 0) {\n      up = new Vector3(0, 1, 0);\n    }\n\n    Matrix.LookAtLHToRef(this._zeroVector, pos, up, this._lookAtTmpMatrix);\n\n    this._lookAtTmpMatrix.invert();\n\n    Quaternion.FromRotationMatrixToRef(this._lookAtTmpMatrix, ref);\n  };\n  /**\n   * Attaches the AttachToBoxBehavior to the passed in mesh\n   * @param target The mesh that the specified node will be attached to\n   */\n\n\n  AttachToBoxBehavior.prototype.attach = function (target) {\n    var _this = this;\n\n    this._target = target;\n    this._scene = this._target.getScene(); // Every frame, update the app bars position\n\n    this._onRenderObserver = this._scene.onBeforeRenderObservable.add(function () {\n      if (!_this._scene.activeCamera) {\n        return;\n      } // Find the face closest to the cameras position\n\n\n      var cameraPos = _this._scene.activeCamera.position;\n\n      if (_this._scene.activeCamera.devicePosition) {\n        cameraPos = _this._scene.activeCamera.devicePosition;\n      }\n\n      var facing = _this._closestFace(cameraPos.subtract(target.position));\n\n      if (_this._scene.activeCamera.leftCamera) {\n        _this._scene.activeCamera.leftCamera.computeWorldMatrix().getRotationMatrixToRef(_this._tmpMatrix);\n      } else {\n        _this._scene.activeCamera.computeWorldMatrix().getRotationMatrixToRef(_this._tmpMatrix);\n      } // Get camera up direction\n\n\n      Vector3.TransformCoordinatesToRef(Vector3.Up(), _this._tmpMatrix, _this._tmpVector); // Ignore faces to not select a parallel face for the up vector of the UI\n\n      _this._faceVectors.forEach(function (v) {\n        if (facing.direction.x && v.direction.x) {\n          v.ignore = true;\n        }\n\n        if (facing.direction.y && v.direction.y) {\n          v.ignore = true;\n        }\n\n        if (facing.direction.z && v.direction.z) {\n          v.ignore = true;\n        }\n      });\n\n      var facingUp = _this._closestFace(_this._tmpVector); // Unignore faces\n\n\n      _this._faceVectors.forEach(function (v) {\n        v.ignore = false;\n      }); // Position the app bar on that face\n\n\n      _this._ui.position.copyFrom(target.position);\n\n      if (facing.direction.x) {\n        facing.rotatedDirection.scaleToRef(target.scaling.x / 2 + _this.distanceAwayFromFace, _this._tmpVector);\n\n        _this._ui.position.addInPlace(_this._tmpVector);\n      }\n\n      if (facing.direction.y) {\n        facing.rotatedDirection.scaleToRef(target.scaling.y / 2 + _this.distanceAwayFromFace, _this._tmpVector);\n\n        _this._ui.position.addInPlace(_this._tmpVector);\n      }\n\n      if (facing.direction.z) {\n        facing.rotatedDirection.scaleToRef(target.scaling.z / 2 + _this.distanceAwayFromFace, _this._tmpVector);\n\n        _this._ui.position.addInPlace(_this._tmpVector);\n      } // Rotate to be oriented properly to the camera\n\n\n      if (!_this._ui.rotationQuaternion) {\n        _this._ui.rotationQuaternion = Quaternion.RotationYawPitchRoll(_this._ui.rotation.y, _this._ui.rotation.x, _this._ui.rotation.z);\n      }\n\n      facing.rotatedDirection.scaleToRef(-1, _this._tmpVector);\n\n      _this._lookAtToRef(_this._tmpVector, facingUp.rotatedDirection, _this._ui.rotationQuaternion); // Place ui the correct distance from the bottom of the mesh\n\n\n      if (facingUp.direction.x) {\n        _this._ui.up.scaleToRef(_this.distanceAwayFromBottomOfFace - target.scaling.x / 2, _this._tmpVector);\n      }\n\n      if (facingUp.direction.y) {\n        _this._ui.up.scaleToRef(_this.distanceAwayFromBottomOfFace - target.scaling.y / 2, _this._tmpVector);\n      }\n\n      if (facingUp.direction.z) {\n        _this._ui.up.scaleToRef(_this.distanceAwayFromBottomOfFace - target.scaling.z / 2, _this._tmpVector);\n      }\n\n      _this._ui.position.addInPlace(_this._tmpVector);\n    });\n  };\n  /**\n   *  Detaches the behavior from the mesh\n   */\n\n\n  AttachToBoxBehavior.prototype.detach = function () {\n    this._scene.onBeforeRenderObservable.remove(this._onRenderObserver);\n  };\n\n  return AttachToBoxBehavior;\n}();\n\nexport { AttachToBoxBehavior };","map":{"version":3,"mappings":";;;;;AAAA,SAASA,OAAT,EAAkBC,MAAlB,EAA0BC,UAA1B,QAA4C,4BAA5C;AAQA;;;;AAGA;AAAA;AAAA;AACI,6BAAmBC,SAAnB,EAA8CC,gBAA9C,EAAuFC,IAAvF,EAAwGC,MAAxG,EAAsH;AAAxE;AAAAF,6BAAuBJ,OAAvB;AAAgC;;AAAS;AAAAK;AAAQ;;AAAS;AAAAC;AAAc;;AAAnG;AAA2B;AAAyC;AAAiB;AAAkB;;AAC9H;AAAC,CAFD;AAIA;;;;;AAGA;AAAA;AAAA;AA2BI;;;;AAIA,+BAAoBC,GAApB,EAAsC;AAAlB;AA9BpB;;;;AAGO,gBAAO,qBAAP;AACP;;;;AAGO,gCAAuB,IAAvB;AACP;;;;AAGO,wCAA+B,IAA/B;AACC,wBAAe,CACnB,IAAIC,iBAAJ,CAAsBR,OAAO,CAACS,EAAR,EAAtB,CADmB,EAEnB,IAAID,iBAAJ,CAAsBR,OAAO,CAACU,IAAR,EAAtB,CAFmB,EAGnB,IAAIF,iBAAJ,CAAsBR,OAAO,CAACW,IAAR,EAAtB,CAHmB,EAInB,IAAIH,iBAAJ,CAAsBR,OAAO,CAACY,KAAR,EAAtB,CAJmB,EAKnB,IAAIJ,iBAAJ,CAAsBR,OAAO,CAACa,OAAR,EAAtB,CALmB,EAMnB,IAAIL,iBAAJ,CAAsBR,OAAO,CAACa,OAAR,GAAkBC,YAAlB,CAA+B,CAAC,CAAhC,CAAtB,CANmB,CAAf;AAWA,sBAAa,IAAIb,MAAJ,EAAb;AACA,sBAAa,IAAID,OAAJ,EAAb;AAuCA,uBAAcA,OAAO,CAACe,IAAR,EAAd;AACA,4BAAmB,IAAId,MAAJ,EAAnB;AAjCJ;AACH;AAED;;;;;AAGOe,uCAAP;AACI;AACH,GAFM;;AAICA,+CAAR,UAAqBC,eAArB,EAA6C;AAA7C,qBAA6C,CACzC;;;AACA,SAAKC,YAAL,CAAkBC,OAAlB,CAA0B,UAACC,CAAD,EAAE;AACxB,UAAI,CAACC,KAAI,CAACC,OAAL,CAAaC,kBAAlB,EAAsC;AAClCF,aAAI,CAACC,OAAL,CAAaC,kBAAb,GAAkCrB,UAAU,CAACsB,oBAAX,CAAgCH,KAAI,CAACC,OAAL,CAAaG,QAAb,CAAsBC,CAAtD,EAAyDL,KAAI,CAACC,OAAL,CAAaG,QAAb,CAAsBE,CAA/E,EAAkFN,KAAI,CAACC,OAAL,CAAaG,QAAb,CAAsBG,CAAxG,CAAlC;AACH;;AACDP,WAAI,CAACC,OAAL,CAAaC,kBAAb,CAAgCM,gBAAhC,CAAiDR,KAAI,CAACS,UAAtD;;AACA9B,aAAO,CAAC+B,yBAAR,CAAkCX,CAAC,CAACjB,SAApC,EAA+CkB,KAAI,CAACS,UAApD,EAAgEV,CAAC,CAAChB,gBAAlE;AACAgB,OAAC,CAACf,IAAF,GAASL,OAAO,CAACgC,sBAAR,CAA+BZ,CAAC,CAAChB,gBAAjC,EAAmDa,eAAnD,EAAoEjB,OAAO,CAACiC,KAAR,CAAcb,CAAC,CAAChB,gBAAhB,EAAkCa,eAAlC,CAApE,CAAT;AACH,KAPD,EAFyC,CAUzC;;;AACA,WAAO,KAAKC,YAAL,CAAkBgB,MAAlB,CAAyB,UAACC,GAAD,EAAMC,CAAN,EAAO;AACnC,UAAID,GAAG,CAAC7B,MAAR,EAAgB;AACZ,eAAO8B,CAAP;AACH,OAFD,MAEO,IAAIA,CAAC,CAAC9B,MAAN,EAAc;AACjB,eAAO6B,GAAP;AACH,OAFM,MAEA;AACH,eAAOA,GAAG,CAAC9B,IAAJ,GAAW+B,CAAC,CAAC/B,IAAb,GAAoB8B,GAApB,GAA0BC,CAAjC;AACH;AACJ,KARM,EAQJ,KAAKlB,YAAL,CAAkB,CAAlB,CARI,CAAP;AASH,GApBO;;AAwBAF,+CAAR,UAAqBqB,GAArB,EAAmCC,EAAnC,EAA8DC,GAA9D,EAA6E;AAA1C;AAAAD,eAAStC,OAAT,CAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB;AAAyB;;AACxDC,UAAM,CAACuC,aAAP,CAAqB,KAAKC,WAA1B,EAAuCJ,GAAvC,EAA4CC,EAA5C,EAAgD,KAAKI,gBAArD;;AACA,SAAKA,gBAAL,CAAsBC,MAAtB;;AACAzC,cAAU,CAAC0C,uBAAX,CAAmC,KAAKF,gBAAxC,EAA0DH,GAA1D;AACH,GAJO;AAMR;;;;;;AAIAvB,mDAAO6B,MAAP,EAAmB;AAAnB;;AACI,SAAKvB,OAAL,GAAeuB,MAAf;AACA,SAAKC,MAAL,GAAc,KAAKxB,OAAL,CAAayB,QAAb,EAAd,CAFe,CAIf;;AACA,SAAKC,iBAAL,GAAyB,KAAKF,MAAL,CAAYG,wBAAZ,CAAqCC,GAArC,CAAyC;AAC9D,UAAI,CAAC7B,KAAI,CAACyB,MAAL,CAAYK,YAAjB,EAA+B;AAC3B;AACH,OAH6D,CAK9D;;;AACA,UAAIC,SAAS,GAAG/B,KAAI,CAACyB,MAAL,CAAYK,YAAZ,CAAyBE,QAAzC;;AACA,UAAUhC,KAAI,CAACyB,MAAL,CAAYK,YAAZ,CAA0BG,cAApC,EAAoD;AAChDF,iBAAS,GAAS/B,KAAI,CAACyB,MAAL,CAAYK,YAAZ,CAA0BG,cAA5C;AACH;;AACD,UAAMC,MAAM,GAAGlC,KAAI,CAACmC,YAAL,CAAkBJ,SAAS,CAACK,QAAV,CAAmBZ,MAAM,CAACQ,QAA1B,CAAlB,CAAf;;AACA,UAAIhC,KAAI,CAACyB,MAAL,CAAYK,YAAZ,CAAyBO,UAA7B,EAAyC;AACrCrC,aAAI,CAACyB,MAAL,CAAYK,YAAZ,CAAyBO,UAAzB,CAAoCC,kBAApC,GAAyDC,sBAAzD,CAAgFvC,KAAI,CAACS,UAArF;AACH,OAFD,MAEO;AACHT,aAAI,CAACyB,MAAL,CAAYK,YAAZ,CAAyBQ,kBAAzB,GAA8CC,sBAA9C,CAAqEvC,KAAI,CAACS,UAA1E;AACH,OAf6D,CAiB9D;;;AACA9B,aAAO,CAAC+B,yBAAR,CAAkC/B,OAAO,CAACS,EAAR,EAAlC,EAAgDY,KAAI,CAACS,UAArD,EAAiET,KAAI,CAACwC,UAAtE,EAlB8D,CAmB9D;;AACAxC,WAAI,CAACH,YAAL,CAAkBC,OAAlB,CAA0B,UAACC,CAAD,EAAE;AACxB,YAAImC,MAAM,CAACpD,SAAP,CAAiBwB,CAAjB,IAAsBP,CAAC,CAACjB,SAAF,CAAYwB,CAAtC,EAAyC;AACrCP,WAAC,CAACd,MAAF,GAAW,IAAX;AACH;;AACD,YAAIiD,MAAM,CAACpD,SAAP,CAAiBuB,CAAjB,IAAsBN,CAAC,CAACjB,SAAF,CAAYuB,CAAtC,EAAyC;AACrCN,WAAC,CAACd,MAAF,GAAW,IAAX;AACH;;AACD,YAAIiD,MAAM,CAACpD,SAAP,CAAiByB,CAAjB,IAAsBR,CAAC,CAACjB,SAAF,CAAYyB,CAAtC,EAAyC;AACrCR,WAAC,CAACd,MAAF,GAAW,IAAX;AACH;AACJ,OAVD;;AAWA,UAAMwD,QAAQ,GAAGzC,KAAI,CAACmC,YAAL,CAAkBnC,KAAI,CAACwC,UAAvB,CAAjB,CA/B8D,CAgC9D;;;AACAxC,WAAI,CAACH,YAAL,CAAkBC,OAAlB,CAA0B,UAACC,CAAD,EAAE;AACxBA,SAAC,CAACd,MAAF,GAAW,KAAX;AACH,OAFD,EAjC8D,CAqC9D;;;AACAe,WAAI,CAACd,GAAL,CAAS8C,QAAT,CAAkBU,QAAlB,CAA2BlB,MAAM,CAACQ,QAAlC;;AACA,UAAIE,MAAM,CAACpD,SAAP,CAAiBwB,CAArB,EAAwB;AACpB4B,cAAM,CAACnD,gBAAP,CAAwB4D,UAAxB,CAAmCnB,MAAM,CAACoB,OAAP,CAAetC,CAAf,GAAmB,CAAnB,GAAuBN,KAAI,CAAC6C,oBAA/D,EAAqF7C,KAAI,CAACwC,UAA1F;;AACAxC,aAAI,CAACd,GAAL,CAAS8C,QAAT,CAAkBc,UAAlB,CAA6B9C,KAAI,CAACwC,UAAlC;AACH;;AACD,UAAIN,MAAM,CAACpD,SAAP,CAAiBuB,CAArB,EAAwB;AACpB6B,cAAM,CAACnD,gBAAP,CAAwB4D,UAAxB,CAAmCnB,MAAM,CAACoB,OAAP,CAAevC,CAAf,GAAmB,CAAnB,GAAuBL,KAAI,CAAC6C,oBAA/D,EAAqF7C,KAAI,CAACwC,UAA1F;;AACAxC,aAAI,CAACd,GAAL,CAAS8C,QAAT,CAAkBc,UAAlB,CAA6B9C,KAAI,CAACwC,UAAlC;AACH;;AACD,UAAIN,MAAM,CAACpD,SAAP,CAAiByB,CAArB,EAAwB;AACpB2B,cAAM,CAACnD,gBAAP,CAAwB4D,UAAxB,CAAmCnB,MAAM,CAACoB,OAAP,CAAerC,CAAf,GAAmB,CAAnB,GAAuBP,KAAI,CAAC6C,oBAA/D,EAAqF7C,KAAI,CAACwC,UAA1F;;AACAxC,aAAI,CAACd,GAAL,CAAS8C,QAAT,CAAkBc,UAAlB,CAA6B9C,KAAI,CAACwC,UAAlC;AACH,OAlD6D,CAoD9D;;;AACA,UAAI,CAACxC,KAAI,CAACd,GAAL,CAASgB,kBAAd,EAAkC;AAC9BF,aAAI,CAACd,GAAL,CAASgB,kBAAT,GAA8BrB,UAAU,CAACsB,oBAAX,CAAgCH,KAAI,CAACd,GAAL,CAASkB,QAAT,CAAkBC,CAAlD,EAAqDL,KAAI,CAACd,GAAL,CAASkB,QAAT,CAAkBE,CAAvE,EAA0EN,KAAI,CAACd,GAAL,CAASkB,QAAT,CAAkBG,CAA5F,CAA9B;AACH;;AACD2B,YAAM,CAACnD,gBAAP,CAAwB4D,UAAxB,CAAmC,CAAC,CAApC,EAAuC3C,KAAI,CAACwC,UAA5C;;AACAxC,WAAI,CAAC+C,YAAL,CAAkB/C,KAAI,CAACwC,UAAvB,EAAmCC,QAAQ,CAAC1D,gBAA5C,EAA8DiB,KAAI,CAACd,GAAL,CAASgB,kBAAvE,EAzD8D,CA2D9D;;;AACA,UAAIuC,QAAQ,CAAC3D,SAAT,CAAmBwB,CAAvB,EAA0B;AACtBN,aAAI,CAACd,GAAL,CAAS+B,EAAT,CAAY0B,UAAZ,CAAuB3C,KAAI,CAACgD,4BAAL,GAAoCxB,MAAM,CAACoB,OAAP,CAAetC,CAAf,GAAmB,CAA9E,EAAiFN,KAAI,CAACwC,UAAtF;AACH;;AACD,UAAIC,QAAQ,CAAC3D,SAAT,CAAmBuB,CAAvB,EAA0B;AACtBL,aAAI,CAACd,GAAL,CAAS+B,EAAT,CAAY0B,UAAZ,CAAuB3C,KAAI,CAACgD,4BAAL,GAAoCxB,MAAM,CAACoB,OAAP,CAAevC,CAAf,GAAmB,CAA9E,EAAiFL,KAAI,CAACwC,UAAtF;AACH;;AACD,UAAIC,QAAQ,CAAC3D,SAAT,CAAmByB,CAAvB,EAA0B;AACtBP,aAAI,CAACd,GAAL,CAAS+B,EAAT,CAAY0B,UAAZ,CAAuB3C,KAAI,CAACgD,4BAAL,GAAoCxB,MAAM,CAACoB,OAAP,CAAerC,CAAf,GAAmB,CAA9E,EAAiFP,KAAI,CAACwC,UAAtF;AACH;;AACDxC,WAAI,CAACd,GAAL,CAAS8C,QAAT,CAAkBc,UAAlB,CAA6B9C,KAAI,CAACwC,UAAlC;AACH,KAtEwB,CAAzB;AAuEH,GA5ED;AA8EA;;;;;AAGA7C;AACI,SAAK8B,MAAL,CAAYG,wBAAZ,CAAqCqB,MAArC,CAA4C,KAAKtB,iBAAjD;AACH,GAFD;;AAGJ;AAAC,CAhKD","names":["Vector3","Matrix","Quaternion","direction","rotatedDirection","diff","ignore","_ui","FaceDirectionInfo","Up","Down","Left","Right","Forward","scaleInPlace","Zero","AttachToBoxBehavior","targetDirection","_faceVectors","forEach","v","_this","_target","rotationQuaternion","RotationYawPitchRoll","rotation","y","x","z","toRotationMatrix","_tmpMatrix","TransformCoordinatesToRef","GetAngleBetweenVectors","Cross","reduce","min","p","pos","up","ref","LookAtLHToRef","_zeroVector","_lookAtTmpMatrix","invert","FromRotationMatrixToRef","target","_scene","getScene","_onRenderObserver","onBeforeRenderObservable","add","activeCamera","cameraPos","position","devicePosition","facing","_closestFace","subtract","leftCamera","computeWorldMatrix","getRotationMatrixToRef","_tmpVector","facingUp","copyFrom","scaleToRef","scaling","distanceAwayFromFace","addInPlace","_lookAtToRef","distanceAwayFromBottomOfFace","remove"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Behaviors/Meshes/attachToBoxBehavior.ts"],"sourcesContent":["import { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Behavior } from \"../../Behaviors/behavior\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nclass FaceDirectionInfo {\r\n    constructor(public direction: Vector3, public rotatedDirection = new Vector3(), public diff = 0, public ignore = false) {}\r\n}\r\n\r\n/**\r\n * A behavior that when attached to a mesh will will place a specified node on the meshes face pointing towards the camera\r\n */\r\nexport class AttachToBoxBehavior implements Behavior<Mesh> {\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public name = \"AttachToBoxBehavior\";\r\n    /**\r\n     * The distance away from the face of the mesh that the UI should be attached to (default: 0.15)\r\n     */\r\n    public distanceAwayFromFace = 0.15;\r\n    /**\r\n     * The distance from the bottom of the face that the UI should be attached to (default: 0.15)\r\n     */\r\n    public distanceAwayFromBottomOfFace = 0.15;\r\n    private _faceVectors = [\r\n        new FaceDirectionInfo(Vector3.Up()),\r\n        new FaceDirectionInfo(Vector3.Down()),\r\n        new FaceDirectionInfo(Vector3.Left()),\r\n        new FaceDirectionInfo(Vector3.Right()),\r\n        new FaceDirectionInfo(Vector3.Forward()),\r\n        new FaceDirectionInfo(Vector3.Forward().scaleInPlace(-1)),\r\n    ];\r\n    private _target: Mesh;\r\n    private _scene: Scene;\r\n    private _onRenderObserver: Nullable<Observer<Scene>>;\r\n    private _tmpMatrix = new Matrix();\r\n    private _tmpVector = new Vector3();\r\n\r\n    /**\r\n     * Creates the AttachToBoxBehavior, used to attach UI to the closest face of the box to a camera\r\n     * @param _ui The transform node that should be attached to the mesh\r\n     */\r\n    constructor(private _ui: TransformNode) {\r\n        /* Does nothing */\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() {\r\n        /* Does nothing */\r\n    }\r\n\r\n    private _closestFace(targetDirection: Vector3) {\r\n        // Go over each face and calculate the angle between the face's normal and targetDirection\r\n        this._faceVectors.forEach((v) => {\r\n            if (!this._target.rotationQuaternion) {\r\n                this._target.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._target.rotation.y, this._target.rotation.x, this._target.rotation.z);\r\n            }\r\n            this._target.rotationQuaternion.toRotationMatrix(this._tmpMatrix);\r\n            Vector3.TransformCoordinatesToRef(v.direction, this._tmpMatrix, v.rotatedDirection);\r\n            v.diff = Vector3.GetAngleBetweenVectors(v.rotatedDirection, targetDirection, Vector3.Cross(v.rotatedDirection, targetDirection));\r\n        });\r\n        // Return the face information of the one with the normal closest to target direction\r\n        return this._faceVectors.reduce((min, p) => {\r\n            if (min.ignore) {\r\n                return p;\r\n            } else if (p.ignore) {\r\n                return min;\r\n            } else {\r\n                return min.diff < p.diff ? min : p;\r\n            }\r\n        }, this._faceVectors[0]);\r\n    }\r\n\r\n    private _zeroVector = Vector3.Zero();\r\n    private _lookAtTmpMatrix = new Matrix();\r\n    private _lookAtToRef(pos: Vector3, up = new Vector3(0, 1, 0), ref: Quaternion) {\r\n        Matrix.LookAtLHToRef(this._zeroVector, pos, up, this._lookAtTmpMatrix);\r\n        this._lookAtTmpMatrix.invert();\r\n        Quaternion.FromRotationMatrixToRef(this._lookAtTmpMatrix, ref);\r\n    }\r\n\r\n    /**\r\n     * Attaches the AttachToBoxBehavior to the passed in mesh\r\n     * @param target The mesh that the specified node will be attached to\r\n     */\r\n    attach(target: Mesh) {\r\n        this._target = target;\r\n        this._scene = this._target.getScene();\r\n\r\n        // Every frame, update the app bars position\r\n        this._onRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\r\n            if (!this._scene.activeCamera) {\r\n                return;\r\n            }\r\n\r\n            // Find the face closest to the cameras position\r\n            let cameraPos = this._scene.activeCamera.position;\r\n            if ((<any>this._scene.activeCamera).devicePosition) {\r\n                cameraPos = (<any>this._scene.activeCamera).devicePosition;\r\n            }\r\n            const facing = this._closestFace(cameraPos.subtract(target.position));\r\n            if (this._scene.activeCamera.leftCamera) {\r\n                this._scene.activeCamera.leftCamera.computeWorldMatrix().getRotationMatrixToRef(this._tmpMatrix);\r\n            } else {\r\n                this._scene.activeCamera.computeWorldMatrix().getRotationMatrixToRef(this._tmpMatrix);\r\n            }\r\n\r\n            // Get camera up direction\r\n            Vector3.TransformCoordinatesToRef(Vector3.Up(), this._tmpMatrix, this._tmpVector);\r\n            // Ignore faces to not select a parallel face for the up vector of the UI\r\n            this._faceVectors.forEach((v) => {\r\n                if (facing.direction.x && v.direction.x) {\r\n                    v.ignore = true;\r\n                }\r\n                if (facing.direction.y && v.direction.y) {\r\n                    v.ignore = true;\r\n                }\r\n                if (facing.direction.z && v.direction.z) {\r\n                    v.ignore = true;\r\n                }\r\n            });\r\n            const facingUp = this._closestFace(this._tmpVector);\r\n            // Unignore faces\r\n            this._faceVectors.forEach((v) => {\r\n                v.ignore = false;\r\n            });\r\n\r\n            // Position the app bar on that face\r\n            this._ui.position.copyFrom(target.position);\r\n            if (facing.direction.x) {\r\n                facing.rotatedDirection.scaleToRef(target.scaling.x / 2 + this.distanceAwayFromFace, this._tmpVector);\r\n                this._ui.position.addInPlace(this._tmpVector);\r\n            }\r\n            if (facing.direction.y) {\r\n                facing.rotatedDirection.scaleToRef(target.scaling.y / 2 + this.distanceAwayFromFace, this._tmpVector);\r\n                this._ui.position.addInPlace(this._tmpVector);\r\n            }\r\n            if (facing.direction.z) {\r\n                facing.rotatedDirection.scaleToRef(target.scaling.z / 2 + this.distanceAwayFromFace, this._tmpVector);\r\n                this._ui.position.addInPlace(this._tmpVector);\r\n            }\r\n\r\n            // Rotate to be oriented properly to the camera\r\n            if (!this._ui.rotationQuaternion) {\r\n                this._ui.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._ui.rotation.y, this._ui.rotation.x, this._ui.rotation.z);\r\n            }\r\n            facing.rotatedDirection.scaleToRef(-1, this._tmpVector);\r\n            this._lookAtToRef(this._tmpVector, facingUp.rotatedDirection, this._ui.rotationQuaternion);\r\n\r\n            // Place ui the correct distance from the bottom of the mesh\r\n            if (facingUp.direction.x) {\r\n                this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.x / 2, this._tmpVector);\r\n            }\r\n            if (facingUp.direction.y) {\r\n                this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.y / 2, this._tmpVector);\r\n            }\r\n            if (facingUp.direction.z) {\r\n                this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.z / 2, this._tmpVector);\r\n            }\r\n            this._ui.position.addInPlace(this._tmpVector);\r\n        });\r\n    }\r\n\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    detach() {\r\n        this._scene.onBeforeRenderObservable.remove(this._onRenderObserver);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}