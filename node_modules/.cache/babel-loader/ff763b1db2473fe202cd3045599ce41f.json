{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport { __assign, __decorate, __extends } from \"tslib\";\nimport { PushMaterial } from \"../pushMaterial.js\";\nimport { AbstractMesh } from \"../../Meshes/abstractMesh.js\";\nimport { Matrix, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../../Maths/math.color.js\";\nimport { Engine } from \"../../Engines/engine.js\";\nimport { NodeMaterialBuildState } from \"./nodeMaterialBuildState.js\";\nimport { Effect } from \"../effect.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterialBuildStateSharedData } from \"./nodeMaterialBuildStateSharedData.js\";\nimport { MaterialDefines } from \"../../Materials/materialDefines.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { TransformBlock } from \"./Blocks/transformBlock.js\";\nimport { VertexOutputBlock } from \"./Blocks/Vertex/vertexOutputBlock.js\";\nimport { FragmentOutputBlock } from \"./Blocks/Fragment/fragmentOutputBlock.js\";\nimport { InputBlock } from \"./Blocks/Input/inputBlock.js\";\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore.js\";\nimport { serialize, SerializationHelper } from \"../../Misc/decorators.js\";\nimport { CurrentScreenBlock } from \"./Blocks/Dual/currentScreenBlock.js\";\nimport { ParticleTextureBlock } from \"./Blocks/Particle/particleTextureBlock.js\";\nimport { ParticleRampGradientBlock } from \"./Blocks/Particle/particleRampGradientBlock.js\";\nimport { ParticleBlendMultiplyBlock } from \"./Blocks/Particle/particleBlendMultiplyBlock.js\";\nimport { EffectFallbacks } from \"../effectFallbacks.js\";\nimport { WebRequest } from \"../../Misc/webRequest.js\";\nimport { PostProcess } from \"../../PostProcesses/postProcess.js\";\nimport { VectorMergerBlock } from \"./Blocks/vectorMergerBlock.js\";\nimport { RemapBlock } from \"./Blocks/remapBlock.js\";\nimport { MultiplyBlock } from \"./Blocks/multiplyBlock.js\";\nimport { NodeMaterialModes } from \"./Enums/nodeMaterialModes.js\";\nimport { Texture } from \"../Textures/texture.js\";\nimport { BaseParticleSystem } from \"../../Particles/baseParticleSystem.js\";\nimport { ColorSplitterBlock } from \"./Blocks/colorSplitterBlock.js\";\nimport { TimingTools } from \"../../Misc/timingTools.js\";\nimport { ProceduralTexture } from \"../Textures/Procedurals/proceduralTexture.js\";\nimport { AnimatedInputBlockTypes } from \"./Blocks/Input/animatedInputBlockTypes.js\";\nimport { TrigonometryBlock, TrigonometryBlockOperations } from \"./Blocks/trigonometryBlock.js\";\nimport { NodeMaterialSystemValues } from \"./Enums/nodeMaterialSystemValues.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\nvar onCreatedEffectParameters = {\n  effect: null,\n  subMesh: null\n};\n/** @hidden */\n\nvar NodeMaterialDefines =\n/** @class */\nfunction (_super) {\n  __extends(NodeMaterialDefines, _super);\n\n  function NodeMaterialDefines() {\n    var _this = _super.call(this) || this;\n\n    _this.NORMAL = false;\n    _this.TANGENT = false;\n    _this.UV1 = false;\n    _this.UV2 = false;\n    _this.UV3 = false;\n    _this.UV4 = false;\n    _this.UV5 = false;\n    _this.UV6 = false;\n    /** BONES */\n\n    _this.NUM_BONE_INFLUENCERS = 0;\n    _this.BonesPerMesh = 0;\n    _this.BONETEXTURE = false;\n    /** MORPH TARGETS */\n\n    _this.MORPHTARGETS = false;\n    _this.MORPHTARGETS_NORMAL = false;\n    _this.MORPHTARGETS_TANGENT = false;\n    _this.MORPHTARGETS_UV = false;\n    _this.NUM_MORPH_INFLUENCERS = 0;\n    _this.MORPHTARGETS_TEXTURE = false;\n    /** IMAGE PROCESSING */\n\n    _this.IMAGEPROCESSING = false;\n    _this.VIGNETTE = false;\n    _this.VIGNETTEBLENDMODEMULTIPLY = false;\n    _this.VIGNETTEBLENDMODEOPAQUE = false;\n    _this.TONEMAPPING = false;\n    _this.TONEMAPPING_ACES = false;\n    _this.CONTRAST = false;\n    _this.EXPOSURE = false;\n    _this.COLORCURVES = false;\n    _this.COLORGRADING = false;\n    _this.COLORGRADING3D = false;\n    _this.SAMPLER3DGREENDEPTH = false;\n    _this.SAMPLER3DBGRMAP = false;\n    _this.IMAGEPROCESSINGPOSTPROCESS = false;\n    _this.SKIPFINALCOLORCLAMP = false;\n    /** MISC. */\n\n    _this.BUMPDIRECTUV = 0;\n\n    _this.rebuild();\n\n    return _this;\n  }\n\n  NodeMaterialDefines.prototype.setValue = function (name, value, markAsUnprocessedIfDirty) {\n    if (markAsUnprocessedIfDirty === void 0) {\n      markAsUnprocessedIfDirty = false;\n    }\n\n    if (this[name] === undefined) {\n      this._keys.push(name);\n    }\n\n    if (markAsUnprocessedIfDirty && this[name] !== value) {\n      this.markAsUnprocessed();\n    }\n\n    this[name] = value;\n  };\n\n  return NodeMaterialDefines;\n}(MaterialDefines);\n\nexport { NodeMaterialDefines };\n/**\n * Class used to create a node based material built by assembling shader blocks\n */\n\nvar NodeMaterial =\n/** @class */\nfunction (_super) {\n  __extends(NodeMaterial, _super);\n  /**\n   * Create a new node based material\n   * @param name defines the material name\n   * @param scene defines the hosting scene\n   * @param options defines creation option\n   */\n\n\n  function NodeMaterial(name, scene, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = _super.call(this, name, scene || EngineStore.LastCreatedScene) || this;\n\n    _this._buildId = NodeMaterial._BuildIdGenerator++;\n    _this._buildWasSuccessful = false;\n    _this._cachedWorldViewMatrix = new Matrix();\n    _this._cachedWorldViewProjectionMatrix = new Matrix();\n    _this._optimizers = new Array();\n    _this._animationFrame = -1;\n    _this.BJSNODEMATERIALEDITOR = _this._getGlobalNodeMaterialEditor();\n    /**\n     * Gets or sets data used by visual editor\n     * @see https://nme.babylonjs.com\n     */\n\n    _this.editorData = null;\n    /**\n     * Gets or sets a boolean indicating that alpha value must be ignored (This will turn alpha blending off even if an alpha value is produced by the material)\n     */\n\n    _this.ignoreAlpha = false;\n    /**\n     * Defines the maximum number of lights that can be used in the material\n     */\n\n    _this.maxSimultaneousLights = 4;\n    /**\n     * Observable raised when the material is built\n     */\n\n    _this.onBuildObservable = new Observable();\n    /**\n     * Gets or sets the root nodes of the material vertex shader\n     */\n\n    _this._vertexOutputNodes = new Array();\n    /**\n     * Gets or sets the root nodes of the material fragment (pixel) shader\n     */\n\n    _this._fragmentOutputNodes = new Array();\n    /**\n     * Gets an array of blocks that needs to be serialized even if they are not yet connected\n     */\n\n    _this.attachedBlocks = new Array();\n    /**\n     * Specifies the mode of the node material\n     * @hidden\n     */\n\n    _this._mode = NodeMaterialModes.Material;\n    /**\n     * Gets or sets a boolean indicating that alpha blending must be enabled no matter what alpha value or alpha channel of the FragmentBlock are\n     */\n\n    _this.forceAlphaBlending = false;\n    _this._options = __assign({\n      emitComments: false\n    }, options); // Setup the default processing configuration to the scene.\n\n    _this._attachImageProcessingConfiguration(null);\n\n    return _this;\n  }\n  /** Get the inspector from bundle or global */\n\n\n  NodeMaterial.prototype._getGlobalNodeMaterialEditor = function () {\n    // UMD Global name detection from Webpack Bundle UMD Name.\n    if (typeof NODEEDITOR !== \"undefined\") {\n      return NODEEDITOR;\n    } // In case of module let's check the global emitted from the editor entry point.\n\n\n    if (typeof BABYLON !== \"undefined\" && typeof BABYLON.NodeEditor !== \"undefined\") {\n      return BABYLON;\n    }\n\n    return undefined;\n  };\n\n  Object.defineProperty(NodeMaterial.prototype, \"options\", {\n    /** Gets or sets options to control the node material overall behavior */\n    get: function get() {\n      return this._options;\n    },\n    set: function set(options) {\n      this._options = options;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterial.prototype, \"imageProcessingConfiguration\", {\n    /**\n     * Gets the image processing configuration used either in this material.\n     */\n    get: function get() {\n      return this._imageProcessingConfiguration;\n    },\n\n    /**\n     * Sets the Default image processing configuration used either in the this material.\n     *\n     * If sets to null, the scene one is in use.\n     */\n    set: function set(value) {\n      this._attachImageProcessingConfiguration(value); // Ensure the effect will be rebuilt.\n\n\n      this._markAllSubMeshesAsTexturesDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterial.prototype, \"mode\", {\n    /**\n     * Gets or sets the mode property\n     */\n    get: function get() {\n      return this._mode;\n    },\n    set: function set(value) {\n      this._mode = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterial.prototype, \"buildId\", {\n    /** Gets or sets the unique identifier used to identified the effect associated with the material */\n    get: function get() {\n      return this._buildId;\n    },\n    set: function set(value) {\n      this._buildId = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets the current class name of the material e.g. \"NodeMaterial\"\n   * @returns the class name\n   */\n\n  NodeMaterial.prototype.getClassName = function () {\n    return \"NodeMaterial\";\n  };\n  /**\n   * Attaches a new image processing configuration to the Standard Material.\n   * @param configuration\n   */\n\n\n  NodeMaterial.prototype._attachImageProcessingConfiguration = function (configuration) {\n    var _this = this;\n\n    if (configuration === this._imageProcessingConfiguration) {\n      return;\n    } // Detaches observer.\n\n\n    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n    } // Pick the scene configuration if needed.\n\n\n    if (!configuration) {\n      this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\n    } else {\n      this._imageProcessingConfiguration = configuration;\n    } // Attaches observer.\n\n\n    if (this._imageProcessingConfiguration) {\n      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function () {\n        _this._markAllSubMeshesAsImageProcessingDirty();\n      });\n    }\n  };\n  /**\n   * Get a block by its name\n   * @param name defines the name of the block to retrieve\n   * @returns the required block or null if not found\n   */\n\n\n  NodeMaterial.prototype.getBlockByName = function (name) {\n    var result = null;\n\n    for (var _i = 0, _a = this.attachedBlocks; _i < _a.length; _i++) {\n      var block = _a[_i];\n\n      if (block.name === name) {\n        if (!result) {\n          result = block;\n        } else {\n          Tools.Warn(\"More than one block was found with the name `\" + name + \"`\");\n          return result;\n        }\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Get a block by its name\n   * @param predicate defines the predicate used to find the good candidate\n   * @returns the required block or null if not found\n   */\n\n\n  NodeMaterial.prototype.getBlockByPredicate = function (predicate) {\n    for (var _i = 0, _a = this.attachedBlocks; _i < _a.length; _i++) {\n      var block = _a[_i];\n\n      if (predicate(block)) {\n        return block;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Get an input block by its name\n   * @param predicate defines the predicate used to find the good candidate\n   * @returns the required input block or null if not found\n   */\n\n\n  NodeMaterial.prototype.getInputBlockByPredicate = function (predicate) {\n    for (var _i = 0, _a = this.attachedBlocks; _i < _a.length; _i++) {\n      var block = _a[_i];\n\n      if (block.isInput && predicate(block)) {\n        return block;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets the list of input blocks attached to this material\n   * @returns an array of InputBlocks\n   */\n\n\n  NodeMaterial.prototype.getInputBlocks = function () {\n    var blocks = [];\n\n    for (var _i = 0, _a = this.attachedBlocks; _i < _a.length; _i++) {\n      var block = _a[_i];\n\n      if (block.isInput) {\n        blocks.push(block);\n      }\n    }\n\n    return blocks;\n  };\n  /**\n   * Adds a new optimizer to the list of optimizers\n   * @param optimizer defines the optimizers to add\n   * @returns the current material\n   */\n\n\n  NodeMaterial.prototype.registerOptimizer = function (optimizer) {\n    var index = this._optimizers.indexOf(optimizer);\n\n    if (index > -1) {\n      return;\n    }\n\n    this._optimizers.push(optimizer);\n\n    return this;\n  };\n  /**\n   * Remove an optimizer from the list of optimizers\n   * @param optimizer defines the optimizers to remove\n   * @returns the current material\n   */\n\n\n  NodeMaterial.prototype.unregisterOptimizer = function (optimizer) {\n    var index = this._optimizers.indexOf(optimizer);\n\n    if (index === -1) {\n      return;\n    }\n\n    this._optimizers.splice(index, 1);\n\n    return this;\n  };\n  /**\n   * Add a new block to the list of output nodes\n   * @param node defines the node to add\n   * @returns the current material\n   */\n\n\n  NodeMaterial.prototype.addOutputNode = function (node) {\n    if (node.target === null) {\n      throw \"This node is not meant to be an output node. You may want to explicitly set its target value.\";\n    }\n\n    if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\n      this._addVertexOutputNode(node);\n    }\n\n    if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\n      this._addFragmentOutputNode(node);\n    }\n\n    return this;\n  };\n  /**\n   * Remove a block from the list of root nodes\n   * @param node defines the node to remove\n   * @returns the current material\n   */\n\n\n  NodeMaterial.prototype.removeOutputNode = function (node) {\n    if (node.target === null) {\n      return this;\n    }\n\n    if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\n      this._removeVertexOutputNode(node);\n    }\n\n    if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\n      this._removeFragmentOutputNode(node);\n    }\n\n    return this;\n  };\n\n  NodeMaterial.prototype._addVertexOutputNode = function (node) {\n    if (this._vertexOutputNodes.indexOf(node) !== -1) {\n      return;\n    }\n\n    node.target = NodeMaterialBlockTargets.Vertex;\n\n    this._vertexOutputNodes.push(node);\n\n    return this;\n  };\n\n  NodeMaterial.prototype._removeVertexOutputNode = function (node) {\n    var index = this._vertexOutputNodes.indexOf(node);\n\n    if (index === -1) {\n      return;\n    }\n\n    this._vertexOutputNodes.splice(index, 1);\n\n    return this;\n  };\n\n  NodeMaterial.prototype._addFragmentOutputNode = function (node) {\n    if (this._fragmentOutputNodes.indexOf(node) !== -1) {\n      return;\n    }\n\n    node.target = NodeMaterialBlockTargets.Fragment;\n\n    this._fragmentOutputNodes.push(node);\n\n    return this;\n  };\n\n  NodeMaterial.prototype._removeFragmentOutputNode = function (node) {\n    var index = this._fragmentOutputNodes.indexOf(node);\n\n    if (index === -1) {\n      return;\n    }\n\n    this._fragmentOutputNodes.splice(index, 1);\n\n    return this;\n  };\n  /**\n   * Specifies if the material will require alpha blending\n   * @returns a boolean specifying if alpha blending is needed\n   */\n\n\n  NodeMaterial.prototype.needAlphaBlending = function () {\n    if (this.ignoreAlpha) {\n      return false;\n    }\n\n    return this.forceAlphaBlending || this.alpha < 1.0 || this._sharedData && this._sharedData.hints.needAlphaBlending;\n  };\n  /**\n   * Specifies if this material should be rendered in alpha test mode\n   * @returns a boolean specifying if an alpha test is needed.\n   */\n\n\n  NodeMaterial.prototype.needAlphaTesting = function () {\n    return this._sharedData && this._sharedData.hints.needAlphaTesting;\n  };\n\n  NodeMaterial.prototype._initializeBlock = function (node, state, nodesToProcessForOtherBuildState, autoConfigure) {\n    if (autoConfigure === void 0) {\n      autoConfigure = true;\n    }\n\n    node.initialize(state);\n\n    if (autoConfigure) {\n      node.autoConfigure(this);\n    }\n\n    node._preparationId = this._buildId;\n\n    if (this.attachedBlocks.indexOf(node) === -1) {\n      if (node.isUnique) {\n        var className = node.getClassName();\n\n        for (var _i = 0, _a = this.attachedBlocks; _i < _a.length; _i++) {\n          var other = _a[_i];\n\n          if (other.getClassName() === className) {\n            throw \"Cannot have multiple blocks of type \".concat(className, \" in the same NodeMaterial\");\n          }\n        }\n      }\n\n      this.attachedBlocks.push(node);\n    }\n\n    for (var _b = 0, _c = node.inputs; _b < _c.length; _b++) {\n      var input = _c[_b];\n      input.associatedVariableName = \"\";\n      var connectedPoint = input.connectedPoint;\n\n      if (connectedPoint) {\n        var block = connectedPoint.ownerBlock;\n\n        if (block !== node) {\n          if (block.target === NodeMaterialBlockTargets.VertexAndFragment) {\n            nodesToProcessForOtherBuildState.push(block);\n          } else if (state.target === NodeMaterialBlockTargets.Fragment && block.target === NodeMaterialBlockTargets.Vertex && block._preparationId !== this._buildId) {\n            nodesToProcessForOtherBuildState.push(block);\n          }\n\n          this._initializeBlock(block, state, nodesToProcessForOtherBuildState, autoConfigure);\n        }\n      }\n    }\n\n    for (var _d = 0, _e = node.outputs; _d < _e.length; _d++) {\n      var output = _e[_d];\n      output.associatedVariableName = \"\";\n    }\n  };\n\n  NodeMaterial.prototype._resetDualBlocks = function (node, id) {\n    if (node.target === NodeMaterialBlockTargets.VertexAndFragment) {\n      node.buildId = id;\n    }\n\n    for (var _i = 0, _a = node.inputs; _i < _a.length; _i++) {\n      var inputs = _a[_i];\n      var connectedPoint = inputs.connectedPoint;\n\n      if (connectedPoint) {\n        var block = connectedPoint.ownerBlock;\n\n        if (block !== node) {\n          this._resetDualBlocks(block, id);\n        }\n      }\n    }\n  };\n  /**\n   * Remove a block from the current node material\n   * @param block defines the block to remove\n   */\n\n\n  NodeMaterial.prototype.removeBlock = function (block) {\n    var attachedBlockIndex = this.attachedBlocks.indexOf(block);\n\n    if (attachedBlockIndex > -1) {\n      this.attachedBlocks.splice(attachedBlockIndex, 1);\n    }\n\n    if (block.isFinalMerger) {\n      this.removeOutputNode(block);\n    }\n  };\n  /**\n   * Build the material and generates the inner effect\n   * @param verbose defines if the build should log activity\n   * @param updateBuildId defines if the internal build Id should be updated (default is true)\n   * @param autoConfigure defines if the autoConfigure method should be called when initializing blocks (default is true)\n   */\n\n\n  NodeMaterial.prototype.build = function (verbose, updateBuildId, autoConfigure) {\n    if (verbose === void 0) {\n      verbose = false;\n    }\n\n    if (updateBuildId === void 0) {\n      updateBuildId = true;\n    }\n\n    if (autoConfigure === void 0) {\n      autoConfigure = true;\n    }\n\n    this._buildWasSuccessful = false;\n    var engine = this.getScene().getEngine();\n    var allowEmptyVertexProgram = this._mode === NodeMaterialModes.Particle;\n\n    if (this._vertexOutputNodes.length === 0 && !allowEmptyVertexProgram) {\n      throw \"You must define at least one vertexOutputNode\";\n    }\n\n    if (this._fragmentOutputNodes.length === 0) {\n      throw \"You must define at least one fragmentOutputNode\";\n    } // Compilation state\n\n\n    this._vertexCompilationState = new NodeMaterialBuildState();\n    this._vertexCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\n    this._vertexCompilationState.target = NodeMaterialBlockTargets.Vertex;\n    this._fragmentCompilationState = new NodeMaterialBuildState();\n    this._fragmentCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\n    this._fragmentCompilationState.target = NodeMaterialBlockTargets.Fragment; // Shared data\n\n    this._sharedData = new NodeMaterialBuildStateSharedData();\n    this._sharedData.fragmentOutputNodes = this._fragmentOutputNodes;\n    this._vertexCompilationState.sharedData = this._sharedData;\n    this._fragmentCompilationState.sharedData = this._sharedData;\n    this._sharedData.buildId = this._buildId;\n    this._sharedData.emitComments = this._options.emitComments;\n    this._sharedData.verbose = verbose;\n    this._sharedData.scene = this.getScene();\n    this._sharedData.allowEmptyVertexProgram = allowEmptyVertexProgram; // Initialize blocks\n\n    var vertexNodes = [];\n    var fragmentNodes = [];\n\n    for (var _i = 0, _a = this._vertexOutputNodes; _i < _a.length; _i++) {\n      var vertexOutputNode = _a[_i];\n      vertexNodes.push(vertexOutputNode);\n\n      this._initializeBlock(vertexOutputNode, this._vertexCompilationState, fragmentNodes, autoConfigure);\n    }\n\n    for (var _b = 0, _c = this._fragmentOutputNodes; _b < _c.length; _b++) {\n      var fragmentOutputNode = _c[_b];\n      fragmentNodes.push(fragmentOutputNode);\n\n      this._initializeBlock(fragmentOutputNode, this._fragmentCompilationState, vertexNodes, autoConfigure);\n    } // Optimize\n\n\n    this.optimize(); // Vertex\n\n    for (var _d = 0, vertexNodes_1 = vertexNodes; _d < vertexNodes_1.length; _d++) {\n      var vertexOutputNode = vertexNodes_1[_d];\n      vertexOutputNode.build(this._vertexCompilationState, vertexNodes);\n    } // Fragment\n\n\n    this._fragmentCompilationState.uniforms = this._vertexCompilationState.uniforms.slice(0);\n    this._fragmentCompilationState._uniformDeclaration = this._vertexCompilationState._uniformDeclaration;\n    this._fragmentCompilationState._constantDeclaration = this._vertexCompilationState._constantDeclaration;\n    this._fragmentCompilationState._vertexState = this._vertexCompilationState;\n\n    for (var _e = 0, fragmentNodes_1 = fragmentNodes; _e < fragmentNodes_1.length; _e++) {\n      var fragmentOutputNode = fragmentNodes_1[_e];\n\n      this._resetDualBlocks(fragmentOutputNode, this._buildId - 1);\n    }\n\n    for (var _f = 0, fragmentNodes_2 = fragmentNodes; _f < fragmentNodes_2.length; _f++) {\n      var fragmentOutputNode = fragmentNodes_2[_f];\n      fragmentOutputNode.build(this._fragmentCompilationState, fragmentNodes);\n    } // Finalize\n\n\n    this._vertexCompilationState.finalize(this._vertexCompilationState);\n\n    this._fragmentCompilationState.finalize(this._fragmentCompilationState);\n\n    if (updateBuildId) {\n      this._buildId = NodeMaterial._BuildIdGenerator++;\n    } // Errors\n\n\n    this._sharedData.emitErrors();\n\n    if (verbose) {\n      console.log(\"Vertex shader:\");\n      console.log(this._vertexCompilationState.compilationString);\n      console.log(\"Fragment shader:\");\n      console.log(this._fragmentCompilationState.compilationString);\n    }\n\n    this._buildWasSuccessful = true;\n    this.onBuildObservable.notifyObservers(this); // Wipe defines\n\n    var meshes = this.getScene().meshes;\n\n    for (var _g = 0, meshes_1 = meshes; _g < meshes_1.length; _g++) {\n      var mesh = meshes_1[_g];\n\n      if (!mesh.subMeshes) {\n        continue;\n      }\n\n      for (var _h = 0, _j = mesh.subMeshes; _h < _j.length; _h++) {\n        var subMesh = _j[_h];\n\n        if (subMesh.getMaterial() !== this) {\n          continue;\n        }\n\n        if (!subMesh.materialDefines) {\n          continue;\n        }\n\n        var defines = subMesh.materialDefines;\n        defines.markAllAsDirty();\n        defines.reset();\n      }\n    }\n  };\n  /**\n   * Runs an otpimization phase to try to improve the shader code\n   */\n\n\n  NodeMaterial.prototype.optimize = function () {\n    for (var _i = 0, _a = this._optimizers; _i < _a.length; _i++) {\n      var optimizer = _a[_i];\n      optimizer.optimize(this._vertexOutputNodes, this._fragmentOutputNodes);\n    }\n  };\n\n  NodeMaterial.prototype._prepareDefinesForAttributes = function (mesh, defines) {\n    var oldNormal = defines[\"NORMAL\"];\n    var oldTangent = defines[\"TANGENT\"];\n    defines[\"NORMAL\"] = mesh.isVerticesDataPresent(VertexBuffer.NormalKind);\n    defines[\"TANGENT\"] = mesh.isVerticesDataPresent(VertexBuffer.TangentKind);\n    var uvChanged = false;\n\n    for (var i = 1; i <= 6; ++i) {\n      var oldUV = defines[\"UV\" + i];\n      defines[\"UV\" + i] = mesh.isVerticesDataPresent(\"uv\".concat(i === 1 ? \"\" : i));\n      uvChanged = uvChanged || defines[\"UV\" + i] !== oldUV;\n    }\n\n    if (oldNormal !== defines[\"NORMAL\"] || oldTangent !== defines[\"TANGENT\"] || uvChanged) {\n      defines.markAsAttributesDirty();\n    }\n  };\n  /**\n   * Create a post process from the material\n   * @param camera The camera to apply the render pass to.\n   * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n   * @param engine The engine which the post process will be applied. (default: current engine)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   * @param textureType Type of textures used when performing the post process. (default: 0)\n   * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\n   * @returns the post process created\n   */\n\n\n  NodeMaterial.prototype.createPostProcess = function (camera, options, samplingMode, engine, reusable, textureType, textureFormat) {\n    if (options === void 0) {\n      options = 1;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 1;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    if (textureFormat === void 0) {\n      textureFormat = 5;\n    }\n\n    if (this.mode !== NodeMaterialModes.PostProcess) {\n      console.log(\"Incompatible material mode\");\n      return null;\n    }\n\n    return this._createEffectForPostProcess(null, camera, options, samplingMode, engine, reusable, textureType, textureFormat);\n  };\n  /**\n   * Create the post process effect from the material\n   * @param postProcess The post process to create the effect for\n   */\n\n\n  NodeMaterial.prototype.createEffectForPostProcess = function (postProcess) {\n    this._createEffectForPostProcess(postProcess);\n  };\n\n  NodeMaterial.prototype._createEffectForPostProcess = function (postProcess, camera, options, samplingMode, engine, reusable, textureType, textureFormat) {\n    var _this = this;\n\n    if (options === void 0) {\n      options = 1;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 1;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    if (textureFormat === void 0) {\n      textureFormat = 5;\n    }\n\n    var tempName = this.name + this._buildId;\n    var defines = new NodeMaterialDefines();\n    var dummyMesh = new AbstractMesh(tempName + \"PostProcess\", this.getScene());\n    var buildId = this._buildId;\n\n    this._processDefines(dummyMesh, defines);\n\n    Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\n\n    if (!postProcess) {\n      postProcess = new PostProcess(this.name + \"PostProcess\", tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, options, camera, samplingMode, engine, reusable, defines.toString(), textureType, tempName, {\n        maxSimultaneousLights: this.maxSimultaneousLights\n      }, false, textureFormat);\n    } else {\n      postProcess.updateEffect(defines.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, {\n        maxSimultaneousLights: this.maxSimultaneousLights\n      }, undefined, undefined, tempName, tempName);\n    }\n\n    postProcess.nodeMaterialSource = this;\n    postProcess.onApplyObservable.add(function (effect) {\n      if (buildId !== _this._buildId) {\n        delete Effect.ShadersStore[tempName + \"VertexShader\"];\n        delete Effect.ShadersStore[tempName + \"PixelShader\"];\n        tempName = _this.name + _this._buildId;\n        defines.markAllAsDirty();\n        buildId = _this._buildId;\n      }\n\n      var result = _this._processDefines(dummyMesh, defines);\n\n      if (result) {\n        Effect.RegisterShader(tempName, _this._fragmentCompilationState._builtCompilationString, _this._vertexCompilationState._builtCompilationString);\n        TimingTools.SetImmediate(function () {\n          return postProcess.updateEffect(defines.toString(), _this._fragmentCompilationState.uniforms, _this._fragmentCompilationState.samplers, {\n            maxSimultaneousLights: _this.maxSimultaneousLights\n          }, undefined, undefined, tempName, tempName);\n        });\n      }\n\n      _this._checkInternals(effect);\n    });\n    return postProcess;\n  };\n  /**\n   * Create a new procedural texture based on this node material\n   * @param size defines the size of the texture\n   * @param scene defines the hosting scene\n   * @returns the new procedural texture attached to this node material\n   */\n\n\n  NodeMaterial.prototype.createProceduralTexture = function (size, scene) {\n    var _this = this;\n\n    if (this.mode !== NodeMaterialModes.ProceduralTexture) {\n      console.log(\"Incompatible material mode\");\n      return null;\n    }\n\n    var tempName = this.name + this._buildId;\n    var proceduralTexture = new ProceduralTexture(tempName, size, null, scene);\n    var dummyMesh = new AbstractMesh(tempName + \"Procedural\", this.getScene());\n    dummyMesh.reservedDataStore = {\n      hidden: true\n    };\n    var defines = new NodeMaterialDefines();\n\n    var result = this._processDefines(dummyMesh, defines);\n\n    Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\n    var effect = this.getScene().getEngine().createEffect({\n      vertexElement: tempName,\n      fragmentElement: tempName\n    }, [VertexBuffer.PositionKind], this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString(), result === null || result === void 0 ? void 0 : result.fallbacks, undefined);\n    proceduralTexture.nodeMaterialSource = this;\n\n    proceduralTexture._setEffect(effect);\n\n    var buildId = this._buildId;\n    proceduralTexture.onBeforeGenerationObservable.add(function () {\n      if (buildId !== _this._buildId) {\n        delete Effect.ShadersStore[tempName + \"VertexShader\"];\n        delete Effect.ShadersStore[tempName + \"PixelShader\"];\n        tempName = _this.name + _this._buildId;\n        defines.markAllAsDirty();\n        buildId = _this._buildId;\n      }\n\n      var result = _this._processDefines(dummyMesh, defines);\n\n      if (result) {\n        Effect.RegisterShader(tempName, _this._fragmentCompilationState._builtCompilationString, _this._vertexCompilationState._builtCompilationString);\n        TimingTools.SetImmediate(function () {\n          effect = _this.getScene().getEngine().createEffect({\n            vertexElement: tempName,\n            fragmentElement: tempName\n          }, [VertexBuffer.PositionKind], _this._fragmentCompilationState.uniforms, _this._fragmentCompilationState.samplers, defines.toString(), result === null || result === void 0 ? void 0 : result.fallbacks, undefined);\n\n          proceduralTexture._setEffect(effect);\n        });\n      }\n\n      _this._checkInternals(effect);\n    });\n    return proceduralTexture;\n  };\n\n  NodeMaterial.prototype._createEffectForParticles = function (particleSystem, blendMode, onCompiled, onError, effect, defines, dummyMesh, particleSystemDefinesJoined) {\n    var _this = this;\n\n    if (particleSystemDefinesJoined === void 0) {\n      particleSystemDefinesJoined = \"\";\n    }\n\n    var tempName = this.name + this._buildId + \"_\" + blendMode;\n\n    if (!defines) {\n      defines = new NodeMaterialDefines();\n    }\n\n    if (!dummyMesh) {\n      dummyMesh = this.getScene().getMeshByName(this.name + \"Particle\");\n\n      if (!dummyMesh) {\n        dummyMesh = new AbstractMesh(this.name + \"Particle\", this.getScene());\n        dummyMesh.reservedDataStore = {\n          hidden: true\n        };\n      }\n    }\n\n    var buildId = this._buildId;\n    var particleSystemDefines = [];\n    var join = particleSystemDefinesJoined;\n\n    if (!effect) {\n      var result = this._processDefines(dummyMesh, defines);\n\n      Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);\n      particleSystem.fillDefines(particleSystemDefines, blendMode);\n      join = particleSystemDefines.join(\"\\n\");\n      effect = this.getScene().getEngine().createEffectForParticles(tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString() + \"\\n\" + join, result === null || result === void 0 ? void 0 : result.fallbacks, onCompiled, onError, particleSystem);\n      particleSystem.setCustomEffect(effect, blendMode);\n    }\n\n    effect.onBindObservable.add(function (effect) {\n      if (buildId !== _this._buildId) {\n        delete Effect.ShadersStore[tempName + \"PixelShader\"];\n        tempName = _this.name + _this._buildId + \"_\" + blendMode;\n        defines.markAllAsDirty();\n        buildId = _this._buildId;\n      }\n\n      particleSystemDefines.length = 0;\n      particleSystem.fillDefines(particleSystemDefines, blendMode);\n      var particleSystemDefinesJoinedCurrent = particleSystemDefines.join(\"\\n\");\n\n      if (particleSystemDefinesJoinedCurrent !== join) {\n        defines.markAllAsDirty();\n        join = particleSystemDefinesJoinedCurrent;\n      }\n\n      var result = _this._processDefines(dummyMesh, defines);\n\n      if (result) {\n        Effect.RegisterShader(tempName, _this._fragmentCompilationState._builtCompilationString);\n        effect = _this.getScene().getEngine().createEffectForParticles(tempName, _this._fragmentCompilationState.uniforms, _this._fragmentCompilationState.samplers, defines.toString() + \"\\n\" + join, result === null || result === void 0 ? void 0 : result.fallbacks, onCompiled, onError, particleSystem);\n        particleSystem.setCustomEffect(effect, blendMode);\n\n        _this._createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect, defines, dummyMesh, particleSystemDefinesJoined); // add the effect.onBindObservable observer\n\n\n        return;\n      }\n\n      _this._checkInternals(effect);\n    });\n  };\n\n  NodeMaterial.prototype._checkInternals = function (effect) {\n    // Animated blocks\n    if (this._sharedData.animatedInputs) {\n      var scene = this.getScene();\n      var frameId = scene.getFrameId();\n\n      if (this._animationFrame !== frameId) {\n        for (var _i = 0, _a = this._sharedData.animatedInputs; _i < _a.length; _i++) {\n          var input = _a[_i];\n          input.animate(scene);\n        }\n\n        this._animationFrame = frameId;\n      }\n    } // Bindable blocks\n\n\n    for (var _b = 0, _c = this._sharedData.bindableBlocks; _b < _c.length; _b++) {\n      var block = _c[_b];\n      block.bind(effect, this);\n    } // Connection points\n\n\n    for (var _d = 0, _e = this._sharedData.inputBlocks; _d < _e.length; _d++) {\n      var inputBlock = _e[_d];\n\n      inputBlock._transmit(effect, this.getScene(), this);\n    }\n  };\n  /**\n   * Create the effect to be used as the custom effect for a particle system\n   * @param particleSystem Particle system to create the effect for\n   * @param onCompiled defines a function to call when the effect creation is successful\n   * @param onError defines a function to call when the effect creation has failed\n   */\n\n\n  NodeMaterial.prototype.createEffectForParticles = function (particleSystem, onCompiled, onError) {\n    if (this.mode !== NodeMaterialModes.Particle) {\n      console.log(\"Incompatible material mode\");\n      return;\n    }\n\n    this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_ONEONE, onCompiled, onError);\n\n    this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_MULTIPLY, onCompiled, onError);\n  };\n\n  NodeMaterial.prototype._processDefines = function (mesh, defines, useInstances, subMesh) {\n    var _this = this;\n\n    if (useInstances === void 0) {\n      useInstances = false;\n    }\n\n    var result = null; // Shared defines\n\n    this._sharedData.blocksWithDefines.forEach(function (b) {\n      b.initializeDefines(mesh, _this, defines, useInstances);\n    });\n\n    this._sharedData.blocksWithDefines.forEach(function (b) {\n      b.prepareDefines(mesh, _this, defines, useInstances, subMesh);\n    }); // Need to recompile?\n\n\n    if (defines.isDirty) {\n      var lightDisposed = defines._areLightsDisposed;\n      defines.markAsProcessed(); // Repeatable content generators\n\n      this._vertexCompilationState.compilationString = this._vertexCompilationState._builtCompilationString;\n      this._fragmentCompilationState.compilationString = this._fragmentCompilationState._builtCompilationString;\n\n      this._sharedData.repeatableContentBlocks.forEach(function (b) {\n        b.replaceRepeatableContent(_this._vertexCompilationState, _this._fragmentCompilationState, mesh, defines);\n      }); // Uniforms\n\n\n      var uniformBuffers_1 = [];\n\n      this._sharedData.dynamicUniformBlocks.forEach(function (b) {\n        b.updateUniformsAndSamples(_this._vertexCompilationState, _this, defines, uniformBuffers_1);\n      });\n\n      var mergedUniforms_1 = this._vertexCompilationState.uniforms;\n\n      this._fragmentCompilationState.uniforms.forEach(function (u) {\n        var index = mergedUniforms_1.indexOf(u);\n\n        if (index === -1) {\n          mergedUniforms_1.push(u);\n        }\n      }); // Samplers\n\n\n      var mergedSamplers_1 = this._vertexCompilationState.samplers;\n\n      this._fragmentCompilationState.samplers.forEach(function (s) {\n        var index = mergedSamplers_1.indexOf(s);\n\n        if (index === -1) {\n          mergedSamplers_1.push(s);\n        }\n      });\n\n      var fallbacks_1 = new EffectFallbacks();\n\n      this._sharedData.blocksWithFallbacks.forEach(function (b) {\n        b.provideFallbacks(mesh, fallbacks_1);\n      });\n\n      result = {\n        lightDisposed: lightDisposed,\n        uniformBuffers: uniformBuffers_1,\n        mergedUniforms: mergedUniforms_1,\n        mergedSamplers: mergedSamplers_1,\n        fallbacks: fallbacks_1\n      };\n    }\n\n    return result;\n  };\n  /**\n   * Get if the submesh is ready to be used and all its information available.\n   * Child classes can use it to update shaders\n   * @param mesh defines the mesh to check\n   * @param subMesh defines which submesh to check\n   * @param useInstances specifies that instances should be used\n   * @returns a boolean indicating that the submesh is ready or not\n   */\n\n\n  NodeMaterial.prototype.isReadyForSubMesh = function (mesh, subMesh, useInstances) {\n    var _this = this;\n\n    if (useInstances === void 0) {\n      useInstances = false;\n    }\n\n    if (!this._buildWasSuccessful) {\n      return false;\n    }\n\n    var scene = this.getScene();\n\n    if (this._sharedData.animatedInputs) {\n      var frameId = scene.getFrameId();\n\n      if (this._animationFrame !== frameId) {\n        for (var _i = 0, _a = this._sharedData.animatedInputs; _i < _a.length; _i++) {\n          var input = _a[_i];\n          input.animate(scene);\n        }\n\n        this._animationFrame = frameId;\n      }\n    }\n\n    if (subMesh.effect && this.isFrozen) {\n      if (subMesh.effect._wasPreviouslyReady) {\n        return true;\n      }\n    }\n\n    if (!subMesh.materialDefines) {\n      subMesh.materialDefines = new NodeMaterialDefines();\n    }\n\n    var defines = subMesh.materialDefines;\n\n    if (this._isReadyForSubMesh(subMesh)) {\n      return true;\n    }\n\n    var engine = scene.getEngine();\n\n    this._prepareDefinesForAttributes(mesh, defines); // Check if blocks are ready\n\n\n    if (this._sharedData.blockingBlocks.some(function (b) {\n      return !b.isReady(mesh, _this, defines, useInstances);\n    })) {\n      return false;\n    }\n\n    var result = this._processDefines(mesh, defines, useInstances, subMesh);\n\n    if (result) {\n      var previousEffect = subMesh.effect; // Compilation\n\n      var join = defines.toString();\n      var effect = engine.createEffect({\n        vertex: \"nodeMaterial\" + this._buildId,\n        fragment: \"nodeMaterial\" + this._buildId,\n        vertexSource: this._vertexCompilationState.compilationString,\n        fragmentSource: this._fragmentCompilationState.compilationString\n      }, {\n        attributes: this._vertexCompilationState.attributes,\n        uniformsNames: result.mergedUniforms,\n        uniformBuffersNames: result.uniformBuffers,\n        samplers: result.mergedSamplers,\n        defines: join,\n        fallbacks: result.fallbacks,\n        onCompiled: this.onCompiled,\n        onError: this.onError,\n        indexParameters: {\n          maxSimultaneousLights: this.maxSimultaneousLights,\n          maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS\n        }\n      }, engine);\n\n      if (effect) {\n        if (this._onEffectCreatedObservable) {\n          onCreatedEffectParameters.effect = effect;\n          onCreatedEffectParameters.subMesh = subMesh;\n\n          this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\n        } // Use previous effect while new one is compiling\n\n\n        if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\n          effect = previousEffect;\n          defines.markAsUnprocessed();\n\n          if (result.lightDisposed) {\n            // re register in case it takes more than one frame.\n            defines._areLightsDisposed = true;\n            return false;\n          }\n        } else {\n          scene.resetCachedMaterial();\n          subMesh.setEffect(effect, defines, this._materialContext);\n        }\n      }\n    }\n\n    if (!subMesh.effect || !subMesh.effect.isReady()) {\n      return false;\n    }\n\n    defines._renderId = scene.getRenderId();\n    subMesh.effect._wasPreviouslyReady = true;\n    return true;\n  };\n\n  Object.defineProperty(NodeMaterial.prototype, \"compiledShaders\", {\n    /**\n     * Get a string representing the shaders built by the current node graph\n     */\n    get: function get() {\n      return \"// Vertex shader\\r\\n\".concat(this._vertexCompilationState.compilationString, \"\\r\\n\\r\\n// Fragment shader\\r\\n\").concat(this._fragmentCompilationState.compilationString);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Binds the world matrix to the material\n   * @param world defines the world transformation matrix\n   */\n\n  NodeMaterial.prototype.bindOnlyWorldMatrix = function (world) {\n    var scene = this.getScene();\n\n    if (!this._activeEffect) {\n      return;\n    }\n\n    var hints = this._sharedData.hints;\n\n    if (hints.needWorldViewMatrix) {\n      world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\n    }\n\n    if (hints.needWorldViewProjectionMatrix) {\n      world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\n    } // Connection points\n\n\n    for (var _i = 0, _a = this._sharedData.inputBlocks; _i < _a.length; _i++) {\n      var inputBlock = _a[_i];\n\n      inputBlock._transmitWorld(this._activeEffect, world, this._cachedWorldViewMatrix, this._cachedWorldViewProjectionMatrix);\n    }\n  };\n  /**\n   * Binds the submesh to this material by preparing the effect and shader to draw\n   * @param world defines the world transformation matrix\n   * @param mesh defines the mesh containing the submesh\n   * @param subMesh defines the submesh to bind the material to\n   */\n\n\n  NodeMaterial.prototype.bindForSubMesh = function (world, mesh, subMesh) {\n    var scene = this.getScene();\n    var effect = subMesh.effect;\n\n    if (!effect) {\n      return;\n    }\n\n    this._activeEffect = effect; // Matrices\n\n    this.bindOnlyWorldMatrix(world);\n\n    var mustRebind = this._mustRebind(scene, effect, mesh.visibility);\n\n    var sharedData = this._sharedData;\n\n    if (mustRebind) {\n      // Bindable blocks\n      for (var _i = 0, _a = sharedData.bindableBlocks; _i < _a.length; _i++) {\n        var block = _a[_i];\n        block.bind(effect, this, mesh, subMesh);\n      }\n\n      for (var _b = 0, _c = sharedData.forcedBindableBlocks; _b < _c.length; _b++) {\n        var block = _c[_b];\n        block.bind(effect, this, mesh, subMesh);\n      } // Connection points\n\n\n      for (var _d = 0, _e = sharedData.inputBlocks; _d < _e.length; _d++) {\n        var inputBlock = _e[_d];\n\n        inputBlock._transmit(effect, scene, this);\n      }\n    } else if (!this.isFrozen) {\n      for (var _f = 0, _g = sharedData.forcedBindableBlocks; _f < _g.length; _f++) {\n        var block = _g[_f];\n        block.bind(effect, this, mesh, subMesh);\n      }\n    }\n\n    this._afterBind(mesh, this._activeEffect);\n  };\n  /**\n   * Gets the active textures from the material\n   * @returns an array of textures\n   */\n\n\n  NodeMaterial.prototype.getActiveTextures = function () {\n    var activeTextures = _super.prototype.getActiveTextures.call(this);\n\n    if (this._sharedData) {\n      activeTextures.push.apply(activeTextures, this._sharedData.textureBlocks.filter(function (tb) {\n        return tb.texture;\n      }).map(function (tb) {\n        return tb.texture;\n      }));\n    }\n\n    return activeTextures;\n  };\n  /**\n   * Gets the list of texture blocks\n   * @returns an array of texture blocks\n   */\n\n\n  NodeMaterial.prototype.getTextureBlocks = function () {\n    if (!this._sharedData) {\n      return [];\n    }\n\n    return this._sharedData.textureBlocks;\n  };\n  /**\n   * Specifies if the material uses a texture\n   * @param texture defines the texture to check against the material\n   * @returns a boolean specifying if the material uses the texture\n   */\n\n\n  NodeMaterial.prototype.hasTexture = function (texture) {\n    if (_super.prototype.hasTexture.call(this, texture)) {\n      return true;\n    }\n\n    if (!this._sharedData) {\n      return false;\n    }\n\n    for (var _i = 0, _a = this._sharedData.textureBlocks; _i < _a.length; _i++) {\n      var t = _a[_i];\n\n      if (t.texture === texture) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Disposes the material\n   * @param forceDisposeEffect specifies if effects should be forcefully disposed\n   * @param forceDisposeTextures specifies if textures should be forcefully disposed\n   * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\n   */\n\n\n  NodeMaterial.prototype.dispose = function (forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {\n    if (forceDisposeTextures) {\n      for (var _i = 0, _a = this.getTextureBlocks().filter(function (tb) {\n        return tb.texture;\n      }).map(function (tb) {\n        return tb.texture;\n      }); _i < _a.length; _i++) {\n        var texture = _a[_i];\n        texture.dispose();\n      }\n    }\n\n    for (var _b = 0, _c = this.attachedBlocks; _b < _c.length; _b++) {\n      var block = _c[_b];\n      block.dispose();\n    }\n\n    this.attachedBlocks = [];\n    this._sharedData = null;\n    this._vertexCompilationState = null;\n    this._fragmentCompilationState = null;\n    this.onBuildObservable.clear();\n\n    if (this._imageProcessingObserver) {\n      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n\n      this._imageProcessingObserver = null;\n    }\n\n    _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\n  };\n  /** Creates the node editor window. */\n\n\n  NodeMaterial.prototype._createNodeEditor = function () {\n    this.BJSNODEMATERIALEDITOR.NodeEditor.Show({\n      nodeMaterial: this\n    });\n  };\n  /**\n   * Launch the node material editor\n   * @param config Define the configuration of the editor\n   * @return a promise fulfilled when the node editor is visible\n   */\n\n\n  NodeMaterial.prototype.edit = function (config) {\n    var _this = this;\n\n    return new Promise(function (resolve) {\n      _this.BJSNODEMATERIALEDITOR = _this.BJSNODEMATERIALEDITOR || _this._getGlobalNodeMaterialEditor();\n\n      if (typeof _this.BJSNODEMATERIALEDITOR == \"undefined\") {\n        var editorUrl = config && config.editorURL ? config.editorURL : NodeMaterial.EditorURL; // Load editor and add it to the DOM\n\n        Tools.LoadScript(editorUrl, function () {\n          _this.BJSNODEMATERIALEDITOR = _this.BJSNODEMATERIALEDITOR || _this._getGlobalNodeMaterialEditor();\n\n          _this._createNodeEditor();\n\n          resolve();\n        });\n      } else {\n        // Otherwise creates the editor\n        _this._createNodeEditor();\n\n        resolve();\n      }\n    });\n  };\n  /**\n   * Clear the current material\n   */\n\n\n  NodeMaterial.prototype.clear = function () {\n    this._vertexOutputNodes = [];\n    this._fragmentOutputNodes = [];\n    this.attachedBlocks = [];\n  };\n  /**\n   * Clear the current material and set it to a default state\n   */\n\n\n  NodeMaterial.prototype.setToDefault = function () {\n    this.clear();\n    this.editorData = null;\n    var positionInput = new InputBlock(\"Position\");\n    positionInput.setAsAttribute(\"position\");\n    var worldInput = new InputBlock(\"World\");\n    worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\n    var worldPos = new TransformBlock(\"WorldPos\");\n    positionInput.connectTo(worldPos);\n    worldInput.connectTo(worldPos);\n    var viewProjectionInput = new InputBlock(\"ViewProjection\");\n    viewProjectionInput.setAsSystemValue(NodeMaterialSystemValues.ViewProjection);\n    var worldPosdMultipliedByViewProjection = new TransformBlock(\"WorldPos * ViewProjectionTransform\");\n    worldPos.connectTo(worldPosdMultipliedByViewProjection);\n    viewProjectionInput.connectTo(worldPosdMultipliedByViewProjection);\n    var vertexOutput = new VertexOutputBlock(\"VertexOutput\");\n    worldPosdMultipliedByViewProjection.connectTo(vertexOutput); // Pixel\n\n    var pixelColor = new InputBlock(\"color\");\n    pixelColor.value = new Color4(0.8, 0.8, 0.8, 1);\n    var fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    pixelColor.connectTo(fragmentOutput); // Add to nodes\n\n    this.addOutputNode(vertexOutput);\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.Material;\n  };\n  /**\n   * Clear the current material and set it to a default state for post process\n   */\n\n\n  NodeMaterial.prototype.setToDefaultPostProcess = function () {\n    this.clear();\n    this.editorData = null;\n    var position = new InputBlock(\"Position\");\n    position.setAsAttribute(\"position2d\");\n    var const1 = new InputBlock(\"Constant1\");\n    const1.isConstant = true;\n    const1.value = 1;\n    var vmerger = new VectorMergerBlock(\"Position3D\");\n    position.connectTo(vmerger);\n    const1.connectTo(vmerger, {\n      input: \"w\"\n    });\n    var vertexOutput = new VertexOutputBlock(\"VertexOutput\");\n    vmerger.connectTo(vertexOutput); // Pixel\n\n    var scale = new InputBlock(\"Scale\");\n    scale.visibleInInspector = true;\n    scale.value = new Vector2(1, 1);\n    var uv0 = new RemapBlock(\"uv0\");\n    position.connectTo(uv0);\n    var uv = new MultiplyBlock(\"UV scale\");\n    uv0.connectTo(uv);\n    scale.connectTo(uv);\n    var currentScreen = new CurrentScreenBlock(\"CurrentScreen\");\n    uv.connectTo(currentScreen);\n    currentScreen.texture = new Texture(\"https://assets.babylonjs.com/nme/currentScreenPostProcess.png\", this.getScene());\n    var fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    currentScreen.connectTo(fragmentOutput, {\n      output: \"rgba\"\n    }); // Add to nodes\n\n    this.addOutputNode(vertexOutput);\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.PostProcess;\n  };\n  /**\n   * Clear the current material and set it to a default state for procedural texture\n   */\n\n\n  NodeMaterial.prototype.setToDefaultProceduralTexture = function () {\n    this.clear();\n    this.editorData = null;\n    var position = new InputBlock(\"Position\");\n    position.setAsAttribute(\"position2d\");\n    var const1 = new InputBlock(\"Constant1\");\n    const1.isConstant = true;\n    const1.value = 1;\n    var vmerger = new VectorMergerBlock(\"Position3D\");\n    position.connectTo(vmerger);\n    const1.connectTo(vmerger, {\n      input: \"w\"\n    });\n    var vertexOutput = new VertexOutputBlock(\"VertexOutput\");\n    vmerger.connectTo(vertexOutput); // Pixel\n\n    var time = new InputBlock(\"Time\");\n    time.value = 0;\n    time.min = 0;\n    time.max = 0;\n    time.isBoolean = false;\n    time.matrixMode = 0;\n    time.animationType = AnimatedInputBlockTypes.Time;\n    time.isConstant = false;\n    var color = new InputBlock(\"Color3\");\n    color.value = new Color3(1, 1, 1);\n    color.isConstant = false;\n    var fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    var vectorMerger = new VectorMergerBlock(\"VectorMerger\");\n    vectorMerger.visibleInInspector = false;\n    var cos = new TrigonometryBlock(\"Cos\");\n    cos.operation = TrigonometryBlockOperations.Cos;\n    position.connectTo(vectorMerger);\n    time.output.connectTo(cos.input);\n    cos.output.connectTo(vectorMerger.z);\n    vectorMerger.xyzOut.connectTo(fragmentOutput.rgb); // Add to nodes\n\n    this.addOutputNode(vertexOutput);\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.ProceduralTexture;\n  };\n  /**\n   * Clear the current material and set it to a default state for particle\n   */\n\n\n  NodeMaterial.prototype.setToDefaultParticle = function () {\n    this.clear();\n    this.editorData = null; // Pixel\n\n    var uv = new InputBlock(\"uv\");\n    uv.setAsAttribute(\"particle_uv\");\n    var texture = new ParticleTextureBlock(\"ParticleTexture\");\n    uv.connectTo(texture);\n    var color = new InputBlock(\"Color\");\n    color.setAsAttribute(\"particle_color\");\n    var multiply = new MultiplyBlock(\"Texture * Color\");\n    texture.connectTo(multiply);\n    color.connectTo(multiply);\n    var rampGradient = new ParticleRampGradientBlock(\"ParticleRampGradient\");\n    multiply.connectTo(rampGradient);\n    var cSplitter = new ColorSplitterBlock(\"ColorSplitter\");\n    color.connectTo(cSplitter);\n    var blendMultiply = new ParticleBlendMultiplyBlock(\"ParticleBlendMultiply\");\n    rampGradient.connectTo(blendMultiply);\n    texture.connectTo(blendMultiply, {\n      output: \"a\"\n    });\n    cSplitter.connectTo(blendMultiply, {\n      output: \"a\"\n    });\n    var fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    blendMultiply.connectTo(fragmentOutput); // Add to nodes\n\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.Particle;\n  };\n  /**\n   * Loads the current Node Material from a url pointing to a file save by the Node Material Editor\n   * @param url defines the url to load from\n   * @param rootUrl defines the root URL for nested url in the node material\n   * @returns a promise that will fulfil when the material is fully loaded\n   */\n\n\n  NodeMaterial.prototype.loadAsync = function (url, rootUrl) {\n    var _this = this;\n\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    return this.getScene()._loadFileAsync(url).then(function (data) {\n      var serializationObject = JSON.parse(data);\n\n      _this.loadFromSerialization(serializationObject, rootUrl);\n    });\n  };\n\n  NodeMaterial.prototype._gatherBlocks = function (rootNode, list) {\n    if (list.indexOf(rootNode) !== -1) {\n      return;\n    }\n\n    list.push(rootNode);\n\n    for (var _i = 0, _a = rootNode.inputs; _i < _a.length; _i++) {\n      var input = _a[_i];\n      var connectedPoint = input.connectedPoint;\n\n      if (connectedPoint) {\n        var block = connectedPoint.ownerBlock;\n\n        if (block !== rootNode) {\n          this._gatherBlocks(block, list);\n        }\n      }\n    }\n  };\n  /**\n   * Generate a string containing the code declaration required to create an equivalent of this material\n   * @returns a string\n   */\n\n\n  NodeMaterial.prototype.generateCode = function () {\n    var alreadyDumped = [];\n    var vertexBlocks = [];\n    var uniqueNames = [\"const\", \"var\", \"let\"]; // Gets active blocks\n\n    for (var _i = 0, _a = this._vertexOutputNodes; _i < _a.length; _i++) {\n      var outputNode = _a[_i];\n\n      this._gatherBlocks(outputNode, vertexBlocks);\n    }\n\n    var fragmentBlocks = [];\n\n    for (var _b = 0, _c = this._fragmentOutputNodes; _b < _c.length; _b++) {\n      var outputNode = _c[_b];\n\n      this._gatherBlocks(outputNode, fragmentBlocks);\n    } // Generate vertex shader\n\n\n    var codeString = \"var nodeMaterial = new BABYLON.NodeMaterial(\\\"\".concat(this.name || \"node material\", \"\\\");\\r\\n\");\n\n    for (var _d = 0, vertexBlocks_1 = vertexBlocks; _d < vertexBlocks_1.length; _d++) {\n      var node = vertexBlocks_1[_d];\n\n      if (node.isInput && alreadyDumped.indexOf(node) === -1) {\n        codeString += node._dumpCode(uniqueNames, alreadyDumped);\n      }\n    } // Generate fragment shader\n\n\n    for (var _e = 0, fragmentBlocks_1 = fragmentBlocks; _e < fragmentBlocks_1.length; _e++) {\n      var node = fragmentBlocks_1[_e];\n\n      if (node.isInput && alreadyDumped.indexOf(node) === -1) {\n        codeString += node._dumpCode(uniqueNames, alreadyDumped);\n      }\n    } // Connections\n\n\n    alreadyDumped = [];\n    codeString += \"\\r\\n// Connections\\r\\n\";\n\n    for (var _f = 0, _g = this._vertexOutputNodes; _f < _g.length; _f++) {\n      var node = _g[_f];\n      codeString += node._dumpCodeForOutputConnections(alreadyDumped);\n    }\n\n    for (var _h = 0, _j = this._fragmentOutputNodes; _h < _j.length; _h++) {\n      var node = _j[_h];\n      codeString += node._dumpCodeForOutputConnections(alreadyDumped);\n    } // Output nodes\n\n\n    codeString += \"\\r\\n// Output nodes\\r\\n\";\n\n    for (var _k = 0, _l = this._vertexOutputNodes; _k < _l.length; _k++) {\n      var node = _l[_k];\n      codeString += \"nodeMaterial.addOutputNode(\".concat(node._codeVariableName, \");\\r\\n\");\n    }\n\n    for (var _m = 0, _o = this._fragmentOutputNodes; _m < _o.length; _m++) {\n      var node = _o[_m];\n      codeString += \"nodeMaterial.addOutputNode(\".concat(node._codeVariableName, \");\\r\\n\");\n    }\n\n    codeString += \"nodeMaterial.build();\\r\\n\";\n    return codeString;\n  };\n  /**\n   * Serializes this material in a JSON representation\n   * @param selectedBlocks\n   * @returns the serialized material object\n   */\n\n\n  NodeMaterial.prototype.serialize = function (selectedBlocks) {\n    var serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);\n    serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData)); // Copy\n\n    var blocks = [];\n\n    if (selectedBlocks) {\n      blocks = selectedBlocks;\n    } else {\n      serializationObject.customType = \"BABYLON.NodeMaterial\";\n      serializationObject.outputNodes = []; // Outputs\n\n      for (var _i = 0, _a = this._vertexOutputNodes; _i < _a.length; _i++) {\n        var outputNode = _a[_i];\n\n        this._gatherBlocks(outputNode, blocks);\n\n        serializationObject.outputNodes.push(outputNode.uniqueId);\n      }\n\n      for (var _b = 0, _c = this._fragmentOutputNodes; _b < _c.length; _b++) {\n        var outputNode = _c[_b];\n\n        this._gatherBlocks(outputNode, blocks);\n\n        if (serializationObject.outputNodes.indexOf(outputNode.uniqueId) === -1) {\n          serializationObject.outputNodes.push(outputNode.uniqueId);\n        }\n      }\n    } // Blocks\n\n\n    serializationObject.blocks = [];\n\n    for (var _d = 0, blocks_1 = blocks; _d < blocks_1.length; _d++) {\n      var block = blocks_1[_d];\n      serializationObject.blocks.push(block.serialize());\n    }\n\n    if (!selectedBlocks) {\n      for (var _e = 0, _f = this.attachedBlocks; _e < _f.length; _e++) {\n        var block = _f[_e];\n\n        if (blocks.indexOf(block) !== -1) {\n          continue;\n        }\n\n        serializationObject.blocks.push(block.serialize());\n      }\n    }\n\n    return serializationObject;\n  };\n\n  NodeMaterial.prototype._restoreConnections = function (block, source, map) {\n    for (var _i = 0, _a = block.outputs; _i < _a.length; _i++) {\n      var outputPoint = _a[_i];\n\n      for (var _b = 0, _c = source.blocks; _b < _c.length; _b++) {\n        var candidate = _c[_b];\n        var target = map[candidate.id];\n\n        if (!target) {\n          continue;\n        }\n\n        for (var _d = 0, _e = candidate.inputs; _d < _e.length; _d++) {\n          var input = _e[_d];\n\n          if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {\n            var inputPoint = target.getInputByName(input.inputName);\n\n            if (!inputPoint || inputPoint.isConnected) {\n              continue;\n            }\n\n            outputPoint.connectTo(inputPoint, true);\n\n            this._restoreConnections(target, source, map);\n\n            continue;\n          }\n        }\n      }\n    }\n  };\n  /**\n   * Clear the current graph and load a new one from a serialization object\n   * @param source defines the JSON representation of the material\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @param merge defines whether or not the source must be merged or replace the current content\n   */\n\n\n  NodeMaterial.prototype.loadFromSerialization = function (source, rootUrl, merge) {\n    var _a;\n\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    if (merge === void 0) {\n      merge = false;\n    }\n\n    if (!merge) {\n      this.clear();\n    }\n\n    var map = {}; // Create blocks\n\n    for (var _i = 0, _b = source.blocks; _i < _b.length; _i++) {\n      var parsedBlock = _b[_i];\n      var blockType = GetClass(parsedBlock.customType);\n\n      if (blockType) {\n        var block = new blockType();\n\n        block._deserialize(parsedBlock, this.getScene(), rootUrl);\n\n        map[parsedBlock.id] = block;\n        this.attachedBlocks.push(block);\n      }\n    } // Connections - Starts with input blocks only (except if in \"merge\" mode where we scan all blocks)\n\n\n    for (var blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {\n      var parsedBlock = source.blocks[blockIndex];\n      var block = map[parsedBlock.id];\n\n      if (!block) {\n        continue;\n      }\n\n      if (block.inputs.length && !merge) {\n        continue;\n      }\n\n      this._restoreConnections(block, source, map);\n    } // Outputs\n\n\n    if (source.outputNodes) {\n      for (var _c = 0, _d = source.outputNodes; _c < _d.length; _c++) {\n        var outputNodeId = _d[_c];\n        this.addOutputNode(map[outputNodeId]);\n      }\n    } // UI related info\n\n\n    if (source.locations || source.editorData && source.editorData.locations) {\n      var locations = source.locations || source.editorData.locations;\n\n      for (var _e = 0, locations_1 = locations; _e < locations_1.length; _e++) {\n        var location_1 = locations_1[_e];\n\n        if (map[location_1.blockId]) {\n          location_1.blockId = map[location_1.blockId].uniqueId;\n        }\n      }\n\n      if (merge && this.editorData && this.editorData.locations) {\n        locations.concat(this.editorData.locations);\n      }\n\n      if (source.locations) {\n        this.editorData = {\n          locations: locations\n        };\n      } else {\n        this.editorData = source.editorData;\n        this.editorData.locations = locations;\n      }\n\n      var blockMap = [];\n\n      for (var key in map) {\n        blockMap[key] = map[key].uniqueId;\n      }\n\n      this.editorData.map = blockMap;\n    }\n\n    this.comment = source.comment;\n\n    if (source.forceAlphaBlending !== undefined) {\n      this.forceAlphaBlending = source.forceAlphaBlending;\n    }\n\n    if (!merge) {\n      this._mode = (_a = source.mode) !== null && _a !== void 0 ? _a : NodeMaterialModes.Material;\n    }\n  };\n  /**\n   * Makes a duplicate of the current material.\n   * @param name defines the name to use for the new material\n   * @param shareEffect defines if the clone material should share the same effect (default is false)\n   */\n\n\n  NodeMaterial.prototype.clone = function (name, shareEffect) {\n    var _this = this;\n\n    if (shareEffect === void 0) {\n      shareEffect = false;\n    }\n\n    var serializationObject = this.serialize();\n    var clone = SerializationHelper.Clone(function () {\n      return new NodeMaterial(name, _this.getScene(), _this.options);\n    }, this);\n    clone.id = name;\n    clone.name = name;\n    clone.loadFromSerialization(serializationObject);\n    clone._buildId = this._buildId;\n    clone.build(false, !shareEffect);\n    return clone;\n  };\n  /**\n   * Creates a node material from parsed material data\n   * @param source defines the JSON representation of the material\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a new node material\n   */\n\n\n  NodeMaterial.Parse = function (source, scene, rootUrl) {\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    var nodeMaterial = SerializationHelper.Parse(function () {\n      return new NodeMaterial(source.name, scene);\n    }, source, scene, rootUrl);\n    nodeMaterial.loadFromSerialization(source, rootUrl);\n    nodeMaterial.build();\n    return nodeMaterial;\n  };\n  /**\n   * Creates a node material from a snippet saved in a remote file\n   * @param name defines the name of the material to create\n   * @param url defines the url to load from\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL for nested url in the node material\n   * @returns a promise that will resolve to the new node material\n   */\n\n\n  NodeMaterial.ParseFromFileAsync = function (name, url, scene, rootUrl) {\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    var material = new NodeMaterial(name, scene);\n    return new Promise(function (resolve, reject) {\n      return material.loadAsync(url, rootUrl).then(function () {\n        material.build();\n        resolve(material);\n      })[\"catch\"](reject);\n    });\n  };\n  /**\n   * Creates a node material from a snippet saved by the node material editor\n   * @param snippetId defines the snippet to load\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @param nodeMaterial defines a node material to update (instead of creating a new one)\n   * @returns a promise that will resolve to the new node material\n   */\n\n\n  NodeMaterial.ParseFromSnippetAsync = function (snippetId, scene, rootUrl, nodeMaterial) {\n    var _this = this;\n\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    if (snippetId === \"_BLANK\") {\n      return Promise.resolve(this.CreateDefault(\"blank\", scene));\n    }\n\n    return new Promise(function (resolve, reject) {\n      var request = new WebRequest();\n      request.addEventListener(\"readystatechange\", function () {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            var serializationObject = JSON.parse(snippet.nodeMaterial);\n\n            if (!nodeMaterial) {\n              nodeMaterial = SerializationHelper.Parse(function () {\n                return new NodeMaterial(snippetId, scene);\n              }, serializationObject, scene, rootUrl);\n              nodeMaterial.uniqueId = scene.getUniqueId();\n            }\n\n            nodeMaterial.loadFromSerialization(serializationObject);\n            nodeMaterial.snippetId = snippetId;\n\n            try {\n              nodeMaterial.build();\n              resolve(nodeMaterial);\n            } catch (err) {\n              reject(err);\n            }\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", _this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  };\n  /**\n   * Creates a new node material set to default basic configuration\n   * @param name defines the name of the material\n   * @param scene defines the hosting scene\n   * @returns a new NodeMaterial\n   */\n\n\n  NodeMaterial.CreateDefault = function (name, scene) {\n    var newMaterial = new NodeMaterial(name, scene);\n    newMaterial.setToDefault();\n    newMaterial.build();\n    return newMaterial;\n  };\n\n  NodeMaterial._BuildIdGenerator = 0;\n  /** Define the Url to load node editor script */\n\n  NodeMaterial.EditorURL = \"https://unpkg.com/babylonjs-node-editor@\".concat(Engine.Version, \"/babylon.nodeEditor.js\");\n  /** Define the Url to load snippets */\n\n  NodeMaterial.SnippetUrl = \"https://snippet.babylonjs.com\";\n  /** Gets or sets a boolean indicating that node materials should not deserialize textures from json / snippet content */\n\n  NodeMaterial.IgnoreTexturesAtLoadTime = false;\n\n  __decorate([serialize()], NodeMaterial.prototype, \"ignoreAlpha\", void 0);\n\n  __decorate([serialize()], NodeMaterial.prototype, \"maxSimultaneousLights\", void 0);\n\n  __decorate([serialize(\"mode\")], NodeMaterial.prototype, \"_mode\", void 0);\n\n  __decorate([serialize(\"comment\")], NodeMaterial.prototype, \"comment\", void 0);\n\n  __decorate([serialize()], NodeMaterial.prototype, \"forceAlphaBlending\", void 0);\n\n  return NodeMaterial;\n}(PushMaterial);\n\nexport { NodeMaterial };\nRegisterClass(\"BABYLON.NodeMaterial\", NodeMaterial);","map":{"version":3,"mappings":"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","names":["PushMaterial","AbstractMesh","Matrix","Vector2","Color3","Color4","Engine","NodeMaterialBuildState","Effect","Observable","NodeMaterialBlockTargets","NodeMaterialBuildStateSharedData","MaterialDefines","VertexBuffer","Tools","TransformBlock","VertexOutputBlock","FragmentOutputBlock","InputBlock","GetClass","RegisterClass","serialize","SerializationHelper","CurrentScreenBlock","ParticleTextureBlock","ParticleRampGradientBlock","ParticleBlendMultiplyBlock","EffectFallbacks","WebRequest","PostProcess","VectorMergerBlock","RemapBlock","MultiplyBlock","NodeMaterialModes","Texture","BaseParticleSystem","ColorSplitterBlock","TimingTools","ProceduralTexture","AnimatedInputBlockTypes","TrigonometryBlock","TrigonometryBlockOperations","NodeMaterialSystemValues","EngineStore","onCreatedEffectParameters","effect","subMesh","__extends","_super","_this","rebuild","NodeMaterialDefines","name","value","markAsUnprocessedIfDirty","undefined","_keys","push","markAsUnprocessed","scene","options","LastCreatedScene","NodeMaterial","_BuildIdGenerator","Array","_getGlobalNodeMaterialEditor","Material","_options","__assign","emitComments","_attachImageProcessingConfiguration","NODEEDITOR","BABYLON","NodeEditor","Object","_imageProcessingConfiguration","_markAllSubMeshesAsTexturesDirty","_mode","_buildId","configuration","_imageProcessingObserver","onUpdateParameters","remove","getScene","imageProcessingConfiguration","add","_markAllSubMeshesAsImageProcessingDirty","result","attachedBlocks","_i","block","Warn","predicate","isInput","blocks","optimizer","index","_optimizers","indexOf","splice","node","target","Vertex","_addVertexOutputNode","Fragment","_addFragmentOutputNode","_removeVertexOutputNode","_removeFragmentOutputNode","_vertexOutputNodes","_fragmentOutputNodes","ignoreAlpha","forceAlphaBlending","alpha","_sharedData","hints","needAlphaBlending","needAlphaTesting","state","nodesToProcessForOtherBuildState","autoConfigure","initialize","_preparationId","isUnique","className","getClassName","other","inputs","_b","input","associatedVariableName","connectedPoint","ownerBlock","VertexAndFragment","_initializeBlock","outputs","_d","output","id","buildId","_resetDualBlocks","attachedBlockIndex","isFinalMerger","removeOutputNode","verbose","updateBuildId","_buildWasSuccessful","engine","getEngine","allowEmptyVertexProgram","Particle","length","_vertexCompilationState","supportUniformBuffers","supportsUniformBuffers","_fragmentCompilationState","fragmentOutputNodes","sharedData","vertexNodes","fragmentNodes","vertexOutputNode","fragmentOutputNode","optimize","build","uniforms","slice","_uniformDeclaration","_constantDeclaration","_vertexState","_e","_f","finalize","emitErrors","console","log","compilationString","onBuildObservable","notifyObservers","meshes","_g","mesh","subMeshes","_h","getMaterial","materialDefines","defines","markAllAsDirty","reset","oldNormal","oldTangent","isVerticesDataPresent","NormalKind","TangentKind","uvChanged","i","oldUV","markAsAttributesDirty","camera","samplingMode","reusable","textureType","textureFormat","mode","_createEffectForPostProcess","postProcess","tempName","dummyMesh","_processDefines","RegisterShader","_builtCompilationString","samplers","toString","maxSimultaneousLights","updateEffect","nodeMaterialSource","onApplyObservable","ShadersStore","SetImmediate","_checkInternals","size","proceduralTexture","reservedDataStore","hidden","createEffect","vertexElement","fragmentElement","PositionKind","fallbacks","_setEffect","onBeforeGenerationObservable","particleSystem","blendMode","onCompiled","onError","particleSystemDefinesJoined","getMeshByName","particleSystemDefines","join","fillDefines","createEffectForParticles","setCustomEffect","onBindObservable","particleSystemDefinesJoinedCurrent","_createEffectForParticles","animatedInputs","frameId","getFrameId","_animationFrame","animate","bindableBlocks","bind","inputBlocks","inputBlock","_transmit","BLENDMODE_ONEONE","BLENDMODE_MULTIPLY","useInstances","blocksWithDefines","forEach","b","initializeDefines","prepareDefines","isDirty","lightDisposed","_areLightsDisposed","markAsProcessed","repeatableContentBlocks","replaceRepeatableContent","uniformBuffers_1","dynamicUniformBlocks","updateUniformsAndSamples","mergedUniforms_1","u","mergedSamplers_1","s","fallbacks_1","blocksWithFallbacks","provideFallbacks","uniformBuffers","mergedUniforms","mergedSamplers","isFrozen","_wasPreviouslyReady","_isReadyForSubMesh","_prepareDefinesForAttributes","blockingBlocks","some","isReady","previousEffect","vertex","fragment","vertexSource","fragmentSource","attributes","uniformsNames","uniformBuffersNames","indexParameters","maxSimultaneousMorphTargets","NUM_MORPH_INFLUENCERS","_onEffectCreatedObservable","allowShaderHotSwapping","resetCachedMaterial","setEffect","_materialContext","_renderId","getRenderId","concat","world","_activeEffect","needWorldViewMatrix","multiplyToRef","getViewMatrix","_cachedWorldViewMatrix","needWorldViewProjectionMatrix","getTransformMatrix","_cachedWorldViewProjectionMatrix","_transmitWorld","bindOnlyWorldMatrix","mustRebind","_mustRebind","visibility","forcedBindableBlocks","_afterBind","activeTextures","getActiveTextures","call","apply","textureBlocks","filter","tb","texture","map","hasTexture","t","forceDisposeEffect","forceDisposeTextures","notBoundToMesh","getTextureBlocks","dispose","clear","BJSNODEMATERIALEDITOR","Show","nodeMaterial","config","Promise","resolve","editorUrl","editorURL","EditorURL","LoadScript","_createNodeEditor","editorData","positionInput","setAsAttribute","worldInput","setAsSystemValue","World","worldPos","connectTo","viewProjectionInput","ViewProjection","worldPosdMultipliedByViewProjection","vertexOutput","pixelColor","fragmentOutput","addOutputNode","position","const1","isConstant","vmerger","scale","visibleInInspector","uv0","uv","currentScreen","time","min","max","isBoolean","matrixMode","animationType","Time","color","vectorMerger","cos","operation","Cos","z","xyzOut","rgb","multiply","rampGradient","cSplitter","blendMultiply","url","rootUrl","_loadFileAsync","then","data","serializationObject","JSON","parse","loadFromSerialization","rootNode","list","_gatherBlocks","alreadyDumped","vertexBlocks","uniqueNames","outputNode","fragmentBlocks","codeString","_dumpCode","_dumpCodeForOutputConnections","_k","_codeVariableName","_m","selectedBlocks","Serialize","stringify","customType","outputNodes","uniqueId","source","outputPoint","candidate","targetBlockId","targetConnectionName","inputPoint","getInputByName","inputName","isConnected","_restoreConnections","merge","parsedBlock","blockType","_deserialize","blockIndex","_c","outputNodeId","locations","location_1","blockId","blockMap","key","comment","_a","shareEffect","clone","Clone","Parse","material","reject","loadAsync","snippetId","CreateDefault","request","addEventListener","readyState","status","snippet","responseText","jsonPayload","getUniqueId","err","open","SnippetUrl","replace","send","newMaterial","setToDefault","Version","__decorate"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Node/nodeMaterial.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { NodeMaterialBlock } from \"./nodeMaterialBlock\";\r\nimport { PushMaterial } from \"../pushMaterial\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Matrix, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../../Maths/math.color\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { Engine } from \"../../Engines/engine\";\r\nimport { NodeMaterialBuildState } from \"./nodeMaterialBuildState\";\r\nimport type { IEffectCreationOptions } from \"../effect\";\r\nimport { Effect } from \"../effect\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport { NodeMaterialBuildStateSharedData } from \"./nodeMaterialBuildStateSharedData\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { MaterialDefines } from \"../../Materials/materialDefines\";\r\nimport type { NodeMaterialOptimizer } from \"./Optimizers/nodeMaterialOptimizer\";\r\nimport type { ImageProcessingConfiguration, IImageProcessingConfigurationDefines } from \"../imageProcessingConfiguration\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { TransformBlock } from \"./Blocks/transformBlock\";\r\nimport { VertexOutputBlock } from \"./Blocks/Vertex/vertexOutputBlock\";\r\nimport { FragmentOutputBlock } from \"./Blocks/Fragment/fragmentOutputBlock\";\r\nimport { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore\";\r\nimport { serialize, SerializationHelper } from \"../../Misc/decorators\";\r\nimport type { TextureBlock } from \"./Blocks/Dual/textureBlock\";\r\nimport type { ReflectionTextureBaseBlock } from \"./Blocks/Dual/reflectionTextureBaseBlock\";\r\nimport type { RefractionBlock } from \"./Blocks/PBR/refractionBlock\";\r\nimport { CurrentScreenBlock } from \"./Blocks/Dual/currentScreenBlock\";\r\nimport { ParticleTextureBlock } from \"./Blocks/Particle/particleTextureBlock\";\r\nimport { ParticleRampGradientBlock } from \"./Blocks/Particle/particleRampGradientBlock\";\r\nimport { ParticleBlendMultiplyBlock } from \"./Blocks/Particle/particleBlendMultiplyBlock\";\r\nimport { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { WebRequest } from \"../../Misc/webRequest\";\r\n\r\nimport type { PostProcessOptions } from \"../../PostProcesses/postProcess\";\r\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport { VectorMergerBlock } from \"./Blocks/vectorMergerBlock\";\r\nimport { RemapBlock } from \"./Blocks/remapBlock\";\r\nimport { MultiplyBlock } from \"./Blocks/multiplyBlock\";\r\nimport { NodeMaterialModes } from \"./Enums/nodeMaterialModes\";\r\nimport { Texture } from \"../Textures/texture\";\r\nimport type { IParticleSystem } from \"../../Particles/IParticleSystem\";\r\nimport { BaseParticleSystem } from \"../../Particles/baseParticleSystem\";\r\nimport { ColorSplitterBlock } from \"./Blocks/colorSplitterBlock\";\r\nimport { TimingTools } from \"../../Misc/timingTools\";\r\nimport { ProceduralTexture } from \"../Textures/Procedurals/proceduralTexture\";\r\nimport { AnimatedInputBlockTypes } from \"./Blocks/Input/animatedInputBlockTypes\";\r\nimport { TrigonometryBlock, TrigonometryBlockOperations } from \"./Blocks/trigonometryBlock\";\r\nimport { NodeMaterialSystemValues } from \"./Enums/nodeMaterialSystemValues\";\r\nimport type { ImageSourceBlock } from \"./Blocks/Dual/imageSourceBlock\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\n// declare NODEEDITOR namespace for compilation issue\r\ndeclare let NODEEDITOR: any;\r\ndeclare let BABYLON: any;\r\n\r\n/**\r\n * Interface used to configure the node material editor\r\n */\r\nexport interface INodeMaterialEditorOptions {\r\n    /** Define the URl to load node editor script */\r\n    editorURL?: string;\r\n}\r\n\r\n/** @hidden */\r\nexport class NodeMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {\r\n    public NORMAL = false;\r\n    public TANGENT = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public UV3 = false;\r\n    public UV4 = false;\r\n    public UV5 = false;\r\n    public UV6 = false;\r\n\r\n    /** BONES */\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public BONETEXTURE = false;\r\n\r\n    /** MORPH TARGETS */\r\n    public MORPHTARGETS = false;\r\n    public MORPHTARGETS_NORMAL = false;\r\n    public MORPHTARGETS_TANGENT = false;\r\n    public MORPHTARGETS_UV = false;\r\n    public NUM_MORPH_INFLUENCERS = 0;\r\n    public MORPHTARGETS_TEXTURE = false;\r\n\r\n    /** IMAGE PROCESSING */\r\n    public IMAGEPROCESSING = false;\r\n    public VIGNETTE = false;\r\n    public VIGNETTEBLENDMODEMULTIPLY = false;\r\n    public VIGNETTEBLENDMODEOPAQUE = false;\r\n    public TONEMAPPING = false;\r\n    public TONEMAPPING_ACES = false;\r\n    public CONTRAST = false;\r\n    public EXPOSURE = false;\r\n    public COLORCURVES = false;\r\n    public COLORGRADING = false;\r\n    public COLORGRADING3D = false;\r\n    public SAMPLER3DGREENDEPTH = false;\r\n    public SAMPLER3DBGRMAP = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n\r\n    /** MISC. */\r\n    public BUMPDIRECTUV = 0;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n\r\n    public setValue(name: string, value: any, markAsUnprocessedIfDirty = false) {\r\n        if (this[name] === undefined) {\r\n            this._keys.push(name);\r\n        }\r\n\r\n        if (markAsUnprocessedIfDirty && this[name] !== value) {\r\n            this.markAsUnprocessed();\r\n        }\r\n\r\n        this[name] = value;\r\n    }\r\n}\r\n\r\n/**\r\n * Class used to configure NodeMaterial\r\n */\r\nexport interface INodeMaterialOptions {\r\n    /**\r\n     * Defines if blocks should emit comments\r\n     */\r\n    emitComments: boolean;\r\n}\r\n\r\n/**\r\n * Class used to create a node based material built by assembling shader blocks\r\n */\r\nexport class NodeMaterial extends PushMaterial {\r\n    private static _BuildIdGenerator: number = 0;\r\n    private _options: INodeMaterialOptions;\r\n    private _vertexCompilationState: NodeMaterialBuildState;\r\n    private _fragmentCompilationState: NodeMaterialBuildState;\r\n    private _sharedData: NodeMaterialBuildStateSharedData;\r\n    private _buildId: number = NodeMaterial._BuildIdGenerator++;\r\n    private _buildWasSuccessful = false;\r\n    private _cachedWorldViewMatrix = new Matrix();\r\n    private _cachedWorldViewProjectionMatrix = new Matrix();\r\n    private _optimizers = new Array<NodeMaterialOptimizer>();\r\n    private _animationFrame = -1;\r\n\r\n    /** Define the Url to load node editor script */\r\n    public static EditorURL = `https://unpkg.com/babylonjs-node-editor@${Engine.Version}/babylon.nodeEditor.js`;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = \"https://snippet.babylonjs.com\";\r\n\r\n    /** Gets or sets a boolean indicating that node materials should not deserialize textures from json / snippet content */\r\n    public static IgnoreTexturesAtLoadTime = false;\r\n\r\n    private BJSNODEMATERIALEDITOR = this._getGlobalNodeMaterialEditor();\r\n\r\n    /** Get the inspector from bundle or global */\r\n    private _getGlobalNodeMaterialEditor(): any {\r\n        // UMD Global name detection from Webpack Bundle UMD Name.\r\n        if (typeof NODEEDITOR !== \"undefined\") {\r\n            return NODEEDITOR;\r\n        }\r\n\r\n        // In case of module let's check the global emitted from the editor entry point.\r\n        if (typeof BABYLON !== \"undefined\" && typeof BABYLON.NodeEditor !== \"undefined\") {\r\n            return BABYLON;\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Snippet ID if the material was created from the snippet server\r\n     */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Gets or sets data used by visual editor\r\n     * @see https://nme.babylonjs.com\r\n     */\r\n    public editorData: any = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that alpha value must be ignored (This will turn alpha blending off even if an alpha value is produced by the material)\r\n     */\r\n    @serialize()\r\n    public ignoreAlpha = false;\r\n\r\n    /**\r\n     * Defines the maximum number of lights that can be used in the material\r\n     */\r\n    @serialize()\r\n    public maxSimultaneousLights = 4;\r\n\r\n    /**\r\n     * Observable raised when the material is built\r\n     */\r\n    public onBuildObservable = new Observable<NodeMaterial>();\r\n\r\n    /**\r\n     * Gets or sets the root nodes of the material vertex shader\r\n     */\r\n    public _vertexOutputNodes = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * Gets or sets the root nodes of the material fragment (pixel) shader\r\n     */\r\n    public _fragmentOutputNodes = new Array<NodeMaterialBlock>();\r\n\r\n    /** Gets or sets options to control the node material overall behavior */\r\n    public get options() {\r\n        return this._options;\r\n    }\r\n\r\n    public set options(options: INodeMaterialOptions) {\r\n        this._options = options;\r\n    }\r\n\r\n    /**\r\n     * Default configuration related to image processing available in the standard Material.\r\n     */\r\n    protected _imageProcessingConfiguration: ImageProcessingConfiguration;\r\n\r\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\r\n    public get imageProcessingConfiguration(): ImageProcessingConfiguration {\r\n        return this._imageProcessingConfiguration;\r\n    }\r\n\r\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\r\n    public set imageProcessingConfiguration(value: ImageProcessingConfiguration) {\r\n        this._attachImageProcessingConfiguration(value);\r\n\r\n        // Ensure the effect will be rebuilt.\r\n        this._markAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets an array of blocks that needs to be serialized even if they are not yet connected\r\n     */\r\n    public attachedBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * Specifies the mode of the node material\r\n     * @hidden\r\n     */\r\n    @serialize(\"mode\")\r\n    public _mode: NodeMaterialModes = NodeMaterialModes.Material;\r\n\r\n    /**\r\n     * Gets or sets the mode property\r\n     */\r\n    public get mode(): NodeMaterialModes {\r\n        return this._mode;\r\n    }\r\n\r\n    public set mode(value: NodeMaterialModes) {\r\n        this._mode = value;\r\n    }\r\n\r\n    /** Gets or sets the unique identifier used to identified the effect associated with the material */\r\n    public get buildId() {\r\n        return this._buildId;\r\n    }\r\n\r\n    public set buildId(value: number) {\r\n        this._buildId = value;\r\n    }\r\n\r\n    /**\r\n     * A free comment about the material\r\n     */\r\n    @serialize(\"comment\")\r\n    public comment: string;\r\n\r\n    /**\r\n     * Create a new node based material\r\n     * @param name defines the material name\r\n     * @param scene defines the hosting scene\r\n     * @param options defines creation option\r\n     */\r\n    constructor(name: string, scene?: Scene, options: Partial<INodeMaterialOptions> = {}) {\r\n        super(name, scene || EngineStore.LastCreatedScene!);\r\n\r\n        this._options = {\r\n            emitComments: false,\r\n            ...options,\r\n        };\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"NodeMaterial\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"NodeMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Keep track of the image processing observer to allow dispose and replace.\r\n     */\r\n    private _imageProcessingObserver: Nullable<Observer<ImageProcessingConfiguration>>;\r\n\r\n    /**\r\n     * Attaches a new image processing configuration to the Standard Material.\r\n     * @param configuration\r\n     */\r\n    protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void {\r\n        if (configuration === this._imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n\r\n        // Detaches observer.\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        // Pick the scene configuration if needed.\r\n        if (!configuration) {\r\n            this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\r\n        } else {\r\n            this._imageProcessingConfiguration = configuration;\r\n        }\r\n\r\n        // Attaches observer.\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n                this._markAllSubMeshesAsImageProcessingDirty();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get a block by its name\r\n     * @param name defines the name of the block to retrieve\r\n     * @returns the required block or null if not found\r\n     */\r\n    public getBlockByName(name: string) {\r\n        let result = null;\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.name === name) {\r\n                if (!result) {\r\n                    result = block;\r\n                } else {\r\n                    Tools.Warn(\"More than one block was found with the name `\" + name + \"`\");\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get a block by its name\r\n     * @param predicate defines the predicate used to find the good candidate\r\n     * @returns the required block or null if not found\r\n     */\r\n    public getBlockByPredicate(predicate: (block: NodeMaterialBlock) => boolean) {\r\n        for (const block of this.attachedBlocks) {\r\n            if (predicate(block)) {\r\n                return block;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get an input block by its name\r\n     * @param predicate defines the predicate used to find the good candidate\r\n     * @returns the required input block or null if not found\r\n     */\r\n    public getInputBlockByPredicate(predicate: (block: InputBlock) => boolean): Nullable<InputBlock> {\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.isInput && predicate(block as InputBlock)) {\r\n                return block as InputBlock;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of input blocks attached to this material\r\n     * @returns an array of InputBlocks\r\n     */\r\n    public getInputBlocks() {\r\n        const blocks: InputBlock[] = [];\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.isInput) {\r\n                blocks.push(block as InputBlock);\r\n            }\r\n        }\r\n\r\n        return blocks;\r\n    }\r\n\r\n    /**\r\n     * Adds a new optimizer to the list of optimizers\r\n     * @param optimizer defines the optimizers to add\r\n     * @returns the current material\r\n     */\r\n    public registerOptimizer(optimizer: NodeMaterialOptimizer) {\r\n        const index = this._optimizers.indexOf(optimizer);\r\n\r\n        if (index > -1) {\r\n            return;\r\n        }\r\n\r\n        this._optimizers.push(optimizer);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove an optimizer from the list of optimizers\r\n     * @param optimizer defines the optimizers to remove\r\n     * @returns the current material\r\n     */\r\n    public unregisterOptimizer(optimizer: NodeMaterialOptimizer) {\r\n        const index = this._optimizers.indexOf(optimizer);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._optimizers.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a new block to the list of output nodes\r\n     * @param node defines the node to add\r\n     * @returns the current material\r\n     */\r\n    public addOutputNode(node: NodeMaterialBlock) {\r\n        if (node.target === null) {\r\n            throw \"This node is not meant to be an output node. You may want to explicitly set its target value.\";\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\r\n            this._addVertexOutputNode(node);\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\r\n            this._addFragmentOutputNode(node);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a block from the list of root nodes\r\n     * @param node defines the node to remove\r\n     * @returns the current material\r\n     */\r\n    public removeOutputNode(node: NodeMaterialBlock) {\r\n        if (node.target === null) {\r\n            return this;\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\r\n            this._removeVertexOutputNode(node);\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\r\n            this._removeFragmentOutputNode(node);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private _addVertexOutputNode(node: NodeMaterialBlock) {\r\n        if (this._vertexOutputNodes.indexOf(node) !== -1) {\r\n            return;\r\n        }\r\n\r\n        node.target = NodeMaterialBlockTargets.Vertex;\r\n        this._vertexOutputNodes.push(node);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _removeVertexOutputNode(node: NodeMaterialBlock) {\r\n        const index = this._vertexOutputNodes.indexOf(node);\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._vertexOutputNodes.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _addFragmentOutputNode(node: NodeMaterialBlock) {\r\n        if (this._fragmentOutputNodes.indexOf(node) !== -1) {\r\n            return;\r\n        }\r\n\r\n        node.target = NodeMaterialBlockTargets.Fragment;\r\n        this._fragmentOutputNodes.push(node);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _removeFragmentOutputNode(node: NodeMaterialBlock) {\r\n        const index = this._fragmentOutputNodes.indexOf(node);\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._fragmentOutputNodes.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that alpha blending must be enabled no matter what alpha value or alpha channel of the FragmentBlock are\r\n     */\r\n    @serialize()\r\n    public forceAlphaBlending = false;\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        if (this.ignoreAlpha) {\r\n            return false;\r\n        }\r\n        return this.forceAlphaBlending || this.alpha < 1.0 || (this._sharedData && this._sharedData.hints.needAlphaBlending);\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        return this._sharedData && this._sharedData.hints.needAlphaTesting;\r\n    }\r\n\r\n    private _initializeBlock(node: NodeMaterialBlock, state: NodeMaterialBuildState, nodesToProcessForOtherBuildState: NodeMaterialBlock[], autoConfigure = true) {\r\n        node.initialize(state);\r\n        if (autoConfigure) {\r\n            node.autoConfigure(this);\r\n        }\r\n        node._preparationId = this._buildId;\r\n\r\n        if (this.attachedBlocks.indexOf(node) === -1) {\r\n            if (node.isUnique) {\r\n                const className = node.getClassName();\r\n\r\n                for (const other of this.attachedBlocks) {\r\n                    if (other.getClassName() === className) {\r\n                        throw `Cannot have multiple blocks of type ${className} in the same NodeMaterial`;\r\n                    }\r\n                }\r\n            }\r\n            this.attachedBlocks.push(node);\r\n        }\r\n\r\n        for (const input of node.inputs) {\r\n            input.associatedVariableName = \"\";\r\n\r\n            const connectedPoint = input.connectedPoint;\r\n            if (connectedPoint) {\r\n                const block = connectedPoint.ownerBlock;\r\n                if (block !== node) {\r\n                    if (block.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                        nodesToProcessForOtherBuildState.push(block);\r\n                    } else if (state.target === NodeMaterialBlockTargets.Fragment && block.target === NodeMaterialBlockTargets.Vertex && block._preparationId !== this._buildId) {\r\n                        nodesToProcessForOtherBuildState.push(block);\r\n                    }\r\n                    this._initializeBlock(block, state, nodesToProcessForOtherBuildState, autoConfigure);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const output of node.outputs) {\r\n            output.associatedVariableName = \"\";\r\n        }\r\n    }\r\n\r\n    private _resetDualBlocks(node: NodeMaterialBlock, id: number) {\r\n        if (node.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n            node.buildId = id;\r\n        }\r\n\r\n        for (const inputs of node.inputs) {\r\n            const connectedPoint = inputs.connectedPoint;\r\n            if (connectedPoint) {\r\n                const block = connectedPoint.ownerBlock;\r\n                if (block !== node) {\r\n                    this._resetDualBlocks(block, id);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a block from the current node material\r\n     * @param block defines the block to remove\r\n     */\r\n    public removeBlock(block: NodeMaterialBlock) {\r\n        const attachedBlockIndex = this.attachedBlocks.indexOf(block);\r\n        if (attachedBlockIndex > -1) {\r\n            this.attachedBlocks.splice(attachedBlockIndex, 1);\r\n        }\r\n\r\n        if (block.isFinalMerger) {\r\n            this.removeOutputNode(block);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Build the material and generates the inner effect\r\n     * @param verbose defines if the build should log activity\r\n     * @param updateBuildId defines if the internal build Id should be updated (default is true)\r\n     * @param autoConfigure defines if the autoConfigure method should be called when initializing blocks (default is true)\r\n     */\r\n    public build(verbose: boolean = false, updateBuildId = true, autoConfigure = true) {\r\n        this._buildWasSuccessful = false;\r\n        const engine = this.getScene().getEngine();\r\n\r\n        const allowEmptyVertexProgram = this._mode === NodeMaterialModes.Particle;\r\n\r\n        if (this._vertexOutputNodes.length === 0 && !allowEmptyVertexProgram) {\r\n            throw \"You must define at least one vertexOutputNode\";\r\n        }\r\n\r\n        if (this._fragmentOutputNodes.length === 0) {\r\n            throw \"You must define at least one fragmentOutputNode\";\r\n        }\r\n\r\n        // Compilation state\r\n        this._vertexCompilationState = new NodeMaterialBuildState();\r\n        this._vertexCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\r\n        this._vertexCompilationState.target = NodeMaterialBlockTargets.Vertex;\r\n        this._fragmentCompilationState = new NodeMaterialBuildState();\r\n        this._fragmentCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\r\n        this._fragmentCompilationState.target = NodeMaterialBlockTargets.Fragment;\r\n\r\n        // Shared data\r\n        this._sharedData = new NodeMaterialBuildStateSharedData();\r\n        this._sharedData.fragmentOutputNodes = this._fragmentOutputNodes;\r\n        this._vertexCompilationState.sharedData = this._sharedData;\r\n        this._fragmentCompilationState.sharedData = this._sharedData;\r\n        this._sharedData.buildId = this._buildId;\r\n        this._sharedData.emitComments = this._options.emitComments;\r\n        this._sharedData.verbose = verbose;\r\n        this._sharedData.scene = this.getScene();\r\n        this._sharedData.allowEmptyVertexProgram = allowEmptyVertexProgram;\r\n\r\n        // Initialize blocks\r\n        const vertexNodes: NodeMaterialBlock[] = [];\r\n        const fragmentNodes: NodeMaterialBlock[] = [];\r\n\r\n        for (const vertexOutputNode of this._vertexOutputNodes) {\r\n            vertexNodes.push(vertexOutputNode);\r\n            this._initializeBlock(vertexOutputNode, this._vertexCompilationState, fragmentNodes, autoConfigure);\r\n        }\r\n\r\n        for (const fragmentOutputNode of this._fragmentOutputNodes) {\r\n            fragmentNodes.push(fragmentOutputNode);\r\n            this._initializeBlock(fragmentOutputNode, this._fragmentCompilationState, vertexNodes, autoConfigure);\r\n        }\r\n\r\n        // Optimize\r\n        this.optimize();\r\n\r\n        // Vertex\r\n        for (const vertexOutputNode of vertexNodes) {\r\n            vertexOutputNode.build(this._vertexCompilationState, vertexNodes);\r\n        }\r\n\r\n        // Fragment\r\n        this._fragmentCompilationState.uniforms = this._vertexCompilationState.uniforms.slice(0);\r\n        this._fragmentCompilationState._uniformDeclaration = this._vertexCompilationState._uniformDeclaration;\r\n        this._fragmentCompilationState._constantDeclaration = this._vertexCompilationState._constantDeclaration;\r\n        this._fragmentCompilationState._vertexState = this._vertexCompilationState;\r\n\r\n        for (const fragmentOutputNode of fragmentNodes) {\r\n            this._resetDualBlocks(fragmentOutputNode, this._buildId - 1);\r\n        }\r\n\r\n        for (const fragmentOutputNode of fragmentNodes) {\r\n            fragmentOutputNode.build(this._fragmentCompilationState, fragmentNodes);\r\n        }\r\n\r\n        // Finalize\r\n        this._vertexCompilationState.finalize(this._vertexCompilationState);\r\n        this._fragmentCompilationState.finalize(this._fragmentCompilationState);\r\n\r\n        if (updateBuildId) {\r\n            this._buildId = NodeMaterial._BuildIdGenerator++;\r\n        }\r\n\r\n        // Errors\r\n        this._sharedData.emitErrors();\r\n\r\n        if (verbose) {\r\n            console.log(\"Vertex shader:\");\r\n            console.log(this._vertexCompilationState.compilationString);\r\n            console.log(\"Fragment shader:\");\r\n            console.log(this._fragmentCompilationState.compilationString);\r\n        }\r\n\r\n        this._buildWasSuccessful = true;\r\n        this.onBuildObservable.notifyObservers(this);\r\n\r\n        // Wipe defines\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                if (!subMesh.materialDefines) {\r\n                    continue;\r\n                }\r\n\r\n                const defines = subMesh.materialDefines;\r\n                defines.markAllAsDirty();\r\n                defines.reset();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs an otpimization phase to try to improve the shader code\r\n     */\r\n    public optimize() {\r\n        for (const optimizer of this._optimizers) {\r\n            optimizer.optimize(this._vertexOutputNodes, this._fragmentOutputNodes);\r\n        }\r\n    }\r\n\r\n    private _prepareDefinesForAttributes(mesh: AbstractMesh, defines: NodeMaterialDefines) {\r\n        const oldNormal = defines[\"NORMAL\"];\r\n        const oldTangent = defines[\"TANGENT\"];\r\n\r\n        defines[\"NORMAL\"] = mesh.isVerticesDataPresent(VertexBuffer.NormalKind);\r\n\r\n        defines[\"TANGENT\"] = mesh.isVerticesDataPresent(VertexBuffer.TangentKind);\r\n\r\n        let uvChanged = false;\r\n        for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n            const oldUV = defines[\"UV\" + i];\r\n            defines[\"UV\" + i] = mesh.isVerticesDataPresent(`uv${i === 1 ? \"\" : i}`);\r\n            uvChanged = uvChanged || defines[\"UV\" + i] !== oldUV;\r\n        }\r\n\r\n        if (oldNormal !== defines[\"NORMAL\"] || oldTangent !== defines[\"TANGENT\"] || uvChanged) {\r\n            defines.markAsAttributesDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a post process from the material\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n     * @returns the post process created\r\n     */\r\n    public createPostProcess(\r\n        camera: Nullable<Camera>,\r\n        options: number | PostProcessOptions = 1,\r\n        samplingMode: number = Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA\r\n    ): Nullable<PostProcess> {\r\n        if (this.mode !== NodeMaterialModes.PostProcess) {\r\n            console.log(\"Incompatible material mode\");\r\n            return null;\r\n        }\r\n        return this._createEffectForPostProcess(null, camera, options, samplingMode, engine, reusable, textureType, textureFormat);\r\n    }\r\n\r\n    /**\r\n     * Create the post process effect from the material\r\n     * @param postProcess The post process to create the effect for\r\n     */\r\n    public createEffectForPostProcess(postProcess: PostProcess) {\r\n        this._createEffectForPostProcess(postProcess);\r\n    }\r\n\r\n    private _createEffectForPostProcess(\r\n        postProcess: Nullable<PostProcess>,\r\n        camera?: Nullable<Camera>,\r\n        options: number | PostProcessOptions = 1,\r\n        samplingMode: number = Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA\r\n    ): PostProcess {\r\n        let tempName = this.name + this._buildId;\r\n\r\n        const defines = new NodeMaterialDefines();\r\n\r\n        const dummyMesh = new AbstractMesh(tempName + \"PostProcess\", this.getScene());\r\n\r\n        let buildId = this._buildId;\r\n\r\n        this._processDefines(dummyMesh, defines);\r\n\r\n        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\r\n\r\n        if (!postProcess) {\r\n            postProcess = new PostProcess(\r\n                this.name + \"PostProcess\",\r\n                tempName,\r\n                this._fragmentCompilationState.uniforms,\r\n                this._fragmentCompilationState.samplers,\r\n                options,\r\n                camera!,\r\n                samplingMode,\r\n                engine,\r\n                reusable,\r\n                defines.toString(),\r\n                textureType,\r\n                tempName,\r\n                { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                false,\r\n                textureFormat\r\n            );\r\n        } else {\r\n            postProcess.updateEffect(\r\n                defines.toString(),\r\n                this._fragmentCompilationState.uniforms,\r\n                this._fragmentCompilationState.samplers,\r\n                { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                undefined,\r\n                undefined,\r\n                tempName,\r\n                tempName\r\n            );\r\n        }\r\n\r\n        postProcess.nodeMaterialSource = this;\r\n\r\n        postProcess.onApplyObservable.add((effect) => {\r\n            if (buildId !== this._buildId) {\r\n                delete Effect.ShadersStore[tempName + \"VertexShader\"];\r\n                delete Effect.ShadersStore[tempName + \"PixelShader\"];\r\n\r\n                tempName = this.name + this._buildId;\r\n\r\n                defines.markAllAsDirty();\r\n\r\n                buildId = this._buildId;\r\n            }\r\n\r\n            const result = this._processDefines(dummyMesh, defines);\r\n\r\n            if (result) {\r\n                Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\r\n\r\n                TimingTools.SetImmediate(() =>\r\n                    postProcess!.updateEffect(\r\n                        defines.toString(),\r\n                        this._fragmentCompilationState.uniforms,\r\n                        this._fragmentCompilationState.samplers,\r\n                        { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                        undefined,\r\n                        undefined,\r\n                        tempName,\r\n                        tempName\r\n                    )\r\n                );\r\n            }\r\n\r\n            this._checkInternals(effect);\r\n        });\r\n\r\n        return postProcess;\r\n    }\r\n\r\n    /**\r\n     * Create a new procedural texture based on this node material\r\n     * @param size defines the size of the texture\r\n     * @param scene defines the hosting scene\r\n     * @returns the new procedural texture attached to this node material\r\n     */\r\n    public createProceduralTexture(size: number | { width: number; height: number; layers?: number }, scene: Scene): Nullable<ProceduralTexture> {\r\n        if (this.mode !== NodeMaterialModes.ProceduralTexture) {\r\n            console.log(\"Incompatible material mode\");\r\n            return null;\r\n        }\r\n\r\n        let tempName = this.name + this._buildId;\r\n\r\n        const proceduralTexture = new ProceduralTexture(tempName, size, null, scene);\r\n\r\n        const dummyMesh = new AbstractMesh(tempName + \"Procedural\", this.getScene());\r\n        dummyMesh.reservedDataStore = {\r\n            hidden: true,\r\n        };\r\n\r\n        const defines = new NodeMaterialDefines();\r\n        const result = this._processDefines(dummyMesh, defines);\r\n        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\r\n\r\n        let effect = this.getScene().getEngine().createEffect(\r\n            {\r\n                vertexElement: tempName,\r\n                fragmentElement: tempName,\r\n            },\r\n            [VertexBuffer.PositionKind],\r\n            this._fragmentCompilationState.uniforms,\r\n            this._fragmentCompilationState.samplers,\r\n            defines.toString(),\r\n            result?.fallbacks,\r\n            undefined\r\n        );\r\n\r\n        proceduralTexture.nodeMaterialSource = this;\r\n        proceduralTexture._setEffect(effect);\r\n\r\n        let buildId = this._buildId;\r\n        proceduralTexture.onBeforeGenerationObservable.add(() => {\r\n            if (buildId !== this._buildId) {\r\n                delete Effect.ShadersStore[tempName + \"VertexShader\"];\r\n                delete Effect.ShadersStore[tempName + \"PixelShader\"];\r\n\r\n                tempName = this.name + this._buildId;\r\n\r\n                defines.markAllAsDirty();\r\n\r\n                buildId = this._buildId;\r\n            }\r\n\r\n            const result = this._processDefines(dummyMesh, defines);\r\n\r\n            if (result) {\r\n                Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\r\n\r\n                TimingTools.SetImmediate(() => {\r\n                    effect = this.getScene().getEngine().createEffect(\r\n                        {\r\n                            vertexElement: tempName,\r\n                            fragmentElement: tempName,\r\n                        },\r\n                        [VertexBuffer.PositionKind],\r\n                        this._fragmentCompilationState.uniforms,\r\n                        this._fragmentCompilationState.samplers,\r\n                        defines.toString(),\r\n                        result?.fallbacks,\r\n                        undefined\r\n                    );\r\n\r\n                    proceduralTexture._setEffect(effect);\r\n                });\r\n            }\r\n\r\n            this._checkInternals(effect);\r\n        });\r\n\r\n        return proceduralTexture;\r\n    }\r\n\r\n    private _createEffectForParticles(\r\n        particleSystem: IParticleSystem,\r\n        blendMode: number,\r\n        onCompiled?: (effect: Effect) => void,\r\n        onError?: (effect: Effect, errors: string) => void,\r\n        effect?: Effect,\r\n        defines?: NodeMaterialDefines,\r\n        dummyMesh?: Nullable<AbstractMesh>,\r\n        particleSystemDefinesJoined = \"\"\r\n    ) {\r\n        let tempName = this.name + this._buildId + \"_\" + blendMode;\r\n\r\n        if (!defines) {\r\n            defines = new NodeMaterialDefines();\r\n        }\r\n\r\n        if (!dummyMesh) {\r\n            dummyMesh = this.getScene().getMeshByName(this.name + \"Particle\");\r\n            if (!dummyMesh) {\r\n                dummyMesh = new AbstractMesh(this.name + \"Particle\", this.getScene());\r\n                dummyMesh.reservedDataStore = {\r\n                    hidden: true,\r\n                };\r\n            }\r\n        }\r\n\r\n        let buildId = this._buildId;\r\n\r\n        const particleSystemDefines: Array<string> = [];\r\n        let join = particleSystemDefinesJoined;\r\n\r\n        if (!effect) {\r\n            const result = this._processDefines(dummyMesh, defines);\r\n\r\n            Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);\r\n\r\n            particleSystem.fillDefines(particleSystemDefines, blendMode);\r\n\r\n            join = particleSystemDefines.join(\"\\n\");\r\n\r\n            effect = this.getScene()\r\n                .getEngine()\r\n                .createEffectForParticles(\r\n                    tempName,\r\n                    this._fragmentCompilationState.uniforms,\r\n                    this._fragmentCompilationState.samplers,\r\n                    defines.toString() + \"\\n\" + join,\r\n                    result?.fallbacks,\r\n                    onCompiled,\r\n                    onError,\r\n                    particleSystem\r\n                );\r\n\r\n            particleSystem.setCustomEffect(effect, blendMode);\r\n        }\r\n\r\n        effect.onBindObservable.add((effect) => {\r\n            if (buildId !== this._buildId) {\r\n                delete Effect.ShadersStore[tempName + \"PixelShader\"];\r\n\r\n                tempName = this.name + this._buildId + \"_\" + blendMode;\r\n\r\n                defines!.markAllAsDirty();\r\n\r\n                buildId = this._buildId;\r\n            }\r\n\r\n            particleSystemDefines.length = 0;\r\n\r\n            particleSystem.fillDefines(particleSystemDefines, blendMode);\r\n\r\n            const particleSystemDefinesJoinedCurrent = particleSystemDefines.join(\"\\n\");\r\n\r\n            if (particleSystemDefinesJoinedCurrent !== join) {\r\n                defines!.markAllAsDirty();\r\n                join = particleSystemDefinesJoinedCurrent;\r\n            }\r\n\r\n            const result = this._processDefines(dummyMesh!, defines!);\r\n\r\n            if (result) {\r\n                Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);\r\n\r\n                effect = this.getScene()\r\n                    .getEngine()\r\n                    .createEffectForParticles(\r\n                        tempName,\r\n                        this._fragmentCompilationState.uniforms,\r\n                        this._fragmentCompilationState.samplers,\r\n                        defines!.toString() + \"\\n\" + join,\r\n                        result?.fallbacks,\r\n                        onCompiled,\r\n                        onError,\r\n                        particleSystem\r\n                    );\r\n                particleSystem.setCustomEffect(effect, blendMode);\r\n                this._createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect, defines, dummyMesh, particleSystemDefinesJoined); // add the effect.onBindObservable observer\r\n                return;\r\n            }\r\n\r\n            this._checkInternals(effect);\r\n        });\r\n    }\r\n\r\n    private _checkInternals(effect: Effect) {\r\n        // Animated blocks\r\n        if (this._sharedData.animatedInputs) {\r\n            const scene = this.getScene();\r\n\r\n            const frameId = scene.getFrameId();\r\n\r\n            if (this._animationFrame !== frameId) {\r\n                for (const input of this._sharedData.animatedInputs) {\r\n                    input.animate(scene);\r\n                }\r\n\r\n                this._animationFrame = frameId;\r\n            }\r\n        }\r\n\r\n        // Bindable blocks\r\n        for (const block of this._sharedData.bindableBlocks) {\r\n            block.bind(effect, this);\r\n        }\r\n\r\n        // Connection points\r\n        for (const inputBlock of this._sharedData.inputBlocks) {\r\n            inputBlock._transmit(effect, this.getScene(), this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create the effect to be used as the custom effect for a particle system\r\n     * @param particleSystem Particle system to create the effect for\r\n     * @param onCompiled defines a function to call when the effect creation is successful\r\n     * @param onError defines a function to call when the effect creation has failed\r\n     */\r\n    public createEffectForParticles(particleSystem: IParticleSystem, onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void) {\r\n        if (this.mode !== NodeMaterialModes.Particle) {\r\n            console.log(\"Incompatible material mode\");\r\n            return;\r\n        }\r\n\r\n        this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_ONEONE, onCompiled, onError);\r\n        this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_MULTIPLY, onCompiled, onError);\r\n    }\r\n\r\n    private _processDefines(\r\n        mesh: AbstractMesh,\r\n        defines: NodeMaterialDefines,\r\n        useInstances = false,\r\n        subMesh?: SubMesh\r\n    ): Nullable<{\r\n        lightDisposed: boolean;\r\n        uniformBuffers: string[];\r\n        mergedUniforms: string[];\r\n        mergedSamplers: string[];\r\n        fallbacks: EffectFallbacks;\r\n    }> {\r\n        let result = null;\r\n\r\n        // Shared defines\r\n        this._sharedData.blocksWithDefines.forEach((b) => {\r\n            b.initializeDefines(mesh, this, defines, useInstances);\r\n        });\r\n\r\n        this._sharedData.blocksWithDefines.forEach((b) => {\r\n            b.prepareDefines(mesh, this, defines, useInstances, subMesh);\r\n        });\r\n\r\n        // Need to recompile?\r\n        if (defines.isDirty) {\r\n            const lightDisposed = defines._areLightsDisposed;\r\n            defines.markAsProcessed();\r\n\r\n            // Repeatable content generators\r\n            this._vertexCompilationState.compilationString = this._vertexCompilationState._builtCompilationString;\r\n            this._fragmentCompilationState.compilationString = this._fragmentCompilationState._builtCompilationString;\r\n\r\n            this._sharedData.repeatableContentBlocks.forEach((b) => {\r\n                b.replaceRepeatableContent(this._vertexCompilationState, this._fragmentCompilationState, mesh, defines);\r\n            });\r\n\r\n            // Uniforms\r\n            const uniformBuffers: string[] = [];\r\n            this._sharedData.dynamicUniformBlocks.forEach((b) => {\r\n                b.updateUniformsAndSamples(this._vertexCompilationState, this, defines, uniformBuffers);\r\n            });\r\n\r\n            const mergedUniforms = this._vertexCompilationState.uniforms;\r\n\r\n            this._fragmentCompilationState.uniforms.forEach((u) => {\r\n                const index = mergedUniforms.indexOf(u);\r\n\r\n                if (index === -1) {\r\n                    mergedUniforms.push(u);\r\n                }\r\n            });\r\n\r\n            // Samplers\r\n            const mergedSamplers = this._vertexCompilationState.samplers;\r\n\r\n            this._fragmentCompilationState.samplers.forEach((s) => {\r\n                const index = mergedSamplers.indexOf(s);\r\n\r\n                if (index === -1) {\r\n                    mergedSamplers.push(s);\r\n                }\r\n            });\r\n\r\n            const fallbacks = new EffectFallbacks();\r\n\r\n            this._sharedData.blocksWithFallbacks.forEach((b) => {\r\n                b.provideFallbacks(mesh, fallbacks);\r\n            });\r\n\r\n            result = {\r\n                lightDisposed,\r\n                uniformBuffers,\r\n                mergedUniforms,\r\n                mergedSamplers,\r\n                fallbacks,\r\n            };\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get if the submesh is ready to be used and all its information available.\r\n     * Child classes can use it to update shaders\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances: boolean = false): boolean {\r\n        if (!this._buildWasSuccessful) {\r\n            return false;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        if (this._sharedData.animatedInputs) {\r\n            const frameId = scene.getFrameId();\r\n\r\n            if (this._animationFrame !== frameId) {\r\n                for (const input of this._sharedData.animatedInputs) {\r\n                    input.animate(scene);\r\n                }\r\n\r\n                this._animationFrame = frameId;\r\n            }\r\n        }\r\n\r\n        if (subMesh.effect && this.isFrozen) {\r\n            if (subMesh.effect._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new NodeMaterialDefines();\r\n        }\r\n\r\n        const defines = <NodeMaterialDefines>subMesh.materialDefines;\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        this._prepareDefinesForAttributes(mesh, defines);\r\n\r\n        // Check if blocks are ready\r\n        if (this._sharedData.blockingBlocks.some((b) => !b.isReady(mesh, this, defines, useInstances))) {\r\n            return false;\r\n        }\r\n\r\n        const result = this._processDefines(mesh, defines, useInstances, subMesh);\r\n\r\n        if (result) {\r\n            const previousEffect = subMesh.effect;\r\n            // Compilation\r\n            const join = defines.toString();\r\n            let effect = engine.createEffect(\r\n                {\r\n                    vertex: \"nodeMaterial\" + this._buildId,\r\n                    fragment: \"nodeMaterial\" + this._buildId,\r\n                    vertexSource: this._vertexCompilationState.compilationString,\r\n                    fragmentSource: this._fragmentCompilationState.compilationString,\r\n                },\r\n                <IEffectCreationOptions>{\r\n                    attributes: this._vertexCompilationState.attributes,\r\n                    uniformsNames: result.mergedUniforms,\r\n                    uniformBuffersNames: result.uniformBuffers,\r\n                    samplers: result.mergedSamplers,\r\n                    defines: join,\r\n                    fallbacks: result.fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS },\r\n                },\r\n                engine\r\n            );\r\n\r\n            if (effect) {\r\n                if (this._onEffectCreatedObservable) {\r\n                    onCreatedEffectParameters.effect = effect;\r\n                    onCreatedEffectParameters.subMesh = subMesh;\r\n                    this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n                }\r\n\r\n                // Use previous effect while new one is compiling\r\n                if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\r\n                    effect = previousEffect;\r\n                    defines.markAsUnprocessed();\r\n\r\n                    if (result.lightDisposed) {\r\n                        // re register in case it takes more than one frame.\r\n                        defines._areLightsDisposed = true;\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    scene.resetCachedMaterial();\r\n                    subMesh.setEffect(effect, defines, this._materialContext);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get a string representing the shaders built by the current node graph\r\n     */\r\n    public get compiledShaders() {\r\n        return `// Vertex shader\\r\\n${this._vertexCompilationState.compilationString}\\r\\n\\r\\n// Fragment shader\\r\\n${this._fragmentCompilationState.compilationString}`;\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     */\r\n    public bindOnlyWorldMatrix(world: Matrix): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!this._activeEffect) {\r\n            return;\r\n        }\r\n\r\n        const hints = this._sharedData.hints;\r\n\r\n        if (hints.needWorldViewMatrix) {\r\n            world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\r\n        }\r\n\r\n        if (hints.needWorldViewProjectionMatrix) {\r\n            world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\r\n        }\r\n\r\n        // Connection points\r\n        for (const inputBlock of this._sharedData.inputBlocks) {\r\n            inputBlock._transmitWorld(this._activeEffect, world, this._cachedWorldViewMatrix, this._cachedWorldViewProjectionMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n\r\n        const mustRebind = this._mustRebind(scene, effect, mesh.visibility);\r\n        const sharedData = this._sharedData;\r\n\r\n        if (mustRebind) {\r\n            // Bindable blocks\r\n            for (const block of sharedData.bindableBlocks) {\r\n                block.bind(effect, this, mesh, subMesh);\r\n            }\r\n\r\n            for (const block of sharedData.forcedBindableBlocks) {\r\n                block.bind(effect, this, mesh, subMesh);\r\n            }\r\n\r\n            // Connection points\r\n            for (const inputBlock of sharedData.inputBlocks) {\r\n                inputBlock._transmit(effect, scene, this);\r\n            }\r\n        } else if (!this.isFrozen) {\r\n            for (const block of sharedData.forcedBindableBlocks) {\r\n                block.bind(effect, this, mesh, subMesh);\r\n            }\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._sharedData) {\r\n            activeTextures.push(...this._sharedData.textureBlocks.filter((tb) => tb.texture).map((tb) => tb.texture!));\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of texture blocks\r\n     * @returns an array of texture blocks\r\n     */\r\n    public getTextureBlocks(): (TextureBlock | ReflectionTextureBaseBlock | RefractionBlock | CurrentScreenBlock | ParticleTextureBlock | ImageSourceBlock)[] {\r\n        if (!this._sharedData) {\r\n            return [];\r\n        }\r\n\r\n        return this._sharedData.textureBlocks;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (!this._sharedData) {\r\n            return false;\r\n        }\r\n\r\n        for (const t of this._sharedData.textureBlocks) {\r\n            if (t.texture === texture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            for (const texture of this.getTextureBlocks()\r\n                .filter((tb) => tb.texture)\r\n                .map((tb) => tb.texture!)) {\r\n                texture.dispose();\r\n            }\r\n        }\r\n\r\n        for (const block of this.attachedBlocks) {\r\n            block.dispose();\r\n        }\r\n\r\n        this.attachedBlocks = [];\r\n        (this._sharedData as any) = null;\r\n        (this._vertexCompilationState as any) = null;\r\n        (this._fragmentCompilationState as any) = null;\r\n\r\n        this.onBuildObservable.clear();\r\n\r\n        if (this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n            this._imageProcessingObserver = null;\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\r\n    }\r\n\r\n    /** Creates the node editor window. */\r\n    private _createNodeEditor() {\r\n        this.BJSNODEMATERIALEDITOR.NodeEditor.Show({\r\n            nodeMaterial: this,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Launch the node material editor\r\n     * @param config Define the configuration of the editor\r\n     * @return a promise fulfilled when the node editor is visible\r\n     */\r\n    public edit(config?: INodeMaterialEditorOptions): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();\r\n            if (typeof this.BJSNODEMATERIALEDITOR == \"undefined\") {\r\n                const editorUrl = config && config.editorURL ? config.editorURL : NodeMaterial.EditorURL;\r\n\r\n                // Load editor and add it to the DOM\r\n                Tools.LoadScript(editorUrl, () => {\r\n                    this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();\r\n                    this._createNodeEditor();\r\n                    resolve();\r\n                });\r\n            } else {\r\n                // Otherwise creates the editor\r\n                this._createNodeEditor();\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Clear the current material\r\n     */\r\n    public clear() {\r\n        this._vertexOutputNodes = [];\r\n        this._fragmentOutputNodes = [];\r\n        this.attachedBlocks = [];\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state\r\n     */\r\n    public setToDefault() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        const positionInput = new InputBlock(\"Position\");\r\n        positionInput.setAsAttribute(\"position\");\r\n\r\n        const worldInput = new InputBlock(\"World\");\r\n        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\r\n\r\n        const worldPos = new TransformBlock(\"WorldPos\");\r\n        positionInput.connectTo(worldPos);\r\n        worldInput.connectTo(worldPos);\r\n\r\n        const viewProjectionInput = new InputBlock(\"ViewProjection\");\r\n        viewProjectionInput.setAsSystemValue(NodeMaterialSystemValues.ViewProjection);\r\n\r\n        const worldPosdMultipliedByViewProjection = new TransformBlock(\"WorldPos * ViewProjectionTransform\");\r\n        worldPos.connectTo(worldPosdMultipliedByViewProjection);\r\n        viewProjectionInput.connectTo(worldPosdMultipliedByViewProjection);\r\n\r\n        const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\r\n        worldPosdMultipliedByViewProjection.connectTo(vertexOutput);\r\n\r\n        // Pixel\r\n        const pixelColor = new InputBlock(\"color\");\r\n        pixelColor.value = new Color4(0.8, 0.8, 0.8, 1);\r\n\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n        pixelColor.connectTo(fragmentOutput);\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(vertexOutput);\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.Material;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state for post process\r\n     */\r\n    public setToDefaultPostProcess() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        const position = new InputBlock(\"Position\");\r\n        position.setAsAttribute(\"position2d\");\r\n\r\n        const const1 = new InputBlock(\"Constant1\");\r\n        const1.isConstant = true;\r\n        const1.value = 1;\r\n\r\n        const vmerger = new VectorMergerBlock(\"Position3D\");\r\n\r\n        position.connectTo(vmerger);\r\n        const1.connectTo(vmerger, { input: \"w\" });\r\n\r\n        const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\r\n        vmerger.connectTo(vertexOutput);\r\n\r\n        // Pixel\r\n        const scale = new InputBlock(\"Scale\");\r\n        scale.visibleInInspector = true;\r\n        scale.value = new Vector2(1, 1);\r\n\r\n        const uv0 = new RemapBlock(\"uv0\");\r\n        position.connectTo(uv0);\r\n\r\n        const uv = new MultiplyBlock(\"UV scale\");\r\n        uv0.connectTo(uv);\r\n        scale.connectTo(uv);\r\n\r\n        const currentScreen = new CurrentScreenBlock(\"CurrentScreen\");\r\n        uv.connectTo(currentScreen);\r\n\r\n        currentScreen.texture = new Texture(\"https://assets.babylonjs.com/nme/currentScreenPostProcess.png\", this.getScene());\r\n\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n        currentScreen.connectTo(fragmentOutput, { output: \"rgba\" });\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(vertexOutput);\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.PostProcess;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state for procedural texture\r\n     */\r\n    public setToDefaultProceduralTexture() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        const position = new InputBlock(\"Position\");\r\n        position.setAsAttribute(\"position2d\");\r\n\r\n        const const1 = new InputBlock(\"Constant1\");\r\n        const1.isConstant = true;\r\n        const1.value = 1;\r\n\r\n        const vmerger = new VectorMergerBlock(\"Position3D\");\r\n\r\n        position.connectTo(vmerger);\r\n        const1.connectTo(vmerger, { input: \"w\" });\r\n\r\n        const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\r\n        vmerger.connectTo(vertexOutput);\r\n\r\n        // Pixel\r\n        const time = new InputBlock(\"Time\");\r\n        time.value = 0;\r\n        time.min = 0;\r\n        time.max = 0;\r\n        time.isBoolean = false;\r\n        time.matrixMode = 0;\r\n        time.animationType = AnimatedInputBlockTypes.Time;\r\n        time.isConstant = false;\r\n\r\n        const color = new InputBlock(\"Color3\");\r\n        color.value = new Color3(1, 1, 1);\r\n        color.isConstant = false;\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n\r\n        const vectorMerger = new VectorMergerBlock(\"VectorMerger\");\r\n        vectorMerger.visibleInInspector = false;\r\n\r\n        const cos = new TrigonometryBlock(\"Cos\");\r\n        cos.operation = TrigonometryBlockOperations.Cos;\r\n\r\n        position.connectTo(vectorMerger);\r\n        time.output.connectTo(cos.input);\r\n        cos.output.connectTo(vectorMerger.z);\r\n        vectorMerger.xyzOut.connectTo(fragmentOutput.rgb);\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(vertexOutput);\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.ProceduralTexture;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state for particle\r\n     */\r\n    public setToDefaultParticle() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        // Pixel\r\n        const uv = new InputBlock(\"uv\");\r\n        uv.setAsAttribute(\"particle_uv\");\r\n\r\n        const texture = new ParticleTextureBlock(\"ParticleTexture\");\r\n        uv.connectTo(texture);\r\n\r\n        const color = new InputBlock(\"Color\");\r\n        color.setAsAttribute(\"particle_color\");\r\n\r\n        const multiply = new MultiplyBlock(\"Texture * Color\");\r\n        texture.connectTo(multiply);\r\n        color.connectTo(multiply);\r\n\r\n        const rampGradient = new ParticleRampGradientBlock(\"ParticleRampGradient\");\r\n        multiply.connectTo(rampGradient);\r\n\r\n        const cSplitter = new ColorSplitterBlock(\"ColorSplitter\");\r\n        color.connectTo(cSplitter);\r\n\r\n        const blendMultiply = new ParticleBlendMultiplyBlock(\"ParticleBlendMultiply\");\r\n        rampGradient.connectTo(blendMultiply);\r\n        texture.connectTo(blendMultiply, { output: \"a\" });\r\n        cSplitter.connectTo(blendMultiply, { output: \"a\" });\r\n\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n        blendMultiply.connectTo(fragmentOutput);\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.Particle;\r\n    }\r\n\r\n    /**\r\n     * Loads the current Node Material from a url pointing to a file save by the Node Material Editor\r\n     * @param url defines the url to load from\r\n     * @param rootUrl defines the root URL for nested url in the node material\r\n     * @returns a promise that will fulfil when the material is fully loaded\r\n     */\r\n    public loadAsync(url: string, rootUrl: string = \"\") {\r\n        return this.getScene()\r\n            ._loadFileAsync(url)\r\n            .then((data) => {\r\n                const serializationObject = JSON.parse(data as string);\r\n                this.loadFromSerialization(serializationObject, rootUrl);\r\n            });\r\n    }\r\n\r\n    private _gatherBlocks(rootNode: NodeMaterialBlock, list: NodeMaterialBlock[]) {\r\n        if (list.indexOf(rootNode) !== -1) {\r\n            return;\r\n        }\r\n        list.push(rootNode);\r\n\r\n        for (const input of rootNode.inputs) {\r\n            const connectedPoint = input.connectedPoint;\r\n            if (connectedPoint) {\r\n                const block = connectedPoint.ownerBlock;\r\n                if (block !== rootNode) {\r\n                    this._gatherBlocks(block, list);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate a string containing the code declaration required to create an equivalent of this material\r\n     * @returns a string\r\n     */\r\n    public generateCode() {\r\n        let alreadyDumped: NodeMaterialBlock[] = [];\r\n        const vertexBlocks: NodeMaterialBlock[] = [];\r\n        const uniqueNames: string[] = [\"const\", \"var\", \"let\"];\r\n        // Gets active blocks\r\n        for (const outputNode of this._vertexOutputNodes) {\r\n            this._gatherBlocks(outputNode, vertexBlocks);\r\n        }\r\n\r\n        const fragmentBlocks: NodeMaterialBlock[] = [];\r\n        for (const outputNode of this._fragmentOutputNodes) {\r\n            this._gatherBlocks(outputNode, fragmentBlocks);\r\n        }\r\n\r\n        // Generate vertex shader\r\n        let codeString = `var nodeMaterial = new BABYLON.NodeMaterial(\"${this.name || \"node material\"}\");\\r\\n`;\r\n        for (const node of vertexBlocks) {\r\n            if (node.isInput && alreadyDumped.indexOf(node) === -1) {\r\n                codeString += node._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Generate fragment shader\r\n        for (const node of fragmentBlocks) {\r\n            if (node.isInput && alreadyDumped.indexOf(node) === -1) {\r\n                codeString += node._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Connections\r\n        alreadyDumped = [];\r\n        codeString += \"\\r\\n// Connections\\r\\n\";\r\n        for (const node of this._vertexOutputNodes) {\r\n            codeString += node._dumpCodeForOutputConnections(alreadyDumped);\r\n        }\r\n        for (const node of this._fragmentOutputNodes) {\r\n            codeString += node._dumpCodeForOutputConnections(alreadyDumped);\r\n        }\r\n\r\n        // Output nodes\r\n        codeString += \"\\r\\n// Output nodes\\r\\n\";\r\n        for (const node of this._vertexOutputNodes) {\r\n            codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});\\r\\n`;\r\n        }\r\n\r\n        for (const node of this._fragmentOutputNodes) {\r\n            codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});\\r\\n`;\r\n        }\r\n\r\n        codeString += `nodeMaterial.build();\\r\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @param selectedBlocks\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(selectedBlocks?: NodeMaterialBlock[]): any {\r\n        const serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);\r\n        serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData)); // Copy\r\n\r\n        let blocks: NodeMaterialBlock[] = [];\r\n\r\n        if (selectedBlocks) {\r\n            blocks = selectedBlocks;\r\n        } else {\r\n            serializationObject.customType = \"BABYLON.NodeMaterial\";\r\n            serializationObject.outputNodes = [];\r\n\r\n            // Outputs\r\n            for (const outputNode of this._vertexOutputNodes) {\r\n                this._gatherBlocks(outputNode, blocks);\r\n                serializationObject.outputNodes.push(outputNode.uniqueId);\r\n            }\r\n\r\n            for (const outputNode of this._fragmentOutputNodes) {\r\n                this._gatherBlocks(outputNode, blocks);\r\n\r\n                if (serializationObject.outputNodes.indexOf(outputNode.uniqueId) === -1) {\r\n                    serializationObject.outputNodes.push(outputNode.uniqueId);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Blocks\r\n        serializationObject.blocks = [];\r\n\r\n        for (const block of blocks) {\r\n            serializationObject.blocks.push(block.serialize());\r\n        }\r\n\r\n        if (!selectedBlocks) {\r\n            for (const block of this.attachedBlocks) {\r\n                if (blocks.indexOf(block) !== -1) {\r\n                    continue;\r\n                }\r\n                serializationObject.blocks.push(block.serialize());\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private _restoreConnections(block: NodeMaterialBlock, source: any, map: { [key: number]: NodeMaterialBlock }) {\r\n        for (const outputPoint of block.outputs) {\r\n            for (const candidate of source.blocks) {\r\n                const target = map[candidate.id];\r\n\r\n                if (!target) {\r\n                    continue;\r\n                }\r\n\r\n                for (const input of candidate.inputs) {\r\n                    if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {\r\n                        const inputPoint = target.getInputByName(input.inputName);\r\n                        if (!inputPoint || inputPoint.isConnected) {\r\n                            continue;\r\n                        }\r\n\r\n                        outputPoint.connectTo(inputPoint, true);\r\n                        this._restoreConnections(target, source, map);\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the current graph and load a new one from a serialization object\r\n     * @param source defines the JSON representation of the material\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param merge defines whether or not the source must be merged or replace the current content\r\n     */\r\n    public loadFromSerialization(source: any, rootUrl: string = \"\", merge = false) {\r\n        if (!merge) {\r\n            this.clear();\r\n        }\r\n\r\n        const map: { [key: number]: NodeMaterialBlock } = {};\r\n\r\n        // Create blocks\r\n        for (const parsedBlock of source.blocks) {\r\n            const blockType = GetClass(parsedBlock.customType);\r\n            if (blockType) {\r\n                const block: NodeMaterialBlock = new blockType();\r\n                block._deserialize(parsedBlock, this.getScene(), rootUrl);\r\n                map[parsedBlock.id] = block;\r\n\r\n                this.attachedBlocks.push(block);\r\n            }\r\n        }\r\n\r\n        // Connections - Starts with input blocks only (except if in \"merge\" mode where we scan all blocks)\r\n        for (let blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {\r\n            const parsedBlock = source.blocks[blockIndex];\r\n            const block = map[parsedBlock.id];\r\n\r\n            if (!block) {\r\n                continue;\r\n            }\r\n\r\n            if (block.inputs.length && !merge) {\r\n                continue;\r\n            }\r\n            this._restoreConnections(block, source, map);\r\n        }\r\n\r\n        // Outputs\r\n        if (source.outputNodes) {\r\n            for (const outputNodeId of source.outputNodes) {\r\n                this.addOutputNode(map[outputNodeId]);\r\n            }\r\n        }\r\n\r\n        // UI related info\r\n        if (source.locations || (source.editorData && source.editorData.locations)) {\r\n            const locations: {\r\n                blockId: number;\r\n                x: number;\r\n                y: number;\r\n            }[] = source.locations || source.editorData.locations;\r\n\r\n            for (const location of locations) {\r\n                if (map[location.blockId]) {\r\n                    location.blockId = map[location.blockId].uniqueId;\r\n                }\r\n            }\r\n\r\n            if (merge && this.editorData && this.editorData.locations) {\r\n                locations.concat(this.editorData.locations);\r\n            }\r\n\r\n            if (source.locations) {\r\n                this.editorData = {\r\n                    locations: locations,\r\n                };\r\n            } else {\r\n                this.editorData = source.editorData;\r\n                this.editorData.locations = locations;\r\n            }\r\n\r\n            const blockMap: number[] = [];\r\n\r\n            for (const key in map) {\r\n                blockMap[key] = map[key].uniqueId;\r\n            }\r\n\r\n            this.editorData.map = blockMap;\r\n        }\r\n\r\n        this.comment = source.comment;\r\n\r\n        if (source.forceAlphaBlending !== undefined) {\r\n            this.forceAlphaBlending = source.forceAlphaBlending;\r\n        }\r\n\r\n        if (!merge) {\r\n            this._mode = source.mode ?? NodeMaterialModes.Material;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current material.\r\n     * @param name defines the name to use for the new material\r\n     * @param shareEffect defines if the clone material should share the same effect (default is false)\r\n     */\r\n    public clone(name: string, shareEffect: boolean = false): NodeMaterial {\r\n        const serializationObject = this.serialize();\r\n\r\n        const clone = SerializationHelper.Clone(() => new NodeMaterial(name, this.getScene(), this.options), this);\r\n        clone.id = name;\r\n        clone.name = name;\r\n\r\n        clone.loadFromSerialization(serializationObject);\r\n        clone._buildId = this._buildId;\r\n        clone.build(false, !shareEffect);\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Creates a node material from parsed material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new node material\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string = \"\"): NodeMaterial {\r\n        const nodeMaterial = SerializationHelper.Parse(() => new NodeMaterial(source.name, scene), source, scene, rootUrl);\r\n\r\n        nodeMaterial.loadFromSerialization(source, rootUrl);\r\n        nodeMaterial.build();\r\n\r\n        return nodeMaterial;\r\n    }\r\n\r\n    /**\r\n     * Creates a node material from a snippet saved in a remote file\r\n     * @param name defines the name of the material to create\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL for nested url in the node material\r\n     * @returns a promise that will resolve to the new node material\r\n     */\r\n    public static ParseFromFileAsync(name: string, url: string, scene: Scene, rootUrl: string = \"\"): Promise<NodeMaterial> {\r\n        const material = new NodeMaterial(name, scene);\r\n\r\n        return new Promise((resolve, reject) => {\r\n            return material\r\n                .loadAsync(url, rootUrl)\r\n                .then(() => {\r\n                    material.build();\r\n                    resolve(material);\r\n                })\r\n                .catch(reject);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a node material from a snippet saved by the node material editor\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param nodeMaterial defines a node material to update (instead of creating a new one)\r\n     * @returns a promise that will resolve to the new node material\r\n     */\r\n    public static ParseFromSnippetAsync(snippetId: string, scene: Scene, rootUrl: string = \"\", nodeMaterial?: NodeMaterial): Promise<NodeMaterial> {\r\n        if (snippetId === \"_BLANK\") {\r\n            return Promise.resolve(this.CreateDefault(\"blank\", scene));\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        const serializationObject = JSON.parse(snippet.nodeMaterial);\r\n\r\n                        if (!nodeMaterial) {\r\n                            nodeMaterial = SerializationHelper.Parse(() => new NodeMaterial(snippetId, scene), serializationObject, scene, rootUrl);\r\n                            nodeMaterial.uniqueId = scene.getUniqueId();\r\n                        }\r\n\r\n                        nodeMaterial.loadFromSerialization(serializationObject);\r\n                        nodeMaterial.snippetId = snippetId;\r\n\r\n                        try {\r\n                            nodeMaterial.build();\r\n                            resolve(nodeMaterial);\r\n                        } catch (err) {\r\n                            reject(err);\r\n                        }\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a new node material set to default basic configuration\r\n     * @param name defines the name of the material\r\n     * @param scene defines the hosting scene\r\n     * @returns a new NodeMaterial\r\n     */\r\n    public static CreateDefault(name: string, scene?: Scene) {\r\n        const newMaterial = new NodeMaterial(name, scene);\r\n\r\n        newMaterial.setToDefault();\r\n        newMaterial.build();\r\n\r\n        return newMaterial;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.NodeMaterial\", NodeMaterial);\r\n"]},"metadata":{},"sourceType":"module"}