{"ast":null,"code":"import \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/web.url.js\";\nimport \"core-js/modules/web.url-search-params.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport { __assign, __awaiter, __generator } from \"tslib\";\nimport { Tools } from \"./tools.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { BaseTexture } from \"../Materials/Textures/baseTexture.js\";\nimport { Scene } from \"../scene.js\";\nimport { PostProcess } from \"../PostProcesses/postProcess.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { RGBDTextureTools } from \"./rgbdTextureTools.js\";\nimport \"../Engines/Extensions/engine.renderTargetCube.js\";\nimport \"../Engines/Extensions/engine.readTexture.js\";\nimport \"../Materials/Textures/baseTexture.polynomial.js\";\nimport \"../Shaders/rgbdEncode.fragment.js\";\nimport \"../Shaders/rgbdDecode.fragment.js\";\nvar DefaultEnvironmentTextureImageType = \"image/png\";\nvar CurrentVersion = 2;\n/**\n * Magic number identifying the env file.\n */\n\nvar MagicBytes = [0x86, 0x16, 0x87, 0x96, 0xf6, 0xd6, 0x96, 0x36];\n/**\n * Gets the environment info from an env file.\n * @param data The array buffer containing the .env bytes.\n * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\n */\n\nexport function GetEnvInfo(data) {\n  var dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n  var pos = 0;\n\n  for (var i = 0; i < MagicBytes.length; i++) {\n    if (dataView.getUint8(pos++) !== MagicBytes[i]) {\n      Logger.Error(\"Not a babylon environment map\");\n      return null;\n    }\n  } // Read json manifest - collect characters up to null terminator\n\n\n  var manifestString = \"\";\n  var charCode = 0x00;\n\n  while (charCode = dataView.getUint8(pos++)) {\n    manifestString += String.fromCharCode(charCode);\n  }\n\n  var manifest = JSON.parse(manifestString);\n  manifest = normalizeEnvInfo(manifest);\n\n  if (manifest.specular) {\n    // Extend the header with the position of the payload.\n    manifest.specular.specularDataPosition = pos; // Fallback to 0.8 exactly if lodGenerationScale is not defined for backward compatibility.\n\n    manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;\n  }\n\n  return manifest;\n}\n/**\n * Normalizes any supported version of the environment file info to the latest version\n * @param info environment file info on any supported version\n * @returns environment file info in the latest supported version\n * @private\n */\n\nexport function normalizeEnvInfo(info) {\n  if (info.version > CurrentVersion) {\n    throw new Error(\"Unsupported babylon environment map version \\\"\".concat(info.version, \"\\\". Latest supported version is \\\"\").concat(CurrentVersion, \"\\\".\"));\n  }\n\n  if (info.version === 2) {\n    return info;\n  } // Migrate a v1 info to v2\n\n\n  info = __assign(__assign({}, info), {\n    version: 2,\n    imageType: DefaultEnvironmentTextureImageType\n  });\n  return info;\n}\n/**\n * Creates an environment texture from a loaded cube texture.\n * @param texture defines the cube texture to convert in env file\n * @param options options for the conversion process\n * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\n * @param options.imageQuality the image quality of encoded WebP images.\n * @return a promise containing the environment data if successful.\n */\n\nexport function CreateEnvTextureAsync(texture, options) {\n  var _a;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  return __awaiter(this, void 0, void 0, function () {\n    var internalTexture, imageType, engine, textureType, cubeWidth, hostingScene, specularTextures, mipmapsCount, i, faceWidth, face, faceData, faceDataFloat, i_1, tempTexture, rgbdEncodedData, imageEncodedData, info, position, i, face, byteLength, infoString, infoBuffer, infoView, i, strLen, totalSize, finalBuffer, finalBufferView, dataView, pos, i, i, face, dataBuffer;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          internalTexture = texture.getInternalTexture();\n\n          if (!internalTexture) {\n            return [2\n            /*return*/\n            , Promise.reject(\"The cube texture is invalid.\")];\n          }\n\n          imageType = (_a = options.imageType) !== null && _a !== void 0 ? _a : DefaultEnvironmentTextureImageType;\n          engine = internalTexture.getEngine();\n\n          if (texture.textureType !== 2 && texture.textureType !== 1 && texture.textureType !== 0 && texture.textureType !== 0 && texture.textureType !== 7 && texture.textureType !== -1) {\n            return [2\n            /*return*/\n            , Promise.reject(\"The cube texture should allow HDR (Full Float or Half Float).\")];\n          }\n\n          textureType = 1;\n\n          if (!engine.getCaps().textureFloatRender) {\n            textureType = 2;\n\n            if (!engine.getCaps().textureHalfFloatRender) {\n              return [2\n              /*return*/\n              , Promise.reject(\"Env texture can only be created when the browser supports half float or full float rendering.\")];\n            }\n          }\n\n          cubeWidth = internalTexture.width;\n          hostingScene = new Scene(engine);\n          specularTextures = {}; // As we are going to readPixels the faces of the cube, make sure the drawing/update commands for the cube texture are fully sent to the GPU in case it is drawn for the first time in this very frame!\n\n          engine.flushFramebuffer();\n          mipmapsCount = Scalar.ILog2(internalTexture.width);\n          i = 0;\n          _b.label = 1;\n\n        case 1:\n          if (!(i <= mipmapsCount)) return [3\n          /*break*/\n          , 9];\n          faceWidth = Math.pow(2, mipmapsCount - i);\n          face = 0;\n          _b.label = 2;\n\n        case 2:\n          if (!(face < 6)) return [3\n          /*break*/\n          , 8];\n          return [4\n          /*yield*/\n          , texture.readPixels(face, i, undefined, false)];\n\n        case 3:\n          faceData = _b.sent();\n\n          if (faceData && faceData.byteLength === faceData.length) {\n            faceDataFloat = new Float32Array(faceData.byteLength * 4);\n\n            for (i_1 = 0; i_1 < faceData.byteLength; i_1++) {\n              faceDataFloat[i_1] = faceData[i_1] / 255; // Gamma to linear\n\n              faceDataFloat[i_1] = Math.pow(faceDataFloat[i_1], 2.2);\n            }\n\n            faceData = faceDataFloat;\n          }\n\n          tempTexture = engine.createRawTexture(faceData, faceWidth, faceWidth, 5, false, true, 1, null, textureType);\n          return [4\n          /*yield*/\n          , RGBDTextureTools.EncodeTextureToRGBD(tempTexture, hostingScene, textureType)];\n\n        case 4:\n          _b.sent();\n\n          return [4\n          /*yield*/\n          , engine._readTexturePixels(tempTexture, faceWidth, faceWidth)];\n\n        case 5:\n          rgbdEncodedData = _b.sent();\n          return [4\n          /*yield*/\n          , Tools.DumpDataAsync(faceWidth, faceWidth, rgbdEncodedData, imageType, undefined, false, true, options.imageQuality)];\n\n        case 6:\n          imageEncodedData = _b.sent();\n          specularTextures[i * 6 + face] = imageEncodedData;\n          tempTexture.dispose();\n          _b.label = 7;\n\n        case 7:\n          face++;\n          return [3\n          /*break*/\n          , 2];\n\n        case 8:\n          i++;\n          return [3\n          /*break*/\n          , 1];\n\n        case 9:\n          // We can delete the hosting scene keeping track of all the creation objects\n          hostingScene.dispose();\n          info = {\n            version: CurrentVersion,\n            width: cubeWidth,\n            imageType: imageType,\n            irradiance: _CreateEnvTextureIrradiance(texture),\n            specular: {\n              mipmaps: [],\n              lodGenerationScale: texture.lodGenerationScale\n            }\n          };\n          position = 0;\n\n          for (i = 0; i <= mipmapsCount; i++) {\n            for (face = 0; face < 6; face++) {\n              byteLength = specularTextures[i * 6 + face].byteLength;\n              info.specular.mipmaps.push({\n                length: byteLength,\n                position: position\n              });\n              position += byteLength;\n            }\n          }\n\n          infoString = JSON.stringify(info);\n          infoBuffer = new ArrayBuffer(infoString.length + 1);\n          infoView = new Uint8Array(infoBuffer);\n\n          for (i = 0, strLen = infoString.length; i < strLen; i++) {\n            infoView[i] = infoString.charCodeAt(i);\n          } // Ends up with a null terminator for easier parsing\n\n\n          infoView[infoString.length] = 0x00;\n          totalSize = MagicBytes.length + position + infoBuffer.byteLength;\n          finalBuffer = new ArrayBuffer(totalSize);\n          finalBufferView = new Uint8Array(finalBuffer);\n          dataView = new DataView(finalBuffer);\n          pos = 0;\n\n          for (i = 0; i < MagicBytes.length; i++) {\n            dataView.setUint8(pos++, MagicBytes[i]);\n          } // Add the json info\n\n\n          finalBufferView.set(new Uint8Array(infoBuffer), pos);\n          pos += infoBuffer.byteLength; // Finally inserts the texture data\n\n          for (i = 0; i <= mipmapsCount; i++) {\n            for (face = 0; face < 6; face++) {\n              dataBuffer = specularTextures[i * 6 + face];\n              finalBufferView.set(new Uint8Array(dataBuffer), pos);\n              pos += dataBuffer.byteLength;\n            }\n          } // Voila\n\n\n          return [2\n          /*return*/\n          , finalBuffer];\n      }\n    });\n  });\n}\n/**\n * Creates a JSON representation of the spherical data.\n * @param texture defines the texture containing the polynomials\n * @return the JSON representation of the spherical info\n */\n\nfunction _CreateEnvTextureIrradiance(texture) {\n  var polynmials = texture.sphericalPolynomial;\n\n  if (polynmials == null) {\n    return null;\n  }\n\n  return {\n    x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],\n    y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],\n    z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],\n    xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],\n    yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],\n    zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],\n    yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],\n    zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],\n    xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z]\n  };\n}\n/**\n * Creates the ArrayBufferViews used for initializing environment texture image data.\n * @param data the image data\n * @param info parameters that determine what views will be created for accessing the underlying buffer\n * @return the views described by info providing access to the underlying buffer\n */\n\n\nexport function CreateImageDataArrayBufferViews(data, info) {\n  info = normalizeEnvInfo(info);\n  var specularInfo = info.specular; // Double checks the enclosed info\n\n  var mipmapsCount = Scalar.Log2(info.width);\n  mipmapsCount = Math.round(mipmapsCount) + 1;\n\n  if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {\n    throw new Error(\"Unsupported specular mipmaps number \\\"\".concat(specularInfo.mipmaps.length, \"\\\"\"));\n  }\n\n  var imageData = new Array(mipmapsCount);\n\n  for (var i = 0; i < mipmapsCount; i++) {\n    imageData[i] = new Array(6);\n\n    for (var face = 0; face < 6; face++) {\n      var imageInfo = specularInfo.mipmaps[i * 6 + face];\n      imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + specularInfo.specularDataPosition + imageInfo.position, imageInfo.length);\n    }\n  }\n\n  return imageData;\n}\n/**\n * Uploads the texture info contained in the env file to the GPU.\n * @param texture defines the internal texture to upload to\n * @param data defines the data to load\n * @param info defines the texture info retrieved through the GetEnvInfo method\n * @returns a promise\n */\n\nexport function UploadEnvLevelsAsync(texture, data, info) {\n  info = normalizeEnvInfo(info);\n  var specularInfo = info.specular;\n\n  if (!specularInfo) {\n    // Nothing else parsed so far\n    return Promise.resolve();\n  }\n\n  texture._lodGenerationScale = specularInfo.lodGenerationScale;\n  var imageData = CreateImageDataArrayBufferViews(data, info);\n  return UploadLevelsAsync(texture, imageData, info.imageType);\n}\n\nfunction _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture) {\n  return new Promise(function (resolve, reject) {\n    if (expandTexture) {\n      var tempTexture_1 = engine.createTexture(null, true, true, null, 1, null, function (message) {\n        reject(message);\n      }, image);\n      rgbdPostProcess.getEffect().executeWhenCompiled(function () {\n        // Uncompress the data to a RTT\n        rgbdPostProcess.externalTextureSamplerBinding = true;\n\n        rgbdPostProcess.onApply = function (effect) {\n          effect._bindTexture(\"textureSampler\", tempTexture_1);\n\n          effect.setFloat2(\"scale\", 1, engine._features.needsInvertingBitmap && image instanceof ImageBitmap ? -1 : 1);\n        };\n\n        if (!engine.scenes.length) {\n          return;\n        }\n\n        engine.scenes[0].postProcessManager.directRender([rgbdPostProcess], cubeRtt, true, face, i); // Cleanup\n\n        engine.restoreDefaultFramebuffer();\n        tempTexture_1.dispose();\n        URL.revokeObjectURL(url);\n        resolve();\n      });\n    } else {\n      engine._uploadImageToTexture(texture, image, face, i); // Upload the face to the non lod texture support\n\n\n      if (generateNonLODTextures) {\n        var lodTexture = lodTextures[i];\n\n        if (lodTexture) {\n          engine._uploadImageToTexture(lodTexture._texture, image, face, 0);\n        }\n      }\n\n      resolve();\n    }\n  });\n}\n/**\n * Uploads the levels of image data to the GPU.\n * @param texture defines the internal texture to upload to\n * @param imageData defines the array buffer views of image data [mipmap][face]\n * @param imageType the mime type of the image data\n * @returns a promise\n */\n\n\nexport function UploadLevelsAsync(texture, imageData, imageType) {\n  if (imageType === void 0) {\n    imageType = DefaultEnvironmentTextureImageType;\n  }\n\n  if (!Tools.IsExponentOfTwo(texture.width)) {\n    throw new Error(\"Texture size must be a power of two\");\n  }\n\n  var mipmapsCount = Scalar.ILog2(texture.width) + 1; // Gets everything ready.\n\n  var engine = texture.getEngine();\n  var expandTexture = false;\n  var generateNonLODTextures = false;\n  var rgbdPostProcess = null;\n  var cubeRtt = null;\n  var lodTextures = null;\n  var caps = engine.getCaps();\n  texture.format = 5;\n  texture.type = 0;\n  texture.generateMipMaps = true;\n  texture._cachedAnisotropicFilteringLevel = null;\n  engine.updateTextureSamplingMode(3, texture); // Add extra process if texture lod is not supported\n\n  if (!caps.textureLOD) {\n    expandTexture = false;\n    generateNonLODTextures = true;\n    lodTextures = {};\n  } // in webgl 1 there are no ways to either render or copy lod level information for float textures.\n  else if (!engine._features.supportRenderAndCopyToLodForFloatTextures) {\n    expandTexture = false;\n  } // If half float available we can uncompress the texture\n  else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\n    expandTexture = true;\n    texture.type = 2;\n  } // If full float available we can uncompress the texture\n  else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\n    expandTexture = true;\n    texture.type = 1;\n  } // Expand the texture if possible\n\n\n  if (expandTexture) {\n    // Simply run through the decode PP\n    rgbdPostProcess = new PostProcess(\"rgbdDecode\", \"rgbdDecode\", null, null, 1, null, 3, engine, false, undefined, texture.type, undefined, null, false);\n    texture._isRGBD = false;\n    texture.invertY = false;\n    cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {\n      generateDepthBuffer: false,\n      generateMipMaps: true,\n      generateStencilBuffer: false,\n      samplingMode: 3,\n      type: texture.type,\n      format: 5\n    });\n  } else {\n    texture._isRGBD = true;\n    texture.invertY = true; // In case of missing support, applies the same patch than DDS files.\n\n    if (generateNonLODTextures) {\n      var mipSlices = 3;\n      var scale = texture._lodGenerationScale;\n      var offset = texture._lodGenerationOffset;\n\n      for (var i = 0; i < mipSlices; i++) {\n        //compute LOD from even spacing in smoothness (matching shader calculation)\n        var smoothness = i / (mipSlices - 1);\n        var roughness = 1 - smoothness;\n        var minLODIndex = offset; // roughness = 0\n\n        var maxLODIndex = (mipmapsCount - 1) * scale + offset; // roughness = 1 (mipmaps start from 0)\n\n        var lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\n        var mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\n        var glTextureFromLod = new InternalTexture(engine, InternalTextureSource.Temp);\n        glTextureFromLod.isCube = true;\n        glTextureFromLod.invertY = true;\n        glTextureFromLod.generateMipMaps = false;\n        engine.updateTextureSamplingMode(2, glTextureFromLod); // Wrap in a base texture for easy binding.\n\n        var lodTexture = new BaseTexture(null);\n        lodTexture.isCube = true;\n        lodTexture._texture = glTextureFromLod;\n        lodTextures[mipmapIndex] = lodTexture;\n\n        switch (i) {\n          case 0:\n            texture._lodTextureLow = lodTexture;\n            break;\n\n          case 1:\n            texture._lodTextureMid = lodTexture;\n            break;\n\n          case 2:\n            texture._lodTextureHigh = lodTexture;\n            break;\n        }\n      }\n    }\n  }\n\n  var promises = [];\n\n  var _loop_1 = function _loop_1(i) {\n    var _loop_2 = function _loop_2(face) {\n      // Constructs an image element from image data\n      var bytes = imageData[i][face];\n      var blob = new Blob([bytes], {\n        type: imageType\n      });\n      var url = URL.createObjectURL(blob);\n      var promise = void 0;\n\n      if (typeof Image === \"undefined\" || engine._features.forceBitmapOverHTMLImageElement) {\n        promise = engine.createImageBitmap(blob, {\n          premultiplyAlpha: \"none\"\n        }).then(function (img) {\n          return _OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture);\n        });\n      } else {\n        var image_1 = new Image();\n        image_1.src = url; // Enqueue promise to upload to the texture.\n\n        promise = new Promise(function (resolve, reject) {\n          image_1.onload = function () {\n            _OnImageReadyAsync(image_1, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture).then(function () {\n              return resolve();\n            })[\"catch\"](function (reason) {\n              reject(reason);\n            });\n          };\n\n          image_1.onerror = function (error) {\n            reject(error);\n          };\n        });\n      }\n\n      promises.push(promise);\n    }; // All faces\n\n\n    for (var face = 0; face < 6; face++) {\n      _loop_2(face);\n    }\n  }; // All mipmaps up to provided number of images\n\n\n  for (var i = 0; i < imageData.length; i++) {\n    _loop_1(i);\n  } // Fill remaining mipmaps with black textures.\n\n\n  if (imageData.length < mipmapsCount) {\n    var data = void 0;\n    var size = Math.pow(2, mipmapsCount - 1 - imageData.length);\n    var dataLength = size * size * 4;\n\n    switch (texture.type) {\n      case 0:\n        {\n          data = new Uint8Array(dataLength);\n          break;\n        }\n\n      case 2:\n        {\n          data = new Uint16Array(dataLength);\n          break;\n        }\n\n      case 1:\n        {\n          data = new Float32Array(dataLength);\n          break;\n        }\n    }\n\n    for (var i = imageData.length; i < mipmapsCount; i++) {\n      for (var face = 0; face < 6; face++) {\n        engine._uploadArrayBufferViewToTexture(texture, data, face, i);\n      }\n    }\n  } // Once all done, finishes the cleanup and return\n\n\n  return Promise.all(promises).then(function () {\n    // Release temp RTT.\n    if (cubeRtt) {\n      engine._releaseTexture(texture);\n\n      cubeRtt._swapAndDie(texture);\n    } // Release temp Post Process.\n\n\n    if (rgbdPostProcess) {\n      rgbdPostProcess.dispose();\n    } // Flag internal texture as ready in case they are in use.\n\n\n    if (generateNonLODTextures) {\n      if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {\n        texture._lodTextureHigh._texture.isReady = true;\n      }\n\n      if (texture._lodTextureMid && texture._lodTextureMid._texture) {\n        texture._lodTextureMid._texture.isReady = true;\n      }\n\n      if (texture._lodTextureLow && texture._lodTextureLow._texture) {\n        texture._lodTextureLow._texture.isReady = true;\n      }\n    }\n  });\n}\n/**\n * Uploads spherical polynomials information to the texture.\n * @param texture defines the texture we are trying to upload the information to\n * @param info defines the environment texture info retrieved through the GetEnvInfo method\n */\n\nexport function UploadEnvSpherical(texture, info) {\n  info = normalizeEnvInfo(info);\n  var irradianceInfo = info.irradiance;\n\n  if (!irradianceInfo) {\n    return;\n  }\n\n  var sp = new SphericalPolynomial();\n  Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);\n  Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);\n  Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);\n  Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);\n  Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);\n  Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);\n  Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);\n  Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);\n  Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);\n  texture._sphericalPolynomial = sp;\n}\n/**\n * @param internalTexture\n * @param data\n * @param sphericalPolynomial\n * @param lodScale\n * @param lodOffset\n * @hidden\n */\n\nexport function _UpdateRGBDAsync(internalTexture, data, sphericalPolynomial, lodScale, lodOffset) {\n  var proxy = internalTexture.getEngine().createRawCubeTexture(null, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);\n  var proxyPromise = UploadLevelsAsync(proxy, data).then(function () {\n    return internalTexture;\n  });\n\n  internalTexture.onRebuildCallback = function (_internalTexture) {\n    return {\n      proxy: proxyPromise,\n      isReady: true,\n      isAsync: true\n    };\n  };\n\n  internalTexture._source = InternalTextureSource.CubeRawRGBD;\n  internalTexture._bufferViewArrayArray = data;\n  internalTexture._lodGenerationScale = lodScale;\n  internalTexture._lodGenerationOffset = lodOffset;\n  internalTexture._sphericalPolynomial = sphericalPolynomial;\n  return UploadLevelsAsync(internalTexture, data).then(function () {\n    internalTexture.isReady = true;\n    return internalTexture;\n  });\n}\n/**\n * Sets of helpers addressing the serialization and deserialization of environment texture\n * stored in a BabylonJS env file.\n * Those files are usually stored as .env files.\n */\n\nexport var EnvironmentTextureTools = {\n  /**\n   * Gets the environment info from an env file.\n   * @param data The array buffer containing the .env bytes.\n   * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\n   */\n  GetEnvInfo: GetEnvInfo,\n\n  /**\n   * Creates an environment texture from a loaded cube texture.\n   * @param texture defines the cube texture to convert in env file\n   * @param options options for the conversion process\n   * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\n   * @param options.imageQuality the image quality of encoded WebP images.\n   * @return a promise containing the environment data if successful.\n   */\n  CreateEnvTextureAsync: CreateEnvTextureAsync,\n\n  /**\n   * Creates the ArrayBufferViews used for initializing environment texture image data.\n   * @param data the image data\n   * @param info parameters that determine what views will be created for accessing the underlying buffer\n   * @return the views described by info providing access to the underlying buffer\n   */\n  CreateImageDataArrayBufferViews: CreateImageDataArrayBufferViews,\n\n  /**\n   * Uploads the texture info contained in the env file to the GPU.\n   * @param texture defines the internal texture to upload to\n   * @param data defines the data to load\n   * @param info defines the texture info retrieved through the GetEnvInfo method\n   * @returns a promise\n   */\n  UploadEnvLevelsAsync: UploadEnvLevelsAsync,\n\n  /**\n   * Uploads the levels of image data to the GPU.\n   * @param texture defines the internal texture to upload to\n   * @param imageData defines the array buffer views of image data [mipmap][face]\n   * @param imageType the mime type of the image data\n   * @returns a promise\n   */\n  UploadLevelsAsync: UploadLevelsAsync,\n\n  /**\n   * Uploads spherical polynomials information to the texture.\n   * @param texture defines the texture we are trying to upload the information to\n   * @param info defines the environment texture info retrieved through the GetEnvInfo method\n   */\n  UploadEnvSpherical: UploadEnvSpherical\n};","map":{"version":3,"mappings":"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","names":["Tools","Vector3","Scalar","SphericalPolynomial","InternalTexture","InternalTextureSource","BaseTexture","Scene","PostProcess","Logger","RGBDTextureTools","DefaultEnvironmentTextureImageType","CurrentVersion","MagicBytes","GetEnvInfo","data","dataView","DataView","buffer","byteOffset","byteLength","pos","i","length","getUint8","Error","manifestString","charCode","String","fromCharCode","manifest","JSON","parse","normalizeEnvInfo","specular","specularDataPosition","lodGenerationScale","info","version","concat","imageType","CreateEnvTextureAsync","texture","options","internalTexture","getInternalTexture","Promise","reject","_a","engine","getEngine","textureType","getCaps","textureFloatRender","textureHalfFloatRender","cubeWidth","width","hostingScene","specularTextures","flushFramebuffer","mipmapsCount","ILog2","faceWidth","Math","pow","face","readPixels","undefined","faceData","_b","faceDataFloat","Float32Array","i_1","tempTexture","createRawTexture","EncodeTextureToRGBD","_readTexturePixels","rgbdEncodedData","DumpDataAsync","imageQuality","imageEncodedData","dispose","irradiance","_CreateEnvTextureIrradiance","mipmaps","position","push","infoString","stringify","infoBuffer","ArrayBuffer","infoView","Uint8Array","strLen","charCodeAt","totalSize","finalBuffer","finalBufferView","setUint8","set","dataBuffer","polynmials","sphericalPolynomial","x","y","z","xx","yy","zz","yz","zx","xy","CreateImageDataArrayBufferViews","specularInfo","Log2","round","imageData","Array","imageInfo","UploadEnvLevelsAsync","resolve","_lodGenerationScale","UploadLevelsAsync","_OnImageReadyAsync","image","expandTexture","rgbdPostProcess","url","generateNonLODTextures","lodTextures","cubeRtt","tempTexture_1","createTexture","message","getEffect","executeWhenCompiled","externalTextureSamplerBinding","onApply","effect","_bindTexture","setFloat2","_features","needsInvertingBitmap","ImageBitmap","scenes","postProcessManager","directRender","restoreDefaultFramebuffer","URL","revokeObjectURL","_uploadImageToTexture","lodTexture","_texture","IsExponentOfTwo","caps","format","type","generateMipMaps","_cachedAnisotropicFilteringLevel","updateTextureSamplingMode","textureLOD","supportRenderAndCopyToLodForFloatTextures","textureHalfFloatLinearFiltering","textureFloatLinearFiltering","_isRGBD","invertY","createRenderTargetCubeTexture","generateDepthBuffer","generateStencilBuffer","samplingMode","mipSlices","scale","offset","_lodGenerationOffset","smoothness","roughness","minLODIndex","maxLODIndex","lodIndex","mipmapIndex","min","max","glTextureFromLod","Temp","isCube","_lodTextureLow","_lodTextureMid","_lodTextureHigh","promises","bytes","blob","Blob","createObjectURL","promise","Image","forceBitmapOverHTMLImageElement","createImageBitmap","premultiplyAlpha","then","img","image_1","src","onload","reason","onerror","error","size","dataLength","Uint16Array","_uploadArrayBufferViewToTexture","all","_releaseTexture","_swapAndDie","isReady","UploadEnvSpherical","irradianceInfo","sp","FromArrayToRef","_sphericalPolynomial","_UpdateRGBDAsync","lodScale","lodOffset","proxy","createRawCubeTexture","_compression","proxyPromise","onRebuildCallback","_internalTexture","isAsync","_source","CubeRawRGBD","_bufferViewArrayArray","EnvironmentTextureTools"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/environmentTextureTools.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../types\";\r\nimport { Tools } from \"./tools\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Scene } from \"../scene\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { RGBDTextureTools } from \"./rgbdTextureTools\";\r\nimport type { RenderTargetWrapper } from \"../Engines/renderTargetWrapper\";\r\n\r\nimport \"../Engines/Extensions/engine.renderTargetCube\";\r\nimport \"../Engines/Extensions/engine.readTexture\";\r\nimport \"../Materials/Textures/baseTexture.polynomial\";\r\n\r\nimport \"../Shaders/rgbdEncode.fragment\";\r\nimport \"../Shaders/rgbdDecode.fragment\";\r\n\r\nconst DefaultEnvironmentTextureImageType = \"image/png\";\r\nconst CurrentVersion = 2;\r\n\r\n/**\r\n * Raw texture data and descriptor sufficient for WebGL texture upload\r\n */\r\nexport type EnvironmentTextureInfo = EnvironmentTextureInfoV1 | EnvironmentTextureInfoV2;\r\n\r\n/**\r\n * v1 of EnvironmentTextureInfo\r\n */\r\ninterface EnvironmentTextureInfoV1 {\r\n    /**\r\n     * Version of the environment map\r\n     */\r\n    version: 1;\r\n\r\n    /**\r\n     * Width of image\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * Irradiance information stored in the file.\r\n     */\r\n    irradiance: any;\r\n\r\n    /**\r\n     * Specular information stored in the file.\r\n     */\r\n    specular: any;\r\n}\r\n\r\n/**\r\n * v2 of EnvironmentTextureInfo\r\n */\r\ninterface EnvironmentTextureInfoV2 {\r\n    /**\r\n     * Version of the environment map\r\n     */\r\n    version: 2;\r\n\r\n    /**\r\n     * Width of image\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * Irradiance information stored in the file.\r\n     */\r\n    irradiance: any;\r\n\r\n    /**\r\n     * Specular information stored in the file.\r\n     */\r\n    specular: any;\r\n\r\n    /**\r\n     * The mime type used to encode the image data.\r\n     */\r\n    imageType: string;\r\n}\r\n\r\n/**\r\n * Defines One Image in the file. It requires only the position in the file\r\n * as well as the length.\r\n */\r\ninterface BufferImageData {\r\n    /**\r\n     * Length of the image data.\r\n     */\r\n    length: number;\r\n    /**\r\n     * Position of the data from the null terminator delimiting the end of the JSON.\r\n     */\r\n    position: number;\r\n}\r\n\r\n/**\r\n * Defines the specular data enclosed in the file.\r\n * This corresponds to the version 1 of the data.\r\n */\r\nexport interface EnvironmentTextureSpecularInfoV1 {\r\n    /**\r\n     * Defines where the specular Payload is located. It is a runtime value only not stored in the file.\r\n     */\r\n    specularDataPosition?: number;\r\n    /**\r\n     * This contains all the images data needed to reconstruct the cubemap.\r\n     */\r\n    mipmaps: Array<BufferImageData>;\r\n    /**\r\n     * Defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness.\r\n     */\r\n    lodGenerationScale: number;\r\n}\r\n\r\n/**\r\n * Defines the required storage to save the environment irradiance information.\r\n */\r\ninterface EnvironmentTextureIrradianceInfoV1 {\r\n    x: Array<number>;\r\n    y: Array<number>;\r\n    z: Array<number>;\r\n\r\n    xx: Array<number>;\r\n    yy: Array<number>;\r\n    zz: Array<number>;\r\n\r\n    yz: Array<number>;\r\n    zx: Array<number>;\r\n    xy: Array<number>;\r\n}\r\n\r\n/**\r\n * Options for creating environment textures\r\n */\r\nexport interface CreateEnvTextureOptions {\r\n    /**\r\n     * The mime type of encoded images.\r\n     */\r\n    imageType?: string;\r\n\r\n    /**\r\n     * the image quality of encoded WebP images.\r\n     */\r\n    imageQuality?: number;\r\n}\r\n\r\n/**\r\n * Magic number identifying the env file.\r\n */\r\nconst MagicBytes = [0x86, 0x16, 0x87, 0x96, 0xf6, 0xd6, 0x96, 0x36];\r\n\r\n/**\r\n * Gets the environment info from an env file.\r\n * @param data The array buffer containing the .env bytes.\r\n * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\r\n */\r\nexport function GetEnvInfo(data: ArrayBufferView): Nullable<EnvironmentTextureInfoV2> {\r\n    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n    let pos = 0;\r\n\r\n    for (let i = 0; i < MagicBytes.length; i++) {\r\n        if (dataView.getUint8(pos++) !== MagicBytes[i]) {\r\n            Logger.Error(\"Not a babylon environment map\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Read json manifest - collect characters up to null terminator\r\n    let manifestString = \"\";\r\n    let charCode = 0x00;\r\n    while ((charCode = dataView.getUint8(pos++))) {\r\n        manifestString += String.fromCharCode(charCode);\r\n    }\r\n\r\n    let manifest: EnvironmentTextureInfo = JSON.parse(manifestString);\r\n    manifest = normalizeEnvInfo(manifest);\r\n    if (manifest.specular) {\r\n        // Extend the header with the position of the payload.\r\n        manifest.specular.specularDataPosition = pos;\r\n        // Fallback to 0.8 exactly if lodGenerationScale is not defined for backward compatibility.\r\n        manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;\r\n    }\r\n\r\n    return manifest;\r\n}\r\n\r\n/**\r\n * Normalizes any supported version of the environment file info to the latest version\r\n * @param info environment file info on any supported version\r\n * @returns environment file info in the latest supported version\r\n * @private\r\n */\r\nexport function normalizeEnvInfo(info: EnvironmentTextureInfo): EnvironmentTextureInfoV2 {\r\n    if (info.version > CurrentVersion) {\r\n        throw new Error(`Unsupported babylon environment map version \"${info.version}\". Latest supported version is \"${CurrentVersion}\".`);\r\n    }\r\n\r\n    if (info.version === 2) {\r\n        return info;\r\n    }\r\n\r\n    // Migrate a v1 info to v2\r\n    info = { ...info, version: 2, imageType: DefaultEnvironmentTextureImageType };\r\n\r\n    return info;\r\n}\r\n\r\n/**\r\n * Creates an environment texture from a loaded cube texture.\r\n * @param texture defines the cube texture to convert in env file\r\n * @param options options for the conversion process\r\n * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\r\n * @param options.imageQuality the image quality of encoded WebP images.\r\n * @return a promise containing the environment data if successful.\r\n */\r\nexport async function CreateEnvTextureAsync(texture: BaseTexture, options: CreateEnvTextureOptions = {}): Promise<ArrayBuffer> {\r\n    const internalTexture = texture.getInternalTexture();\r\n    if (!internalTexture) {\r\n        return Promise.reject(\"The cube texture is invalid.\");\r\n    }\r\n\r\n    const imageType = options.imageType ?? DefaultEnvironmentTextureImageType;\r\n\r\n    const engine = internalTexture.getEngine() as Engine;\r\n\r\n    if (\r\n        texture.textureType !== Constants.TEXTURETYPE_HALF_FLOAT &&\r\n        texture.textureType !== Constants.TEXTURETYPE_FLOAT &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_BYTE &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_INT &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_INTEGER &&\r\n        texture.textureType !== -1\r\n    ) {\r\n        return Promise.reject(\"The cube texture should allow HDR (Full Float or Half Float).\");\r\n    }\r\n\r\n    let textureType = Constants.TEXTURETYPE_FLOAT;\r\n    if (!engine.getCaps().textureFloatRender) {\r\n        textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        if (!engine.getCaps().textureHalfFloatRender) {\r\n            return Promise.reject(\"Env texture can only be created when the browser supports half float or full float rendering.\");\r\n        }\r\n    }\r\n\r\n    const cubeWidth = internalTexture.width;\r\n    const hostingScene = new Scene(engine);\r\n    const specularTextures: { [key: number]: ArrayBuffer } = {};\r\n\r\n    // As we are going to readPixels the faces of the cube, make sure the drawing/update commands for the cube texture are fully sent to the GPU in case it is drawn for the first time in this very frame!\r\n    engine.flushFramebuffer();\r\n\r\n    // Read and collect all mipmaps data from the cube.\r\n    const mipmapsCount = Scalar.ILog2(internalTexture.width);\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        const faceWidth = Math.pow(2, mipmapsCount - i);\r\n\r\n        // All faces of the cube.\r\n        for (let face = 0; face < 6; face++) {\r\n            let faceData = await texture.readPixels(face, i, undefined, false);\r\n            if (faceData && faceData.byteLength === (faceData as Uint8Array).length) {\r\n                const faceDataFloat = new Float32Array(faceData!.byteLength * 4);\r\n                for (let i = 0; i < faceData.byteLength; i++) {\r\n                    faceDataFloat[i] = (faceData as Uint8Array)[i] / 255;\r\n                    // Gamma to linear\r\n                    faceDataFloat[i] = Math.pow(faceDataFloat[i], 2.2);\r\n                }\r\n                faceData = faceDataFloat;\r\n            }\r\n\r\n            const tempTexture = engine.createRawTexture(\r\n                faceData,\r\n                faceWidth,\r\n                faceWidth,\r\n                Constants.TEXTUREFORMAT_RGBA,\r\n                false,\r\n                true,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                null,\r\n                textureType\r\n            );\r\n\r\n            await RGBDTextureTools.EncodeTextureToRGBD(tempTexture, hostingScene, textureType);\r\n\r\n            const rgbdEncodedData = await engine._readTexturePixels(tempTexture, faceWidth, faceWidth);\r\n\r\n            const imageEncodedData = await Tools.DumpDataAsync(faceWidth, faceWidth, rgbdEncodedData, imageType, undefined, false, true, options.imageQuality);\r\n\r\n            specularTextures[i * 6 + face] = imageEncodedData as ArrayBuffer;\r\n\r\n            tempTexture.dispose();\r\n        }\r\n    }\r\n\r\n    // We can delete the hosting scene keeping track of all the creation objects\r\n    hostingScene.dispose();\r\n\r\n    // Creates the json header for the env texture\r\n    const info: EnvironmentTextureInfo = {\r\n        version: CurrentVersion,\r\n        width: cubeWidth,\r\n        imageType,\r\n        irradiance: _CreateEnvTextureIrradiance(texture),\r\n        specular: {\r\n            mipmaps: [],\r\n            lodGenerationScale: texture.lodGenerationScale,\r\n        },\r\n    };\r\n\r\n    // Sets the specular image data information\r\n    let position = 0;\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        for (let face = 0; face < 6; face++) {\r\n            const byteLength = specularTextures[i * 6 + face].byteLength;\r\n            info.specular.mipmaps.push({\r\n                length: byteLength,\r\n                position: position,\r\n            });\r\n            position += byteLength;\r\n        }\r\n    }\r\n\r\n    // Encode the JSON as an array buffer\r\n    const infoString = JSON.stringify(info);\r\n    const infoBuffer = new ArrayBuffer(infoString.length + 1);\r\n    const infoView = new Uint8Array(infoBuffer); // Limited to ascii subset matching unicode.\r\n    for (let i = 0, strLen = infoString.length; i < strLen; i++) {\r\n        infoView[i] = infoString.charCodeAt(i);\r\n    }\r\n    // Ends up with a null terminator for easier parsing\r\n    infoView[infoString.length] = 0x00;\r\n\r\n    // Computes the final required size and creates the storage\r\n    const totalSize = MagicBytes.length + position + infoBuffer.byteLength;\r\n    const finalBuffer = new ArrayBuffer(totalSize);\r\n    const finalBufferView = new Uint8Array(finalBuffer);\r\n    const dataView = new DataView(finalBuffer);\r\n\r\n    // Copy the magic bytes identifying the file in\r\n    let pos = 0;\r\n    for (let i = 0; i < MagicBytes.length; i++) {\r\n        dataView.setUint8(pos++, MagicBytes[i]);\r\n    }\r\n\r\n    // Add the json info\r\n    finalBufferView.set(new Uint8Array(infoBuffer), pos);\r\n    pos += infoBuffer.byteLength;\r\n\r\n    // Finally inserts the texture data\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        for (let face = 0; face < 6; face++) {\r\n            const dataBuffer = specularTextures[i * 6 + face];\r\n            finalBufferView.set(new Uint8Array(dataBuffer), pos);\r\n            pos += dataBuffer.byteLength;\r\n        }\r\n    }\r\n\r\n    // Voila\r\n    return finalBuffer;\r\n}\r\n\r\n/**\r\n * Creates a JSON representation of the spherical data.\r\n * @param texture defines the texture containing the polynomials\r\n * @return the JSON representation of the spherical info\r\n */\r\nfunction _CreateEnvTextureIrradiance(texture: BaseTexture): Nullable<EnvironmentTextureIrradianceInfoV1> {\r\n    const polynmials = texture.sphericalPolynomial;\r\n    if (polynmials == null) {\r\n        return null;\r\n    }\r\n\r\n    return {\r\n        x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],\r\n        y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],\r\n        z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],\r\n\r\n        xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],\r\n        yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],\r\n        zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],\r\n\r\n        yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],\r\n        zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],\r\n        xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z],\r\n    } as any;\r\n}\r\n\r\n/**\r\n * Creates the ArrayBufferViews used for initializing environment texture image data.\r\n * @param data the image data\r\n * @param info parameters that determine what views will be created for accessing the underlying buffer\r\n * @return the views described by info providing access to the underlying buffer\r\n */\r\nexport function CreateImageDataArrayBufferViews(data: ArrayBufferView, info: EnvironmentTextureInfo): Array<Array<ArrayBufferView>> {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const specularInfo = info.specular as EnvironmentTextureSpecularInfoV1;\r\n\r\n    // Double checks the enclosed info\r\n    let mipmapsCount = Scalar.Log2(info.width);\r\n    mipmapsCount = Math.round(mipmapsCount) + 1;\r\n    if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {\r\n        throw new Error(`Unsupported specular mipmaps number \"${specularInfo.mipmaps.length}\"`);\r\n    }\r\n\r\n    const imageData = new Array<Array<ArrayBufferView>>(mipmapsCount);\r\n    for (let i = 0; i < mipmapsCount; i++) {\r\n        imageData[i] = new Array<ArrayBufferView>(6);\r\n        for (let face = 0; face < 6; face++) {\r\n            const imageInfo = specularInfo.mipmaps[i * 6 + face];\r\n            imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + specularInfo.specularDataPosition! + imageInfo.position, imageInfo.length);\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * Uploads the texture info contained in the env file to the GPU.\r\n * @param texture defines the internal texture to upload to\r\n * @param data defines the data to load\r\n * @param info defines the texture info retrieved through the GetEnvInfo method\r\n * @returns a promise\r\n */\r\nexport function UploadEnvLevelsAsync(texture: InternalTexture, data: ArrayBufferView, info: EnvironmentTextureInfo): Promise<void> {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const specularInfo = info.specular as EnvironmentTextureSpecularInfoV1;\r\n    if (!specularInfo) {\r\n        // Nothing else parsed so far\r\n        return Promise.resolve();\r\n    }\r\n\r\n    texture._lodGenerationScale = specularInfo.lodGenerationScale;\r\n\r\n    const imageData = CreateImageDataArrayBufferViews(data, info);\r\n\r\n    return UploadLevelsAsync(texture, imageData, info.imageType);\r\n}\r\n\r\nfunction _OnImageReadyAsync(\r\n    image: HTMLImageElement | ImageBitmap,\r\n    engine: Engine,\r\n    expandTexture: boolean,\r\n    rgbdPostProcess: Nullable<PostProcess>,\r\n    url: string,\r\n    face: number,\r\n    i: number,\r\n    generateNonLODTextures: boolean,\r\n    lodTextures: Nullable<{ [lod: number]: BaseTexture }>,\r\n    cubeRtt: Nullable<RenderTargetWrapper>,\r\n    texture: InternalTexture\r\n): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n        if (expandTexture) {\r\n            const tempTexture = engine.createTexture(\r\n                null,\r\n                true,\r\n                true,\r\n                null,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                null,\r\n                (message) => {\r\n                    reject(message);\r\n                },\r\n                image\r\n            );\r\n\r\n            rgbdPostProcess!.getEffect().executeWhenCompiled(() => {\r\n                // Uncompress the data to a RTT\r\n                rgbdPostProcess!.externalTextureSamplerBinding = true;\r\n                rgbdPostProcess!.onApply = (effect) => {\r\n                    effect._bindTexture(\"textureSampler\", tempTexture);\r\n                    effect.setFloat2(\"scale\", 1, engine._features.needsInvertingBitmap && image instanceof ImageBitmap ? -1 : 1);\r\n                };\r\n\r\n                if (!engine.scenes.length) {\r\n                    return;\r\n                }\r\n\r\n                engine.scenes[0].postProcessManager.directRender([rgbdPostProcess!], cubeRtt, true, face, i);\r\n\r\n                // Cleanup\r\n                engine.restoreDefaultFramebuffer();\r\n                tempTexture.dispose();\r\n                URL.revokeObjectURL(url);\r\n                resolve();\r\n            });\r\n        } else {\r\n            engine._uploadImageToTexture(texture, image, face, i);\r\n\r\n            // Upload the face to the non lod texture support\r\n            if (generateNonLODTextures) {\r\n                const lodTexture = lodTextures![i];\r\n                if (lodTexture) {\r\n                    engine._uploadImageToTexture(lodTexture._texture!, image, face, 0);\r\n                }\r\n            }\r\n            resolve();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Uploads the levels of image data to the GPU.\r\n * @param texture defines the internal texture to upload to\r\n * @param imageData defines the array buffer views of image data [mipmap][face]\r\n * @param imageType the mime type of the image data\r\n * @returns a promise\r\n */\r\nexport function UploadLevelsAsync(texture: InternalTexture, imageData: ArrayBufferView[][], imageType: string = DefaultEnvironmentTextureImageType): Promise<void> {\r\n    if (!Tools.IsExponentOfTwo(texture.width)) {\r\n        throw new Error(\"Texture size must be a power of two\");\r\n    }\r\n\r\n    const mipmapsCount = Scalar.ILog2(texture.width) + 1;\r\n\r\n    // Gets everything ready.\r\n    const engine = texture.getEngine() as Engine;\r\n    let expandTexture = false;\r\n    let generateNonLODTextures = false;\r\n    let rgbdPostProcess: Nullable<PostProcess> = null;\r\n    let cubeRtt: Nullable<RenderTargetWrapper> = null;\r\n    let lodTextures: Nullable<{ [lod: number]: BaseTexture }> = null;\r\n    const caps = engine.getCaps();\r\n\r\n    texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n    texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n    texture.generateMipMaps = true;\r\n    texture._cachedAnisotropicFilteringLevel = null;\r\n    engine.updateTextureSamplingMode(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, texture);\r\n\r\n    // Add extra process if texture lod is not supported\r\n    if (!caps.textureLOD) {\r\n        expandTexture = false;\r\n        generateNonLODTextures = true;\r\n        lodTextures = {};\r\n    }\r\n    // in webgl 1 there are no ways to either render or copy lod level information for float textures.\r\n    else if (!engine._features.supportRenderAndCopyToLodForFloatTextures) {\r\n        expandTexture = false;\r\n    }\r\n    // If half float available we can uncompress the texture\r\n    else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\r\n        expandTexture = true;\r\n        texture.type = Constants.TEXTURETYPE_HALF_FLOAT;\r\n    }\r\n    // If full float available we can uncompress the texture\r\n    else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\r\n        expandTexture = true;\r\n        texture.type = Constants.TEXTURETYPE_FLOAT;\r\n    }\r\n\r\n    // Expand the texture if possible\r\n    if (expandTexture) {\r\n        // Simply run through the decode PP\r\n        rgbdPostProcess = new PostProcess(\r\n            \"rgbdDecode\",\r\n            \"rgbdDecode\",\r\n            null,\r\n            null,\r\n            1,\r\n            null,\r\n            Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n            engine,\r\n            false,\r\n            undefined,\r\n            texture.type,\r\n            undefined,\r\n            null,\r\n            false\r\n        );\r\n\r\n        texture._isRGBD = false;\r\n        texture.invertY = false;\r\n        cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {\r\n            generateDepthBuffer: false,\r\n            generateMipMaps: true,\r\n            generateStencilBuffer: false,\r\n            samplingMode: Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n            type: texture.type,\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n        });\r\n    } else {\r\n        texture._isRGBD = true;\r\n        texture.invertY = true;\r\n\r\n        // In case of missing support, applies the same patch than DDS files.\r\n        if (generateNonLODTextures) {\r\n            const mipSlices = 3;\r\n            const scale = texture._lodGenerationScale;\r\n            const offset = texture._lodGenerationOffset;\r\n\r\n            for (let i = 0; i < mipSlices; i++) {\r\n                //compute LOD from even spacing in smoothness (matching shader calculation)\r\n                const smoothness = i / (mipSlices - 1);\r\n                const roughness = 1 - smoothness;\r\n\r\n                const minLODIndex = offset; // roughness = 0\r\n                const maxLODIndex = (mipmapsCount - 1) * scale + offset; // roughness = 1 (mipmaps start from 0)\r\n\r\n                const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\r\n                const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\r\n\r\n                const glTextureFromLod = new InternalTexture(engine, InternalTextureSource.Temp);\r\n                glTextureFromLod.isCube = true;\r\n                glTextureFromLod.invertY = true;\r\n                glTextureFromLod.generateMipMaps = false;\r\n                engine.updateTextureSamplingMode(Constants.TEXTURE_LINEAR_LINEAR, glTextureFromLod);\r\n\r\n                // Wrap in a base texture for easy binding.\r\n                const lodTexture = new BaseTexture(null);\r\n                lodTexture.isCube = true;\r\n                lodTexture._texture = glTextureFromLod;\r\n                lodTextures![mipmapIndex] = lodTexture;\r\n\r\n                switch (i) {\r\n                    case 0:\r\n                        texture._lodTextureLow = lodTexture;\r\n                        break;\r\n                    case 1:\r\n                        texture._lodTextureMid = lodTexture;\r\n                        break;\r\n                    case 2:\r\n                        texture._lodTextureHigh = lodTexture;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const promises: Promise<void>[] = [];\r\n    // All mipmaps up to provided number of images\r\n    for (let i = 0; i < imageData.length; i++) {\r\n        // All faces\r\n        for (let face = 0; face < 6; face++) {\r\n            // Constructs an image element from image data\r\n            const bytes = imageData[i][face];\r\n            const blob = new Blob([bytes], { type: imageType });\r\n            const url = URL.createObjectURL(blob);\r\n            let promise: Promise<void>;\r\n\r\n            if (typeof Image === \"undefined\" || engine._features.forceBitmapOverHTMLImageElement) {\r\n                promise = engine.createImageBitmap(blob, { premultiplyAlpha: \"none\" }).then((img) => {\r\n                    return _OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture);\r\n                });\r\n            } else {\r\n                const image = new Image();\r\n                image.src = url;\r\n\r\n                // Enqueue promise to upload to the texture.\r\n                promise = new Promise<void>((resolve, reject) => {\r\n                    image.onload = () => {\r\n                        _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture)\r\n                            .then(() => resolve())\r\n                            .catch((reason) => {\r\n                                reject(reason);\r\n                            });\r\n                    };\r\n                    image.onerror = (error) => {\r\n                        reject(error);\r\n                    };\r\n                });\r\n            }\r\n            promises.push(promise);\r\n        }\r\n    }\r\n\r\n    // Fill remaining mipmaps with black textures.\r\n    if (imageData.length < mipmapsCount) {\r\n        let data: ArrayBufferView;\r\n        const size = Math.pow(2, mipmapsCount - 1 - imageData.length);\r\n        const dataLength = size * size * 4;\r\n        switch (texture.type) {\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT: {\r\n                data = new Uint8Array(dataLength);\r\n                break;\r\n            }\r\n            case Constants.TEXTURETYPE_HALF_FLOAT: {\r\n                data = new Uint16Array(dataLength);\r\n                break;\r\n            }\r\n            case Constants.TEXTURETYPE_FLOAT: {\r\n                data = new Float32Array(dataLength);\r\n                break;\r\n            }\r\n        }\r\n        for (let i = imageData.length; i < mipmapsCount; i++) {\r\n            for (let face = 0; face < 6; face++) {\r\n                engine._uploadArrayBufferViewToTexture(texture, data!, face, i);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Once all done, finishes the cleanup and return\r\n    return Promise.all(promises).then(() => {\r\n        // Release temp RTT.\r\n        if (cubeRtt) {\r\n            engine._releaseTexture(texture);\r\n            cubeRtt._swapAndDie(texture);\r\n        }\r\n        // Release temp Post Process.\r\n        if (rgbdPostProcess) {\r\n            rgbdPostProcess.dispose();\r\n        }\r\n        // Flag internal texture as ready in case they are in use.\r\n        if (generateNonLODTextures) {\r\n            if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {\r\n                texture._lodTextureHigh._texture.isReady = true;\r\n            }\r\n            if (texture._lodTextureMid && texture._lodTextureMid._texture) {\r\n                texture._lodTextureMid._texture.isReady = true;\r\n            }\r\n            if (texture._lodTextureLow && texture._lodTextureLow._texture) {\r\n                texture._lodTextureLow._texture.isReady = true;\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Uploads spherical polynomials information to the texture.\r\n * @param texture defines the texture we are trying to upload the information to\r\n * @param info defines the environment texture info retrieved through the GetEnvInfo method\r\n */\r\nexport function UploadEnvSpherical(texture: InternalTexture, info: EnvironmentTextureInfo): void {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const irradianceInfo = info.irradiance as EnvironmentTextureIrradianceInfoV1;\r\n    if (!irradianceInfo) {\r\n        return;\r\n    }\r\n\r\n    const sp = new SphericalPolynomial();\r\n    Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);\r\n    Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);\r\n    Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);\r\n    Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);\r\n    Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);\r\n    Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);\r\n    Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);\r\n    Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);\r\n    Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);\r\n    texture._sphericalPolynomial = sp;\r\n}\r\n\r\n/**\r\n * @param internalTexture\r\n * @param data\r\n * @param sphericalPolynomial\r\n * @param lodScale\r\n * @param lodOffset\r\n * @hidden\r\n */\r\nexport function _UpdateRGBDAsync(\r\n    internalTexture: InternalTexture,\r\n    data: ArrayBufferView[][],\r\n    sphericalPolynomial: Nullable<SphericalPolynomial>,\r\n    lodScale: number,\r\n    lodOffset: number\r\n): Promise<InternalTexture> {\r\n    const proxy = internalTexture\r\n        .getEngine()\r\n        .createRawCubeTexture(\r\n            null,\r\n            internalTexture.width,\r\n            internalTexture.format,\r\n            internalTexture.type,\r\n            internalTexture.generateMipMaps,\r\n            internalTexture.invertY,\r\n            internalTexture.samplingMode,\r\n            internalTexture._compression\r\n        );\r\n    const proxyPromise = UploadLevelsAsync(proxy, data).then(() => internalTexture);\r\n    internalTexture.onRebuildCallback = (_internalTexture) => {\r\n        return {\r\n            proxy: proxyPromise,\r\n            isReady: true,\r\n            isAsync: true,\r\n        };\r\n    };\r\n    internalTexture._source = InternalTextureSource.CubeRawRGBD;\r\n    internalTexture._bufferViewArrayArray = data;\r\n    internalTexture._lodGenerationScale = lodScale;\r\n    internalTexture._lodGenerationOffset = lodOffset;\r\n    internalTexture._sphericalPolynomial = sphericalPolynomial;\r\n\r\n    return UploadLevelsAsync(internalTexture, data).then(() => {\r\n        internalTexture.isReady = true;\r\n        return internalTexture;\r\n    });\r\n}\r\n\r\n/**\r\n * Sets of helpers addressing the serialization and deserialization of environment texture\r\n * stored in a BabylonJS env file.\r\n * Those files are usually stored as .env files.\r\n */\r\nexport const EnvironmentTextureTools = {\r\n    /**\r\n     * Gets the environment info from an env file.\r\n     * @param data The array buffer containing the .env bytes.\r\n     * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\r\n     */\r\n    GetEnvInfo,\r\n\r\n    /**\r\n     * Creates an environment texture from a loaded cube texture.\r\n     * @param texture defines the cube texture to convert in env file\r\n     * @param options options for the conversion process\r\n     * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\r\n     * @param options.imageQuality the image quality of encoded WebP images.\r\n     * @return a promise containing the environment data if successful.\r\n     */\r\n    CreateEnvTextureAsync,\r\n\r\n    /**\r\n     * Creates the ArrayBufferViews used for initializing environment texture image data.\r\n     * @param data the image data\r\n     * @param info parameters that determine what views will be created for accessing the underlying buffer\r\n     * @return the views described by info providing access to the underlying buffer\r\n     */\r\n    CreateImageDataArrayBufferViews,\r\n\r\n    /**\r\n     * Uploads the texture info contained in the env file to the GPU.\r\n     * @param texture defines the internal texture to upload to\r\n     * @param data defines the data to load\r\n     * @param info defines the texture info retrieved through the GetEnvInfo method\r\n     * @returns a promise\r\n     */\r\n    UploadEnvLevelsAsync,\r\n\r\n    /**\r\n     * Uploads the levels of image data to the GPU.\r\n     * @param texture defines the internal texture to upload to\r\n     * @param imageData defines the array buffer views of image data [mipmap][face]\r\n     * @param imageType the mime type of the image data\r\n     * @returns a promise\r\n     */\r\n    UploadLevelsAsync,\r\n\r\n    /**\r\n     * Uploads spherical polynomials information to the texture.\r\n     * @param texture defines the texture we are trying to upload the information to\r\n     * @param info defines the environment texture info retrieved through the GetEnvInfo method\r\n     */\r\n    UploadEnvSpherical,\r\n};\r\n"]},"metadata":{},"sourceType":"module"}