{"ast":null,"code":"import { Vector3, TmpVectors, Matrix } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { CreateRibbon } from \"./ribbonBuilder.js\";\nimport { Path3D } from \"../../Maths/math.path.js\";\n/**\n * Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\n * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\n * * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.\n * * The parameter `scale` (float, default 1) is the value to scale the shape.\n * * The parameter `closeShape` (boolean, default false) closes the shape when true, since v5.0.0.\n * * The parameter `closePath` (boolean, default false) closes the path when true and no caps, since v5.0.0.\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\n * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.shape\n * @param options.path\n * @param options.scale\n * @param options.rotation\n * @param options.closeShape\n * @param options.closePath\n * @param options.cap\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.instance\n * @param options.invertUV\n * @param scene defines the hosting scene\n * @returns the extruded shape mesh\n * @see https://doc.babylonjs.com/how_to/parametric_shapes\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\n */\n\nexport function ExtrudeShape(name, options, scene) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  var path = options.path;\n  var shape = options.shape;\n  var scale = options.scale || 1;\n  var rotation = options.rotation || 0;\n  var cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\n  var updatable = options.updatable;\n\n  var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n\n  var instance = options.instance || null;\n  var invertUV = options.invertUV || false;\n  var closeShape = options.closeShape || false;\n  var closePath = options.closePath || false;\n  return _ExtrudeShapeGeneric(name, shape, path, scale, rotation, null, null, closePath, closeShape, cap, false, scene, updatable ? true : false, sideOrientation, instance, invertUV, options.frontUVs || null, options.backUVs || null);\n}\n/**\n * Creates an custom extruded shape mesh.\n * The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\n * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\n * * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the beginning of the path\n * * It must returns a float value that will be the rotation in radians applied to the shape on each path point.\n * * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the beginning of the path\n * * It must returns a float value that will be the scale value applied to the shape on each path point\n * * The parameter `closeShape` (boolean, default false) closes the shape when true, since v5.0.0.\n * * The parameter `closePath` (boolean, default false) closes the path when true and no caps, since v5.0.0.\n * * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray` - depreciated in favor of closeShape\n * * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray` - depreciated in favor of closePath\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\n * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.shape\n * @param options.path\n * @param options.scaleFunction\n * @param options.rotationFunction\n * @param options.ribbonCloseArray\n * @param options.ribbonClosePath\n * @param options.closeShape\n * @param options.closePath\n * @param options.cap\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.instance\n * @param options.invertUV\n * @param scene defines the hosting scene\n * @returns the custom extruded shape mesh\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#custom-extruded-shapes\n * @see https://doc.babylonjs.com/how_to/parametric_shapes\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\n */\n\nexport function ExtrudeShapeCustom(name, options, scene) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  var path = options.path;\n  var shape = options.shape;\n\n  var scaleFunction = options.scaleFunction || function () {\n    return 1;\n  };\n\n  var rotationFunction = options.rotationFunction || function () {\n    return 0;\n  };\n\n  var ribbonCloseArray = options.closePath || options.ribbonCloseArray || false;\n  var ribbonClosePath = options.closeShape || options.ribbonClosePath || false;\n  var cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\n  var updatable = options.updatable;\n\n  var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n\n  var instance = options.instance;\n  var invertUV = options.invertUV || false;\n  return _ExtrudeShapeGeneric(name, shape, path, null, null, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, true, scene, updatable ? true : false, sideOrientation, instance || null, invertUV, options.frontUVs || null, options.backUVs || null);\n}\n\nfunction _ExtrudeShapeGeneric(name, shape, curve, scale, rotation, scaleFunction, rotateFunction, rbCA, rbCP, cap, custom, scene, updtbl, side, instance, invertUV, frontUVs, backUVs) {\n  // extrusion geometry\n  var extrusionPathArray = function extrusionPathArray(shape, curve, path3D, shapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom) {\n    var tangents = path3D.getTangents();\n    var normals = path3D.getNormals();\n    var binormals = path3D.getBinormals();\n    var distances = path3D.getDistances();\n    var angle = 0;\n\n    var returnScale = function returnScale() {\n      return scale !== null ? scale : 1;\n    };\n\n    var returnRotation = function returnRotation() {\n      return rotation !== null ? rotation : 0;\n    };\n\n    var rotate = custom && rotateFunction ? rotateFunction : returnRotation;\n    var scl = custom && scaleFunction ? scaleFunction : returnScale;\n    var index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\n    var rotationMatrix = TmpVectors.Matrix[0];\n\n    for (var i = 0; i < curve.length; i++) {\n      var shapePath = new Array();\n      var angleStep = rotate(i, distances[i]);\n      var scaleRatio = scl(i, distances[i]);\n\n      for (var p = 0; p < shape.length; p++) {\n        Matrix.RotationAxisToRef(tangents[i], angle, rotationMatrix);\n        var planed = tangents[i].scale(shape[p].z).add(normals[i].scale(shape[p].x)).add(binormals[i].scale(shape[p].y));\n        var rotated = shapePath[p] ? shapePath[p] : Vector3.Zero();\n        Vector3.TransformCoordinatesToRef(planed, rotationMatrix, rotated);\n        rotated.scaleInPlace(scaleRatio).addInPlace(curve[i]);\n        shapePath[p] = rotated;\n      }\n\n      shapePaths[index] = shapePath;\n      angle += angleStep;\n      index++;\n    } // cap\n\n\n    var capPath = function capPath(shapePath) {\n      var pointCap = Array();\n      var barycenter = Vector3.Zero();\n      var i;\n\n      for (i = 0; i < shapePath.length; i++) {\n        barycenter.addInPlace(shapePath[i]);\n      }\n\n      barycenter.scaleInPlace(1.0 / shapePath.length);\n\n      for (i = 0; i < shapePath.length; i++) {\n        pointCap.push(barycenter);\n      }\n\n      return pointCap;\n    };\n\n    switch (cap) {\n      case Mesh.NO_CAP:\n        break;\n\n      case Mesh.CAP_START:\n        shapePaths[0] = capPath(shapePaths[2]);\n        shapePaths[1] = shapePaths[2];\n        break;\n\n      case Mesh.CAP_END:\n        shapePaths[index] = shapePaths[index - 1];\n        shapePaths[index + 1] = capPath(shapePaths[index - 1]);\n        break;\n\n      case Mesh.CAP_ALL:\n        shapePaths[0] = capPath(shapePaths[2]);\n        shapePaths[1] = shapePaths[2];\n        shapePaths[index] = shapePaths[index - 1];\n        shapePaths[index + 1] = capPath(shapePaths[index - 1]);\n        break;\n\n      default:\n        break;\n    }\n\n    return shapePaths;\n  };\n\n  var path3D;\n  var pathArray;\n\n  if (instance) {\n    // instance update\n    var storage = instance._creationDataStorage;\n    path3D = storage.path3D.update(curve);\n    pathArray = extrusionPathArray(shape, curve, storage.path3D, storage.pathArray, scale, rotation, scaleFunction, rotateFunction, storage.cap, custom);\n    instance = CreateRibbon(\"\", {\n      pathArray: pathArray,\n      closeArray: false,\n      closePath: false,\n      offset: 0,\n      updatable: false,\n      sideOrientation: 0,\n      instance: instance\n    }, scene || undefined);\n    return instance;\n  } // extruded shape creation\n\n\n  path3D = new Path3D(curve);\n  var newShapePaths = new Array();\n  cap = cap < 0 || cap > 3 ? 0 : cap;\n  pathArray = extrusionPathArray(shape, curve, path3D, newShapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom);\n  var extrudedGeneric = CreateRibbon(name, {\n    pathArray: pathArray,\n    closeArray: rbCA,\n    closePath: rbCP,\n    updatable: updtbl,\n    sideOrientation: side,\n    invertUV: invertUV,\n    frontUVs: frontUVs || undefined,\n    backUVs: backUVs || undefined\n  }, scene);\n  extrudedGeneric._creationDataStorage.pathArray = pathArray;\n  extrudedGeneric._creationDataStorage.path3D = path3D;\n  extrudedGeneric._creationDataStorage.cap = cap;\n  return extrudedGeneric;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated please use the functions directly from the module\n */\n\n\nexport var ShapeBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ExtrudeShape: ExtrudeShape,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ExtrudeShapeCustom: ExtrudeShapeCustom\n};\n\nMesh.ExtrudeShape = function (name, shape, path, scale, rotation, cap, scene, updatable, sideOrientation, instance) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  var options = {\n    shape: shape,\n    path: path,\n    scale: scale,\n    rotation: rotation,\n    cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\n    sideOrientation: sideOrientation,\n    instance: instance,\n    updatable: updatable\n  };\n  return ExtrudeShape(name, options, scene);\n};\n\nMesh.ExtrudeShapeCustom = function (name, shape, path, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, scene, updatable, sideOrientation, instance) {\n  var options = {\n    shape: shape,\n    path: path,\n    scaleFunction: scaleFunction,\n    rotationFunction: rotationFunction,\n    ribbonCloseArray: ribbonCloseArray,\n    ribbonClosePath: ribbonClosePath,\n    cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\n    sideOrientation: sideOrientation,\n    instance: instance,\n    updatable: updatable\n  };\n  return ExtrudeShapeCustom(name, options, scene);\n};","map":{"version":3,"mappings":"AAGA,SAASA,OAAT,EAAkBC,UAAlB,EAA8BC,MAA9B,QAA4C,4BAA5C;AACA,SAASC,IAAT,QAAqB,YAArB;AACA,SAASC,YAAT,QAA6B,oBAA7B;AACA,SAASC,MAAT,QAAuB,0BAAvB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA,OAAM,SAAUC,YAAV,CACFC,IADE,EAEFC,OAFE,EAiBFC,KAjBE,EAiB2B;AAA7B;AAAAA;AAA6B;;AAE7B,MAAMC,IAAI,GAAGF,OAAO,CAACE,IAArB;AACA,MAAMC,KAAK,GAAGH,OAAO,CAACG,KAAtB;AACA,MAAMC,KAAK,GAAGJ,OAAO,CAACI,KAAR,IAAiB,CAA/B;AACA,MAAMC,QAAQ,GAAGL,OAAO,CAACK,QAAR,IAAoB,CAArC;AACA,MAAMC,GAAG,GAAGN,OAAO,CAACM,GAAR,KAAgB,CAAhB,GAAoB,CAApB,GAAwBN,OAAO,CAACM,GAAR,IAAeX,IAAI,CAACY,MAAxD;AACA,MAAMC,SAAS,GAAGR,OAAO,CAACQ,SAA1B;;AACA,MAAMC,eAAe,GAAGd,IAAI,CAACe,0BAAL,CAAgCV,OAAO,CAACS,eAAxC,CAAxB;;AACA,MAAME,QAAQ,GAAGX,OAAO,CAACW,QAAR,IAAoB,IAArC;AACA,MAAMC,QAAQ,GAAGZ,OAAO,CAACY,QAAR,IAAoB,KAArC;AACA,MAAMC,UAAU,GAAGb,OAAO,CAACa,UAAR,IAAsB,KAAzC;AACA,MAAMC,SAAS,GAAGd,OAAO,CAACc,SAAR,IAAqB,KAAvC;AAEA,SAAOC,oBAAoB,CACvBhB,IADuB,EAEvBI,KAFuB,EAGvBD,IAHuB,EAIvBE,KAJuB,EAKvBC,QALuB,EAMvB,IANuB,EAOvB,IAPuB,EAQvBS,SARuB,EASvBD,UATuB,EAUvBP,GAVuB,EAWvB,KAXuB,EAYvBL,KAZuB,EAavBO,SAAS,GAAG,IAAH,GAAU,KAbI,EAcvBC,eAduB,EAevBE,QAfuB,EAgBvBC,QAhBuB,EAiBvBZ,OAAO,CAACgB,QAAR,IAAoB,IAjBG,EAkBvBhB,OAAO,CAACiB,OAAR,IAAmB,IAlBI,CAA3B;AAoBH;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CA,OAAM,SAAUC,kBAAV,CACFnB,IADE,EAEFC,OAFE,EAmBFC,KAnBE,EAmB2B;AAA7B;AAAAA;AAA6B;;AAE7B,MAAMC,IAAI,GAAGF,OAAO,CAACE,IAArB;AACA,MAAMC,KAAK,GAAGH,OAAO,CAACG,KAAtB;;AACA,MAAMgB,aAAa,GACfnB,OAAO,CAACmB,aAAR,IACC;AACG,WAAO,CAAP;AACH,GAJL;;AAKA,MAAMC,gBAAgB,GAClBpB,OAAO,CAACoB,gBAAR,IACC;AACG,WAAO,CAAP;AACH,GAJL;;AAKA,MAAMC,gBAAgB,GAAGrB,OAAO,CAACc,SAAR,IAAqBd,OAAO,CAACqB,gBAA7B,IAAiD,KAA1E;AACA,MAAMC,eAAe,GAAGtB,OAAO,CAACa,UAAR,IAAsBb,OAAO,CAACsB,eAA9B,IAAiD,KAAzE;AACA,MAAMhB,GAAG,GAAGN,OAAO,CAACM,GAAR,KAAgB,CAAhB,GAAoB,CAApB,GAAwBN,OAAO,CAACM,GAAR,IAAeX,IAAI,CAACY,MAAxD;AACA,MAAMC,SAAS,GAAGR,OAAO,CAACQ,SAA1B;;AACA,MAAMC,eAAe,GAAGd,IAAI,CAACe,0BAAL,CAAgCV,OAAO,CAACS,eAAxC,CAAxB;;AACA,MAAME,QAAQ,GAAGX,OAAO,CAACW,QAAzB;AACA,MAAMC,QAAQ,GAAGZ,OAAO,CAACY,QAAR,IAAoB,KAArC;AACA,SAAOG,oBAAoB,CACvBhB,IADuB,EAEvBI,KAFuB,EAGvBD,IAHuB,EAIvB,IAJuB,EAKvB,IALuB,EAMvBiB,aANuB,EAOvBC,gBAPuB,EAQvBC,gBARuB,EASvBC,eATuB,EAUvBhB,GAVuB,EAWvB,IAXuB,EAYvBL,KAZuB,EAavBO,SAAS,GAAG,IAAH,GAAU,KAbI,EAcvBC,eAduB,EAevBE,QAAQ,IAAI,IAfW,EAgBvBC,QAhBuB,EAiBvBZ,OAAO,CAACgB,QAAR,IAAoB,IAjBG,EAkBvBhB,OAAO,CAACiB,OAAR,IAAmB,IAlBI,CAA3B;AAoBH;;AAED,SAASF,oBAAT,CACIhB,IADJ,EAEII,KAFJ,EAGIoB,KAHJ,EAIInB,KAJJ,EAKIC,QALJ,EAMIc,aANJ,EAOIK,cAPJ,EAQIC,IARJ,EASIC,IATJ,EAUIpB,GAVJ,EAWIqB,MAXJ,EAYI1B,KAZJ,EAaI2B,MAbJ,EAcIC,IAdJ,EAeIlB,QAfJ,EAgBIC,QAhBJ,EAiBII,QAjBJ,EAkBIC,OAlBJ,EAkB8B;AAE1B;AACA,MAAMa,kBAAkB,GAAG,SAArBA,kBAAqB,CACvB3B,KADuB,EAEvBoB,KAFuB,EAGvBQ,MAHuB,EAIvBC,UAJuB,EAKvB5B,KALuB,EAMvBC,QANuB,EAOvBc,aAPuB,EAQvBK,cARuB,EASvBlB,GATuB,EAUvBqB,MAVuB,EAUR;AAEf,QAAMM,QAAQ,GAAGF,MAAM,CAACG,WAAP,EAAjB;AACA,QAAMC,OAAO,GAAGJ,MAAM,CAACK,UAAP,EAAhB;AACA,QAAMC,SAAS,GAAGN,MAAM,CAACO,YAAP,EAAlB;AACA,QAAMC,SAAS,GAAGR,MAAM,CAACS,YAAP,EAAlB;AAEA,QAAIC,KAAK,GAAG,CAAZ;;AACA,QAAMC,WAAW,GAAG,SAAdA,WAAc;AAChB,aAAOtC,KAAK,KAAK,IAAV,GAAiBA,KAAjB,GAAyB,CAAhC;AACH,KAFD;;AAGA,QAAMuC,cAAc,GAAG,SAAjBA,cAAiB;AACnB,aAAOtC,QAAQ,KAAK,IAAb,GAAoBA,QAApB,GAA+B,CAAtC;AACH,KAFD;;AAGA,QAAMuC,MAAM,GAA8CjB,MAAM,IAAIH,cAAV,GAA2BA,cAA3B,GAA4CmB,cAAtG;AACA,QAAME,GAAG,GAA8ClB,MAAM,IAAIR,aAAV,GAA0BA,aAA1B,GAA0CuB,WAAjG;AACA,QAAII,KAAK,GAAGxC,GAAG,KAAKX,IAAI,CAACY,MAAb,IAAuBD,GAAG,KAAKX,IAAI,CAACoD,OAApC,GAA8C,CAA9C,GAAkD,CAA9D;AACA,QAAMC,cAAc,GAAWvD,UAAU,CAACC,MAAX,CAAkB,CAAlB,CAA/B;;AAEA,SAAK,IAAIuD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG1B,KAAK,CAAC2B,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACnC,UAAME,SAAS,GAAG,IAAIC,KAAJ,EAAlB;AACA,UAAMC,SAAS,GAAGT,MAAM,CAACK,CAAD,EAAIV,SAAS,CAACU,CAAD,CAAb,CAAxB;AACA,UAAMK,UAAU,GAAGT,GAAG,CAACI,CAAD,EAAIV,SAAS,CAACU,CAAD,CAAb,CAAtB;;AACA,WAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpD,KAAK,CAAC+C,MAA1B,EAAkCK,CAAC,EAAnC,EAAuC;AACnC7D,cAAM,CAAC8D,iBAAP,CAAyBvB,QAAQ,CAACgB,CAAD,CAAjC,EAAsCR,KAAtC,EAA6CO,cAA7C;AACA,YAAMS,MAAM,GAAGxB,QAAQ,CAACgB,CAAD,CAAR,CAAY7C,KAAZ,CAAkBD,KAAK,CAACoD,CAAD,CAAL,CAASG,CAA3B,EAA8BC,GAA9B,CAAkCxB,OAAO,CAACc,CAAD,CAAP,CAAW7C,KAAX,CAAiBD,KAAK,CAACoD,CAAD,CAAL,CAASK,CAA1B,CAAlC,EAAgED,GAAhE,CAAoEtB,SAAS,CAACY,CAAD,CAAT,CAAa7C,KAAb,CAAmBD,KAAK,CAACoD,CAAD,CAAL,CAASM,CAA5B,CAApE,CAAf;AACA,YAAMC,OAAO,GAAGX,SAAS,CAACI,CAAD,CAAT,GAAeJ,SAAS,CAACI,CAAD,CAAxB,GAA8B/D,OAAO,CAACuE,IAAR,EAA9C;AACAvE,eAAO,CAACwE,yBAAR,CAAkCP,MAAlC,EAA0CT,cAA1C,EAA0Dc,OAA1D;AACAA,eAAO,CAACG,YAAR,CAAqBX,UAArB,EAAiCY,UAAjC,CAA4C3C,KAAK,CAAC0B,CAAD,CAAjD;AACAE,iBAAS,CAACI,CAAD,CAAT,GAAeO,OAAf;AACH;;AACD9B,gBAAU,CAACc,KAAD,CAAV,GAAoBK,SAApB;AACAV,WAAK,IAAIY,SAAT;AACAP,WAAK;AACR,KAlCc,CAmCf;;;AACA,QAAMqB,OAAO,GAAG,SAAVA,OAAU,CAAChB,SAAD,EAAqB;AACjC,UAAMiB,QAAQ,GAAGhB,KAAK,EAAtB;AACA,UAAMiB,UAAU,GAAG7E,OAAO,CAACuE,IAAR,EAAnB;AACA,UAAId,CAAJ;;AACA,WAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGE,SAAS,CAACD,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACnCoB,kBAAU,CAACH,UAAX,CAAsBf,SAAS,CAACF,CAAD,CAA/B;AACH;;AACDoB,gBAAU,CAACJ,YAAX,CAAwB,MAAMd,SAAS,CAACD,MAAxC;;AACA,WAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGE,SAAS,CAACD,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACnCmB,gBAAQ,CAACE,IAAT,CAAcD,UAAd;AACH;;AACD,aAAOD,QAAP;AACH,KAZD;;AAaA,YAAQ9D,GAAR;AACI,WAAKX,IAAI,CAACY,MAAV;AACI;;AACJ,WAAKZ,IAAI,CAAC4E,SAAV;AACIvC,kBAAU,CAAC,CAAD,CAAV,GAAgBmC,OAAO,CAACnC,UAAU,CAAC,CAAD,CAAX,CAAvB;AACAA,kBAAU,CAAC,CAAD,CAAV,GAAgBA,UAAU,CAAC,CAAD,CAA1B;AACA;;AACJ,WAAKrC,IAAI,CAACoD,OAAV;AACIf,kBAAU,CAACc,KAAD,CAAV,GAAoBd,UAAU,CAACc,KAAK,GAAG,CAAT,CAA9B;AACAd,kBAAU,CAACc,KAAK,GAAG,CAAT,CAAV,GAAwBqB,OAAO,CAACnC,UAAU,CAACc,KAAK,GAAG,CAAT,CAAX,CAA/B;AACA;;AACJ,WAAKnD,IAAI,CAAC6E,OAAV;AACIxC,kBAAU,CAAC,CAAD,CAAV,GAAgBmC,OAAO,CAACnC,UAAU,CAAC,CAAD,CAAX,CAAvB;AACAA,kBAAU,CAAC,CAAD,CAAV,GAAgBA,UAAU,CAAC,CAAD,CAA1B;AACAA,kBAAU,CAACc,KAAD,CAAV,GAAoBd,UAAU,CAACc,KAAK,GAAG,CAAT,CAA9B;AACAd,kBAAU,CAACc,KAAK,GAAG,CAAT,CAAV,GAAwBqB,OAAO,CAACnC,UAAU,CAACc,KAAK,GAAG,CAAT,CAAX,CAA/B;AACA;;AACJ;AACI;AAlBR;;AAoBA,WAAOd,UAAP;AACH,GAhFD;;AAiFA,MAAID,MAAJ;AACA,MAAI0C,SAAJ;;AACA,MAAI9D,QAAJ,EAAc;AACV;AACA,QAAM+D,OAAO,GAAG/D,QAAQ,CAACgE,oBAAzB;AACA5C,UAAM,GAAG2C,OAAO,CAAC3C,MAAR,CAAe6C,MAAf,CAAsBrD,KAAtB,CAAT;AACAkD,aAAS,GAAG3C,kBAAkB,CAAC3B,KAAD,EAAQoB,KAAR,EAAemD,OAAO,CAAC3C,MAAvB,EAA+B2C,OAAO,CAACD,SAAvC,EAAkDrE,KAAlD,EAAyDC,QAAzD,EAAmEc,aAAnE,EAAkFK,cAAlF,EAAkGkD,OAAO,CAACpE,GAA1G,EAA+GqB,MAA/G,CAA9B;AACAhB,YAAQ,GAAGf,YAAY,CAAC,EAAD,EAAK;AAAE6E,eAAS,WAAX;AAAaI,gBAAU,EAAE,KAAzB;AAAgC/D,eAAS,EAAE,KAA3C;AAAkDgE,YAAM,EAAE,CAA1D;AAA6DtE,eAAS,EAAE,KAAxE;AAA+EC,qBAAe,EAAE,CAAhG;AAAmGE,cAAQ;AAA3G,KAAL,EAAoHV,KAAK,IAAI8E,SAA7H,CAAvB;AAEA,WAAOpE,QAAP;AACH,GA9FyB,CA+F1B;;;AACAoB,QAAM,GAAQ,IAAIlC,MAAJ,CAAW0B,KAAX,CAAd;AACA,MAAMyD,aAAa,GAAG,IAAI5B,KAAJ,EAAtB;AACA9C,KAAG,GAAGA,GAAG,GAAG,CAAN,IAAWA,GAAG,GAAG,CAAjB,GAAqB,CAArB,GAAyBA,GAA/B;AACAmE,WAAS,GAAG3C,kBAAkB,CAAC3B,KAAD,EAAQoB,KAAR,EAAeQ,MAAf,EAAuBiD,aAAvB,EAAsC5E,KAAtC,EAA6CC,QAA7C,EAAuDc,aAAvD,EAAsEK,cAAtE,EAAsFlB,GAAtF,EAA2FqB,MAA3F,CAA9B;AACA,MAAMsD,eAAe,GAAGrF,YAAY,CAChCG,IADgC,EAEhC;AACI0E,aAAS,EAAEA,SADf;AAEII,cAAU,EAAEpD,IAFhB;AAGIX,aAAS,EAAEY,IAHf;AAIIlB,aAAS,EAAEoB,MAJf;AAKInB,mBAAe,EAAEoB,IALrB;AAMIjB,YAAQ,EAAEA,QANd;AAOII,YAAQ,EAAEA,QAAQ,IAAI+D,SAP1B;AAQI9D,WAAO,EAAEA,OAAO,IAAI8D;AARxB,GAFgC,EAYhC9E,KAZgC,CAApC;AAcAgF,iBAAe,CAACN,oBAAhB,CAAsCF,SAAtC,GAAkDA,SAAlD;AACAQ,iBAAe,CAACN,oBAAhB,CAAsC5C,MAAtC,GAA+CA,MAA/C;AACAkD,iBAAe,CAACN,oBAAhB,CAAsCrE,GAAtC,GAA4CA,GAA5C;AAEA,SAAO2E,eAAP;AACH;AAED;;;;;;AAIA,OAAO,IAAMC,YAAY,GAAG;AACxB;AACApF,cAAY,cAFY;AAGxB;AACAoB,oBAAkB;AAJM,CAArB;;AAONvB,IAAY,CAACG,YAAb,GAA4B,UACzBC,IADyB,EAEzBI,KAFyB,EAGzBD,IAHyB,EAIzBE,KAJyB,EAKzBC,QALyB,EAMzBC,GANyB,EAOzBL,KAPyB,EAQzBO,SARyB,EASzBC,eATyB,EAUzBE,QAVyB,EAUV;AAHf;AAAAV;AAA6B;;AAK7B,MAAMD,OAAO,GAAG;AACZG,SAAK,EAAEA,KADK;AAEZD,QAAI,EAAEA,IAFM;AAGZE,SAAK,EAAEA,KAHK;AAIZC,YAAQ,EAAEA,QAJE;AAKZC,OAAG,EAAEA,GAAG,KAAK,CAAR,GAAY,CAAZ,GAAgBA,GAAG,IAAIX,IAAI,CAACY,MALrB;AAMZE,mBAAe,EAAEA,eANL;AAOZE,YAAQ,EAAEA,QAPE;AAQZH,aAAS,EAAEA;AARC,GAAhB;AAWA,SAAOV,YAAY,CAACC,IAAD,EAAOC,OAAP,EAAgBC,KAAhB,CAAnB;AACH,CAxBA;;AA0BAN,IAAY,CAACuB,kBAAb,GAAkC,UAC/BnB,IAD+B,EAE/BI,KAF+B,EAG/BD,IAH+B,EAI/BiB,aAJ+B,EAK/BC,gBAL+B,EAM/BC,gBAN+B,EAO/BC,eAP+B,EAQ/BhB,GAR+B,EAS/BL,KAT+B,EAU/BO,SAV+B,EAW/BC,eAX+B,EAY/BE,QAZ+B,EAYhB;AAEf,MAAMX,OAAO,GAAG;AACZG,SAAK,EAAEA,KADK;AAEZD,QAAI,EAAEA,IAFM;AAGZiB,iBAAa,EAAEA,aAHH;AAIZC,oBAAgB,EAAEA,gBAJN;AAKZC,oBAAgB,EAAEA,gBALN;AAMZC,mBAAe,EAAEA,eANL;AAOZhB,OAAG,EAAEA,GAAG,KAAK,CAAR,GAAY,CAAZ,GAAgBA,GAAG,IAAIX,IAAI,CAACY,MAPrB;AAQZE,mBAAe,EAAEA,eARL;AASZE,YAAQ,EAAEA,QATE;AAUZH,aAAS,EAAEA;AAVC,GAAhB;AAaA,SAAOU,kBAAkB,CAACnB,IAAD,EAAOC,OAAP,EAAgBC,KAAhB,CAAzB;AACH,CA5BA","names":["Vector3","TmpVectors","Matrix","Mesh","CreateRibbon","Path3D","ExtrudeShape","name","options","scene","path","shape","scale","rotation","cap","NO_CAP","updatable","sideOrientation","_GetDefaultSideOrientation","instance","invertUV","closeShape","closePath","_ExtrudeShapeGeneric","frontUVs","backUVs","ExtrudeShapeCustom","scaleFunction","rotationFunction","ribbonCloseArray","ribbonClosePath","curve","rotateFunction","rbCA","rbCP","custom","updtbl","side","extrusionPathArray","path3D","shapePaths","tangents","getTangents","normals","getNormals","binormals","getBinormals","distances","getDistances","angle","returnScale","returnRotation","rotate","scl","index","CAP_END","rotationMatrix","i","length","shapePath","Array","angleStep","scaleRatio","p","RotationAxisToRef","planed","z","add","x","y","rotated","Zero","TransformCoordinatesToRef","scaleInPlace","addInPlace","capPath","pointCap","barycenter","push","CAP_START","CAP_ALL","pathArray","storage","_creationDataStorage","update","closeArray","offset","undefined","newShapePaths","extrudedGeneric","ShapeBuilder"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Meshes/Builders/shapeBuilder.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, TmpVectors, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { CreateRibbon } from \"./ribbonBuilder\";\r\nimport { Path3D } from \"../../Maths/math.path\";\r\n\r\n/**\r\n * Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n * * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.\r\n * * The parameter `scale` (float, default 1) is the value to scale the shape.\r\n * * The parameter `closeShape` (boolean, default false) closes the shape when true, since v5.0.0.\r\n * * The parameter `closePath` (boolean, default false) closes the path when true and no caps, since v5.0.0.\r\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\r\n * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.shape\r\n * @param options.path\r\n * @param options.scale\r\n * @param options.rotation\r\n * @param options.closeShape\r\n * @param options.closePath\r\n * @param options.cap\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.instance\r\n * @param options.invertUV\r\n * @param scene defines the hosting scene\r\n * @returns the extruded shape mesh\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\r\n */\r\nexport function ExtrudeShape(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        path: Vector3[];\r\n        scale?: number;\r\n        rotation?: number;\r\n        closeShape?: boolean;\r\n        closePath?: boolean;\r\n        cap?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        instance?: Mesh;\r\n        invertUV?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const path = options.path;\r\n    const shape = options.shape;\r\n    const scale = options.scale || 1;\r\n    const rotation = options.rotation || 0;\r\n    const cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\r\n    const updatable = options.updatable;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const instance = options.instance || null;\r\n    const invertUV = options.invertUV || false;\r\n    const closeShape = options.closeShape || false;\r\n    const closePath = options.closePath || false;\r\n\r\n    return _ExtrudeShapeGeneric(\r\n        name,\r\n        shape,\r\n        path,\r\n        scale,\r\n        rotation,\r\n        null,\r\n        null,\r\n        closePath,\r\n        closeShape,\r\n        cap,\r\n        false,\r\n        scene,\r\n        updatable ? true : false,\r\n        sideOrientation,\r\n        instance,\r\n        invertUV,\r\n        options.frontUVs || null,\r\n        options.backUVs || null\r\n    );\r\n}\r\n\r\n/**\r\n * Creates an custom extruded shape mesh.\r\n * The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n * * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the beginning of the path\r\n * * It must returns a float value that will be the rotation in radians applied to the shape on each path point.\r\n * * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the beginning of the path\r\n * * It must returns a float value that will be the scale value applied to the shape on each path point\r\n * * The parameter `closeShape` (boolean, default false) closes the shape when true, since v5.0.0.\r\n * * The parameter `closePath` (boolean, default false) closes the path when true and no caps, since v5.0.0.\r\n * * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray` - depreciated in favor of closeShape\r\n * * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray` - depreciated in favor of closePath\r\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\r\n * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.shape\r\n * @param options.path\r\n * @param options.scaleFunction\r\n * @param options.rotationFunction\r\n * @param options.ribbonCloseArray\r\n * @param options.ribbonClosePath\r\n * @param options.closeShape\r\n * @param options.closePath\r\n * @param options.cap\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.instance\r\n * @param options.invertUV\r\n * @param scene defines the hosting scene\r\n * @returns the custom extruded shape mesh\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#custom-extruded-shapes\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\r\n */\r\nexport function ExtrudeShapeCustom(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        path: Vector3[];\r\n        scaleFunction?: Nullable<{ (i: number, distance: number): number }>;\r\n        rotationFunction?: Nullable<{ (i: number, distance: number): number }>;\r\n        ribbonCloseArray?: boolean;\r\n        ribbonClosePath?: boolean;\r\n        closeShape?: boolean;\r\n        closePath?: boolean;\r\n        cap?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        instance?: Mesh;\r\n        invertUV?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const path = options.path;\r\n    const shape = options.shape;\r\n    const scaleFunction =\r\n        options.scaleFunction ||\r\n        (() => {\r\n            return 1;\r\n        });\r\n    const rotationFunction =\r\n        options.rotationFunction ||\r\n        (() => {\r\n            return 0;\r\n        });\r\n    const ribbonCloseArray = options.closePath || options.ribbonCloseArray || false;\r\n    const ribbonClosePath = options.closeShape || options.ribbonClosePath || false;\r\n    const cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\r\n    const updatable = options.updatable;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const instance = options.instance;\r\n    const invertUV = options.invertUV || false;\r\n    return _ExtrudeShapeGeneric(\r\n        name,\r\n        shape,\r\n        path,\r\n        null,\r\n        null,\r\n        scaleFunction,\r\n        rotationFunction,\r\n        ribbonCloseArray,\r\n        ribbonClosePath,\r\n        cap,\r\n        true,\r\n        scene,\r\n        updatable ? true : false,\r\n        sideOrientation,\r\n        instance || null,\r\n        invertUV,\r\n        options.frontUVs || null,\r\n        options.backUVs || null\r\n    );\r\n}\r\n\r\nfunction _ExtrudeShapeGeneric(\r\n    name: string,\r\n    shape: Vector3[],\r\n    curve: Vector3[],\r\n    scale: Nullable<number>,\r\n    rotation: Nullable<number>,\r\n    scaleFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    rotateFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    rbCA: boolean,\r\n    rbCP: boolean,\r\n    cap: number,\r\n    custom: boolean,\r\n    scene: Nullable<Scene>,\r\n    updtbl: boolean,\r\n    side: number,\r\n    instance: Nullable<Mesh>,\r\n    invertUV: boolean,\r\n    frontUVs: Nullable<Vector4>,\r\n    backUVs: Nullable<Vector4>\r\n): Mesh {\r\n    // extrusion geometry\r\n    const extrusionPathArray = (\r\n        shape: Vector3[],\r\n        curve: Vector3[],\r\n        path3D: Path3D,\r\n        shapePaths: Vector3[][],\r\n        scale: Nullable<number>,\r\n        rotation: Nullable<number>,\r\n        scaleFunction: Nullable<{ (i: number, distance: number): number }>,\r\n        rotateFunction: Nullable<{ (i: number, distance: number): number }>,\r\n        cap: number,\r\n        custom: boolean\r\n    ) => {\r\n        const tangents = path3D.getTangents();\r\n        const normals = path3D.getNormals();\r\n        const binormals = path3D.getBinormals();\r\n        const distances = path3D.getDistances();\r\n\r\n        let angle = 0;\r\n        const returnScale = () => {\r\n            return scale !== null ? scale : 1;\r\n        };\r\n        const returnRotation = () => {\r\n            return rotation !== null ? rotation : 0;\r\n        };\r\n        const rotate: { (i: number, distance: number): number } = custom && rotateFunction ? rotateFunction : returnRotation;\r\n        const scl: { (i: number, distance: number): number } = custom && scaleFunction ? scaleFunction : returnScale;\r\n        let index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\r\n        const rotationMatrix: Matrix = TmpVectors.Matrix[0];\r\n\r\n        for (let i = 0; i < curve.length; i++) {\r\n            const shapePath = new Array<Vector3>();\r\n            const angleStep = rotate(i, distances[i]);\r\n            const scaleRatio = scl(i, distances[i]);\r\n            for (let p = 0; p < shape.length; p++) {\r\n                Matrix.RotationAxisToRef(tangents[i], angle, rotationMatrix);\r\n                const planed = tangents[i].scale(shape[p].z).add(normals[i].scale(shape[p].x)).add(binormals[i].scale(shape[p].y));\r\n                const rotated = shapePath[p] ? shapePath[p] : Vector3.Zero();\r\n                Vector3.TransformCoordinatesToRef(planed, rotationMatrix, rotated);\r\n                rotated.scaleInPlace(scaleRatio).addInPlace(curve[i]);\r\n                shapePath[p] = rotated;\r\n            }\r\n            shapePaths[index] = shapePath;\r\n            angle += angleStep;\r\n            index++;\r\n        }\r\n        // cap\r\n        const capPath = (shapePath: Vector3[]) => {\r\n            const pointCap = Array<Vector3>();\r\n            const barycenter = Vector3.Zero();\r\n            let i: number;\r\n            for (i = 0; i < shapePath.length; i++) {\r\n                barycenter.addInPlace(shapePath[i]);\r\n            }\r\n            barycenter.scaleInPlace(1.0 / shapePath.length);\r\n            for (i = 0; i < shapePath.length; i++) {\r\n                pointCap.push(barycenter);\r\n            }\r\n            return pointCap;\r\n        };\r\n        switch (cap) {\r\n            case Mesh.NO_CAP:\r\n                break;\r\n            case Mesh.CAP_START:\r\n                shapePaths[0] = capPath(shapePaths[2]);\r\n                shapePaths[1] = shapePaths[2];\r\n                break;\r\n            case Mesh.CAP_END:\r\n                shapePaths[index] = shapePaths[index - 1];\r\n                shapePaths[index + 1] = capPath(shapePaths[index - 1]);\r\n                break;\r\n            case Mesh.CAP_ALL:\r\n                shapePaths[0] = capPath(shapePaths[2]);\r\n                shapePaths[1] = shapePaths[2];\r\n                shapePaths[index] = shapePaths[index - 1];\r\n                shapePaths[index + 1] = capPath(shapePaths[index - 1]);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        return shapePaths;\r\n    };\r\n    let path3D;\r\n    let pathArray;\r\n    if (instance) {\r\n        // instance update\r\n        const storage = instance._creationDataStorage!;\r\n        path3D = storage.path3D.update(curve);\r\n        pathArray = extrusionPathArray(shape, curve, storage.path3D, storage.pathArray, scale, rotation, scaleFunction, rotateFunction, storage.cap, custom);\r\n        instance = CreateRibbon(\"\", { pathArray, closeArray: false, closePath: false, offset: 0, updatable: false, sideOrientation: 0, instance }, scene || undefined);\r\n\r\n        return instance;\r\n    }\r\n    // extruded shape creation\r\n    path3D = <any>new Path3D(curve);\r\n    const newShapePaths = new Array<Array<Vector3>>();\r\n    cap = cap < 0 || cap > 3 ? 0 : cap;\r\n    pathArray = extrusionPathArray(shape, curve, path3D, newShapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom);\r\n    const extrudedGeneric = CreateRibbon(\r\n        name,\r\n        {\r\n            pathArray: pathArray,\r\n            closeArray: rbCA,\r\n            closePath: rbCP,\r\n            updatable: updtbl,\r\n            sideOrientation: side,\r\n            invertUV: invertUV,\r\n            frontUVs: frontUVs || undefined,\r\n            backUVs: backUVs || undefined,\r\n        },\r\n        scene\r\n    );\r\n    extrudedGeneric._creationDataStorage!.pathArray = pathArray;\r\n    extrudedGeneric._creationDataStorage!.path3D = path3D;\r\n    extrudedGeneric._creationDataStorage!.cap = cap;\r\n\r\n    return extrudedGeneric;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated please use the functions directly from the module\r\n */\r\nexport const ShapeBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    ExtrudeShape,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    ExtrudeShapeCustom,\r\n};\r\n\r\n(Mesh as any).ExtrudeShape = (\r\n    name: string,\r\n    shape: Vector3[],\r\n    path: Vector3[],\r\n    scale: number,\r\n    rotation: number,\r\n    cap: number,\r\n    scene: Nullable<Scene> = null,\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        path: path,\r\n        scale: scale,\r\n        rotation: rotation,\r\n        cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return ExtrudeShape(name, options, scene);\r\n};\r\n\r\n(Mesh as any).ExtrudeShapeCustom = (\r\n    name: string,\r\n    shape: Vector3[],\r\n    path: Vector3[],\r\n    scaleFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    rotationFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    ribbonCloseArray: boolean,\r\n    ribbonClosePath: boolean,\r\n    cap: number,\r\n    scene: Scene,\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        path: path,\r\n        scaleFunction: scaleFunction,\r\n        rotationFunction: rotationFunction,\r\n        ribbonCloseArray: ribbonCloseArray,\r\n        ribbonClosePath: ribbonClosePath,\r\n        cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return ExtrudeShapeCustom(name, options, scene);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}