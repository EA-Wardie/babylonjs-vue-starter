{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport { __extends } from \"tslib\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { Texture } from \"../../../Textures/texture.js\";\n/**\n * Base block used for the particle texture\n */\n\nvar ParticleTextureBlock =\n/** @class */\nfunction (_super) {\n  __extends(ParticleTextureBlock, _super);\n  /**\n   * Create a new ParticleTextureBlock\n   * @param name defines the block name\n   */\n\n\n  function ParticleTextureBlock(name) {\n    var _this = _super.call(this, name, NodeMaterialBlockTargets.Fragment) || this;\n\n    _this._samplerName = \"diffuseSampler\";\n    /**\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\n     */\n\n    _this.convertToGammaSpace = false;\n    /**\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\n     */\n\n    _this.convertToLinearSpace = false;\n    _this._isUnique = false;\n\n    _this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, false, NodeMaterialBlockTargets.VertexAndFragment);\n\n    _this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);\n\n    return _this;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n\n\n  ParticleTextureBlock.prototype.getClassName = function () {\n    return \"ParticleTextureBlock\";\n  };\n\n  Object.defineProperty(ParticleTextureBlock.prototype, \"uv\", {\n    /**\n     * Gets the uv input component\n     */\n    get: function get() {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleTextureBlock.prototype, \"rgba\", {\n    /**\n     * Gets the rgba output component\n     */\n    get: function get() {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleTextureBlock.prototype, \"rgb\", {\n    /**\n     * Gets the rgb output component\n     */\n    get: function get() {\n      return this._outputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleTextureBlock.prototype, \"r\", {\n    /**\n     * Gets the r output component\n     */\n    get: function get() {\n      return this._outputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleTextureBlock.prototype, \"g\", {\n    /**\n     * Gets the g output component\n     */\n    get: function get() {\n      return this._outputs[3];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleTextureBlock.prototype, \"b\", {\n    /**\n     * Gets the b output component\n     */\n    get: function get() {\n      return this._outputs[4];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleTextureBlock.prototype, \"a\", {\n    /**\n     * Gets the a output component\n     */\n    get: function get() {\n      return this._outputs[5];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n\n  ParticleTextureBlock.prototype.initialize = function (state) {\n    state._excludeVariableName(\"diffuseSampler\");\n  };\n\n  ParticleTextureBlock.prototype.autoConfigure = function (material) {\n    if (!this.uv.isConnected) {\n      var uvInput = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"particle_uv\";\n      });\n\n      if (!uvInput) {\n        uvInput = new InputBlock(\"uv\");\n        uvInput.setAsAttribute(\"particle_uv\");\n      }\n\n      uvInput.output.connectTo(this.uv);\n    }\n  };\n\n  ParticleTextureBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);\n    defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);\n  };\n\n  ParticleTextureBlock.prototype.isReady = function () {\n    if (this.texture && !this.texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n\n    return true;\n  };\n\n  ParticleTextureBlock.prototype._writeOutput = function (state, output, swizzle) {\n    state.compilationString += \"\".concat(this._declareOutput(output, state), \" = \").concat(this._tempTextureRead, \".\").concat(swizzle, \";\\r\\n\");\n    state.compilationString += \"#ifdef \".concat(this._linearDefineName, \"\\r\\n\");\n    state.compilationString += \"\".concat(output.associatedVariableName, \" = toGammaSpace(\").concat(output.associatedVariableName, \");\\r\\n\");\n    state.compilationString += \"#endif\\r\\n\";\n    state.compilationString += \"#ifdef \".concat(this._gammaDefineName, \"\\r\\n\");\n    state.compilationString += \"\".concat(output.associatedVariableName, \" = toLinearSpace(\").concat(output.associatedVariableName, \");\\r\\n\");\n    state.compilationString += \"#endif\\r\\n\";\n  };\n\n  ParticleTextureBlock.prototype._buildBlock = function (state) {\n    _super.prototype._buildBlock.call(this, state);\n\n    if (state.target === NodeMaterialBlockTargets.Vertex) {\n      return;\n    }\n\n    this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\n\n    state._emit2DSampler(this._samplerName);\n\n    state.sharedData.blockingBlocks.push(this);\n    state.sharedData.textureBlocks.push(this);\n    state.sharedData.blocksWithDefines.push(this);\n    this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\n    this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\n    var comments = \"//\".concat(this.name);\n\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n\n    state.compilationString += \"vec4 \".concat(this._tempTextureRead, \" = texture2D(\").concat(this._samplerName, \", \").concat(this.uv.associatedVariableName, \");\\r\\n\");\n\n    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {\n      var output = _a[_i];\n\n      if (output.hasEndpoints) {\n        this._writeOutput(state, output, output.name);\n      }\n    }\n\n    return this;\n  };\n\n  ParticleTextureBlock.prototype.serialize = function () {\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n    serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n\n    if (this.texture && !this.texture.isRenderTarget) {\n      serializationObject.texture = this.texture.serialize();\n    }\n\n    return serializationObject;\n  };\n\n  ParticleTextureBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {\n    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);\n\n    this.convertToGammaSpace = serializationObject.convertToGammaSpace;\n    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\n\n    if (serializationObject.texture) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n    }\n  };\n\n  return ParticleTextureBlock;\n}(NodeMaterialBlock);\n\nexport { ParticleTextureBlock };\nRegisterClass(\"BABYLON.ParticleTextureBlock\", ParticleTextureBlock);","map":{"version":3,"mappings":"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","names":["NodeMaterialBlock","NodeMaterialBlockConnectionPointTypes","NodeMaterialBlockTargets","InputBlock","RegisterClass","Texture","__extends","name","_super","Fragment","_this","_isUnique","registerInput","Vector2","VertexAndFragment","registerOutput","Color4","Neutral","Color3","Float","_inputs","acceptedConnectionPointTypes","push","Vector3","Vector4","ParticleTextureBlock","Object","_outputs","state","_excludeVariableName","material","uv","isConnected","uvInput","getInputBlockByPredicate","b","isAttribute","setAsAttribute","output","connectTo","mesh","nodeMaterial","defines","setValue","_linearDefineName","convertToGammaSpace","_gammaDefineName","convertToLinearSpace","texture","isReadyOrNotBlocking","swizzle","compilationString","_declareOutput","concat","_tempTextureRead","associatedVariableName","_buildBlock","call","target","Vertex","_getFreeVariableName","_emit2DSampler","_samplerName","sharedData","blockingBlocks","textureBlocks","blocksWithDefines","_getFreeDefineName","comments","_emitFunctionFromInclude","_i","hasEndpoints","_writeOutput","serializationObject","serialize","isRenderTarget","scene","rootUrl","_deserialize","url","indexOf","Parse"],"sourceRoot":"","sources":["../../../../../../../../lts/core/generated/Materials/Node/Blocks/Particle/particleTextureBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport type { Scene } from \"../../../../scene\";\r\n\r\ndeclare type NodeMaterial = import(\"../../nodeMaterial\").NodeMaterial;\r\n\r\n/**\r\n * Base block used for the particle texture\r\n */\r\nexport class ParticleTextureBlock extends NodeMaterialBlock {\r\n    private _samplerName = \"diffuseSampler\";\r\n    private _linearDefineName: string;\r\n    private _gammaDefineName: string;\r\n    private _tempTextureRead: string;\r\n\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\r\n     */\r\n    public convertToGammaSpace = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\r\n     */\r\n    public convertToLinearSpace = false;\r\n\r\n    /**\r\n     * Create a new ParticleTextureBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = false;\r\n\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, false, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ParticleTextureBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba output component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb output component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the r output component\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the g output component\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the b output component\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the a output component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"diffuseSampler\");\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial) {\r\n        if (!this.uv.isConnected) {\r\n            let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"particle_uv\");\r\n\r\n            if (!uvInput) {\r\n                uvInput = new InputBlock(\"uv\");\r\n                uvInput.setAsAttribute(\"particle_uv\");\r\n            }\r\n            uvInput.output.connectTo(this.uv);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);\r\n        defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);\r\n    }\r\n\r\n    public isReady() {\r\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _writeOutput(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string) {\r\n        state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\r\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._linearDefineName}\\r\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._gammaDefineName}\\r\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            return;\r\n        }\r\n\r\n        this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\r\n\r\n        state._emit2DSampler(this._samplerName);\r\n\r\n        state.sharedData.blockingBlocks.push(this);\r\n        state.sharedData.textureBlocks.push(this);\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\r\n        this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${this.uv.associatedVariableName});\\r\\n`;\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, output.name);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        if (this.texture && !this.texture.isRenderTarget) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n\r\n        if (serializationObject.texture) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl) as Texture;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ParticleTextureBlock\", ParticleTextureBlock);\r\n"]},"metadata":{},"sourceType":"module"}