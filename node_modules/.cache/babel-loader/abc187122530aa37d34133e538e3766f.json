{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { PostProcess } from \"./postProcess.js\";\nimport \"../Shaders/tonemap.fragment.js\";\n/** Defines operator used for tonemapping */\n\nexport var TonemappingOperator;\n\n(function (TonemappingOperator) {\n  /** Hable */\n  TonemappingOperator[TonemappingOperator[\"Hable\"] = 0] = \"Hable\";\n  /** Reinhard */\n\n  TonemappingOperator[TonemappingOperator[\"Reinhard\"] = 1] = \"Reinhard\";\n  /** HejiDawson */\n\n  TonemappingOperator[TonemappingOperator[\"HejiDawson\"] = 2] = \"HejiDawson\";\n  /** Photographic */\n\n  TonemappingOperator[TonemappingOperator[\"Photographic\"] = 3] = \"Photographic\";\n})(TonemappingOperator || (TonemappingOperator = {}));\n/**\n * Defines a post process to apply tone mapping\n */\n\n\nvar TonemapPostProcess =\n/** @class */\nfunction (_super) {\n  __extends(TonemapPostProcess, _super);\n  /**\n   * Creates a new TonemapPostProcess\n   * @param name defines the name of the postprocess\n   * @param _operator defines the operator to use\n   * @param exposureAdjustment defines the required exposure adjustment\n   * @param camera defines the camera to use (can be null)\n   * @param samplingMode defines the required sampling mode (BABYLON.Texture.BILINEAR_SAMPLINGMODE by default)\n   * @param engine defines the hosting engine (can be ignore if camera is set)\n   * @param textureFormat defines the texture format to use (BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT by default)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   */\n\n\n  function TonemapPostProcess(name, _operator,\n  /** Defines the required exposure adjustment */\n  exposureAdjustment, camera, samplingMode, engine, textureFormat, reusable) {\n    if (samplingMode === void 0) {\n      samplingMode = 2;\n    }\n\n    if (textureFormat === void 0) {\n      textureFormat = 0;\n    }\n\n    var _this = _super.call(this, name, \"tonemap\", [\"_ExposureAdjustment\"], null, 1.0, camera, samplingMode, engine, reusable, null, textureFormat) || this;\n\n    _this._operator = _operator;\n    _this.exposureAdjustment = exposureAdjustment;\n    var defines = \"#define \";\n\n    if (_this._operator === TonemappingOperator.Hable) {\n      defines += \"HABLE_TONEMAPPING\";\n    } else if (_this._operator === TonemappingOperator.Reinhard) {\n      defines += \"REINHARD_TONEMAPPING\";\n    } else if (_this._operator === TonemappingOperator.HejiDawson) {\n      defines += \"OPTIMIZED_HEJIDAWSON_TONEMAPPING\";\n    } else if (_this._operator === TonemappingOperator.Photographic) {\n      defines += \"PHOTOGRAPHIC_TONEMAPPING\";\n    } //sadly a second call to create the effect.\n\n\n    _this.updateEffect(defines);\n\n    _this.onApply = function (effect) {\n      effect.setFloat(\"_ExposureAdjustment\", _this.exposureAdjustment);\n    };\n\n    return _this;\n  }\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"TonemapPostProcess\" string\n   */\n\n\n  TonemapPostProcess.prototype.getClassName = function () {\n    return \"TonemapPostProcess\";\n  };\n\n  return TonemapPostProcess;\n}(PostProcess);\n\nexport { TonemapPostProcess };","map":{"version":3,"mappings":";AAEA,SAASA,WAAT,QAA4B,kBAA5B;AAGA,OAAO,gCAAP;AAIA;;AACA,WAAYC,mBAAZ;;AAAA,WAAYA,mBAAZ,EAA+B;AAC3B;AACAA;AACA;;AACAA;AACA;;AACAA;AACA;;AACAA;AACH,CATD,EAAYA,mBAAmB,KAAnBA,mBAAmB,MAA/B;AAWA;;;;;AAGA;AAAA;AAAA;AAAwCC;AASpC;;;;;;;;;;;;;AAWA,8BACIC,IADJ,EAEYC,SAFZ;AAGI;AACOC,oBAJX,EAKIC,MALJ,EAMIC,YANJ,EAOIC,MAPJ,EAQIC,aARJ,EASIC,QATJ,EASsB;AAHlB;AAAAH,qBAAuB,CAAvB;AAAuB;;AAEvB;AAAAE,sBAAgB,CAAhB;AAAgB;;AARpB,gBAWIE,kBAAMR,IAAN,EAAY,SAAZ,EAAuB,CAAC,qBAAD,CAAvB,EAAgD,IAAhD,EAAsD,GAAtD,EAA2DG,MAA3D,EAAmEC,YAAnE,EAAiFC,MAAjF,EAAyFE,QAAzF,EAAmG,IAAnG,EAAyGD,aAAzG,KAAuH,IAX3H;;AAEYG;AAEDA;AASP,QAAIC,OAAO,GAAG,UAAd;;AAEA,QAAID,KAAI,CAACR,SAAL,KAAmBH,mBAAmB,CAACa,KAA3C,EAAkD;AAC9CD,aAAO,IAAI,mBAAX;AACH,KAFD,MAEO,IAAID,KAAI,CAACR,SAAL,KAAmBH,mBAAmB,CAACc,QAA3C,EAAqD;AACxDF,aAAO,IAAI,sBAAX;AACH,KAFM,MAEA,IAAID,KAAI,CAACR,SAAL,KAAmBH,mBAAmB,CAACe,UAA3C,EAAuD;AAC1DH,aAAO,IAAI,kCAAX;AACH,KAFM,MAEA,IAAID,KAAI,CAACR,SAAL,KAAmBH,mBAAmB,CAACgB,YAA3C,EAAyD;AAC5DJ,aAAO,IAAI,0BAAX;AACH,KAdiB,CAgBlB;;;AACAD,SAAI,CAACM,YAAL,CAAkBL,OAAlB;;AAEAD,SAAI,CAACO,OAAL,GAAe,UAACC,MAAD,EAAe;AAC1BA,YAAM,CAACC,QAAP,CAAgB,qBAAhB,EAAuCT,KAAI,CAACP,kBAA5C;AACH,KAFD;;;AAGH;AAlDD;;;;;;AAIOiB,8CAAP;AACI,WAAO,oBAAP;AACH,GAFM;;AA+CX;AAAC,CApDD,CAAwCtB,WAAxC","names":["PostProcess","TonemappingOperator","__extends","name","_operator","exposureAdjustment","camera","samplingMode","engine","textureFormat","reusable","_super","_this","defines","Hable","Reinhard","HejiDawson","Photographic","updateEffect","onApply","effect","setFloat","TonemapPostProcess"],"sourceRoot":"","sources":["../../../../../lts/core/generated/PostProcesses/tonemapPostProcess.ts"],"sourcesContent":["import type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/tonemap.fragment\";\r\n\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\n\r\n/** Defines operator used for tonemapping */\r\nexport enum TonemappingOperator {\r\n    /** Hable */\r\n    Hable = 0,\r\n    /** Reinhard */\r\n    Reinhard = 1,\r\n    /** HejiDawson */\r\n    HejiDawson = 2,\r\n    /** Photographic */\r\n    Photographic = 3,\r\n}\r\n\r\n/**\r\n * Defines a post process to apply tone mapping\r\n */\r\nexport class TonemapPostProcess extends PostProcess {\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"TonemapPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"TonemapPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new TonemapPostProcess\r\n     * @param name defines the name of the postprocess\r\n     * @param _operator defines the operator to use\r\n     * @param exposureAdjustment defines the required exposure adjustment\r\n     * @param camera defines the camera to use (can be null)\r\n     * @param samplingMode defines the required sampling mode (BABYLON.Texture.BILINEAR_SAMPLINGMODE by default)\r\n     * @param engine defines the hosting engine (can be ignore if camera is set)\r\n     * @param textureFormat defines the texture format to use (BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        private _operator: TonemappingOperator,\r\n        /** Defines the required exposure adjustment */\r\n        public exposureAdjustment: number,\r\n        camera: Camera,\r\n        samplingMode: number = Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\r\n        engine?: Engine,\r\n        textureFormat = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        reusable?: boolean\r\n    ) {\r\n        super(name, \"tonemap\", [\"_ExposureAdjustment\"], null, 1.0, camera, samplingMode, engine, reusable, null, textureFormat);\r\n\r\n        let defines = \"#define \";\r\n\r\n        if (this._operator === TonemappingOperator.Hable) {\r\n            defines += \"HABLE_TONEMAPPING\";\r\n        } else if (this._operator === TonemappingOperator.Reinhard) {\r\n            defines += \"REINHARD_TONEMAPPING\";\r\n        } else if (this._operator === TonemappingOperator.HejiDawson) {\r\n            defines += \"OPTIMIZED_HEJIDAWSON_TONEMAPPING\";\r\n        } else if (this._operator === TonemappingOperator.Photographic) {\r\n            defines += \"PHOTOGRAPHIC_TONEMAPPING\";\r\n        }\r\n\r\n        //sadly a second call to create the effect.\r\n        this.updateEffect(defines);\r\n\r\n        this.onApply = (effect: Effect) => {\r\n            effect.setFloat(\"_ExposureAdjustment\", this.exposureAdjustment);\r\n        };\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}