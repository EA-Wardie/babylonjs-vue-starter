{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Scene } from \"../scene.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport \"../Shaders/outline.fragment.js\";\nimport \"../Shaders/outline.vertex.js\";\n/**\n * Gets the outline renderer associated with the scene\n * @returns a OutlineRenderer\n */\n\nScene.prototype.getOutlineRenderer = function () {\n  if (!this._outlineRenderer) {\n    this._outlineRenderer = new OutlineRenderer(this);\n  }\n\n  return this._outlineRenderer;\n};\n\nObject.defineProperty(Mesh.prototype, \"renderOutline\", {\n  get: function get() {\n    return this._renderOutline;\n  },\n  set: function set(value) {\n    if (value) {\n      // Lazy Load the component.\n      this.getScene().getOutlineRenderer();\n    }\n\n    this._renderOutline = value;\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(Mesh.prototype, \"renderOverlay\", {\n  get: function get() {\n    return this._renderOverlay;\n  },\n  set: function set(value) {\n    if (value) {\n      // Lazy Load the component.\n      this.getScene().getOutlineRenderer();\n    }\n\n    this._renderOverlay = value;\n  },\n  enumerable: true,\n  configurable: true\n});\n/**\n * This class is responsible to draw the outline/overlay of meshes.\n * It should not be used directly but through the available method on mesh.\n */\n\nvar OutlineRenderer =\n/** @class */\nfunction () {\n  /**\n   * Instantiates a new outline renderer. (There could be only one per scene).\n   * @param scene Defines the scene it belongs to\n   */\n  function OutlineRenderer(scene) {\n    /**\n     * The name of the component. Each component must have a unique name.\n     */\n    this.name = SceneComponentConstants.NAME_OUTLINERENDERER;\n    /**\n     * Defines a zOffset default Factor to prevent zFighting between the overlay and the mesh.\n     */\n\n    this.zOffset = 1;\n    /**\n     * Defines a zOffset default Unit to prevent zFighting between the overlay and the mesh.\n     */\n\n    this.zOffsetUnits = 4; // 4 to account for projection a bit by default\n\n    this.scene = scene;\n    this._engine = scene.getEngine();\n\n    this.scene._addComponent(this);\n\n    this._passIdForDrawWrapper = [];\n\n    for (var i = 0; i < 4; ++i) {\n      this._passIdForDrawWrapper[i] = this._engine.createRenderPassId(\"Outline Renderer (\".concat(i, \")\"));\n    }\n  }\n  /**\n   * Register the component to one instance of a scene.\n   */\n\n\n  OutlineRenderer.prototype.register = function () {\n    this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE, this, this._beforeRenderingMesh);\n\n    this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE, this, this._afterRenderingMesh);\n  };\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n\n\n  OutlineRenderer.prototype.rebuild = function () {// Nothing to do here.\n  };\n  /**\n   * Disposes the component and the associated resources.\n   */\n\n\n  OutlineRenderer.prototype.dispose = function () {\n    for (var i = 0; i < this._passIdForDrawWrapper.length; ++i) {\n      this._engine.releaseRenderPassId(this._passIdForDrawWrapper[i]);\n    }\n  };\n  /**\n   * Renders the outline in the canvas.\n   * @param subMesh Defines the sumesh to render\n   * @param batch Defines the batch of meshes in case of instances\n   * @param useOverlay Defines if the rendering is for the overlay or the outline\n   * @param renderPassId Render pass id to use to render the mesh\n   */\n\n\n  OutlineRenderer.prototype.render = function (subMesh, batch, useOverlay, renderPassId) {\n    if (useOverlay === void 0) {\n      useOverlay = false;\n    }\n\n    renderPassId = renderPassId !== null && renderPassId !== void 0 ? renderPassId : this._passIdForDrawWrapper[0];\n    var scene = this.scene;\n    var engine = scene.getEngine();\n    var hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined || subMesh.getRenderingMesh().hasThinInstances);\n\n    if (!this.isReady(subMesh, hardwareInstancedRendering, renderPassId)) {\n      return;\n    }\n\n    var ownerMesh = subMesh.getMesh();\n    var replacementMesh = ownerMesh._internalAbstractMeshDataInfo._actAsRegularMesh ? ownerMesh : null;\n    var renderingMesh = subMesh.getRenderingMesh();\n    var effectiveMesh = replacementMesh ? replacementMesh : renderingMesh;\n    var material = subMesh.getMaterial();\n\n    if (!material || !scene.activeCamera) {\n      return;\n    }\n\n    var drawWrapper = subMesh._getDrawWrapper(renderPassId);\n\n    var effect = DrawWrapper.GetEffect(drawWrapper);\n    engine.enableEffect(drawWrapper); // Logarithmic depth\n\n    if (material.useLogarithmicDepth) {\n      effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(scene.activeCamera.maxZ + 1.0) / Math.LN2));\n    }\n\n    effect.setFloat(\"offset\", useOverlay ? 0 : renderingMesh.outlineWidth);\n    effect.setColor4(\"color\", useOverlay ? renderingMesh.overlayColor : renderingMesh.outlineColor, useOverlay ? renderingMesh.overlayAlpha : material.alpha);\n    effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n    effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix()); // Bones\n\n    if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n      effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\n    }\n\n    if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n      renderingMesh.morphTargetManager._bind(effect);\n    } // Morph targets\n\n\n    MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\n\n    if (!hardwareInstancedRendering) {\n      renderingMesh._bind(subMesh, effect, material.fillMode);\n    } // Alpha test\n\n\n    if (material && material.needAlphaTesting()) {\n      var alphaTexture = material.getAlphaTestTexture();\n\n      if (alphaTexture) {\n        effect.setTexture(\"diffuseSampler\", alphaTexture);\n        effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n      }\n    } // Clip plane\n\n\n    MaterialHelper.BindClipPlane(effect, scene);\n    engine.setZOffset(-this.zOffset);\n    engine.setZOffsetUnits(-this.zOffsetUnits);\n\n    renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, function (isInstance, world) {\n      effect.setMatrix(\"world\", world);\n    });\n\n    engine.setZOffset(0);\n    engine.setZOffsetUnits(0);\n  };\n  /**\n   * Returns whether or not the outline renderer is ready for a given submesh.\n   * All the dependencies e.g. submeshes, texture, effect... mus be ready\n   * @param subMesh Defines the submesh to check readiness for\n   * @param useInstances Defines whether wee are trying to render instances or not\n   * @param renderPassId Render pass id to use to render the mesh\n   * @returns true if ready otherwise false\n   */\n\n\n  OutlineRenderer.prototype.isReady = function (subMesh, useInstances, renderPassId) {\n    renderPassId = renderPassId !== null && renderPassId !== void 0 ? renderPassId : this._passIdForDrawWrapper[0];\n    var defines = [];\n    var attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\n    var mesh = subMesh.getMesh();\n    var material = subMesh.getMaterial();\n    var scene = mesh.getScene();\n\n    if (material) {\n      // Alpha test\n      if (material.needAlphaTesting()) {\n        defines.push(\"#define ALPHATEST\");\n\n        if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n          attribs.push(VertexBuffer.UVKind);\n          defines.push(\"#define UV1\");\n        }\n\n        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n          attribs.push(VertexBuffer.UV2Kind);\n          defines.push(\"#define UV2\");\n        }\n      } //Logarithmic depth\n\n\n      if (material.useLogarithmicDepth) {\n        defines.push(\"#define LOGARITHMICDEPTH\");\n      }\n    } // Bones\n\n\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    } // Morph targets\n\n\n    var morphTargetManager = mesh.morphTargetManager;\n    var numMorphInfluencers = 0;\n\n    if (morphTargetManager) {\n      if (morphTargetManager.numInfluencers > 0) {\n        numMorphInfluencers = morphTargetManager.numInfluencers;\n        defines.push(\"#define MORPHTARGETS\");\n        defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\n\n        if (morphTargetManager.isUsingTextureForTargets) {\n          defines.push(\"#define MORPHTARGETS_TEXTURE\");\n        }\n\n        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\n      }\n    } // Instances\n\n\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs);\n\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    } // Clip planes\n\n\n    if (scene.clipPlane) {\n      defines.push(\"#define CLIPPLANE\");\n    }\n\n    if (scene.clipPlane2) {\n      defines.push(\"#define CLIPPLANE2\");\n    }\n\n    if (scene.clipPlane3) {\n      defines.push(\"#define CLIPPLANE3\");\n    }\n\n    if (scene.clipPlane4) {\n      defines.push(\"#define CLIPPLANE4\");\n    }\n\n    if (scene.clipPlane5) {\n      defines.push(\"#define CLIPPLANE5\");\n    }\n\n    if (scene.clipPlane6) {\n      defines.push(\"#define CLIPPLANE6\");\n    } // Get correct effect\n\n\n    var drawWrapper = subMesh._getDrawWrapper(renderPassId, true);\n\n    var cachedDefines = drawWrapper.defines;\n    var join = defines.join(\"\\n\");\n\n    if (cachedDefines !== join) {\n      drawWrapper.setEffect(this.scene.getEngine().createEffect(\"outline\", attribs, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"offset\", \"color\", \"logarithmicDepthConstant\", \"morphTargetInfluences\", \"morphTargetTextureInfo\", \"morphTargetTextureIndices\", \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\"], [\"diffuseSampler\", \"morphTargets\"], join, undefined, undefined, undefined, {\n        maxSimultaneousMorphTargets: numMorphInfluencers\n      }), join);\n    }\n\n    return drawWrapper.effect.isReady();\n  };\n\n  OutlineRenderer.prototype._beforeRenderingMesh = function (mesh, subMesh, batch) {\n    // Outline - step 1\n    this._savedDepthWrite = this._engine.getDepthWrite();\n\n    if (mesh.renderOutline) {\n      var material = subMesh.getMaterial();\n\n      if (material && material.needAlphaBlendingForMesh(mesh)) {\n        this._engine.cacheStencilState(); // Draw only to stencil buffer for the original mesh\n        // The resulting stencil buffer will be used so the outline is not visible inside the mesh when the mesh is transparent\n\n\n        this._engine.setDepthWrite(false);\n\n        this._engine.setColorWrite(false);\n\n        this._engine.setStencilBuffer(true);\n\n        this._engine.setStencilOperationPass(7681);\n\n        this._engine.setStencilFunction(519);\n\n        this._engine.setStencilMask(OutlineRenderer._StencilReference);\n\n        this._engine.setStencilFunctionReference(OutlineRenderer._StencilReference);\n\n        this._engine.stencilStateComposer.useStencilGlobalOnly = true;\n        this.render(subMesh, batch,\n        /* This sets offset to 0 */\n        true, this._passIdForDrawWrapper[1]);\n\n        this._engine.setColorWrite(true);\n\n        this._engine.setStencilFunction(517);\n      } // Draw the outline using the above stencil if needed to avoid drawing within the mesh\n\n\n      this._engine.setDepthWrite(false);\n\n      this.render(subMesh, batch, false, this._passIdForDrawWrapper[0]);\n\n      this._engine.setDepthWrite(this._savedDepthWrite);\n\n      if (material && material.needAlphaBlendingForMesh(mesh)) {\n        this._engine.stencilStateComposer.useStencilGlobalOnly = false;\n\n        this._engine.restoreStencilState();\n      }\n    }\n  };\n\n  OutlineRenderer.prototype._afterRenderingMesh = function (mesh, subMesh, batch) {\n    // Overlay\n    if (mesh.renderOverlay) {\n      var currentMode = this._engine.getAlphaMode();\n\n      var alphaBlendState = this._engine.alphaState.alphaBlend;\n\n      this._engine.setAlphaMode(2);\n\n      this.render(subMesh, batch, true, this._passIdForDrawWrapper[3]);\n\n      this._engine.setAlphaMode(currentMode);\n\n      this._engine.setDepthWrite(this._savedDepthWrite);\n\n      this._engine.alphaState.alphaBlend = alphaBlendState;\n    } // Outline - step 2\n\n\n    if (mesh.renderOutline && this._savedDepthWrite) {\n      this._engine.setDepthWrite(true);\n\n      this._engine.setColorWrite(false);\n\n      this.render(subMesh, batch, false, this._passIdForDrawWrapper[2]);\n\n      this._engine.setColorWrite(true);\n    }\n  };\n  /**\n   * Stencil value used to avoid outline being seen within the mesh when the mesh is transparent\n   */\n\n\n  OutlineRenderer._StencilReference = 0x04;\n  return OutlineRenderer;\n}();\n\nexport { OutlineRenderer };","map":{"version":3,"mappings":"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","names":["VertexBuffer","Mesh","Scene","SceneComponentConstants","DrawWrapper","MaterialHelper","prototype","getOutlineRenderer","_outlineRenderer","OutlineRenderer","Object","defineProperty","get","_renderOutline","set","value","getScene","enumerable","configurable","_renderOverlay","scene","NAME_OUTLINERENDERER","_engine","getEngine","_addComponent","_passIdForDrawWrapper","i","createRenderPassId","_beforeRenderingMeshStage","registerStep","STEP_BEFORERENDERINGMESH_OUTLINE","_beforeRenderingMesh","_afterRenderingMeshStage","STEP_AFTERRENDERINGMESH_OUTLINE","_afterRenderingMesh","length","releaseRenderPassId","subMesh","batch","useOverlay","renderPassId","engine","hardwareInstancedRendering","getCaps","instancedArrays","visibleInstances","_id","undefined","getRenderingMesh","hasThinInstances","isReady","ownerMesh","getMesh","replacementMesh","_internalAbstractMeshDataInfo","_actAsRegularMesh","renderingMesh","effectiveMesh","material","getMaterial","activeCamera","drawWrapper","_getDrawWrapper","effect","GetEffect","enableEffect","useLogarithmicDepth","setFloat","Math","log","maxZ","LN2","outlineWidth","setColor4","overlayColor","outlineColor","overlayAlpha","alpha","setMatrix","getTransformMatrix","getWorldMatrix","useBones","computeBonesUsingShaders","skeleton","setMatrices","getTransformMatrices","morphTargetManager","isUsingTextureForTargets","_bind","BindMorphTargetParameters","fillMode","needAlphaTesting","alphaTexture","getAlphaTestTexture","setTexture","getTextureMatrix","BindClipPlane","setZOffset","zOffset","setZOffsetUnits","zOffsetUnits","_processRendering","isInstance","world","useInstances","defines","attribs","PositionKind","NormalKind","mesh","push","isVerticesDataPresent","UVKind","UV2Kind","MatricesIndicesKind","MatricesWeightsKind","numBoneInfluencers","MatricesIndicesExtraKind","MatricesWeightsExtraKind","bones","numMorphInfluencers","numInfluencers","PrepareAttributesForMorphTargetsInfluencers","PushAttributesForInstances","clipPlane","clipPlane2","clipPlane3","clipPlane4","clipPlane5","clipPlane6","cachedDefines","join","setEffect","createEffect","maxSimultaneousMorphTargets","_savedDepthWrite","getDepthWrite","renderOutline","needAlphaBlendingForMesh","cacheStencilState","setDepthWrite","setColorWrite","setStencilBuffer","setStencilOperationPass","setStencilFunction","setStencilMask","_StencilReference","setStencilFunctionReference","stencilStateComposer","useStencilGlobalOnly","render","restoreStencilState","renderOverlay","currentMode","getAlphaMode","alphaBlendState","alphaState","alphaBlend","setAlphaMode"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Rendering/outlineRenderer.ts"],"sourcesContent":["import { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { _InstancesBatch } from \"../Meshes/mesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Scene } from \"../scene\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\n\r\nimport \"../Shaders/outline.fragment\";\r\nimport \"../Shaders/outline.vertex\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @hidden */\r\n        _outlineRenderer: OutlineRenderer;\r\n\r\n        /**\r\n         * Gets the outline renderer associated with the scene\r\n         * @returns a OutlineRenderer\r\n         */\r\n        getOutlineRenderer(): OutlineRenderer;\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the outline renderer associated with the scene\r\n * @returns a OutlineRenderer\r\n */\r\nScene.prototype.getOutlineRenderer = function (): OutlineRenderer {\r\n    if (!this._outlineRenderer) {\r\n        this._outlineRenderer = new OutlineRenderer(this);\r\n    }\r\n    return this._outlineRenderer;\r\n};\r\n\r\ndeclare module \"../Meshes/abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /** @hidden (Backing field) */\r\n        _renderOutline: boolean;\r\n        /**\r\n         * Gets or sets a boolean indicating if the outline must be rendered as well\r\n         * @see https://www.babylonjs-playground.com/#10WJ5S#3\r\n         */\r\n        renderOutline: boolean;\r\n\r\n        /** @hidden (Backing field) */\r\n        _renderOverlay: boolean;\r\n        /**\r\n         * Gets or sets a boolean indicating if the overlay must be rendered as well\r\n         * @see https://www.babylonjs-playground.com/#10WJ5S#2\r\n         */\r\n        renderOverlay: boolean;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Mesh.prototype, \"renderOutline\", {\r\n    get: function (this: Mesh) {\r\n        return this._renderOutline;\r\n    },\r\n    set: function (this: Mesh, value: boolean) {\r\n        if (value) {\r\n            // Lazy Load the component.\r\n            this.getScene().getOutlineRenderer();\r\n        }\r\n        this._renderOutline = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(Mesh.prototype, \"renderOverlay\", {\r\n    get: function (this: Mesh) {\r\n        return this._renderOverlay;\r\n    },\r\n    set: function (this: Mesh, value: boolean) {\r\n        if (value) {\r\n            // Lazy Load the component.\r\n            this.getScene().getOutlineRenderer();\r\n        }\r\n        this._renderOverlay = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\n/**\r\n * This class is responsible to draw the outline/overlay of meshes.\r\n * It should not be used directly but through the available method on mesh.\r\n */\r\nexport class OutlineRenderer implements ISceneComponent {\r\n    /**\r\n     * Stencil value used to avoid outline being seen within the mesh when the mesh is transparent\r\n     */\r\n    private static _StencilReference = 0x04;\r\n    /**\r\n     * The name of the component. Each component must have a unique name.\r\n     */\r\n    public name = SceneComponentConstants.NAME_OUTLINERENDERER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Defines a zOffset default Factor to prevent zFighting between the overlay and the mesh.\r\n     */\r\n    public zOffset = 1;\r\n\r\n    /**\r\n     * Defines a zOffset default Unit to prevent zFighting between the overlay and the mesh.\r\n     */\r\n    public zOffsetUnits = 4; // 4 to account for projection a bit by default\r\n\r\n    private _engine: Engine;\r\n    private _savedDepthWrite: boolean;\r\n    private _passIdForDrawWrapper: number[];\r\n\r\n    /**\r\n     * Instantiates a new outline renderer. (There could be only one per scene).\r\n     * @param scene Defines the scene it belongs to\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this._engine = scene.getEngine();\r\n        this.scene._addComponent(this);\r\n        this._passIdForDrawWrapper = [];\r\n        for (let i = 0; i < 4; ++i) {\r\n            this._passIdForDrawWrapper[i] = this._engine.createRenderPassId(`Outline Renderer (${i})`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register the component to one instance of a scene.\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE, this, this._beforeRenderingMesh);\r\n        this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE, this, this._afterRenderingMesh);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        for (let i = 0; i < this._passIdForDrawWrapper.length; ++i) {\r\n            this._engine.releaseRenderPassId(this._passIdForDrawWrapper[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders the outline in the canvas.\r\n     * @param subMesh Defines the sumesh to render\r\n     * @param batch Defines the batch of meshes in case of instances\r\n     * @param useOverlay Defines if the rendering is for the overlay or the outline\r\n     * @param renderPassId Render pass id to use to render the mesh\r\n     */\r\n    public render(subMesh: SubMesh, batch: _InstancesBatch, useOverlay: boolean = false, renderPassId?: number): void {\r\n        renderPassId = renderPassId ?? this._passIdForDrawWrapper[0];\r\n\r\n        const scene = this.scene;\r\n        const engine = scene.getEngine();\r\n\r\n        const hardwareInstancedRendering =\r\n            engine.getCaps().instancedArrays &&\r\n            ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || subMesh.getRenderingMesh().hasThinInstances);\r\n\r\n        if (!this.isReady(subMesh, hardwareInstancedRendering, renderPassId)) {\r\n            return;\r\n        }\r\n\r\n        const ownerMesh = subMesh.getMesh();\r\n        const replacementMesh = ownerMesh._internalAbstractMeshDataInfo._actAsRegularMesh ? ownerMesh : null;\r\n        const renderingMesh = subMesh.getRenderingMesh();\r\n        const effectiveMesh = replacementMesh ? replacementMesh : renderingMesh;\r\n        const material = subMesh.getMaterial();\r\n\r\n        if (!material || !scene.activeCamera) {\r\n            return;\r\n        }\r\n\r\n        const drawWrapper = subMesh._getDrawWrapper(renderPassId)!;\r\n        const effect = DrawWrapper.GetEffect(drawWrapper)!;\r\n\r\n        engine.enableEffect(drawWrapper);\r\n\r\n        // Logarithmic depth\r\n        if ((<any>material).useLogarithmicDepth) {\r\n            effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(scene.activeCamera.maxZ + 1.0) / Math.LN2));\r\n        }\r\n\r\n        effect.setFloat(\"offset\", useOverlay ? 0 : renderingMesh.outlineWidth);\r\n        effect.setColor4(\"color\", useOverlay ? renderingMesh.overlayColor : renderingMesh.outlineColor, useOverlay ? renderingMesh.overlayAlpha : material.alpha);\r\n        effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n        effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\r\n\r\n        // Bones\r\n        if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\r\n            effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\r\n        }\r\n\r\n        if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\r\n            renderingMesh.morphTargetManager._bind(effect);\r\n        }\r\n\r\n        // Morph targets\r\n        MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\r\n\r\n        if (!hardwareInstancedRendering) {\r\n            renderingMesh._bind(subMesh, effect, material.fillMode);\r\n        }\r\n\r\n        // Alpha test\r\n        if (material && material.needAlphaTesting()) {\r\n            const alphaTexture = material.getAlphaTestTexture();\r\n            if (alphaTexture) {\r\n                effect.setTexture(\"diffuseSampler\", alphaTexture);\r\n                effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\r\n            }\r\n        }\r\n\r\n        // Clip plane\r\n        MaterialHelper.BindClipPlane(effect, scene);\r\n\r\n        engine.setZOffset(-this.zOffset);\r\n        engine.setZOffsetUnits(-this.zOffsetUnits);\r\n\r\n        renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) => {\r\n            effect.setMatrix(\"world\", world);\r\n        });\r\n\r\n        engine.setZOffset(0);\r\n        engine.setZOffsetUnits(0);\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the outline renderer is ready for a given submesh.\r\n     * All the dependencies e.g. submeshes, texture, effect... mus be ready\r\n     * @param subMesh Defines the submesh to check readiness for\r\n     * @param useInstances Defines whether wee are trying to render instances or not\r\n     * @param renderPassId Render pass id to use to render the mesh\r\n     * @returns true if ready otherwise false\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean, renderPassId?: number): boolean {\r\n        renderPassId = renderPassId ?? this._passIdForDrawWrapper[0];\r\n\r\n        const defines = [];\r\n        const attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\r\n\r\n        const mesh = subMesh.getMesh();\r\n        const material = subMesh.getMaterial();\r\n\r\n        const scene = mesh.getScene();\r\n\r\n        if (material) {\r\n            // Alpha test\r\n            if (material.needAlphaTesting()) {\r\n                defines.push(\"#define ALPHATEST\");\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                    attribs.push(VertexBuffer.UVKind);\r\n                    defines.push(\"#define UV1\");\r\n                }\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n                    attribs.push(VertexBuffer.UV2Kind);\r\n                    defines.push(\"#define UV2\");\r\n                }\r\n            }\r\n            //Logarithmic depth\r\n            if ((<any>material).useLogarithmicDepth) {\r\n                defines.push(\"#define LOGARITHMICDEPTH\");\r\n            }\r\n        }\r\n        // Bones\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph targets\r\n        const morphTargetManager = (mesh as Mesh).morphTargetManager;\r\n        let numMorphInfluencers = 0;\r\n        if (morphTargetManager) {\r\n            if (morphTargetManager.numInfluencers > 0) {\r\n                numMorphInfluencers = morphTargetManager.numInfluencers;\r\n\r\n                defines.push(\"#define MORPHTARGETS\");\r\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\r\n\r\n                if (morphTargetManager.isUsingTextureForTargets) {\r\n                    defines.push(\"#define MORPHTARGETS_TEXTURE\");\r\n                }\r\n\r\n                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\r\n            }\r\n        }\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // Clip planes\r\n        if (scene.clipPlane) {\r\n            defines.push(\"#define CLIPPLANE\");\r\n        }\r\n\r\n        if (scene.clipPlane2) {\r\n            defines.push(\"#define CLIPPLANE2\");\r\n        }\r\n\r\n        if (scene.clipPlane3) {\r\n            defines.push(\"#define CLIPPLANE3\");\r\n        }\r\n\r\n        if (scene.clipPlane4) {\r\n            defines.push(\"#define CLIPPLANE4\");\r\n        }\r\n\r\n        if (scene.clipPlane5) {\r\n            defines.push(\"#define CLIPPLANE5\");\r\n        }\r\n\r\n        if (scene.clipPlane6) {\r\n            defines.push(\"#define CLIPPLANE6\");\r\n        }\r\n\r\n        // Get correct effect\r\n        const drawWrapper = subMesh._getDrawWrapper(renderPassId, true)!;\r\n        const cachedDefines = drawWrapper.defines;\r\n        const join = defines.join(\"\\n\");\r\n\r\n        if (cachedDefines !== join) {\r\n            drawWrapper.setEffect(\r\n                this.scene\r\n                    .getEngine()\r\n                    .createEffect(\r\n                        \"outline\",\r\n                        attribs,\r\n                        [\r\n                            \"world\",\r\n                            \"mBones\",\r\n                            \"viewProjection\",\r\n                            \"diffuseMatrix\",\r\n                            \"offset\",\r\n                            \"color\",\r\n                            \"logarithmicDepthConstant\",\r\n                            \"morphTargetInfluences\",\r\n                            \"morphTargetTextureInfo\",\r\n                            \"morphTargetTextureIndices\",\r\n                            \"vClipPlane\",\r\n                            \"vClipPlane2\",\r\n                            \"vClipPlane3\",\r\n                            \"vClipPlane4\",\r\n                            \"vClipPlane5\",\r\n                            \"vClipPlane6\",\r\n                        ],\r\n                        [\"diffuseSampler\", \"morphTargets\"],\r\n                        join,\r\n                        undefined,\r\n                        undefined,\r\n                        undefined,\r\n                        { maxSimultaneousMorphTargets: numMorphInfluencers }\r\n                    ),\r\n                join\r\n            );\r\n        }\r\n\r\n        return drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    private _beforeRenderingMesh(mesh: Mesh, subMesh: SubMesh, batch: _InstancesBatch): void {\r\n        // Outline - step 1\r\n        this._savedDepthWrite = this._engine.getDepthWrite();\r\n        if (mesh.renderOutline) {\r\n            const material = subMesh.getMaterial();\r\n            if (material && material.needAlphaBlendingForMesh(mesh)) {\r\n                this._engine.cacheStencilState();\r\n                // Draw only to stencil buffer for the original mesh\r\n                // The resulting stencil buffer will be used so the outline is not visible inside the mesh when the mesh is transparent\r\n                this._engine.setDepthWrite(false);\r\n                this._engine.setColorWrite(false);\r\n                this._engine.setStencilBuffer(true);\r\n                this._engine.setStencilOperationPass(Constants.REPLACE);\r\n                this._engine.setStencilFunction(Constants.ALWAYS);\r\n                this._engine.setStencilMask(OutlineRenderer._StencilReference);\r\n                this._engine.setStencilFunctionReference(OutlineRenderer._StencilReference);\r\n                this._engine.stencilStateComposer.useStencilGlobalOnly = true;\r\n                this.render(subMesh, batch, /* This sets offset to 0 */ true, this._passIdForDrawWrapper[1]);\r\n\r\n                this._engine.setColorWrite(true);\r\n                this._engine.setStencilFunction(Constants.NOTEQUAL);\r\n            }\r\n\r\n            // Draw the outline using the above stencil if needed to avoid drawing within the mesh\r\n            this._engine.setDepthWrite(false);\r\n            this.render(subMesh, batch, false, this._passIdForDrawWrapper[0]);\r\n            this._engine.setDepthWrite(this._savedDepthWrite);\r\n\r\n            if (material && material.needAlphaBlendingForMesh(mesh)) {\r\n                this._engine.stencilStateComposer.useStencilGlobalOnly = false;\r\n                this._engine.restoreStencilState();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _afterRenderingMesh(mesh: Mesh, subMesh: SubMesh, batch: _InstancesBatch): void {\r\n        // Overlay\r\n        if (mesh.renderOverlay) {\r\n            const currentMode = this._engine.getAlphaMode();\r\n            const alphaBlendState = this._engine.alphaState.alphaBlend;\r\n            this._engine.setAlphaMode(Constants.ALPHA_COMBINE);\r\n            this.render(subMesh, batch, true, this._passIdForDrawWrapper[3]);\r\n            this._engine.setAlphaMode(currentMode);\r\n            this._engine.setDepthWrite(this._savedDepthWrite);\r\n            this._engine.alphaState.alphaBlend = alphaBlendState;\r\n        }\r\n\r\n        // Outline - step 2\r\n        if (mesh.renderOutline && this._savedDepthWrite) {\r\n            this._engine.setDepthWrite(true);\r\n            this._engine.setColorWrite(false);\r\n            this.render(subMesh, batch, false, this._passIdForDrawWrapper[2]);\r\n            this._engine.setColorWrite(true);\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}