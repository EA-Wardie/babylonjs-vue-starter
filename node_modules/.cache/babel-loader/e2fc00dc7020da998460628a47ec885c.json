{"ast":null,"code":"import \"core-js/modules/es.array.slice.js\";\nimport { Vector3, TmpVectors, Matrix } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { CreateRibbon } from \"./ribbonBuilder.js\";\nimport { Path3D } from \"../../Maths/math.path.js\";\n/**\n * Creates a tube mesh.\n * The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters\n * * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube\n * * The parameter `radius` (positive float, default 1) sets the tube radius size\n * * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface\n * * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overrides the parameter `radius`\n * * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)\n * * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n * * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#tube\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.path\n * @param options.radius\n * @param options.tessellation\n * @param options.radiusFunction\n * @param options.cap\n * @param options.arc\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.instance\n * @param options.invertUV\n * @param scene defines the hosting scene\n * @returns the tube mesh\n * @see https://doc.babylonjs.com/how_to/parametric_shapes\n * @see https://doc.babylonjs.com/how_to/set_shapes#tube\n */\n\nexport function CreateTube(name, options, scene) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  var path = options.path;\n  var instance = options.instance;\n  var radius = 1.0;\n\n  if (options.radius !== undefined) {\n    radius = options.radius;\n  } else if (instance) {\n    radius = instance._creationDataStorage.radius;\n  }\n\n  var tessellation = options.tessellation || 64 | 0;\n  var radiusFunction = options.radiusFunction || null;\n  var cap = options.cap || Mesh.NO_CAP;\n  var invertUV = options.invertUV || false;\n  var updatable = options.updatable;\n\n  var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n\n  options.arc = options.arc && (options.arc <= 0.0 || options.arc > 1.0) ? 1.0 : options.arc || 1.0; // tube geometry\n\n  var tubePathArray = function tubePathArray(path, path3D, circlePaths, radius, tessellation, radiusFunction, cap, arc) {\n    var tangents = path3D.getTangents();\n    var normals = path3D.getNormals();\n    var distances = path3D.getDistances();\n    var pi2 = Math.PI * 2;\n    var step = pi2 / tessellation * arc;\n\n    var returnRadius = function returnRadius() {\n      return radius;\n    };\n\n    var radiusFunctionFinal = radiusFunction || returnRadius;\n    var circlePath;\n    var rad;\n    var normal;\n    var rotated;\n    var rotationMatrix = TmpVectors.Matrix[0];\n    var index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\n\n    for (var i = 0; i < path.length; i++) {\n      rad = radiusFunctionFinal(i, distances[i]); // current radius\n\n      circlePath = Array(); // current circle array\n\n      normal = normals[i]; // current normal\n\n      for (var t = 0; t < tessellation; t++) {\n        Matrix.RotationAxisToRef(tangents[i], step * t, rotationMatrix);\n        rotated = circlePath[t] ? circlePath[t] : Vector3.Zero();\n        Vector3.TransformCoordinatesToRef(normal, rotationMatrix, rotated);\n        rotated.scaleInPlace(rad).addInPlace(path[i]);\n        circlePath[t] = rotated;\n      }\n\n      circlePaths[index] = circlePath;\n      index++;\n    } // cap\n\n\n    var capPath = function capPath(nbPoints, pathIndex) {\n      var pointCap = Array();\n\n      for (var i = 0; i < nbPoints; i++) {\n        pointCap.push(path[pathIndex]);\n      }\n\n      return pointCap;\n    };\n\n    switch (cap) {\n      case Mesh.NO_CAP:\n        break;\n\n      case Mesh.CAP_START:\n        circlePaths[0] = capPath(tessellation, 0);\n        circlePaths[1] = circlePaths[2].slice(0);\n        break;\n\n      case Mesh.CAP_END:\n        circlePaths[index] = circlePaths[index - 1].slice(0);\n        circlePaths[index + 1] = capPath(tessellation, path.length - 1);\n        break;\n\n      case Mesh.CAP_ALL:\n        circlePaths[0] = capPath(tessellation, 0);\n        circlePaths[1] = circlePaths[2].slice(0);\n        circlePaths[index] = circlePaths[index - 1].slice(0);\n        circlePaths[index + 1] = capPath(tessellation, path.length - 1);\n        break;\n\n      default:\n        break;\n    }\n\n    return circlePaths;\n  };\n\n  var path3D;\n  var pathArray;\n\n  if (instance) {\n    // tube update\n    var storage = instance._creationDataStorage;\n    var arc = options.arc || storage.arc;\n    path3D = storage.path3D.update(path);\n    pathArray = tubePathArray(path, path3D, storage.pathArray, radius, storage.tessellation, radiusFunction, storage.cap, arc);\n    instance = CreateRibbon(\"\", {\n      pathArray: pathArray,\n      instance: instance\n    }); // Update mode, no need to recreate the storage.\n\n    storage.path3D = path3D;\n    storage.pathArray = pathArray;\n    storage.arc = arc;\n    storage.radius = radius;\n    return instance;\n  } // tube creation\n\n\n  path3D = new Path3D(path);\n  var newPathArray = new Array();\n  cap = cap < 0 || cap > 3 ? 0 : cap;\n  pathArray = tubePathArray(path, path3D, newPathArray, radius, tessellation, radiusFunction, cap, options.arc);\n  var tube = CreateRibbon(name, {\n    pathArray: pathArray,\n    closePath: true,\n    closeArray: false,\n    updatable: updatable,\n    sideOrientation: sideOrientation,\n    invertUV: invertUV,\n    frontUVs: options.frontUVs,\n    backUVs: options.backUVs\n  }, scene);\n  tube._creationDataStorage.pathArray = pathArray;\n  tube._creationDataStorage.path3D = path3D;\n  tube._creationDataStorage.tessellation = tessellation;\n  tube._creationDataStorage.cap = cap;\n  tube._creationDataStorage.arc = options.arc;\n  tube._creationDataStorage.radius = radius;\n  return tube;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateTube directly\n */\n\nexport var TubeBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateTube: CreateTube\n};\n\nMesh.CreateTube = function (name, path, radius, tessellation, radiusFunction, cap, scene, updatable, sideOrientation, instance) {\n  var options = {\n    path: path,\n    radius: radius,\n    tessellation: tessellation,\n    radiusFunction: radiusFunction,\n    arc: 1,\n    cap: cap,\n    updatable: updatable,\n    sideOrientation: sideOrientation,\n    instance: instance\n  };\n  return CreateTube(name, options, scene);\n};","map":{"version":3,"mappings":"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","names":["Vector3","TmpVectors","Matrix","Mesh","CreateRibbon","Path3D","CreateTube","name","options","scene","path","instance","radius","undefined","_creationDataStorage","tessellation","radiusFunction","cap","NO_CAP","invertUV","updatable","sideOrientation","_GetDefaultSideOrientation","arc","tubePathArray","path3D","circlePaths","tangents","getTangents","normals","getNormals","distances","getDistances","pi2","Math","PI","step","returnRadius","radiusFunctionFinal","circlePath","rad","normal","rotated","rotationMatrix","index","CAP_END","i","length","Array","t","RotationAxisToRef","Zero","TransformCoordinatesToRef","scaleInPlace","addInPlace","capPath","nbPoints","pathIndex","pointCap","push","CAP_START","slice","CAP_ALL","pathArray","storage","update","newPathArray","tube","closePath","closeArray","frontUVs","backUVs","TubeBuilder"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Meshes/Builders/tubeBuilder.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, TmpVectors, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { CreateRibbon } from \"./ribbonBuilder\";\r\nimport { Path3D } from \"../../Maths/math.path\";\r\n\r\n/**\r\n * Creates a tube mesh.\r\n * The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters\r\n * * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube\r\n * * The parameter `radius` (positive float, default 1) sets the tube radius size\r\n * * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface\r\n * * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overrides the parameter `radius`\r\n * * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)\r\n * * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc\r\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n * * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#tube\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.path\r\n * @param options.radius\r\n * @param options.tessellation\r\n * @param options.radiusFunction\r\n * @param options.cap\r\n * @param options.arc\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.instance\r\n * @param options.invertUV\r\n * @param scene defines the hosting scene\r\n * @returns the tube mesh\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n * @see https://doc.babylonjs.com/how_to/set_shapes#tube\r\n */\r\nexport function CreateTube(\r\n    name: string,\r\n    options: {\r\n        path: Vector3[];\r\n        radius?: number;\r\n        tessellation?: number;\r\n        radiusFunction?: { (i: number, distance: number): number };\r\n        cap?: number;\r\n        arc?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        instance?: Mesh;\r\n        invertUV?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const path = options.path;\r\n    let instance = options.instance;\r\n    let radius = 1.0;\r\n\r\n    if (options.radius !== undefined) {\r\n        radius = options.radius;\r\n    } else if (instance) {\r\n        radius = instance._creationDataStorage!.radius;\r\n    }\r\n\r\n    const tessellation = options.tessellation || 64 | 0;\r\n    const radiusFunction = options.radiusFunction || null;\r\n    let cap = options.cap || Mesh.NO_CAP;\r\n    const invertUV = options.invertUV || false;\r\n    const updatable = options.updatable;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    options.arc = options.arc && (options.arc <= 0.0 || options.arc > 1.0) ? 1.0 : options.arc || 1.0;\r\n\r\n    // tube geometry\r\n    const tubePathArray = (\r\n        path: Vector3[],\r\n        path3D: Path3D,\r\n        circlePaths: Vector3[][],\r\n        radius: number,\r\n        tessellation: number,\r\n        radiusFunction: Nullable<{ (i: number, distance: number): number }>,\r\n        cap: number,\r\n        arc: number\r\n    ) => {\r\n        const tangents = path3D.getTangents();\r\n        const normals = path3D.getNormals();\r\n        const distances = path3D.getDistances();\r\n        const pi2 = Math.PI * 2;\r\n        const step = (pi2 / tessellation) * arc;\r\n        const returnRadius: { (i: number, distance: number): number } = () => radius;\r\n        const radiusFunctionFinal: { (i: number, distance: number): number } = radiusFunction || returnRadius;\r\n\r\n        let circlePath: Vector3[];\r\n        let rad: number;\r\n        let normal: Vector3;\r\n        let rotated: Vector3;\r\n        const rotationMatrix: Matrix = TmpVectors.Matrix[0];\r\n        let index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\r\n        for (let i = 0; i < path.length; i++) {\r\n            rad = radiusFunctionFinal(i, distances[i]); // current radius\r\n            circlePath = Array<Vector3>(); // current circle array\r\n            normal = normals[i]; // current normal\r\n            for (let t = 0; t < tessellation; t++) {\r\n                Matrix.RotationAxisToRef(tangents[i], step * t, rotationMatrix);\r\n                rotated = circlePath[t] ? circlePath[t] : Vector3.Zero();\r\n                Vector3.TransformCoordinatesToRef(normal, rotationMatrix, rotated);\r\n                rotated.scaleInPlace(rad).addInPlace(path[i]);\r\n                circlePath[t] = rotated;\r\n            }\r\n            circlePaths[index] = circlePath;\r\n            index++;\r\n        }\r\n        // cap\r\n        const capPath = (nbPoints: number, pathIndex: number): Array<Vector3> => {\r\n            const pointCap = Array<Vector3>();\r\n            for (let i = 0; i < nbPoints; i++) {\r\n                pointCap.push(path[pathIndex]);\r\n            }\r\n            return pointCap;\r\n        };\r\n        switch (cap) {\r\n            case Mesh.NO_CAP:\r\n                break;\r\n            case Mesh.CAP_START:\r\n                circlePaths[0] = capPath(tessellation, 0);\r\n                circlePaths[1] = circlePaths[2].slice(0);\r\n                break;\r\n            case Mesh.CAP_END:\r\n                circlePaths[index] = circlePaths[index - 1].slice(0);\r\n                circlePaths[index + 1] = capPath(tessellation, path.length - 1);\r\n                break;\r\n            case Mesh.CAP_ALL:\r\n                circlePaths[0] = capPath(tessellation, 0);\r\n                circlePaths[1] = circlePaths[2].slice(0);\r\n                circlePaths[index] = circlePaths[index - 1].slice(0);\r\n                circlePaths[index + 1] = capPath(tessellation, path.length - 1);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        return circlePaths;\r\n    };\r\n\r\n    let path3D;\r\n    let pathArray;\r\n    if (instance) {\r\n        // tube update\r\n        const storage = instance._creationDataStorage!;\r\n        const arc = options.arc || storage.arc;\r\n        path3D = storage.path3D.update(path);\r\n        pathArray = tubePathArray(path, path3D, storage.pathArray, radius, storage.tessellation, radiusFunction, storage.cap, arc);\r\n        instance = CreateRibbon(\"\", { pathArray: pathArray, instance: instance });\r\n        // Update mode, no need to recreate the storage.\r\n        storage.path3D = path3D;\r\n        storage.pathArray = pathArray;\r\n        storage.arc = arc;\r\n        storage.radius = radius;\r\n\r\n        return instance;\r\n    }\r\n\r\n    // tube creation\r\n    path3D = <any>new Path3D(path);\r\n    const newPathArray = new Array<Array<Vector3>>();\r\n    cap = cap < 0 || cap > 3 ? 0 : cap;\r\n    pathArray = tubePathArray(path, path3D, newPathArray, radius, tessellation, radiusFunction, cap, options.arc);\r\n    const tube = CreateRibbon(\r\n        name,\r\n        {\r\n            pathArray: pathArray,\r\n            closePath: true,\r\n            closeArray: false,\r\n            updatable: updatable,\r\n            sideOrientation: sideOrientation,\r\n            invertUV: invertUV,\r\n            frontUVs: options.frontUVs,\r\n            backUVs: options.backUVs,\r\n        },\r\n        scene\r\n    );\r\n    tube._creationDataStorage!.pathArray = pathArray;\r\n    tube._creationDataStorage!.path3D = path3D;\r\n    tube._creationDataStorage!.tessellation = tessellation;\r\n    tube._creationDataStorage!.cap = cap;\r\n    tube._creationDataStorage!.arc = options.arc;\r\n    tube._creationDataStorage!.radius = radius;\r\n\r\n    return tube;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTube directly\r\n */\r\nexport const TubeBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTube,\r\n};\r\n\r\n(Mesh as any).CreateTube = (\r\n    name: string,\r\n    path: Vector3[],\r\n    radius: number,\r\n    tessellation: number,\r\n    radiusFunction: { (i: number, distance: number): number },\r\n    cap: number,\r\n    scene: Scene,\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n): Mesh => {\r\n    const options = {\r\n        path: path,\r\n        radius: radius,\r\n        tessellation: tessellation,\r\n        radiusFunction: radiusFunction,\r\n        arc: 1,\r\n        cap: cap,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n    };\r\n    return CreateTube(name, options, scene);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}