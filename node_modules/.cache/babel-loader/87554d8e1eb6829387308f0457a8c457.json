{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport { __decorate } from \"tslib\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { serialize, SerializationHelper } from \"../Misc/decorators.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\n/**\n * Defines a target to use with MorphTargetManager\n * @see https://doc.babylonjs.com/how_to/how_to_use_morphtargets\n */\n\nvar MorphTarget =\n/** @class */\nfunction () {\n  /**\n   * Creates a new MorphTarget\n   * @param name defines the name of the target\n   * @param influence defines the influence to use\n   * @param scene defines the scene the morphtarget belongs to\n   */\n  function MorphTarget(\n  /** defines the name of the target */\n  name, influence, scene) {\n    if (influence === void 0) {\n      influence = 0;\n    }\n\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    this.name = name;\n    /**\n     * Gets or sets the list of animations\n     */\n\n    this.animations = new Array();\n    this._positions = null;\n    this._normals = null;\n    this._tangents = null;\n    this._uvs = null;\n    this._uniqueId = 0;\n    /**\n     * Observable raised when the influence changes\n     */\n\n    this.onInfluenceChanged = new Observable();\n    /** @hidden */\n\n    this._onDataLayoutChanged = new Observable();\n    this._animationPropertiesOverride = null;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this.influence = influence;\n\n    if (this._scene) {\n      this._uniqueId = this._scene.getUniqueId();\n    }\n  }\n\n  Object.defineProperty(MorphTarget.prototype, \"influence\", {\n    /**\n     * Gets or sets the influence of this target (ie. its weight in the overall morphing)\n     */\n    get: function get() {\n      return this._influence;\n    },\n    set: function set(influence) {\n      if (this._influence === influence) {\n        return;\n      }\n\n      var previous = this._influence;\n      this._influence = influence;\n\n      if (this.onInfluenceChanged.hasObservers()) {\n        this.onInfluenceChanged.notifyObservers(previous === 0 || influence === 0);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTarget.prototype, \"animationPropertiesOverride\", {\n    /**\n     * Gets or sets the animation properties override\n     */\n    get: function get() {\n      if (!this._animationPropertiesOverride && this._scene) {\n        return this._scene.animationPropertiesOverride;\n      }\n\n      return this._animationPropertiesOverride;\n    },\n    set: function set(value) {\n      this._animationPropertiesOverride = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTarget.prototype, \"uniqueId\", {\n    /**\n     * Gets the unique ID of this manager\n     */\n    get: function get() {\n      return this._uniqueId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTarget.prototype, \"hasPositions\", {\n    /**\n     * Gets a boolean defining if the target contains position data\n     */\n    get: function get() {\n      return !!this._positions;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTarget.prototype, \"hasNormals\", {\n    /**\n     * Gets a boolean defining if the target contains normal data\n     */\n    get: function get() {\n      return !!this._normals;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTarget.prototype, \"hasTangents\", {\n    /**\n     * Gets a boolean defining if the target contains tangent data\n     */\n    get: function get() {\n      return !!this._tangents;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTarget.prototype, \"hasUVs\", {\n    /**\n     * Gets a boolean defining if the target contains texture coordinates data\n     */\n    get: function get() {\n      return !!this._uvs;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Affects position data to this target\n   * @param data defines the position data to use\n   */\n\n  MorphTarget.prototype.setPositions = function (data) {\n    var hadPositions = this.hasPositions;\n    this._positions = data;\n\n    if (hadPositions !== this.hasPositions) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  };\n  /**\n   * Gets the position data stored in this target\n   * @returns a FloatArray containing the position data (or null if not present)\n   */\n\n\n  MorphTarget.prototype.getPositions = function () {\n    return this._positions;\n  };\n  /**\n   * Affects normal data to this target\n   * @param data defines the normal data to use\n   */\n\n\n  MorphTarget.prototype.setNormals = function (data) {\n    var hadNormals = this.hasNormals;\n    this._normals = data;\n\n    if (hadNormals !== this.hasNormals) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  };\n  /**\n   * Gets the normal data stored in this target\n   * @returns a FloatArray containing the normal data (or null if not present)\n   */\n\n\n  MorphTarget.prototype.getNormals = function () {\n    return this._normals;\n  };\n  /**\n   * Affects tangent data to this target\n   * @param data defines the tangent data to use\n   */\n\n\n  MorphTarget.prototype.setTangents = function (data) {\n    var hadTangents = this.hasTangents;\n    this._tangents = data;\n\n    if (hadTangents !== this.hasTangents) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  };\n  /**\n   * Gets the tangent data stored in this target\n   * @returns a FloatArray containing the tangent data (or null if not present)\n   */\n\n\n  MorphTarget.prototype.getTangents = function () {\n    return this._tangents;\n  };\n  /**\n   * Affects texture coordinates data to this target\n   * @param data defines the texture coordinates data to use\n   */\n\n\n  MorphTarget.prototype.setUVs = function (data) {\n    var hadUVs = this.hasUVs;\n    this._uvs = data;\n\n    if (hadUVs !== this.hasUVs) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  };\n  /**\n   * Gets the texture coordinates data stored in this target\n   * @returns a FloatArray containing the texture coordinates data (or null if not present)\n   */\n\n\n  MorphTarget.prototype.getUVs = function () {\n    return this._uvs;\n  };\n  /**\n   * Clone the current target\n   * @returns a new MorphTarget\n   */\n\n\n  MorphTarget.prototype.clone = function () {\n    var _this = this;\n\n    var newOne = SerializationHelper.Clone(function () {\n      return new MorphTarget(_this.name, _this.influence, _this._scene);\n    }, this);\n    newOne._positions = this._positions;\n    newOne._normals = this._normals;\n    newOne._tangents = this._tangents;\n    newOne._uvs = this._uvs;\n    return newOne;\n  };\n  /**\n   * Serializes the current target into a Serialization object\n   * @returns the serialized object\n   */\n\n\n  MorphTarget.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.influence = this.influence;\n    serializationObject.positions = Array.prototype.slice.call(this.getPositions());\n\n    if (this.id != null) {\n      serializationObject.id = this.id;\n    }\n\n    if (this.hasNormals) {\n      serializationObject.normals = Array.prototype.slice.call(this.getNormals());\n    }\n\n    if (this.hasTangents) {\n      serializationObject.tangents = Array.prototype.slice.call(this.getTangents());\n    }\n\n    if (this.hasUVs) {\n      serializationObject.uvs = Array.prototype.slice.call(this.getUVs());\n    } // Animations\n\n\n    SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n    return serializationObject;\n  };\n  /**\n   * Returns the string \"MorphTarget\"\n   * @returns \"MorphTarget\"\n   */\n\n\n  MorphTarget.prototype.getClassName = function () {\n    return \"MorphTarget\";\n  }; // Statics\n\n  /**\n   * Creates a new target from serialized data\n   * @param serializationObject defines the serialized data to use\n   * @param scene defines the hosting scene\n   * @returns a new MorphTarget\n   */\n\n\n  MorphTarget.Parse = function (serializationObject, scene) {\n    var result = new MorphTarget(serializationObject.name, serializationObject.influence);\n    result.setPositions(serializationObject.positions);\n\n    if (serializationObject.id != null) {\n      result.id = serializationObject.id;\n    }\n\n    if (serializationObject.normals) {\n      result.setNormals(serializationObject.normals);\n    }\n\n    if (serializationObject.tangents) {\n      result.setTangents(serializationObject.tangents);\n    }\n\n    if (serializationObject.uvs) {\n      result.setUVs(serializationObject.uvs);\n    } // Animations\n\n\n    if (serializationObject.animations) {\n      for (var animationIndex = 0; animationIndex < serializationObject.animations.length; animationIndex++) {\n        var parsedAnimation = serializationObject.animations[animationIndex];\n        var internalClass = GetClass(\"BABYLON.Animation\");\n\n        if (internalClass) {\n          result.animations.push(internalClass.Parse(parsedAnimation));\n        }\n      }\n\n      if (serializationObject.autoAnimate && scene) {\n        scene.beginAnimation(result, serializationObject.autoAnimateFrom, serializationObject.autoAnimateTo, serializationObject.autoAnimateLoop, serializationObject.autoAnimateSpeed || 1.0);\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Creates a MorphTarget from mesh data\n   * @param mesh defines the source mesh\n   * @param name defines the name to use for the new target\n   * @param influence defines the influence to attach to the target\n   * @returns a new MorphTarget\n   */\n\n\n  MorphTarget.FromMesh = function (mesh, name, influence) {\n    if (!name) {\n      name = mesh.name;\n    }\n\n    var result = new MorphTarget(name, influence, mesh.getScene());\n    result.setPositions(mesh.getVerticesData(VertexBuffer.PositionKind));\n\n    if (mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      result.setNormals(mesh.getVerticesData(VertexBuffer.NormalKind));\n    }\n\n    if (mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n      result.setTangents(mesh.getVerticesData(VertexBuffer.TangentKind));\n    }\n\n    if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n      result.setUVs(mesh.getVerticesData(VertexBuffer.UVKind));\n    }\n\n    return result;\n  };\n\n  __decorate([serialize()], MorphTarget.prototype, \"id\", void 0);\n\n  return MorphTarget;\n}();\n\nexport { MorphTarget };","map":{"version":3,"mappings":"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","names":["Observable","EngineStore","VertexBuffer","serialize","SerializationHelper","GetClass","name","influence","scene","Array","_scene","LastCreatedScene","_uniqueId","getUniqueId","Object","MorphTarget","_influence","previous","onInfluenceChanged","hasObservers","notifyObservers","_animationPropertiesOverride","animationPropertiesOverride","value","_positions","_normals","_tangents","_uvs","data","hadPositions","hasPositions","_onDataLayoutChanged","undefined","hadNormals","hasNormals","hadTangents","hasTangents","hadUVs","hasUVs","newOne","Clone","_this","serializationObject","positions","prototype","slice","call","getPositions","id","normals","getNormals","tangents","getTangents","uvs","getUVs","AppendSerializedAnimations","result","setPositions","setNormals","setTangents","setUVs","animations","animationIndex","length","parsedAnimation","internalClass","push","Parse","autoAnimate","beginAnimation","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","mesh","getScene","getVerticesData","PositionKind","isVerticesDataPresent","NormalKind","TangentKind","UVKind","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Morph/morphTarget.ts"],"sourcesContent":["import type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable, FloatArray } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { AnimationPropertiesOverride } from \"../Animations/animationPropertiesOverride\";\r\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\n\r\ndeclare type Animation = import(\"../Animations/animation\").Animation;\r\n\r\n/**\r\n * Defines a target to use with MorphTargetManager\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_morphtargets\r\n */\r\nexport class MorphTarget implements IAnimatable {\r\n    /**\r\n     * Gets or sets the list of animations\r\n     */\r\n    public animations = new Array<Animation>();\r\n\r\n    private _scene: Nullable<Scene>;\r\n    private _positions: Nullable<FloatArray> = null;\r\n    private _normals: Nullable<FloatArray> = null;\r\n    private _tangents: Nullable<FloatArray> = null;\r\n    private _uvs: Nullable<FloatArray> = null;\r\n    private _influence: number;\r\n    private _uniqueId = 0;\r\n\r\n    /**\r\n     * Observable raised when the influence changes\r\n     */\r\n    public onInfluenceChanged = new Observable<boolean>();\r\n\r\n    /** @hidden */\r\n    public _onDataLayoutChanged = new Observable<void>();\r\n\r\n    /**\r\n     * Gets or sets the influence of this target (ie. its weight in the overall morphing)\r\n     */\r\n    public get influence(): number {\r\n        return this._influence;\r\n    }\r\n\r\n    public set influence(influence: number) {\r\n        if (this._influence === influence) {\r\n            return;\r\n        }\r\n\r\n        const previous = this._influence;\r\n        this._influence = influence;\r\n\r\n        if (this.onInfluenceChanged.hasObservers()) {\r\n            this.onInfluenceChanged.notifyObservers(previous === 0 || influence === 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the id of the morph Target\r\n     */\r\n    @serialize()\r\n    public id: string;\r\n\r\n    private _animationPropertiesOverride: Nullable<AnimationPropertiesOverride> = null;\r\n\r\n    /**\r\n     * Gets or sets the animation properties override\r\n     */\r\n    public get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        if (!this._animationPropertiesOverride && this._scene) {\r\n            return this._scene.animationPropertiesOverride;\r\n        }\r\n        return this._animationPropertiesOverride;\r\n    }\r\n\r\n    public set animationPropertiesOverride(value: Nullable<AnimationPropertiesOverride>) {\r\n        this._animationPropertiesOverride = value;\r\n    }\r\n\r\n    /**\r\n     * Creates a new MorphTarget\r\n     * @param name defines the name of the target\r\n     * @param influence defines the influence to use\r\n     * @param scene defines the scene the morphtarget belongs to\r\n     */\r\n    public constructor(\r\n        /** defines the name of the target */\r\n        public name: string,\r\n        influence = 0,\r\n        scene: Nullable<Scene> = null\r\n    ) {\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        this.influence = influence;\r\n\r\n        if (this._scene) {\r\n            this._uniqueId = this._scene.getUniqueId();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the unique ID of this manager\r\n     */\r\n    public get uniqueId(): number {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains position data\r\n     */\r\n    public get hasPositions(): boolean {\r\n        return !!this._positions;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains normal data\r\n     */\r\n    public get hasNormals(): boolean {\r\n        return !!this._normals;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains tangent data\r\n     */\r\n    public get hasTangents(): boolean {\r\n        return !!this._tangents;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains texture coordinates data\r\n     */\r\n    public get hasUVs(): boolean {\r\n        return !!this._uvs;\r\n    }\r\n\r\n    /**\r\n     * Affects position data to this target\r\n     * @param data defines the position data to use\r\n     */\r\n    public setPositions(data: Nullable<FloatArray>) {\r\n        const hadPositions = this.hasPositions;\r\n\r\n        this._positions = data;\r\n\r\n        if (hadPositions !== this.hasPositions) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the position data stored in this target\r\n     * @returns a FloatArray containing the position data (or null if not present)\r\n     */\r\n    public getPositions(): Nullable<FloatArray> {\r\n        return this._positions;\r\n    }\r\n\r\n    /**\r\n     * Affects normal data to this target\r\n     * @param data defines the normal data to use\r\n     */\r\n    public setNormals(data: Nullable<FloatArray>) {\r\n        const hadNormals = this.hasNormals;\r\n\r\n        this._normals = data;\r\n\r\n        if (hadNormals !== this.hasNormals) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the normal data stored in this target\r\n     * @returns a FloatArray containing the normal data (or null if not present)\r\n     */\r\n    public getNormals(): Nullable<FloatArray> {\r\n        return this._normals;\r\n    }\r\n\r\n    /**\r\n     * Affects tangent data to this target\r\n     * @param data defines the tangent data to use\r\n     */\r\n    public setTangents(data: Nullable<FloatArray>) {\r\n        const hadTangents = this.hasTangents;\r\n\r\n        this._tangents = data;\r\n\r\n        if (hadTangents !== this.hasTangents) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent data stored in this target\r\n     * @returns a FloatArray containing the tangent data (or null if not present)\r\n     */\r\n    public getTangents(): Nullable<FloatArray> {\r\n        return this._tangents;\r\n    }\r\n\r\n    /**\r\n     * Affects texture coordinates data to this target\r\n     * @param data defines the texture coordinates data to use\r\n     */\r\n    public setUVs(data: Nullable<FloatArray>) {\r\n        const hadUVs = this.hasUVs;\r\n\r\n        this._uvs = data;\r\n\r\n        if (hadUVs !== this.hasUVs) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the texture coordinates data stored in this target\r\n     * @returns a FloatArray containing the texture coordinates data (or null if not present)\r\n     */\r\n    public getUVs(): Nullable<FloatArray> {\r\n        return this._uvs;\r\n    }\r\n\r\n    /**\r\n     * Clone the current target\r\n     * @returns a new MorphTarget\r\n     */\r\n    public clone(): MorphTarget {\r\n        const newOne = SerializationHelper.Clone(() => new MorphTarget(this.name, this.influence, this._scene), this);\r\n\r\n        newOne._positions = this._positions;\r\n        newOne._normals = this._normals;\r\n        newOne._tangents = this._tangents;\r\n        newOne._uvs = this._uvs;\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current target into a Serialization object\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.influence = this.influence;\r\n\r\n        serializationObject.positions = Array.prototype.slice.call(this.getPositions());\r\n        if (this.id != null) {\r\n            serializationObject.id = this.id;\r\n        }\r\n        if (this.hasNormals) {\r\n            serializationObject.normals = Array.prototype.slice.call(this.getNormals());\r\n        }\r\n        if (this.hasTangents) {\r\n            serializationObject.tangents = Array.prototype.slice.call(this.getTangents());\r\n        }\r\n        if (this.hasUVs) {\r\n            serializationObject.uvs = Array.prototype.slice.call(this.getUVs());\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"MorphTarget\"\r\n     * @returns \"MorphTarget\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"MorphTarget\";\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Creates a new target from serialized data\r\n     * @param serializationObject defines the serialized data to use\r\n     * @param scene defines the hosting scene\r\n     * @returns a new MorphTarget\r\n     */\r\n    public static Parse(serializationObject: any, scene?: Scene): MorphTarget {\r\n        const result = new MorphTarget(serializationObject.name, serializationObject.influence);\r\n\r\n        result.setPositions(serializationObject.positions);\r\n\r\n        if (serializationObject.id != null) {\r\n            result.id = serializationObject.id;\r\n        }\r\n        if (serializationObject.normals) {\r\n            result.setNormals(serializationObject.normals);\r\n        }\r\n        if (serializationObject.tangents) {\r\n            result.setTangents(serializationObject.tangents);\r\n        }\r\n        if (serializationObject.uvs) {\r\n            result.setUVs(serializationObject.uvs);\r\n        }\r\n\r\n        // Animations\r\n        if (serializationObject.animations) {\r\n            for (let animationIndex = 0; animationIndex < serializationObject.animations.length; animationIndex++) {\r\n                const parsedAnimation = serializationObject.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    result.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n\r\n            if (serializationObject.autoAnimate && scene) {\r\n                scene.beginAnimation(\r\n                    result,\r\n                    serializationObject.autoAnimateFrom,\r\n                    serializationObject.autoAnimateTo,\r\n                    serializationObject.autoAnimateLoop,\r\n                    serializationObject.autoAnimateSpeed || 1.0\r\n                );\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a MorphTarget from mesh data\r\n     * @param mesh defines the source mesh\r\n     * @param name defines the name to use for the new target\r\n     * @param influence defines the influence to attach to the target\r\n     * @returns a new MorphTarget\r\n     */\r\n    public static FromMesh(mesh: AbstractMesh, name?: string, influence?: number): MorphTarget {\r\n        if (!name) {\r\n            name = mesh.name;\r\n        }\r\n\r\n        const result = new MorphTarget(name, influence, mesh.getScene());\r\n\r\n        result.setPositions(<FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind));\r\n\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            result.setNormals(<FloatArray>mesh.getVerticesData(VertexBuffer.NormalKind));\r\n        }\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            result.setTangents(<FloatArray>mesh.getVerticesData(VertexBuffer.TangentKind));\r\n        }\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            result.setUVs(<FloatArray>mesh.getVerticesData(VertexBuffer.UVKind));\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}