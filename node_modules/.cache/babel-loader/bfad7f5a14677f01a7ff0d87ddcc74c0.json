{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport { __decorate, __extends } from \"tslib\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { CubeTexture } from \"../../../Textures/cubeTexture.js\";\nimport { Texture } from \"../../../Textures/texture.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport { Scalar } from \"../../../../Maths/math.scalar.js\";\n/**\n * Block used to implement the refraction part of the sub surface module of the PBR material\n */\n\nvar RefractionBlock =\n/** @class */\nfunction (_super) {\n  __extends(RefractionBlock, _super);\n  /**\n   * Create a new RefractionBlock\n   * @param name defines the block name\n   */\n\n\n  function RefractionBlock(name) {\n    var _this = _super.call(this, name, NodeMaterialBlockTargets.Fragment) || this;\n    /**\n     * This parameters will make the material used its opacity to control how much it is refracting against not.\n     * Materials half opaque for instance using refraction could benefit from this control.\n     */\n\n\n    _this.linkRefractionWithTransparency = false;\n    /**\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\n     */\n\n    _this.invertRefractionY = false;\n    /**\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\n     */\n\n    _this.useThicknessAsDepth = false;\n    _this._isUnique = true;\n\n    _this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerInput(\"tintAtDistance\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerInput(\"volumeIndexOfRefraction\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerOutput(\"refraction\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"refraction\", _this, NodeMaterialConnectionPointDirection.Output, RefractionBlock, \"RefractionBlock\"));\n\n    return _this;\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n\n\n  RefractionBlock.prototype.initialize = function (state) {\n    state._excludeVariableName(\"vRefractionPosition\");\n\n    state._excludeVariableName(\"vRefractionSize\");\n  };\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n\n\n  RefractionBlock.prototype.getClassName = function () {\n    return \"RefractionBlock\";\n  };\n\n  Object.defineProperty(RefractionBlock.prototype, \"intensity\", {\n    /**\n     * Gets the intensity input component\n     */\n    get: function get() {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RefractionBlock.prototype, \"tintAtDistance\", {\n    /**\n     * Gets the tint at distance input component\n     */\n    get: function get() {\n      return this._inputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RefractionBlock.prototype, \"volumeIndexOfRefraction\", {\n    /**\n     * Gets the volume index of refraction input component\n     */\n    get: function get() {\n      return this._inputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RefractionBlock.prototype, \"view\", {\n    /**\n     * Gets the view input component\n     */\n    get: function get() {\n      return this.viewConnectionPoint;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RefractionBlock.prototype, \"refraction\", {\n    /**\n     * Gets the refraction object output component\n     */\n    get: function get() {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RefractionBlock.prototype, \"hasTexture\", {\n    /**\n     * Returns true if the block has a texture\n     */\n    get: function get() {\n      return !!this._getTexture();\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  RefractionBlock.prototype._getTexture = function () {\n    if (this.texture) {\n      return this.texture;\n    }\n\n    return this._scene.environmentTexture;\n  };\n\n  RefractionBlock.prototype.autoConfigure = function (material) {\n    if (!this.intensity.isConnected) {\n      var intensityInput = new InputBlock(\"Refraction intensity\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\n      intensityInput.value = 1;\n      intensityInput.output.connectTo(this.intensity);\n    }\n\n    if (this.view && !this.view.isConnected) {\n      var viewInput = material.getInputBlockByPredicate(function (b) {\n        return b.systemValue === NodeMaterialSystemValues.View;\n      });\n\n      if (!viewInput) {\n        viewInput = new InputBlock(\"view\");\n        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\n      }\n\n      viewInput.output.connectTo(this.view);\n    }\n  };\n\n  RefractionBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    _super.prototype.prepareDefines.call(this, mesh, nodeMaterial, defines);\n\n    var refractionTexture = this._getTexture();\n\n    var refraction = refractionTexture && refractionTexture.getTextureMatrix;\n    defines.setValue(\"SS_REFRACTION\", refraction, true);\n\n    if (!refraction) {\n      return;\n    }\n\n    defines.setValue(this._define3DName, refractionTexture.isCube, true);\n    defines.setValue(this._defineLODRefractionAlpha, refractionTexture.lodLevelInAlpha, true);\n    defines.setValue(this._defineLinearSpecularRefraction, refractionTexture.linearSpecularLOD, true);\n    defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem ? !refractionTexture.invertZ : refractionTexture.invertZ, true);\n    defines.setValue(\"SS_LINKREFRACTIONTOTRANSPARENCY\", this.linkRefractionWithTransparency, true);\n    defines.setValue(\"SS_GAMMAREFRACTION\", refractionTexture.gammaSpace, true);\n    defines.setValue(\"SS_RGBDREFRACTION\", refractionTexture.isRGBD, true);\n    defines.setValue(\"SS_USE_LOCAL_REFRACTIONMAP_CUBIC\", refractionTexture.boundingBoxSize ? true : false, true);\n    defines.setValue(\"SS_USE_THICKNESS_AS_DEPTH\", this.useThicknessAsDepth, true);\n  };\n\n  RefractionBlock.prototype.isReady = function () {\n    var texture = this._getTexture();\n\n    if (texture && !texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n\n    return true;\n  };\n\n  RefractionBlock.prototype.bind = function (effect, nodeMaterial, mesh) {\n    var _a, _b, _c, _d;\n\n    _super.prototype.bind.call(this, effect, nodeMaterial, mesh);\n\n    var refractionTexture = this._getTexture();\n\n    if (!refractionTexture) {\n      return;\n    }\n\n    if (refractionTexture.isCube) {\n      effect.setTexture(this._cubeSamplerName, refractionTexture);\n    } else {\n      effect.setTexture(this._2DSamplerName, refractionTexture);\n    }\n\n    effect.setMatrix(this._refractionMatrixName, refractionTexture.getReflectionTextureMatrix());\n    var depth = 1.0;\n\n    if (!refractionTexture.isCube) {\n      if (refractionTexture.depth) {\n        depth = refractionTexture.depth;\n      }\n    }\n\n    var indexOfRefraction = (_d = (_b = (_a = this.volumeIndexOfRefraction.connectInputBlock) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : (_c = this.indexOfRefractionConnectionPoint.connectInputBlock) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : 1.5;\n    effect.setFloat4(this._vRefractionInfosName, refractionTexture.level, 1 / indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);\n    effect.setFloat4(this._vRefractionMicrosurfaceInfosName, refractionTexture.getSize().width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset, 1 / indexOfRefraction);\n    var width = refractionTexture.getSize().width;\n    effect.setFloat2(this._vRefractionFilteringInfoName, width, Scalar.Log2(width));\n\n    if (refractionTexture.boundingBoxSize) {\n      var cubeTexture = refractionTexture;\n      effect.setVector3(\"vRefractionPosition\", cubeTexture.boundingBoxPosition);\n      effect.setVector3(\"vRefractionSize\", cubeTexture.boundingBoxSize);\n    }\n  };\n  /**\n   * Gets the main code of the block (fragment side)\n   * @param state current state of the node material building\n   * @returns the shader code\n   */\n\n\n  RefractionBlock.prototype.getCode = function (state) {\n    var code = \"\";\n    state.sharedData.blockingBlocks.push(this);\n    state.sharedData.textureBlocks.push(this); // Samplers\n\n    this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\n    state.samplers.push(this._cubeSamplerName);\n    this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\n    state.samplers.push(this._2DSamplerName);\n    this._define3DName = state._getFreeDefineName(\"SS_REFRACTIONMAP_3D\");\n    state._samplerDeclaration += \"#ifdef \".concat(this._define3DName, \"\\r\\n\");\n    state._samplerDeclaration += \"uniform samplerCube \".concat(this._cubeSamplerName, \";\\r\\n\");\n    state._samplerDeclaration += \"#else\\r\\n\";\n    state._samplerDeclaration += \"uniform sampler2D \".concat(this._2DSamplerName, \";\\r\\n\");\n    state._samplerDeclaration += \"#endif\\r\\n\"; // Fragment\n\n    state.sharedData.blocksWithDefines.push(this);\n    state.sharedData.bindableBlocks.push(this);\n    this._defineLODRefractionAlpha = state._getFreeDefineName(\"SS_LODINREFRACTIONALPHA\");\n    this._defineLinearSpecularRefraction = state._getFreeDefineName(\"SS_LINEARSPECULARREFRACTION\");\n    this._defineOppositeZ = state._getFreeDefineName(\"SS_REFRACTIONMAP_OPPOSITEZ\");\n    this._refractionMatrixName = state._getFreeVariableName(\"refractionMatrix\");\n\n    state._emitUniformFromString(this._refractionMatrixName, \"mat4\");\n\n    state._emitFunction(\"sampleRefraction\", \"\\n            #ifdef \".concat(this._define3DName, \"\\n                #define sampleRefraction(s, c) textureCube(s, c)\\n            #else\\n                #define sampleRefraction(s, c) texture2D(s, c)\\n            #endif\\r\\n\"), \"//\".concat(this.name));\n\n    state._emitFunction(\"sampleRefractionLod\", \"\\n            #ifdef \".concat(this._define3DName, \"\\n                #define sampleRefractionLod(s, c, l) textureCubeLodEXT(s, c, l)\\n            #else\\n                #define sampleRefractionLod(s, c, l) texture2DLodEXT(s, c, l)\\n            #endif\\r\\n\"), \"//\".concat(this.name));\n\n    this._vRefractionMicrosurfaceInfosName = state._getFreeVariableName(\"vRefractionMicrosurfaceInfos\");\n\n    state._emitUniformFromString(this._vRefractionMicrosurfaceInfosName, \"vec4\");\n\n    this._vRefractionInfosName = state._getFreeVariableName(\"vRefractionInfos\");\n\n    state._emitUniformFromString(this._vRefractionInfosName, \"vec4\");\n\n    this._vRefractionFilteringInfoName = state._getFreeVariableName(\"vRefractionFilteringInfo\");\n\n    state._emitUniformFromString(this._vRefractionFilteringInfoName, \"vec2\");\n\n    state._emitUniformFromString(\"vRefractionPosition\", \"vec3\");\n\n    state._emitUniformFromString(\"vRefractionSize\", \"vec3\");\n\n    return code;\n  };\n\n  RefractionBlock.prototype._buildBlock = function (state) {\n    this._scene = state.sharedData.scene;\n    return this;\n  };\n\n  RefractionBlock.prototype._dumpPropertiesCode = function () {\n    var codeString = _super.prototype._dumpPropertiesCode.call(this);\n\n    if (this.texture) {\n      if (this.texture.isCube) {\n        codeString = \"\".concat(this._codeVariableName, \".texture = new BABYLON.CubeTexture(\\\"\").concat(this.texture.name, \"\\\");\\r\\n\");\n      } else {\n        codeString = \"\".concat(this._codeVariableName, \".texture = new BABYLON.Texture(\\\"\").concat(this.texture.name, \"\\\");\\r\\n\");\n      }\n\n      codeString += \"\".concat(this._codeVariableName, \".texture.coordinatesMode = \").concat(this.texture.coordinatesMode, \";\\r\\n\");\n    }\n\n    codeString += \"\".concat(this._codeVariableName, \".linkRefractionWithTransparency = \").concat(this.linkRefractionWithTransparency, \";\\r\\n\");\n    codeString += \"\".concat(this._codeVariableName, \".invertRefractionY = \").concat(this.invertRefractionY, \";\\r\\n\");\n    codeString += \"\".concat(this._codeVariableName, \".useThicknessAsDepth = \").concat(this.useThicknessAsDepth, \";\\r\\n\");\n    return codeString;\n  };\n\n  RefractionBlock.prototype.serialize = function () {\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    if (this.texture && !this.texture.isRenderTarget) {\n      serializationObject.texture = this.texture.serialize();\n    }\n\n    serializationObject.linkRefractionWithTransparency = this.linkRefractionWithTransparency;\n    serializationObject.invertRefractionY = this.invertRefractionY;\n    serializationObject.useThicknessAsDepth = this.useThicknessAsDepth;\n    return serializationObject;\n  };\n\n  RefractionBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {\n    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);\n\n    if (serializationObject.texture) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n\n      if (serializationObject.texture.isCube) {\n        this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\n      } else {\n        this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n      }\n    }\n\n    this.linkRefractionWithTransparency = serializationObject.linkRefractionWithTransparency;\n    this.invertRefractionY = serializationObject.invertRefractionY;\n    this.useThicknessAsDepth = !!serializationObject.useThicknessAsDepth;\n  };\n\n  __decorate([editableInPropertyPage(\"Link refraction to transparency\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n    notifiers: {\n      update: true\n    }\n  })], RefractionBlock.prototype, \"linkRefractionWithTransparency\", void 0);\n\n  __decorate([editableInPropertyPage(\"Invert refraction Y\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n    notifiers: {\n      update: true\n    }\n  })], RefractionBlock.prototype, \"invertRefractionY\", void 0);\n\n  __decorate([editableInPropertyPage(\"Use thickness as depth\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n    notifiers: {\n      update: true\n    }\n  })], RefractionBlock.prototype, \"useThicknessAsDepth\", void 0);\n\n  return RefractionBlock;\n}(NodeMaterialBlock);\n\nexport { RefractionBlock };\nRegisterClass(\"BABYLON.RefractionBlock\", RefractionBlock);","map":{"version":3,"mappings":"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","names":["NodeMaterialBlockConnectionPointTypes","NodeMaterialConnectionPointDirection","NodeMaterialBlockTargets","RegisterClass","InputBlock","NodeMaterialConnectionPointCustomObject","editableInPropertyPage","PropertyTypeForEdition","NodeMaterialBlock","CubeTexture","Texture","NodeMaterialSystemValues","Scalar","__extends","name","_super","Fragment","_this","_isUnique","registerInput","Float","registerOutput","Object","Output","RefractionBlock","state","_excludeVariableName","_inputs","viewConnectionPoint","_outputs","_getTexture","texture","_scene","environmentTexture","material","intensity","isConnected","intensityInput","value","output","connectTo","view","viewInput","getInputBlockByPredicate","b","systemValue","View","setAsSystemValue","mesh","nodeMaterial","defines","prepareDefines","call","refractionTexture","refraction","getTextureMatrix","setValue","_define3DName","isCube","_defineLODRefractionAlpha","lodLevelInAlpha","_defineLinearSpecularRefraction","linearSpecularLOD","_defineOppositeZ","useRightHandedSystem","invertZ","linkRefractionWithTransparency","gammaSpace","isRGBD","boundingBoxSize","useThicknessAsDepth","isReadyOrNotBlocking","effect","bind","setTexture","_cubeSamplerName","_2DSamplerName","setMatrix","_refractionMatrixName","getReflectionTextureMatrix","depth","indexOfRefraction","volumeIndexOfRefraction","connectInputBlock","_a","_b","indexOfRefractionConnectionPoint","_c","_d","setFloat4","_vRefractionInfosName","level","invertRefractionY","_vRefractionMicrosurfaceInfosName","getSize","width","lodGenerationScale","lodGenerationOffset","setFloat2","_vRefractionFilteringInfoName","Log2","cubeTexture","setVector3","boundingBoxPosition","code","sharedData","blockingBlocks","push","textureBlocks","_getFreeVariableName","samplers","_getFreeDefineName","_samplerDeclaration","blocksWithDefines","bindableBlocks","_emitUniformFromString","_emitFunction","scene","codeString","_dumpPropertiesCode","_codeVariableName","concat","coordinatesMode","serializationObject","serialize","isRenderTarget","rootUrl","_deserialize","url","indexOf","Parse","__decorate","Boolean","notifiers","update"],"sourceRoot":"","sources":["../../../../../../../../lts/core/generated/Materials/Node/Blocks/PBR/refractionBlock.ts"],"sourcesContent":["import { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { CubeTexture } from \"../../../Textures/cubeTexture\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport { Scalar } from \"../../../../Maths/math.scalar\";\r\n\r\n/**\r\n * Block used to implement the refraction part of the sub surface module of the PBR material\r\n */\r\nexport class RefractionBlock extends NodeMaterialBlock {\r\n    /** @hidden */\r\n    public _define3DName: string;\r\n    /** @hidden */\r\n    public _refractionMatrixName: string;\r\n    /** @hidden */\r\n    public _defineLODRefractionAlpha: string;\r\n    /** @hidden */\r\n    public _defineLinearSpecularRefraction: string;\r\n    /** @hidden */\r\n    public _defineOppositeZ: string;\r\n    /** @hidden */\r\n    public _cubeSamplerName: string;\r\n    /** @hidden */\r\n    public _2DSamplerName: string;\r\n    /** @hidden */\r\n    public _vRefractionMicrosurfaceInfosName: string;\r\n    /** @hidden */\r\n    public _vRefractionInfosName: string;\r\n    /** @hidden */\r\n    public _vRefractionFilteringInfoName: string;\r\n\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * The properties below are set by the main PBR block prior to calling methods of this class.\r\n     * This is to avoid having to add them as inputs here whereas they are already inputs of the main block, so already known.\r\n     * It's less burden on the user side in the editor part.\r\n     */\r\n\r\n    /** @hidden */\r\n    public viewConnectionPoint: NodeMaterialConnectionPoint;\r\n\r\n    /** @hidden */\r\n    public indexOfRefractionConnectionPoint: NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * This parameters will make the material used its opacity to control how much it is refracting against not.\r\n     * Materials half opaque for instance using refraction could benefit from this control.\r\n     */\r\n    @editableInPropertyPage(\"Link refraction to transparency\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public linkRefractionWithTransparency: boolean = false;\r\n\r\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\r\n    @editableInPropertyPage(\"Invert refraction Y\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public invertRefractionY: boolean = false;\r\n\r\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\r\n    @editableInPropertyPage(\"Use thickness as depth\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public useThicknessAsDepth: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Create a new RefractionBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"tintAtDistance\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"volumeIndexOfRefraction\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\r\n            \"refraction\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"refraction\", this, NodeMaterialConnectionPointDirection.Output, RefractionBlock, \"RefractionBlock\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"vRefractionPosition\");\r\n        state._excludeVariableName(\"vRefractionSize\");\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"RefractionBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity input component\r\n     */\r\n    public get intensity(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the tint at distance input component\r\n     */\r\n    public get tintAtDistance(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the volume index of refraction input component\r\n     */\r\n    public get volumeIndexOfRefraction(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the view input component\r\n     */\r\n    public get view(): NodeMaterialConnectionPoint {\r\n        return this.viewConnectionPoint;\r\n    }\r\n\r\n    /**\r\n     * Gets the refraction object output component\r\n     */\r\n    public get refraction(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Returns true if the block has a texture\r\n     */\r\n    public get hasTexture(): boolean {\r\n        return !!this._getTexture();\r\n    }\r\n\r\n    protected _getTexture(): Nullable<BaseTexture> {\r\n        if (this.texture) {\r\n            return this.texture;\r\n        }\r\n\r\n        return this._scene.environmentTexture;\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial) {\r\n        if (!this.intensity.isConnected) {\r\n            const intensityInput = new InputBlock(\"Refraction intensity\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\r\n            intensityInput.value = 1;\r\n            intensityInput.output.connectTo(this.intensity);\r\n        }\r\n\r\n        if (this.view && !this.view.isConnected) {\r\n            let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View);\r\n\r\n            if (!viewInput) {\r\n                viewInput = new InputBlock(\"view\");\r\n                viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\r\n            }\r\n            viewInput.output.connectTo(this.view);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        super.prepareDefines(mesh, nodeMaterial, defines);\r\n\r\n        const refractionTexture = this._getTexture();\r\n        const refraction = refractionTexture && refractionTexture.getTextureMatrix;\r\n\r\n        defines.setValue(\"SS_REFRACTION\", refraction, true);\r\n\r\n        if (!refraction) {\r\n            return;\r\n        }\r\n\r\n        defines.setValue(this._define3DName, refractionTexture!.isCube, true);\r\n        defines.setValue(this._defineLODRefractionAlpha, refractionTexture!.lodLevelInAlpha, true);\r\n        defines.setValue(this._defineLinearSpecularRefraction, refractionTexture!.linearSpecularLOD, true);\r\n        defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem ? !refractionTexture!.invertZ : refractionTexture!.invertZ, true);\r\n\r\n        defines.setValue(\"SS_LINKREFRACTIONTOTRANSPARENCY\", this.linkRefractionWithTransparency, true);\r\n        defines.setValue(\"SS_GAMMAREFRACTION\", refractionTexture!.gammaSpace, true);\r\n        defines.setValue(\"SS_RGBDREFRACTION\", refractionTexture!.isRGBD, true);\r\n        defines.setValue(\"SS_USE_LOCAL_REFRACTIONMAP_CUBIC\", (<any>refractionTexture).boundingBoxSize ? true : false, true);\r\n        defines.setValue(\"SS_USE_THICKNESS_AS_DEPTH\", this.useThicknessAsDepth, true);\r\n    }\r\n\r\n    public isReady() {\r\n        const texture = this._getTexture();\r\n\r\n        if (texture && !texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        super.bind(effect, nodeMaterial, mesh);\r\n\r\n        const refractionTexture = this._getTexture();\r\n\r\n        if (!refractionTexture) {\r\n            return;\r\n        }\r\n\r\n        if (refractionTexture.isCube) {\r\n            effect.setTexture(this._cubeSamplerName, refractionTexture);\r\n        } else {\r\n            effect.setTexture(this._2DSamplerName, refractionTexture);\r\n        }\r\n\r\n        effect.setMatrix(this._refractionMatrixName, refractionTexture.getReflectionTextureMatrix());\r\n\r\n        let depth = 1.0;\r\n        if (!refractionTexture.isCube) {\r\n            if ((<any>refractionTexture).depth) {\r\n                depth = (<any>refractionTexture).depth;\r\n            }\r\n        }\r\n\r\n        const indexOfRefraction = this.volumeIndexOfRefraction.connectInputBlock?.value ?? this.indexOfRefractionConnectionPoint.connectInputBlock?.value ?? 1.5;\r\n\r\n        effect.setFloat4(this._vRefractionInfosName, refractionTexture.level, 1 / indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);\r\n\r\n        effect.setFloat4(\r\n            this._vRefractionMicrosurfaceInfosName,\r\n            refractionTexture.getSize().width,\r\n            refractionTexture.lodGenerationScale,\r\n            refractionTexture.lodGenerationOffset,\r\n            1 / indexOfRefraction\r\n        );\r\n\r\n        const width = refractionTexture.getSize().width;\r\n\r\n        effect.setFloat2(this._vRefractionFilteringInfoName, width, Scalar.Log2(width));\r\n\r\n        if ((<any>refractionTexture).boundingBoxSize) {\r\n            const cubeTexture = <CubeTexture>refractionTexture;\r\n            effect.setVector3(\"vRefractionPosition\", cubeTexture.boundingBoxPosition);\r\n            effect.setVector3(\"vRefractionSize\", cubeTexture.boundingBoxSize);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the main code of the block (fragment side)\r\n     * @param state current state of the node material building\r\n     * @returns the shader code\r\n     */\r\n    public getCode(state: NodeMaterialBuildState): string {\r\n        const code = \"\";\r\n\r\n        state.sharedData.blockingBlocks.push(this);\r\n        state.sharedData.textureBlocks.push(this);\r\n\r\n        // Samplers\r\n        this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\r\n        state.samplers.push(this._cubeSamplerName);\r\n\r\n        this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\r\n        state.samplers.push(this._2DSamplerName);\r\n\r\n        this._define3DName = state._getFreeDefineName(\"SS_REFRACTIONMAP_3D\");\r\n\r\n        state._samplerDeclaration += `#ifdef ${this._define3DName}\\r\\n`;\r\n        state._samplerDeclaration += `uniform samplerCube ${this._cubeSamplerName};\\r\\n`;\r\n        state._samplerDeclaration += `#else\\r\\n`;\r\n        state._samplerDeclaration += `uniform sampler2D ${this._2DSamplerName};\\r\\n`;\r\n        state._samplerDeclaration += `#endif\\r\\n`;\r\n\r\n        // Fragment\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        this._defineLODRefractionAlpha = state._getFreeDefineName(\"SS_LODINREFRACTIONALPHA\");\r\n        this._defineLinearSpecularRefraction = state._getFreeDefineName(\"SS_LINEARSPECULARREFRACTION\");\r\n        this._defineOppositeZ = state._getFreeDefineName(\"SS_REFRACTIONMAP_OPPOSITEZ\");\r\n\r\n        this._refractionMatrixName = state._getFreeVariableName(\"refractionMatrix\");\r\n\r\n        state._emitUniformFromString(this._refractionMatrixName, \"mat4\");\r\n\r\n        state._emitFunction(\r\n            \"sampleRefraction\",\r\n            `\r\n            #ifdef ${this._define3DName}\r\n                #define sampleRefraction(s, c) textureCube(s, c)\r\n            #else\r\n                #define sampleRefraction(s, c) texture2D(s, c)\r\n            #endif\\r\\n`,\r\n            `//${this.name}`\r\n        );\r\n\r\n        state._emitFunction(\r\n            \"sampleRefractionLod\",\r\n            `\r\n            #ifdef ${this._define3DName}\r\n                #define sampleRefractionLod(s, c, l) textureCubeLodEXT(s, c, l)\r\n            #else\r\n                #define sampleRefractionLod(s, c, l) texture2DLodEXT(s, c, l)\r\n            #endif\\r\\n`,\r\n            `//${this.name}`\r\n        );\r\n\r\n        this._vRefractionMicrosurfaceInfosName = state._getFreeVariableName(\"vRefractionMicrosurfaceInfos\");\r\n\r\n        state._emitUniformFromString(this._vRefractionMicrosurfaceInfosName, \"vec4\");\r\n\r\n        this._vRefractionInfosName = state._getFreeVariableName(\"vRefractionInfos\");\r\n\r\n        state._emitUniformFromString(this._vRefractionInfosName, \"vec4\");\r\n\r\n        this._vRefractionFilteringInfoName = state._getFreeVariableName(\"vRefractionFilteringInfo\");\r\n\r\n        state._emitUniformFromString(this._vRefractionFilteringInfoName, \"vec2\");\r\n\r\n        state._emitUniformFromString(\"vRefractionPosition\", \"vec3\");\r\n        state._emitUniformFromString(\"vRefractionSize\", \"vec3\");\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        this._scene = state.sharedData.scene;\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        if (this.texture) {\r\n            if (this.texture.isCube) {\r\n                codeString = `${this._codeVariableName}.texture = new BABYLON.CubeTexture(\"${this.texture.name}\");\\r\\n`;\r\n            } else {\r\n                codeString = `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\");\\r\\n`;\r\n            }\r\n            codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\r\\n`;\r\n        }\r\n\r\n        codeString += `${this._codeVariableName}.linkRefractionWithTransparency = ${this.linkRefractionWithTransparency};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.invertRefractionY = ${this.invertRefractionY};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.useThicknessAsDepth = ${this.useThicknessAsDepth};\\r\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        if (this.texture && !this.texture.isRenderTarget) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        serializationObject.linkRefractionWithTransparency = this.linkRefractionWithTransparency;\r\n        serializationObject.invertRefractionY = this.invertRefractionY;\r\n        serializationObject.useThicknessAsDepth = this.useThicknessAsDepth;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        if (serializationObject.texture) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            if (serializationObject.texture.isCube) {\r\n                this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\r\n            } else {\r\n                this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\r\n            }\r\n        }\r\n\r\n        this.linkRefractionWithTransparency = serializationObject.linkRefractionWithTransparency;\r\n        this.invertRefractionY = serializationObject.invertRefractionY;\r\n        this.useThicknessAsDepth = !!serializationObject.useThicknessAsDepth;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.RefractionBlock\", RefractionBlock);\r\n"]},"metadata":{},"sourceType":"module"}