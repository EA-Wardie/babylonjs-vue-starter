{"ast":null,"code":"import \"core-js/modules/es.date.now.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport { __extends } from \"tslib\";\nimport { WebGLHardwareTexture } from \"../../Engines/WebGL/webGLHardwareTexture.js\";\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { DirectionalLight } from \"../../Lights/directionalLight.js\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture.js\";\nimport { SphericalHarmonics, SphericalPolynomial } from \"../../Maths/sphericalPolynomial.js\";\nimport { LightConstants } from \"../../Lights/lightConstants.js\";\n/**\n * Light Estimation Feature\n *\n * @since 5.0.0\n */\n\nvar WebXRLightEstimation =\n/** @class */\nfunction (_super) {\n  __extends(WebXRLightEstimation, _super);\n  /**\n   * Creates a new instance of the light estimation feature\n   * @param _xrSessionManager an instance of WebXRSessionManager\n   * @param options options to use when constructing this feature\n   */\n\n\n  function WebXRLightEstimation(_xrSessionManager,\n  /**\n   * options to use when constructing this feature\n   */\n  options) {\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this.options = options;\n    _this._canvasContext = null;\n    _this._reflectionCubeMap = null;\n    _this._xrLightEstimate = null;\n    _this._xrLightProbe = null;\n    _this._xrWebGLBinding = null;\n    _this._lightDirection = Vector3.Up().negateInPlace();\n    _this._lightColor = Color3.White();\n    _this._intensity = 1;\n    _this._sphericalHarmonics = new SphericalHarmonics();\n    _this._cubeMapPollTime = Date.now();\n    _this._lightEstimationPollTime = Date.now();\n    /**\n     * ARCore's reflection cube map size is 16x16.\n     * Once other systems support this feature we will need to change this to be dynamic.\n     * see https://github.com/immersive-web/lighting-estimation/blob/main/lighting-estimation-explainer.md#cube-map-open-questions\n     */\n\n    _this._reflectionCubeMapTextureSize = 16;\n    /**\n     * If createDirectionalLightSource is set to true this light source will be created automatically.\n     * Otherwise this can be set with an external directional light source.\n     * This light will be updated whenever the light estimation values change.\n     */\n\n    _this.directionalLight = null;\n    /**\n     * This observable will notify when the reflection cube map is updated.\n     */\n\n    _this.onReflectionCubeMapUpdatedObservable = new Observable();\n    /**\n     * Event Listener for \"reflectionchange\" events.\n     */\n\n    _this._updateReflectionCubeMap = function () {\n      var _a;\n\n      if (!_this._xrLightProbe) {\n        return;\n      } // check poll time, do not update if it has not been long enough\n\n\n      if (_this.options.cubeMapPollInterval) {\n        var now = Date.now();\n\n        if (now - _this._cubeMapPollTime < _this.options.cubeMapPollInterval) {\n          return;\n        }\n\n        _this._cubeMapPollTime = now;\n      }\n\n      var lp = _this._getXRGLBinding().getReflectionCubeMap(_this._xrLightProbe);\n\n      if (lp && _this._reflectionCubeMap) {\n        if (!_this._reflectionCubeMap._texture) {\n          var internalTexture = new InternalTexture(_this._xrSessionManager.scene.getEngine(), InternalTextureSource.Unknown);\n          internalTexture.isCube = true;\n          internalTexture.invertY = false;\n          internalTexture._useSRGBBuffer = _this.options.reflectionFormat === \"srgba8\";\n          internalTexture.format = 5;\n          internalTexture.generateMipMaps = true;\n          internalTexture.type = _this.options.reflectionFormat !== \"srgba8\" ? 2 : 0;\n          internalTexture.samplingMode = 3;\n          internalTexture.width = _this._reflectionCubeMapTextureSize;\n          internalTexture.height = _this._reflectionCubeMapTextureSize;\n          internalTexture._cachedWrapU = 1;\n          internalTexture._cachedWrapV = 1;\n          internalTexture._hardwareTexture = new WebGLHardwareTexture(lp, _this._getCanvasContext());\n          _this._reflectionCubeMap._texture = internalTexture;\n        } else {\n          (_a = _this._reflectionCubeMap._texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.set(lp);\n\n          _this._reflectionCubeMap._texture.getEngine().resetTextureCache();\n        }\n\n        _this._reflectionCubeMap._texture.isReady = true;\n\n        _this._xrSessionManager.scene.markAllMaterialsAsDirty(1);\n\n        _this.onReflectionCubeMapUpdatedObservable.notifyObservers(_this._reflectionCubeMap);\n      }\n    };\n\n    _this.xrNativeFeatureName = \"light-estimation\";\n\n    if (_this.options.createDirectionalLightSource) {\n      _this.directionalLight = new DirectionalLight(\"light estimation directional\", _this._lightDirection, _this._xrSessionManager.scene);\n      _this.directionalLight.position = new Vector3(0, 8, 0); // intensity will be set later\n\n      _this.directionalLight.intensity = 0;\n      _this.directionalLight.falloffType = LightConstants.FALLOFF_GLTF;\n    } // https://immersive-web.github.io/lighting-estimation/\n\n\n    Tools.Warn(\"light-estimation is an experimental and unstable feature.\");\n    return _this;\n  }\n\n  Object.defineProperty(WebXRLightEstimation.prototype, \"reflectionCubeMapTexture\", {\n    /**\n     * While the estimated cube map is expected to update over time to better reflect the user's environment as they move around those changes are unlikely to happen with every XRFrame.\n     * Since creating and processing the cube map is potentially expensive, especially if mip maps are needed, you can listen to the onReflectionCubeMapUpdatedObservable to determine\n     * when it has been updated.\n     */\n    get: function get() {\n      return this._reflectionCubeMap;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebXRLightEstimation.prototype, \"xrLightingEstimate\", {\n    /**\n     * The most recent light estimate.  Available starting on the first frame where the device provides a light probe.\n     */\n    get: function get() {\n      if (this._xrLightEstimate) {\n        return {\n          lightColor: this._lightColor,\n          lightDirection: this._lightDirection,\n          lightIntensity: this._intensity,\n          sphericalHarmonics: this._sphericalHarmonics\n        };\n      }\n\n      return this._xrLightEstimate;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  WebXRLightEstimation.prototype._getCanvasContext = function () {\n    if (this._canvasContext === null) {\n      this._canvasContext = this._xrSessionManager.scene.getEngine()._gl;\n    }\n\n    return this._canvasContext;\n  };\n\n  WebXRLightEstimation.prototype._getXRGLBinding = function () {\n    if (this._xrWebGLBinding === null) {\n      var context_1 = this._getCanvasContext();\n\n      this._xrWebGLBinding = new XRWebGLBinding(this._xrSessionManager.session, context_1);\n    }\n\n    return this._xrWebGLBinding;\n  };\n  /**\n   * attach this feature\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n\n\n  WebXRLightEstimation.prototype.attach = function () {\n    var _this = this;\n\n    var _a;\n\n    if (!_super.prototype.attach.call(this)) {\n      return false;\n    }\n\n    var reflectionFormat = (_a = this.options.reflectionFormat) !== null && _a !== void 0 ? _a : this._xrSessionManager.session.preferredReflectionFormat || \"srgba8\";\n    this.options.reflectionFormat = reflectionFormat;\n\n    this._xrSessionManager.session.requestLightProbe({\n      reflectionFormat: reflectionFormat\n    }).then(function (xrLightProbe) {\n      _this._xrLightProbe = xrLightProbe;\n\n      if (!_this.options.disableCubeMapReflection) {\n        if (!_this._reflectionCubeMap) {\n          _this._reflectionCubeMap = new BaseTexture(_this._xrSessionManager.scene);\n          _this._reflectionCubeMap.isCube = true;\n          _this._reflectionCubeMap.coordinatesMode = 3;\n\n          if (_this.options.setSceneEnvironmentTexture) {\n            _this._xrSessionManager.scene.environmentTexture = _this._reflectionCubeMap;\n          }\n        }\n\n        _this._xrLightProbe.addEventListener(\"reflectionchange\", _this._updateReflectionCubeMap);\n      }\n    });\n\n    return true;\n  };\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n\n\n  WebXRLightEstimation.prototype.detach = function () {\n    var detached = _super.prototype.detach.call(this);\n\n    if (this._xrLightProbe !== null && !this.options.disableCubeMapReflection) {\n      this._xrLightProbe.removeEventListener(\"reflectionchange\", this._updateReflectionCubeMap);\n\n      this._xrLightProbe = null;\n    }\n\n    this._canvasContext = null;\n    this._xrLightEstimate = null; // When the session ends (on detach) we must clear our XRWebGLBinging instance, which references the ended session.\n\n    this._xrWebGLBinding = null;\n    return detached;\n  };\n  /**\n   * Dispose this feature and all of the resources attached\n   */\n\n\n  WebXRLightEstimation.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.onReflectionCubeMapUpdatedObservable.clear();\n\n    if (this.directionalLight) {\n      this.directionalLight.dispose();\n      this.directionalLight = null;\n    }\n\n    if (this._reflectionCubeMap !== null) {\n      if (this._reflectionCubeMap._texture) {\n        this._reflectionCubeMap._texture.dispose();\n      }\n\n      this._reflectionCubeMap.dispose();\n\n      this._reflectionCubeMap = null;\n    }\n  };\n\n  WebXRLightEstimation.prototype._onXRFrame = function (_xrFrame) {\n    var _a;\n\n    if (this._xrLightProbe !== null) {\n      if (this.options.lightEstimationPollInterval) {\n        var now = Date.now();\n\n        if (now - this._lightEstimationPollTime < this.options.lightEstimationPollInterval) {\n          return;\n        }\n\n        this._lightEstimationPollTime = now;\n      }\n\n      this._xrLightEstimate = _xrFrame.getLightEstimate(this._xrLightProbe);\n\n      if (this._xrLightEstimate) {\n        this._intensity = Math.max(1.0, this._xrLightEstimate.primaryLightIntensity.x, this._xrLightEstimate.primaryLightIntensity.y, this._xrLightEstimate.primaryLightIntensity.z);\n        var rhsFactor = this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0; // recreate the vector caches, so that the last one provided to the user will persist\n\n        if (this.options.disableVectorReuse) {\n          this._lightDirection = new Vector3();\n          this._lightColor = new Color3();\n\n          if (this.directionalLight) {\n            this.directionalLight.direction = this._lightDirection;\n            this.directionalLight.diffuse = this._lightColor;\n          }\n        }\n\n        this._lightDirection.copyFromFloats(this._xrLightEstimate.primaryLightDirection.x, this._xrLightEstimate.primaryLightDirection.y, this._xrLightEstimate.primaryLightDirection.z * rhsFactor);\n\n        this._lightColor.copyFromFloats(this._xrLightEstimate.primaryLightIntensity.x / this._intensity, this._xrLightEstimate.primaryLightIntensity.y / this._intensity, this._xrLightEstimate.primaryLightIntensity.z / this._intensity);\n\n        this._sphericalHarmonics.updateFromFloatsArray(this._xrLightEstimate.sphericalHarmonicsCoefficients);\n\n        if (this._reflectionCubeMap && !this.options.disableSphericalPolynomial) {\n          this._reflectionCubeMap.sphericalPolynomial = this._reflectionCubeMap.sphericalPolynomial || new SphericalPolynomial();\n          (_a = this._reflectionCubeMap.sphericalPolynomial) === null || _a === void 0 ? void 0 : _a.updateFromHarmonics(this._sphericalHarmonics);\n        } // direction from instead of direction to\n\n\n        this._lightDirection.negateInPlace(); // set the values after calculating them\n\n\n        if (this.directionalLight) {\n          this.directionalLight.direction.copyFrom(this._lightDirection);\n          this.directionalLight.intensity = Math.min(this._intensity, 1.0);\n          this.directionalLight.diffuse.copyFrom(this._lightColor);\n        }\n      }\n    }\n  };\n  /**\n   * The module's name\n   */\n\n\n  WebXRLightEstimation.Name = WebXRFeatureName.LIGHT_ESTIMATION;\n  /**\n   * The (Babylon) version of this module.\n   * This is an integer representing the implementation version.\n   * This number does not correspond to the WebXR specs version\n   */\n\n  WebXRLightEstimation.Version = 1;\n  return WebXRLightEstimation;\n}(WebXRAbstractFeature);\n\nexport { WebXRLightEstimation }; // register the plugin\n\nWebXRFeaturesManager.AddWebXRFeature(WebXRLightEstimation.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRLightEstimation(xrSessionManager, options);\n  };\n}, WebXRLightEstimation.Version, false);","map":{"version":3,"mappings":"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","names":["WebGLHardwareTexture","InternalTexture","InternalTextureSource","Observable","Tools","WebXRFeatureName","WebXRFeaturesManager","WebXRAbstractFeature","Color3","Vector3","DirectionalLight","BaseTexture","SphericalHarmonics","SphericalPolynomial","LightConstants","__extends","_xrSessionManager","options","_super","_this","Up","negateInPlace","White","Date","now","_xrLightProbe","cubeMapPollInterval","_cubeMapPollTime","lp","_getXRGLBinding","getReflectionCubeMap","_reflectionCubeMap","_texture","internalTexture","scene","getEngine","Unknown","isCube","invertY","_useSRGBBuffer","reflectionFormat","format","generateMipMaps","type","samplingMode","width","_reflectionCubeMapTextureSize","height","_cachedWrapU","_cachedWrapV","_hardwareTexture","_getCanvasContext","_a","set","resetTextureCache","isReady","markAllMaterialsAsDirty","onReflectionCubeMapUpdatedObservable","notifyObservers","xrNativeFeatureName","createDirectionalLightSource","directionalLight","_lightDirection","position","intensity","falloffType","FALLOFF_GLTF","Warn","Object","WebXRLightEstimation","_xrLightEstimate","lightColor","_lightColor","lightDirection","lightIntensity","_intensity","sphericalHarmonics","_sphericalHarmonics","_canvasContext","_gl","_xrWebGLBinding","context_1","XRWebGLBinding","session","attach","call","preferredReflectionFormat","requestLightProbe","then","xrLightProbe","disableCubeMapReflection","coordinatesMode","setSceneEnvironmentTexture","environmentTexture","addEventListener","_updateReflectionCubeMap","detached","detach","removeEventListener","dispose","clear","_xrFrame","lightEstimationPollInterval","_lightEstimationPollTime","getLightEstimate","Math","max","primaryLightIntensity","x","y","z","rhsFactor","useRightHandedSystem","disableVectorReuse","direction","diffuse","copyFromFloats","primaryLightDirection","updateFromFloatsArray","sphericalHarmonicsCoefficients","disableSphericalPolynomial","sphericalPolynomial","updateFromHarmonics","copyFrom","min","LIGHT_ESTIMATION","AddWebXRFeature","Name","xrSessionManager","Version"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/XR/features/WebXRLightEstimation.ts"],"sourcesContent":["import { WebGLHardwareTexture } from \"../../Engines/WebGL/webGLHardwareTexture\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { DirectionalLight } from \"../../Lights/directionalLight\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { SphericalHarmonics, SphericalPolynomial } from \"../../Maths/sphericalPolynomial\";\r\nimport { LightConstants } from \"../../Lights/lightConstants\";\r\n\r\n/**\r\n * Options for Light Estimation feature\r\n */\r\nexport interface IWebXRLightEstimationOptions {\r\n    /**\r\n     * Disable the cube map reflection feature. In this case only light direction and color will be updated\r\n     */\r\n    disableCubeMapReflection?: boolean;\r\n    /**\r\n     * Should the scene's env texture be set to the cube map reflection texture\r\n     * Note that this doesn't work is disableCubeMapReflection if set to false\r\n     */\r\n    setSceneEnvironmentTexture?: boolean;\r\n    /**\r\n     * How often should the cubemap update in ms.\r\n     * If not set the cubemap will be updated every time the underlying system updates the environment texture.\r\n     */\r\n    cubeMapPollInterval?: number;\r\n    /**\r\n     * How often should the light estimation properties update in ms.\r\n     * If not set the light estimation properties will be updated on every frame (depending on the underlying system)\r\n     */\r\n    lightEstimationPollInterval?: number;\r\n    /**\r\n     * Should a directional light source be created.\r\n     * If created, this light source will be updated whenever the light estimation values change\r\n     */\r\n    createDirectionalLightSource?: boolean;\r\n    /**\r\n     * Define the format to be used for the light estimation texture.\r\n     */\r\n    reflectionFormat?: XRReflectionFormat;\r\n    /**\r\n     * Should the light estimation's needed vectors be constructed on each frame.\r\n     * Use this when you use those vectors and don't want their values to change outside of the light estimation feature\r\n     */\r\n    disableVectorReuse?: boolean;\r\n\r\n    /**\r\n     * disable applying the spherical polynomial to the cube map texture\r\n     */\r\n    disableSphericalPolynomial?: boolean;\r\n}\r\n\r\n/**\r\n * An interface describing the result of a light estimation\r\n */\r\nexport interface IWebXRLightEstimation {\r\n    /**\r\n     * The intensity of the light source\r\n     */\r\n    lightIntensity: number;\r\n    /**\r\n     * Color of light source\r\n     */\r\n    lightColor: Color3;\r\n    /**\r\n     * The direction from the light source\r\n     */\r\n    lightDirection: Vector3;\r\n    /**\r\n     * Spherical harmonics coefficients of the light source\r\n     */\r\n    sphericalHarmonics: SphericalHarmonics;\r\n}\r\n\r\n/**\r\n * Light Estimation Feature\r\n *\r\n * @since 5.0.0\r\n */\r\nexport class WebXRLightEstimation extends WebXRAbstractFeature {\r\n    private _canvasContext: Nullable<WebGLRenderingContext | WebGL2RenderingContext> = null;\r\n    private _reflectionCubeMap: Nullable<BaseTexture> = null;\r\n    private _xrLightEstimate: Nullable<XRLightEstimate> = null;\r\n    private _xrLightProbe: Nullable<XRLightProbe> = null;\r\n    private _xrWebGLBinding: Nullable<XRWebGLBinding> = null;\r\n    private _lightDirection: Vector3 = Vector3.Up().negateInPlace();\r\n    private _lightColor: Color3 = Color3.White();\r\n    private _intensity: number = 1;\r\n    private _sphericalHarmonics: SphericalHarmonics = new SphericalHarmonics();\r\n    private _cubeMapPollTime = Date.now();\r\n    private _lightEstimationPollTime = Date.now();\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.LIGHT_ESTIMATION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * ARCore's reflection cube map size is 16x16.\r\n     * Once other systems support this feature we will need to change this to be dynamic.\r\n     * see https://github.com/immersive-web/lighting-estimation/blob/main/lighting-estimation-explainer.md#cube-map-open-questions\r\n     */\r\n    private _reflectionCubeMapTextureSize: number = 16;\r\n\r\n    /**\r\n     * If createDirectionalLightSource is set to true this light source will be created automatically.\r\n     * Otherwise this can be set with an external directional light source.\r\n     * This light will be updated whenever the light estimation values change.\r\n     */\r\n    public directionalLight: Nullable<DirectionalLight> = null;\r\n\r\n    /**\r\n     * This observable will notify when the reflection cube map is updated.\r\n     */\r\n    public onReflectionCubeMapUpdatedObservable: Observable<BaseTexture> = new Observable();\r\n\r\n    /**\r\n     * Creates a new instance of the light estimation feature\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param options options to use when constructing this feature\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        /**\r\n         * options to use when constructing this feature\r\n         */\r\n        public readonly options: IWebXRLightEstimationOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"light-estimation\";\r\n\r\n        if (this.options.createDirectionalLightSource) {\r\n            this.directionalLight = new DirectionalLight(\"light estimation directional\", this._lightDirection, this._xrSessionManager.scene);\r\n            this.directionalLight.position = new Vector3(0, 8, 0);\r\n            // intensity will be set later\r\n            this.directionalLight.intensity = 0;\r\n            this.directionalLight.falloffType = LightConstants.FALLOFF_GLTF;\r\n        }\r\n\r\n        // https://immersive-web.github.io/lighting-estimation/\r\n        Tools.Warn(\"light-estimation is an experimental and unstable feature.\");\r\n    }\r\n\r\n    /**\r\n     * While the estimated cube map is expected to update over time to better reflect the user's environment as they move around those changes are unlikely to happen with every XRFrame.\r\n     * Since creating and processing the cube map is potentially expensive, especially if mip maps are needed, you can listen to the onReflectionCubeMapUpdatedObservable to determine\r\n     * when it has been updated.\r\n     */\r\n    public get reflectionCubeMapTexture(): Nullable<BaseTexture> {\r\n        return this._reflectionCubeMap;\r\n    }\r\n\r\n    /**\r\n     * The most recent light estimate.  Available starting on the first frame where the device provides a light probe.\r\n     */\r\n    public get xrLightingEstimate(): Nullable<IWebXRLightEstimation> {\r\n        if (this._xrLightEstimate) {\r\n            return {\r\n                lightColor: this._lightColor,\r\n                lightDirection: this._lightDirection,\r\n                lightIntensity: this._intensity,\r\n                sphericalHarmonics: this._sphericalHarmonics,\r\n            };\r\n        }\r\n        return this._xrLightEstimate;\r\n    }\r\n\r\n    private _getCanvasContext(): WebGLRenderingContext | WebGL2RenderingContext {\r\n        if (this._canvasContext === null) {\r\n            this._canvasContext = this._xrSessionManager.scene.getEngine()._gl;\r\n        }\r\n        return this._canvasContext;\r\n    }\r\n\r\n    private _getXRGLBinding(): XRWebGLBinding {\r\n        if (this._xrWebGLBinding === null) {\r\n            const context = this._getCanvasContext();\r\n            this._xrWebGLBinding = new XRWebGLBinding(this._xrSessionManager.session, context);\r\n        }\r\n        return this._xrWebGLBinding;\r\n    }\r\n\r\n    /**\r\n     * Event Listener for \"reflectionchange\" events.\r\n     */\r\n    private _updateReflectionCubeMap = (): void => {\r\n        if (!this._xrLightProbe) {\r\n            return;\r\n        }\r\n        // check poll time, do not update if it has not been long enough\r\n        if (this.options.cubeMapPollInterval) {\r\n            const now = Date.now();\r\n            if (now - this._cubeMapPollTime < this.options.cubeMapPollInterval) {\r\n                return;\r\n            }\r\n            this._cubeMapPollTime = now;\r\n        }\r\n        const lp = this._getXRGLBinding().getReflectionCubeMap(this._xrLightProbe);\r\n        if (lp && this._reflectionCubeMap) {\r\n            if (!this._reflectionCubeMap._texture) {\r\n                const internalTexture = new InternalTexture(this._xrSessionManager.scene.getEngine(), InternalTextureSource.Unknown);\r\n                internalTexture.isCube = true;\r\n                internalTexture.invertY = false;\r\n                internalTexture._useSRGBBuffer = this.options.reflectionFormat === \"srgba8\";\r\n                internalTexture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                internalTexture.generateMipMaps = true;\r\n                internalTexture.type = this.options.reflectionFormat !== \"srgba8\" ? Constants.TEXTURETYPE_HALF_FLOAT : Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                internalTexture.samplingMode = Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR;\r\n                internalTexture.width = this._reflectionCubeMapTextureSize;\r\n                internalTexture.height = this._reflectionCubeMapTextureSize;\r\n                internalTexture._cachedWrapU = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n                internalTexture._cachedWrapV = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n                internalTexture._hardwareTexture = new WebGLHardwareTexture(lp, this._getCanvasContext() as WebGLRenderingContext);\r\n                this._reflectionCubeMap._texture = internalTexture;\r\n            } else {\r\n                this._reflectionCubeMap._texture._hardwareTexture?.set(lp);\r\n                this._reflectionCubeMap._texture.getEngine().resetTextureCache();\r\n            }\r\n            this._reflectionCubeMap._texture.isReady = true;\r\n            this._xrSessionManager.scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n\r\n            this.onReflectionCubeMapUpdatedObservable.notifyObservers(this._reflectionCubeMap);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        const reflectionFormat = this.options.reflectionFormat ?? (this._xrSessionManager.session.preferredReflectionFormat || \"srgba8\");\r\n        this.options.reflectionFormat = reflectionFormat;\r\n        this._xrSessionManager.session\r\n            .requestLightProbe({\r\n                reflectionFormat,\r\n            })\r\n            .then((xrLightProbe: XRLightProbe) => {\r\n                this._xrLightProbe = xrLightProbe;\r\n                if (!this.options.disableCubeMapReflection) {\r\n                    if (!this._reflectionCubeMap) {\r\n                        this._reflectionCubeMap = new BaseTexture(this._xrSessionManager.scene);\r\n                        this._reflectionCubeMap.isCube = true;\r\n                        this._reflectionCubeMap.coordinatesMode = Constants.TEXTURE_CUBIC_MODE;\r\n                        if (this.options.setSceneEnvironmentTexture) {\r\n                            this._xrSessionManager.scene.environmentTexture = this._reflectionCubeMap;\r\n                        }\r\n                    }\r\n                    this._xrLightProbe.addEventListener(\"reflectionchange\", this._updateReflectionCubeMap);\r\n                }\r\n            });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        const detached = super.detach();\r\n\r\n        if (this._xrLightProbe !== null && !this.options.disableCubeMapReflection) {\r\n            this._xrLightProbe.removeEventListener(\"reflectionchange\", this._updateReflectionCubeMap);\r\n            this._xrLightProbe = null;\r\n        }\r\n\r\n        this._canvasContext = null;\r\n        this._xrLightEstimate = null;\r\n        // When the session ends (on detach) we must clear our XRWebGLBinging instance, which references the ended session.\r\n        this._xrWebGLBinding = null;\r\n\r\n        return detached;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        this.onReflectionCubeMapUpdatedObservable.clear();\r\n\r\n        if (this.directionalLight) {\r\n            this.directionalLight.dispose();\r\n            this.directionalLight = null;\r\n        }\r\n\r\n        if (this._reflectionCubeMap !== null) {\r\n            if (this._reflectionCubeMap._texture) {\r\n                this._reflectionCubeMap._texture.dispose();\r\n            }\r\n            this._reflectionCubeMap.dispose();\r\n            this._reflectionCubeMap = null;\r\n        }\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame): void {\r\n        if (this._xrLightProbe !== null) {\r\n            if (this.options.lightEstimationPollInterval) {\r\n                const now = Date.now();\r\n                if (now - this._lightEstimationPollTime < this.options.lightEstimationPollInterval) {\r\n                    return;\r\n                }\r\n                this._lightEstimationPollTime = now;\r\n            }\r\n            this._xrLightEstimate = _xrFrame.getLightEstimate(this._xrLightProbe);\r\n            if (this._xrLightEstimate) {\r\n                this._intensity = Math.max(\r\n                    1.0,\r\n                    this._xrLightEstimate.primaryLightIntensity.x,\r\n                    this._xrLightEstimate.primaryLightIntensity.y,\r\n                    this._xrLightEstimate.primaryLightIntensity.z\r\n                );\r\n\r\n                const rhsFactor = this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0;\r\n\r\n                // recreate the vector caches, so that the last one provided to the user will persist\r\n                if (this.options.disableVectorReuse) {\r\n                    this._lightDirection = new Vector3();\r\n                    this._lightColor = new Color3();\r\n                    if (this.directionalLight) {\r\n                        this.directionalLight.direction = this._lightDirection;\r\n                        this.directionalLight.diffuse = this._lightColor;\r\n                    }\r\n                }\r\n\r\n                this._lightDirection.copyFromFloats(\r\n                    this._xrLightEstimate.primaryLightDirection.x,\r\n                    this._xrLightEstimate.primaryLightDirection.y,\r\n                    this._xrLightEstimate.primaryLightDirection.z * rhsFactor\r\n                );\r\n                this._lightColor.copyFromFloats(\r\n                    this._xrLightEstimate.primaryLightIntensity.x / this._intensity,\r\n                    this._xrLightEstimate.primaryLightIntensity.y / this._intensity,\r\n                    this._xrLightEstimate.primaryLightIntensity.z / this._intensity\r\n                );\r\n                this._sphericalHarmonics.updateFromFloatsArray(this._xrLightEstimate.sphericalHarmonicsCoefficients);\r\n                if (this._reflectionCubeMap && !this.options.disableSphericalPolynomial) {\r\n                    this._reflectionCubeMap.sphericalPolynomial = this._reflectionCubeMap.sphericalPolynomial || new SphericalPolynomial();\r\n                    this._reflectionCubeMap.sphericalPolynomial?.updateFromHarmonics(this._sphericalHarmonics);\r\n                }\r\n\r\n                // direction from instead of direction to\r\n                this._lightDirection.negateInPlace();\r\n                // set the values after calculating them\r\n                if (this.directionalLight) {\r\n                    this.directionalLight.direction.copyFrom(this._lightDirection);\r\n                    this.directionalLight.intensity = Math.min(this._intensity, 1.0);\r\n                    this.directionalLight.diffuse.copyFrom(this._lightColor);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRLightEstimation.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRLightEstimation(xrSessionManager, options);\r\n    },\r\n    WebXRLightEstimation.Version,\r\n    false\r\n);\r\n"]},"metadata":{},"sourceType":"module"}