{"ast":null,"code":"import \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { MultiMaterial } from \"../Materials/multiMaterial.js\";\nimport { SerializationHelper } from \"./decorators.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nvar serializedGeometries = [];\n\nvar SerializeGeometry = function SerializeGeometry(geometry, serializationGeometries) {\n  if (geometry.doNotSerialize) {\n    return;\n  }\n\n  serializationGeometries.vertexData.push(geometry.serializeVerticeData());\n  serializedGeometries[geometry.id] = true;\n};\n\nvar SerializeMesh = function SerializeMesh(mesh, serializationScene) {\n  var serializationObject = {}; // Geometry\n\n  var geometry = mesh._geometry;\n\n  if (geometry) {\n    if (!mesh.getScene().getGeometryById(geometry.id)) {\n      // Geometry was in the memory but not added to the scene, nevertheless it's better to serialize to be able to reload the mesh with its geometry\n      SerializeGeometry(geometry, serializationScene.geometries);\n    }\n  } // Custom\n\n\n  if (mesh.serialize) {\n    mesh.serialize(serializationObject);\n  }\n\n  return serializationObject;\n};\n\nvar FinalizeSingleMesh = function FinalizeSingleMesh(mesh, serializationObject) {\n  //only works if the mesh is already loaded\n  if (mesh.delayLoadState === 1 || mesh.delayLoadState === 0) {\n    var serializeMaterial = function serializeMaterial(material) {\n      serializationObject.materials = serializationObject.materials || [];\n\n      if (!serializationObject.materials.some(function (mat) {\n        return mat.id === mesh.material.id;\n      })) {\n        serializationObject.materials.push(material.serialize());\n      }\n    }; //serialize material\n\n\n    if (mesh.material && !mesh.material.doNotSerialize) {\n      if (mesh.material instanceof MultiMaterial) {\n        serializationObject.multiMaterials = serializationObject.multiMaterials || [];\n\n        if (!serializationObject.multiMaterials.some(function (mat) {\n          return mat.id === mesh.material.id;\n        })) {\n          serializationObject.multiMaterials.push(mesh.material.serialize());\n\n          for (var _i = 0, _a = mesh.material.subMaterials; _i < _a.length; _i++) {\n            var submaterial = _a[_i];\n\n            if (submaterial) {\n              serializeMaterial(submaterial);\n            }\n          }\n        }\n      } else {\n        serializeMaterial(mesh.material);\n      }\n    } else if (!mesh.material) {\n      serializeMaterial(mesh.getScene().defaultMaterial);\n    } //serialize geometry\n\n\n    var geometry = mesh._geometry;\n\n    if (geometry) {\n      if (!serializationObject.geometries) {\n        serializationObject.geometries = {};\n        serializationObject.geometries.boxes = [];\n        serializationObject.geometries.spheres = [];\n        serializationObject.geometries.cylinders = [];\n        serializationObject.geometries.toruses = [];\n        serializationObject.geometries.grounds = [];\n        serializationObject.geometries.planes = [];\n        serializationObject.geometries.torusKnots = [];\n        serializationObject.geometries.vertexData = [];\n      }\n\n      SerializeGeometry(geometry, serializationObject.geometries);\n    } // Skeletons\n\n\n    if (mesh.skeleton && !mesh.skeleton.doNotSerialize) {\n      serializationObject.skeletons = serializationObject.skeletons || [];\n      serializationObject.skeletons.push(mesh.skeleton.serialize());\n    } //serialize the actual mesh\n\n\n    serializationObject.meshes = serializationObject.meshes || [];\n    serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));\n  }\n};\n/**\n * Class used to serialize a scene into a string\n */\n\n\nvar SceneSerializer =\n/** @class */\nfunction () {\n  function SceneSerializer() {}\n  /**\n   * Clear cache used by a previous serialization\n   */\n\n\n  SceneSerializer.ClearCache = function () {\n    serializedGeometries = [];\n  };\n  /**\n   * Serialize a scene into a JSON compatible object\n   * Note that if the current engine does not support synchronous texture reading (like WebGPU), you should use SerializeAsync instead\n   * as else you may not retrieve the proper base64 encoded texture data (when using the Texture.ForceSerializeBuffers flag)\n   * @param scene defines the scene to serialize\n   * @returns a JSON compatible object\n   */\n\n\n  SceneSerializer.Serialize = function (scene) {\n    return SceneSerializer._Serialize(scene);\n  };\n\n  SceneSerializer._Serialize = function (scene, checkSyncReadSupported) {\n    if (checkSyncReadSupported === void 0) {\n      checkSyncReadSupported = true;\n    }\n\n    var serializationObject = {};\n\n    if (checkSyncReadSupported && !scene.getEngine()._features.supportSyncTextureRead && Texture.ForceSerializeBuffers) {\n      console.warn(\"The serialization object may not contain the proper base64 encoded texture data! You should use the SerializeAsync method instead.\");\n    }\n\n    SceneSerializer.ClearCache(); // Scene\n\n    serializationObject.useDelayedTextureLoading = scene.useDelayedTextureLoading;\n    serializationObject.autoClear = scene.autoClear;\n    serializationObject.clearColor = scene.clearColor.asArray();\n    serializationObject.ambientColor = scene.ambientColor.asArray();\n    serializationObject.gravity = scene.gravity.asArray();\n    serializationObject.collisionsEnabled = scene.collisionsEnabled;\n    serializationObject.useRightHandedSystem = scene.useRightHandedSystem; // Fog\n\n    if (scene.fogMode && scene.fogMode !== 0) {\n      serializationObject.fogMode = scene.fogMode;\n      serializationObject.fogColor = scene.fogColor.asArray();\n      serializationObject.fogStart = scene.fogStart;\n      serializationObject.fogEnd = scene.fogEnd;\n      serializationObject.fogDensity = scene.fogDensity;\n    } //Physics\n\n\n    if (scene.isPhysicsEnabled()) {\n      var physicEngine = scene.getPhysicsEngine();\n\n      if (physicEngine) {\n        serializationObject.physicsEnabled = true;\n        serializationObject.physicsGravity = physicEngine.gravity.asArray();\n        serializationObject.physicsEngine = physicEngine.getPhysicsPluginName();\n      }\n    } // Metadata\n\n\n    if (scene.metadata) {\n      serializationObject.metadata = scene.metadata;\n    } // Morph targets\n\n\n    serializationObject.morphTargetManagers = [];\n\n    for (var _i = 0, _a = scene.meshes; _i < _a.length; _i++) {\n      var abstractMesh = _a[_i];\n      var manager = abstractMesh.morphTargetManager;\n\n      if (manager) {\n        serializationObject.morphTargetManagers.push(manager.serialize());\n      }\n    } // Lights\n\n\n    serializationObject.lights = [];\n    var index;\n    var light;\n\n    for (index = 0; index < scene.lights.length; index++) {\n      light = scene.lights[index];\n\n      if (!light.doNotSerialize) {\n        serializationObject.lights.push(light.serialize());\n      }\n    } // Cameras\n\n\n    serializationObject.cameras = [];\n\n    for (index = 0; index < scene.cameras.length; index++) {\n      var camera = scene.cameras[index];\n\n      if (!camera.doNotSerialize) {\n        serializationObject.cameras.push(camera.serialize());\n      }\n    }\n\n    if (scene.activeCamera) {\n      serializationObject.activeCameraID = scene.activeCamera.id;\n    } // Animations\n\n\n    SerializationHelper.AppendSerializedAnimations(scene, serializationObject); // Animation Groups\n\n    if (scene.animationGroups && scene.animationGroups.length > 0) {\n      serializationObject.animationGroups = [];\n\n      for (var animationGroupIndex = 0; animationGroupIndex < scene.animationGroups.length; animationGroupIndex++) {\n        var animationGroup = scene.animationGroups[animationGroupIndex];\n        serializationObject.animationGroups.push(animationGroup.serialize());\n      }\n    } // Reflection probes\n\n\n    if (scene.reflectionProbes && scene.reflectionProbes.length > 0) {\n      serializationObject.reflectionProbes = [];\n\n      for (index = 0; index < scene.reflectionProbes.length; index++) {\n        var reflectionProbe = scene.reflectionProbes[index];\n        serializationObject.reflectionProbes.push(reflectionProbe.serialize());\n      }\n    } // Materials\n\n\n    serializationObject.materials = [];\n    serializationObject.multiMaterials = [];\n    var material;\n\n    for (index = 0; index < scene.materials.length; index++) {\n      material = scene.materials[index];\n\n      if (!material.doNotSerialize) {\n        serializationObject.materials.push(material.serialize());\n      }\n    } // MultiMaterials\n\n\n    serializationObject.multiMaterials = [];\n\n    for (index = 0; index < scene.multiMaterials.length; index++) {\n      var multiMaterial = scene.multiMaterials[index];\n      serializationObject.multiMaterials.push(multiMaterial.serialize());\n    } // Environment texture\n\n\n    if (scene.environmentTexture) {\n      serializationObject.environmentTexture = scene.environmentTexture.name;\n      serializationObject.environmentTextureRotationY = scene.environmentTexture.rotationY;\n    } // Environment Intensity\n\n\n    serializationObject.environmentIntensity = scene.environmentIntensity; // Skeletons\n\n    serializationObject.skeletons = [];\n\n    for (index = 0; index < scene.skeletons.length; index++) {\n      var skeleton = scene.skeletons[index];\n\n      if (!skeleton.doNotSerialize) {\n        serializationObject.skeletons.push(skeleton.serialize());\n      }\n    } // Transform nodes\n\n\n    serializationObject.transformNodes = [];\n\n    for (index = 0; index < scene.transformNodes.length; index++) {\n      if (!scene.transformNodes[index].doNotSerialize) {\n        serializationObject.transformNodes.push(scene.transformNodes[index].serialize());\n      }\n    } // Geometries\n\n\n    serializationObject.geometries = {};\n    serializationObject.geometries.boxes = [];\n    serializationObject.geometries.spheres = [];\n    serializationObject.geometries.cylinders = [];\n    serializationObject.geometries.toruses = [];\n    serializationObject.geometries.grounds = [];\n    serializationObject.geometries.planes = [];\n    serializationObject.geometries.torusKnots = [];\n    serializationObject.geometries.vertexData = [];\n    serializedGeometries = [];\n    var geometries = scene.getGeometries();\n\n    for (index = 0; index < geometries.length; index++) {\n      var geometry = geometries[index];\n\n      if (geometry.isReady()) {\n        SerializeGeometry(geometry, serializationObject.geometries);\n      }\n    } // Meshes\n\n\n    serializationObject.meshes = [];\n\n    for (index = 0; index < scene.meshes.length; index++) {\n      var abstractMesh = scene.meshes[index];\n\n      if (abstractMesh instanceof Mesh) {\n        var mesh = abstractMesh;\n\n        if (!mesh.doNotSerialize) {\n          if (mesh.delayLoadState === 1 || mesh.delayLoadState === 0) {\n            serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));\n          }\n        }\n      }\n    } // Particles Systems\n\n\n    serializationObject.particleSystems = [];\n\n    for (index = 0; index < scene.particleSystems.length; index++) {\n      serializationObject.particleSystems.push(scene.particleSystems[index].serialize(false));\n    } // Post processes\n\n\n    serializationObject.postProcesses = [];\n\n    for (index = 0; index < scene.postProcesses.length; index++) {\n      serializationObject.postProcesses.push(scene.postProcesses[index].serialize());\n    } // Action Manager\n\n\n    if (scene.actionManager) {\n      serializationObject.actions = scene.actionManager.serialize(\"scene\");\n    } // Components\n\n\n    for (var _b = 0, _c = scene._serializableComponents; _b < _c.length; _b++) {\n      var component = _c[_b];\n      component.serialize(serializationObject);\n    }\n\n    return serializationObject;\n  };\n  /**\n   * Serialize a scene into a JSON compatible object\n   * @param scene defines the scene to serialize\n   * @returns a JSON promise compatible object\n   */\n\n\n  SceneSerializer.SerializeAsync = function (scene) {\n    var serializationObject = SceneSerializer._Serialize(scene, false);\n\n    var promises = [];\n\n    this._CollectPromises(serializationObject, promises);\n\n    return Promise.all(promises).then(function () {\n      return serializationObject;\n    });\n  };\n\n  SceneSerializer._CollectPromises = function (obj, promises) {\n    if (Array.isArray(obj)) {\n      var _loop_1 = function _loop_1(i) {\n        var o = obj[i];\n\n        if (o instanceof Promise) {\n          promises.push(o.then(function (res) {\n            return obj[i] = res;\n          }));\n        } else if (o instanceof Object || Array.isArray(o)) {\n          this_1._CollectPromises(o, promises);\n        }\n      };\n\n      var this_1 = this;\n\n      for (var i = 0; i < obj.length; ++i) {\n        _loop_1(i);\n      }\n    } else if (obj instanceof Object) {\n      var _loop_2 = function _loop_2(name_1) {\n        if (Object.prototype.hasOwnProperty.call(obj, name_1)) {\n          var o = obj[name_1];\n\n          if (o instanceof Promise) {\n            promises.push(o.then(function (res) {\n              return obj[name_1] = res;\n            }));\n          } else if (o instanceof Object || Array.isArray(o)) {\n            this_2._CollectPromises(o, promises);\n          }\n        }\n      };\n\n      var this_2 = this;\n\n      for (var name_1 in obj) {\n        _loop_2(name_1);\n      }\n    }\n  };\n  /**\n   * Serialize a mesh into a JSON compatible object\n   * @param toSerialize defines the mesh to serialize\n   * @param withParents defines if parents must be serialized as well\n   * @param withChildren defines if children must be serialized as well\n   * @returns a JSON compatible object\n   */\n\n\n  SceneSerializer.SerializeMesh = function (toSerialize\n  /* Mesh || Mesh[] */\n  , withParents, withChildren) {\n    if (withParents === void 0) {\n      withParents = false;\n    }\n\n    if (withChildren === void 0) {\n      withChildren = false;\n    }\n\n    var serializationObject = {};\n    SceneSerializer.ClearCache();\n    toSerialize = toSerialize instanceof Array ? toSerialize : [toSerialize];\n\n    if (withParents || withChildren) {\n      //deliberate for loop! not for each, appended should be processed as well.\n      for (var i = 0; i < toSerialize.length; ++i) {\n        if (withChildren) {\n          toSerialize[i].getDescendants().forEach(function (node) {\n            if (node instanceof Mesh && toSerialize.indexOf(node) < 0 && !node.doNotSerialize) {\n              toSerialize.push(node);\n            }\n          });\n        } //make sure the array doesn't contain the object already\n\n\n        if (withParents && toSerialize[i].parent && toSerialize.indexOf(toSerialize[i].parent) < 0 && !toSerialize[i].parent.doNotSerialize) {\n          toSerialize.push(toSerialize[i].parent);\n        }\n      }\n    }\n\n    toSerialize.forEach(function (mesh) {\n      FinalizeSingleMesh(mesh, serializationObject);\n    });\n    return serializationObject;\n  };\n\n  return SceneSerializer;\n}();\n\nexport { SceneSerializer };","map":{"version":3,"mappings":"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","names":["Mesh","MultiMaterial","SerializationHelper","Texture","serializedGeometries","SerializeGeometry","geometry","serializationGeometries","doNotSerialize","vertexData","push","serializeVerticeData","id","SerializeMesh","mesh","serializationScene","serializationObject","_geometry","getScene","getGeometryById","geometries","serialize","FinalizeSingleMesh","delayLoadState","serializeMaterial","material","materials","some","mat","multiMaterials","subMaterials","_i","submaterial","defaultMaterial","boxes","spheres","cylinders","toruses","grounds","planes","torusKnots","skeleton","skeletons","meshes","SceneSerializer","scene","_Serialize","checkSyncReadSupported","getEngine","_features","supportSyncTextureRead","ForceSerializeBuffers","console","warn","ClearCache","useDelayedTextureLoading","autoClear","clearColor","asArray","ambientColor","gravity","collisionsEnabled","useRightHandedSystem","fogMode","fogColor","fogStart","fogEnd","fogDensity","isPhysicsEnabled","physicEngine","getPhysicsEngine","physicsEnabled","physicsGravity","physicsEngine","getPhysicsPluginName","metadata","morphTargetManagers","abstractMesh","manager","morphTargetManager","lights","index","light","length","cameras","camera","activeCamera","activeCameraID","AppendSerializedAnimations","animationGroups","animationGroupIndex","animationGroup","reflectionProbes","reflectionProbe","multiMaterial","environmentTexture","name","environmentTextureRotationY","rotationY","environmentIntensity","transformNodes","getGeometries","isReady","particleSystems","postProcesses","actionManager","actions","_serializableComponents","_b","component","promises","_CollectPromises","Promise","all","then","obj","Array","isArray","i","o","res","Object","this_1","name_1","prototype","hasOwnProperty","call","this_2","toSerialize","withParents","withChildren","getDescendants","forEach","node","indexOf","parent"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/sceneSerializer.ts"],"sourcesContent":["import type { Geometry } from \"../Meshes/geometry\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { MultiMaterial } from \"../Materials/multiMaterial\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport { SerializationHelper } from \"./decorators\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { CubeTexture } from \"../Materials/Textures/cubeTexture\";\r\n\r\nlet serializedGeometries: Geometry[] = [];\r\nconst SerializeGeometry = (geometry: Geometry, serializationGeometries: any): any => {\r\n    if (geometry.doNotSerialize) {\r\n        return;\r\n    }\r\n\r\n    serializationGeometries.vertexData.push(geometry.serializeVerticeData());\r\n\r\n    (<any>serializedGeometries)[geometry.id] = true;\r\n};\r\n\r\nconst SerializeMesh = (mesh: Mesh, serializationScene: any): any => {\r\n    const serializationObject: any = {};\r\n\r\n    // Geometry\r\n    const geometry = mesh._geometry;\r\n    if (geometry) {\r\n        if (!mesh.getScene().getGeometryById(geometry.id)) {\r\n            // Geometry was in the memory but not added to the scene, nevertheless it's better to serialize to be able to reload the mesh with its geometry\r\n            SerializeGeometry(geometry, serializationScene.geometries);\r\n        }\r\n    }\r\n\r\n    // Custom\r\n    if (mesh.serialize) {\r\n        mesh.serialize(serializationObject);\r\n    }\r\n\r\n    return serializationObject;\r\n};\r\n\r\nconst FinalizeSingleMesh = (mesh: Mesh, serializationObject: any) => {\r\n    //only works if the mesh is already loaded\r\n    if (mesh.delayLoadState === Constants.DELAYLOADSTATE_LOADED || mesh.delayLoadState === Constants.DELAYLOADSTATE_NONE) {\r\n        const serializeMaterial = (material: Material) => {\r\n            serializationObject.materials = serializationObject.materials || [];\r\n            if (!serializationObject.materials.some((mat: Material) => mat.id === (<Material>mesh.material).id)) {\r\n                serializationObject.materials.push(material.serialize());\r\n            }\r\n        };\r\n\r\n        //serialize material\r\n        if (mesh.material && !mesh.material.doNotSerialize) {\r\n            if (mesh.material instanceof MultiMaterial) {\r\n                serializationObject.multiMaterials = serializationObject.multiMaterials || [];\r\n                if (!serializationObject.multiMaterials.some((mat: Material) => mat.id === (<Material>mesh.material).id)) {\r\n                    serializationObject.multiMaterials.push(mesh.material.serialize());\r\n                    for (const submaterial of mesh.material.subMaterials) {\r\n                        if (submaterial) {\r\n                            serializeMaterial(submaterial);\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                serializeMaterial(mesh.material);\r\n            }\r\n        } else if (!mesh.material) {\r\n            serializeMaterial(mesh.getScene().defaultMaterial);\r\n        }\r\n\r\n        //serialize geometry\r\n        const geometry = mesh._geometry;\r\n        if (geometry) {\r\n            if (!serializationObject.geometries) {\r\n                serializationObject.geometries = {};\r\n\r\n                serializationObject.geometries.boxes = [];\r\n                serializationObject.geometries.spheres = [];\r\n                serializationObject.geometries.cylinders = [];\r\n                serializationObject.geometries.toruses = [];\r\n                serializationObject.geometries.grounds = [];\r\n                serializationObject.geometries.planes = [];\r\n                serializationObject.geometries.torusKnots = [];\r\n                serializationObject.geometries.vertexData = [];\r\n            }\r\n\r\n            SerializeGeometry(geometry, serializationObject.geometries);\r\n        }\r\n        // Skeletons\r\n        if (mesh.skeleton && !mesh.skeleton.doNotSerialize) {\r\n            serializationObject.skeletons = serializationObject.skeletons || [];\r\n            serializationObject.skeletons.push(mesh.skeleton.serialize());\r\n        }\r\n\r\n        //serialize the actual mesh\r\n        serializationObject.meshes = serializationObject.meshes || [];\r\n        serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));\r\n    }\r\n};\r\n\r\n/**\r\n * Class used to serialize a scene into a string\r\n */\r\nexport class SceneSerializer {\r\n    /**\r\n     * Clear cache used by a previous serialization\r\n     */\r\n    public static ClearCache(): void {\r\n        serializedGeometries = [];\r\n    }\r\n\r\n    /**\r\n     * Serialize a scene into a JSON compatible object\r\n     * Note that if the current engine does not support synchronous texture reading (like WebGPU), you should use SerializeAsync instead\r\n     * as else you may not retrieve the proper base64 encoded texture data (when using the Texture.ForceSerializeBuffers flag)\r\n     * @param scene defines the scene to serialize\r\n     * @returns a JSON compatible object\r\n     */\r\n    public static Serialize(scene: Scene): any {\r\n        return SceneSerializer._Serialize(scene);\r\n    }\r\n\r\n    private static _Serialize(scene: Scene, checkSyncReadSupported = true): any {\r\n        const serializationObject: any = {};\r\n\r\n        if (checkSyncReadSupported && !scene.getEngine()._features.supportSyncTextureRead && Texture.ForceSerializeBuffers) {\r\n            console.warn(\"The serialization object may not contain the proper base64 encoded texture data! You should use the SerializeAsync method instead.\");\r\n        }\r\n\r\n        SceneSerializer.ClearCache();\r\n\r\n        // Scene\r\n        serializationObject.useDelayedTextureLoading = scene.useDelayedTextureLoading;\r\n        serializationObject.autoClear = scene.autoClear;\r\n        serializationObject.clearColor = scene.clearColor.asArray();\r\n        serializationObject.ambientColor = scene.ambientColor.asArray();\r\n        serializationObject.gravity = scene.gravity.asArray();\r\n        serializationObject.collisionsEnabled = scene.collisionsEnabled;\r\n        serializationObject.useRightHandedSystem = scene.useRightHandedSystem;\r\n\r\n        // Fog\r\n        if (scene.fogMode && scene.fogMode !== 0) {\r\n            serializationObject.fogMode = scene.fogMode;\r\n            serializationObject.fogColor = scene.fogColor.asArray();\r\n            serializationObject.fogStart = scene.fogStart;\r\n            serializationObject.fogEnd = scene.fogEnd;\r\n            serializationObject.fogDensity = scene.fogDensity;\r\n        }\r\n\r\n        //Physics\r\n        if (scene.isPhysicsEnabled()) {\r\n            const physicEngine = scene.getPhysicsEngine();\r\n\r\n            if (physicEngine) {\r\n                serializationObject.physicsEnabled = true;\r\n                serializationObject.physicsGravity = physicEngine.gravity.asArray();\r\n                serializationObject.physicsEngine = physicEngine.getPhysicsPluginName();\r\n            }\r\n        }\r\n\r\n        // Metadata\r\n        if (scene.metadata) {\r\n            serializationObject.metadata = scene.metadata;\r\n        }\r\n\r\n        // Morph targets\r\n        serializationObject.morphTargetManagers = [];\r\n        for (const abstractMesh of scene.meshes) {\r\n            const manager = (<Mesh>abstractMesh).morphTargetManager;\r\n\r\n            if (manager) {\r\n                serializationObject.morphTargetManagers.push(manager.serialize());\r\n            }\r\n        }\r\n\r\n        // Lights\r\n        serializationObject.lights = [];\r\n        let index: number;\r\n        let light: Light;\r\n        for (index = 0; index < scene.lights.length; index++) {\r\n            light = scene.lights[index];\r\n\r\n            if (!light.doNotSerialize) {\r\n                serializationObject.lights.push(light.serialize());\r\n            }\r\n        }\r\n\r\n        // Cameras\r\n        serializationObject.cameras = [];\r\n        for (index = 0; index < scene.cameras.length; index++) {\r\n            const camera = scene.cameras[index];\r\n\r\n            if (!camera.doNotSerialize) {\r\n                serializationObject.cameras.push(camera.serialize());\r\n            }\r\n        }\r\n\r\n        if (scene.activeCamera) {\r\n            serializationObject.activeCameraID = scene.activeCamera.id;\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(scene, serializationObject);\r\n\r\n        // Animation Groups\r\n        if (scene.animationGroups && scene.animationGroups.length > 0) {\r\n            serializationObject.animationGroups = [];\r\n            for (let animationGroupIndex = 0; animationGroupIndex < scene.animationGroups.length; animationGroupIndex++) {\r\n                const animationGroup = scene.animationGroups[animationGroupIndex];\r\n\r\n                serializationObject.animationGroups.push(animationGroup.serialize());\r\n            }\r\n        }\r\n\r\n        // Reflection probes\r\n        if (scene.reflectionProbes && scene.reflectionProbes.length > 0) {\r\n            serializationObject.reflectionProbes = [];\r\n\r\n            for (index = 0; index < scene.reflectionProbes.length; index++) {\r\n                const reflectionProbe = scene.reflectionProbes[index];\r\n                serializationObject.reflectionProbes.push(reflectionProbe.serialize());\r\n            }\r\n        }\r\n\r\n        // Materials\r\n        serializationObject.materials = [];\r\n        serializationObject.multiMaterials = [];\r\n        let material: Material;\r\n        for (index = 0; index < scene.materials.length; index++) {\r\n            material = scene.materials[index];\r\n            if (!material.doNotSerialize) {\r\n                serializationObject.materials.push(material.serialize());\r\n            }\r\n        }\r\n\r\n        // MultiMaterials\r\n        serializationObject.multiMaterials = [];\r\n        for (index = 0; index < scene.multiMaterials.length; index++) {\r\n            const multiMaterial = scene.multiMaterials[index];\r\n            serializationObject.multiMaterials.push(multiMaterial.serialize());\r\n        }\r\n\r\n        // Environment texture\r\n        if (scene.environmentTexture) {\r\n            serializationObject.environmentTexture = scene.environmentTexture.name;\r\n            serializationObject.environmentTextureRotationY = (scene.environmentTexture as CubeTexture).rotationY;\r\n        }\r\n\r\n        // Environment Intensity\r\n        serializationObject.environmentIntensity = scene.environmentIntensity;\r\n\r\n        // Skeletons\r\n        serializationObject.skeletons = [];\r\n        for (index = 0; index < scene.skeletons.length; index++) {\r\n            const skeleton = scene.skeletons[index];\r\n            if (!skeleton.doNotSerialize) {\r\n                serializationObject.skeletons.push(skeleton.serialize());\r\n            }\r\n        }\r\n\r\n        // Transform nodes\r\n        serializationObject.transformNodes = [];\r\n        for (index = 0; index < scene.transformNodes.length; index++) {\r\n            if (!scene.transformNodes[index].doNotSerialize) {\r\n                serializationObject.transformNodes.push(scene.transformNodes[index].serialize());\r\n            }\r\n        }\r\n\r\n        // Geometries\r\n        serializationObject.geometries = {};\r\n\r\n        serializationObject.geometries.boxes = [];\r\n        serializationObject.geometries.spheres = [];\r\n        serializationObject.geometries.cylinders = [];\r\n        serializationObject.geometries.toruses = [];\r\n        serializationObject.geometries.grounds = [];\r\n        serializationObject.geometries.planes = [];\r\n        serializationObject.geometries.torusKnots = [];\r\n        serializationObject.geometries.vertexData = [];\r\n\r\n        serializedGeometries = [];\r\n        const geometries = scene.getGeometries();\r\n        for (index = 0; index < geometries.length; index++) {\r\n            const geometry = geometries[index];\r\n\r\n            if (geometry.isReady()) {\r\n                SerializeGeometry(geometry, serializationObject.geometries);\r\n            }\r\n        }\r\n\r\n        // Meshes\r\n        serializationObject.meshes = [];\r\n        for (index = 0; index < scene.meshes.length; index++) {\r\n            const abstractMesh = scene.meshes[index];\r\n\r\n            if (abstractMesh instanceof Mesh) {\r\n                const mesh = abstractMesh;\r\n                if (!mesh.doNotSerialize) {\r\n                    if (mesh.delayLoadState === Constants.DELAYLOADSTATE_LOADED || mesh.delayLoadState === Constants.DELAYLOADSTATE_NONE) {\r\n                        serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Particles Systems\r\n        serializationObject.particleSystems = [];\r\n        for (index = 0; index < scene.particleSystems.length; index++) {\r\n            serializationObject.particleSystems.push(scene.particleSystems[index].serialize(false));\r\n        }\r\n\r\n        // Post processes\r\n        serializationObject.postProcesses = [];\r\n        for (index = 0; index < scene.postProcesses.length; index++) {\r\n            serializationObject.postProcesses.push(scene.postProcesses[index].serialize());\r\n        }\r\n\r\n        // Action Manager\r\n        if (scene.actionManager) {\r\n            serializationObject.actions = scene.actionManager.serialize(\"scene\");\r\n        }\r\n\r\n        // Components\r\n        for (const component of scene._serializableComponents) {\r\n            component.serialize(serializationObject);\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Serialize a scene into a JSON compatible object\r\n     * @param scene defines the scene to serialize\r\n     * @returns a JSON promise compatible object\r\n     */\r\n    public static SerializeAsync(scene: Scene): Promise<any> {\r\n        const serializationObject = SceneSerializer._Serialize(scene, false);\r\n\r\n        const promises: Array<Promise<any>> = [];\r\n\r\n        this._CollectPromises(serializationObject, promises);\r\n\r\n        return Promise.all(promises).then(() => serializationObject);\r\n    }\r\n\r\n    private static _CollectPromises(obj: any, promises: Array<Promise<any>>): void {\r\n        if (Array.isArray(obj)) {\r\n            for (let i = 0; i < obj.length; ++i) {\r\n                const o = obj[i];\r\n                if (o instanceof Promise) {\r\n                    promises.push(o.then((res: any) => (obj[i] = res)));\r\n                } else if (o instanceof Object || Array.isArray(o)) {\r\n                    this._CollectPromises(o, promises);\r\n                }\r\n            }\r\n        } else if (obj instanceof Object) {\r\n            for (const name in obj) {\r\n                if (Object.prototype.hasOwnProperty.call(obj, name)) {\r\n                    const o = obj[name];\r\n                    if (o instanceof Promise) {\r\n                        promises.push(o.then((res: any) => (obj[name] = res)));\r\n                    } else if (o instanceof Object || Array.isArray(o)) {\r\n                        this._CollectPromises(o, promises);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize a mesh into a JSON compatible object\r\n     * @param toSerialize defines the mesh to serialize\r\n     * @param withParents defines if parents must be serialized as well\r\n     * @param withChildren defines if children must be serialized as well\r\n     * @returns a JSON compatible object\r\n     */\r\n    public static SerializeMesh(toSerialize: any /* Mesh || Mesh[] */, withParents: boolean = false, withChildren: boolean = false): any {\r\n        const serializationObject: any = {};\r\n\r\n        SceneSerializer.ClearCache();\r\n\r\n        toSerialize = toSerialize instanceof Array ? toSerialize : [toSerialize];\r\n\r\n        if (withParents || withChildren) {\r\n            //deliberate for loop! not for each, appended should be processed as well.\r\n            for (let i = 0; i < toSerialize.length; ++i) {\r\n                if (withChildren) {\r\n                    toSerialize[i].getDescendants().forEach((node: Node) => {\r\n                        if (node instanceof Mesh && toSerialize.indexOf(node) < 0 && !node.doNotSerialize) {\r\n                            toSerialize.push(node);\r\n                        }\r\n                    });\r\n                }\r\n                //make sure the array doesn't contain the object already\r\n                if (withParents && toSerialize[i].parent && toSerialize.indexOf(toSerialize[i].parent) < 0 && !toSerialize[i].parent.doNotSerialize) {\r\n                    toSerialize.push(toSerialize[i].parent);\r\n                }\r\n            }\r\n        }\r\n\r\n        toSerialize.forEach((mesh: Mesh) => {\r\n            FinalizeSingleMesh(mesh, serializationObject);\r\n        });\r\n\r\n        return serializationObject;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}