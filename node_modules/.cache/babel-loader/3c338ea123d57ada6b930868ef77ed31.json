{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport { Vector3, Quaternion, Matrix } from \"../Maths/math.vector.js\";\nimport { Space } from \"../Maths/math.axis.js\";\n/**\n * Class used to apply inverse kinematics to bones\n * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons#boneikcontroller\n */\n\nvar BoneIKController =\n/** @class */\nfunction () {\n  /**\n   * Creates a new BoneIKController\n   * @param mesh defines the TransformNode to control\n   * @param bone defines the bone to control\n   * @param options defines options to set up the controller\n   * @param options.targetMesh\n   * @param options.poleTargetMesh\n   * @param options.poleTargetBone\n   * @param options.poleTargetLocalOffset\n   * @param options.poleAngle\n   * @param options.bendAxis\n   * @param options.maxAngle\n   * @param options.slerpAmount\n   */\n  function BoneIKController(mesh, bone, options) {\n    /**\n     * Gets or sets the target position\n     */\n    this.targetPosition = Vector3.Zero();\n    /**\n     * Gets or sets the pole target position\n     */\n\n    this.poleTargetPosition = Vector3.Zero();\n    /**\n     * Gets or sets the pole target local offset\n     */\n\n    this.poleTargetLocalOffset = Vector3.Zero();\n    /**\n     * Gets or sets the pole angle\n     */\n\n    this.poleAngle = 0;\n    /**\n     * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)\n     */\n\n    this.slerpAmount = 1;\n    this._bone1Quat = Quaternion.Identity();\n    this._bone1Mat = Matrix.Identity();\n    this._bone2Ang = Math.PI;\n    this._maxAngle = Math.PI;\n    this._rightHandedSystem = false;\n    this._bendAxis = Vector3.Right();\n    this._slerping = false;\n    this._adjustRoll = 0;\n    this._bone2 = bone;\n    this._bone1 = bone.getParent();\n\n    if (!this._bone1) {\n      return;\n    }\n\n    this.mesh = mesh;\n    var bonePos = bone.getPosition();\n\n    if (bone.getAbsoluteTransform().determinant() > 0) {\n      this._rightHandedSystem = true;\n      this._bendAxis.x = 0;\n      this._bendAxis.y = 0;\n      this._bendAxis.z = -1;\n\n      if (bonePos.x > bonePos.y && bonePos.x > bonePos.z) {\n        this._adjustRoll = Math.PI * 0.5;\n        this._bendAxis.z = 1;\n      }\n    }\n\n    if (this._bone1.length) {\n      var boneScale1 = this._bone1.getScale();\n\n      var boneScale2 = this._bone2.getScale();\n\n      this._bone1Length = this._bone1.length * boneScale1.y * this.mesh.scaling.y;\n      this._bone2Length = this._bone2.length * boneScale2.y * this.mesh.scaling.y;\n    } else if (this._bone1.children[0]) {\n      mesh.computeWorldMatrix(true);\n\n      var pos1 = this._bone2.children[0].getAbsolutePosition(mesh);\n\n      var pos2 = this._bone2.getAbsolutePosition(mesh);\n\n      var pos3 = this._bone1.getAbsolutePosition(mesh);\n\n      this._bone1Length = Vector3.Distance(pos1, pos2);\n      this._bone2Length = Vector3.Distance(pos2, pos3);\n    }\n\n    this._bone1.getRotationMatrixToRef(Space.WORLD, mesh, this._bone1Mat);\n\n    this.maxAngle = Math.PI;\n\n    if (options) {\n      if (options.targetMesh) {\n        this.targetMesh = options.targetMesh;\n        this.targetMesh.computeWorldMatrix(true);\n      }\n\n      if (options.poleTargetMesh) {\n        this.poleTargetMesh = options.poleTargetMesh;\n        this.poleTargetMesh.computeWorldMatrix(true);\n      } else if (options.poleTargetBone) {\n        this.poleTargetBone = options.poleTargetBone;\n      } else if (this._bone1.getParent()) {\n        this.poleTargetBone = this._bone1.getParent();\n      }\n\n      if (options.poleTargetLocalOffset) {\n        this.poleTargetLocalOffset.copyFrom(options.poleTargetLocalOffset);\n      }\n\n      if (options.poleAngle) {\n        this.poleAngle = options.poleAngle;\n      }\n\n      if (options.bendAxis) {\n        this._bendAxis.copyFrom(options.bendAxis);\n      }\n\n      if (options.maxAngle) {\n        this.maxAngle = options.maxAngle;\n      }\n\n      if (options.slerpAmount) {\n        this.slerpAmount = options.slerpAmount;\n      }\n    }\n  }\n\n  Object.defineProperty(BoneIKController.prototype, \"maxAngle\", {\n    /**\n     * Gets or sets maximum allowed angle\n     */\n    get: function get() {\n      return this._maxAngle;\n    },\n    set: function set(value) {\n      this._setMaxAngle(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  BoneIKController.prototype._setMaxAngle = function (ang) {\n    if (ang < 0) {\n      ang = 0;\n    }\n\n    if (ang > Math.PI || ang == undefined) {\n      ang = Math.PI;\n    }\n\n    this._maxAngle = ang;\n    var a = this._bone1Length;\n    var b = this._bone2Length;\n    this._maxReach = Math.sqrt(a * a + b * b - 2 * a * b * Math.cos(ang));\n  };\n  /**\n   * Force the controller to update the bones\n   */\n\n\n  BoneIKController.prototype.update = function () {\n    var bone1 = this._bone1;\n\n    if (!bone1) {\n      return;\n    }\n\n    var target = this.targetPosition;\n    var poleTarget = this.poleTargetPosition;\n    var mat1 = BoneIKController._TmpMats[0];\n    var mat2 = BoneIKController._TmpMats[1];\n\n    if (this.targetMesh) {\n      target.copyFrom(this.targetMesh.getAbsolutePosition());\n    }\n\n    if (this.poleTargetBone) {\n      this.poleTargetBone.getAbsolutePositionFromLocalToRef(this.poleTargetLocalOffset, this.mesh, poleTarget);\n    } else if (this.poleTargetMesh) {\n      Vector3.TransformCoordinatesToRef(this.poleTargetLocalOffset, this.poleTargetMesh.getWorldMatrix(), poleTarget);\n    }\n\n    var bonePos = BoneIKController._TmpVecs[0];\n    var zaxis = BoneIKController._TmpVecs[1];\n    var xaxis = BoneIKController._TmpVecs[2];\n    var yaxis = BoneIKController._TmpVecs[3];\n    var upAxis = BoneIKController._TmpVecs[4];\n    var tmpQuat = BoneIKController._TmpQuat;\n    bone1.getAbsolutePositionToRef(this.mesh, bonePos);\n    poleTarget.subtractToRef(bonePos, upAxis);\n\n    if (upAxis.x == 0 && upAxis.y == 0 && upAxis.z == 0) {\n      upAxis.y = 1;\n    } else {\n      upAxis.normalize();\n    }\n\n    target.subtractToRef(bonePos, yaxis);\n    yaxis.normalize();\n    Vector3.CrossToRef(yaxis, upAxis, zaxis);\n    zaxis.normalize();\n    Vector3.CrossToRef(yaxis, zaxis, xaxis);\n    xaxis.normalize();\n    Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, mat1);\n    var a = this._bone1Length;\n    var b = this._bone2Length;\n    var c = Vector3.Distance(bonePos, target);\n\n    if (this._maxReach > 0) {\n      c = Math.min(this._maxReach, c);\n    }\n\n    var acosa = (b * b + c * c - a * a) / (2 * b * c);\n    var acosb = (c * c + a * a - b * b) / (2 * c * a);\n\n    if (acosa > 1) {\n      acosa = 1;\n    }\n\n    if (acosb > 1) {\n      acosb = 1;\n    }\n\n    if (acosa < -1) {\n      acosa = -1;\n    }\n\n    if (acosb < -1) {\n      acosb = -1;\n    }\n\n    var angA = Math.acos(acosa);\n    var angB = Math.acos(acosb);\n    var angC = -angA - angB;\n\n    if (this._rightHandedSystem) {\n      Matrix.RotationYawPitchRollToRef(0, 0, this._adjustRoll, mat2);\n      mat2.multiplyToRef(mat1, mat1);\n      Matrix.RotationAxisToRef(this._bendAxis, angB, mat2);\n      mat2.multiplyToRef(mat1, mat1);\n    } else {\n      var _tmpVec = BoneIKController._TmpVecs[5];\n\n      _tmpVec.copyFrom(this._bendAxis);\n\n      _tmpVec.x *= -1;\n      Matrix.RotationAxisToRef(_tmpVec, -angB, mat2);\n      mat2.multiplyToRef(mat1, mat1);\n    }\n\n    if (this.poleAngle) {\n      Matrix.RotationAxisToRef(yaxis, this.poleAngle, mat2);\n      mat1.multiplyToRef(mat2, mat1);\n    }\n\n    if (this._bone1) {\n      if (this.slerpAmount < 1) {\n        if (!this._slerping) {\n          Quaternion.FromRotationMatrixToRef(this._bone1Mat, this._bone1Quat);\n        }\n\n        Quaternion.FromRotationMatrixToRef(mat1, tmpQuat);\n        Quaternion.SlerpToRef(this._bone1Quat, tmpQuat, this.slerpAmount, this._bone1Quat);\n        angC = this._bone2Ang * (1.0 - this.slerpAmount) + angC * this.slerpAmount;\n\n        this._bone1.setRotationQuaternion(this._bone1Quat, Space.WORLD, this.mesh);\n\n        this._slerping = true;\n      } else {\n        this._bone1.setRotationMatrix(mat1, Space.WORLD, this.mesh);\n\n        this._bone1Mat.copyFrom(mat1);\n\n        this._slerping = false;\n      }\n\n      this._updateLinkedTransformRotation(this._bone1);\n    }\n\n    this._bone2.setAxisAngle(this._bendAxis, angC, Space.LOCAL);\n\n    this._updateLinkedTransformRotation(this._bone2);\n\n    this._bone2Ang = angC;\n  };\n\n  BoneIKController.prototype._updateLinkedTransformRotation = function (bone) {\n    if (bone._linkedTransformNode) {\n      if (!bone._linkedTransformNode.rotationQuaternion) {\n        bone._linkedTransformNode.rotationQuaternion = new Quaternion();\n      }\n\n      bone.getRotationQuaternionToRef(Space.LOCAL, null, bone._linkedTransformNode.rotationQuaternion);\n    }\n  };\n\n  BoneIKController._TmpVecs = [Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero()];\n  BoneIKController._TmpQuat = Quaternion.Identity();\n  BoneIKController._TmpMats = [Matrix.Identity(), Matrix.Identity()];\n  return BoneIKController;\n}();\n\nexport { BoneIKController };","map":{"version":3,"mappings":"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","names":["Vector3","Quaternion","Matrix","Space","mesh","bone","options","Zero","Identity","Math","PI","Right","_bone2","_bone1","getParent","bonePos","getPosition","getAbsoluteTransform","determinant","_rightHandedSystem","_bendAxis","x","y","z","_adjustRoll","length","boneScale1","getScale","boneScale2","_bone1Length","scaling","_bone2Length","children","computeWorldMatrix","pos1","getAbsolutePosition","pos2","pos3","Distance","getRotationMatrixToRef","WORLD","_bone1Mat","maxAngle","targetMesh","poleTargetMesh","poleTargetBone","poleTargetLocalOffset","copyFrom","poleAngle","bendAxis","slerpAmount","Object","BoneIKController","_maxAngle","value","_setMaxAngle","ang","undefined","a","b","_maxReach","sqrt","cos","bone1","target","targetPosition","poleTarget","poleTargetPosition","mat1","_TmpMats","mat2","getAbsolutePositionFromLocalToRef","TransformCoordinatesToRef","getWorldMatrix","_TmpVecs","zaxis","xaxis","yaxis","upAxis","tmpQuat","_TmpQuat","getAbsolutePositionToRef","subtractToRef","normalize","CrossToRef","FromXYZAxesToRef","c","min","acosa","acosb","angA","acos","angB","angC","RotationYawPitchRollToRef","multiplyToRef","RotationAxisToRef","_tmpVec","_slerping","FromRotationMatrixToRef","_bone1Quat","SlerpToRef","_bone2Ang","setRotationQuaternion","setRotationMatrix","_updateLinkedTransformRotation","setAxisAngle","LOCAL","_linkedTransformNode","rotationQuaternion","getRotationQuaternionToRef"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Bones/boneIKController.ts"],"sourcesContent":["import type { Bone } from \"./bone\";\r\nimport { Vector3, Quaternion, Matrix } from \"../Maths/math.vector\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Space } from \"../Maths/math.axis\";\r\n\r\n/**\r\n * Class used to apply inverse kinematics to bones\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons#boneikcontroller\r\n */\r\nexport class BoneIKController {\r\n    private static _TmpVecs: Vector3[] = [Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero()];\r\n    private static _TmpQuat = Quaternion.Identity();\r\n    private static _TmpMats: Matrix[] = [Matrix.Identity(), Matrix.Identity()];\r\n\r\n    /**\r\n     * Gets or sets the target TransformNode\r\n     * Name kept as mesh for back compatibility\r\n     */\r\n    public targetMesh: TransformNode;\r\n\r\n    /** Gets or sets the mesh used as pole */\r\n    public poleTargetMesh: TransformNode;\r\n\r\n    /**\r\n     * Gets or sets the bone used as pole\r\n     */\r\n    public poleTargetBone: Nullable<Bone>;\r\n\r\n    /**\r\n     * Gets or sets the target position\r\n     */\r\n    public targetPosition = Vector3.Zero();\r\n\r\n    /**\r\n     * Gets or sets the pole target position\r\n     */\r\n    public poleTargetPosition = Vector3.Zero();\r\n\r\n    /**\r\n     * Gets or sets the pole target local offset\r\n     */\r\n    public poleTargetLocalOffset = Vector3.Zero();\r\n\r\n    /**\r\n     * Gets or sets the pole angle\r\n     */\r\n    public poleAngle = 0;\r\n\r\n    /**\r\n     * Gets or sets the TransformNode associated with the controller\r\n     * Name kept as mesh for back compatibility\r\n     */\r\n    public mesh: TransformNode;\r\n\r\n    /**\r\n     * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)\r\n     */\r\n    public slerpAmount = 1;\r\n\r\n    private _bone1Quat = Quaternion.Identity();\r\n    private _bone1Mat = Matrix.Identity();\r\n    private _bone2Ang = Math.PI;\r\n\r\n    private _bone1: Nullable<Bone>;\r\n    private _bone2: Bone;\r\n    private _bone1Length: number;\r\n    private _bone2Length: number;\r\n    private _maxAngle = Math.PI;\r\n    private _maxReach: number;\r\n\r\n    private _rightHandedSystem = false;\r\n\r\n    private _bendAxis = Vector3.Right();\r\n    private _slerping = false;\r\n\r\n    private _adjustRoll = 0;\r\n\r\n    /**\r\n     * Gets or sets maximum allowed angle\r\n     */\r\n    public get maxAngle(): number {\r\n        return this._maxAngle;\r\n    }\r\n\r\n    public set maxAngle(value: number) {\r\n        this._setMaxAngle(value);\r\n    }\r\n\r\n    /**\r\n     * Creates a new BoneIKController\r\n     * @param mesh defines the TransformNode to control\r\n     * @param bone defines the bone to control\r\n     * @param options defines options to set up the controller\r\n     * @param options.targetMesh\r\n     * @param options.poleTargetMesh\r\n     * @param options.poleTargetBone\r\n     * @param options.poleTargetLocalOffset\r\n     * @param options.poleAngle\r\n     * @param options.bendAxis\r\n     * @param options.maxAngle\r\n     * @param options.slerpAmount\r\n     */\r\n    constructor(\r\n        mesh: TransformNode,\r\n        bone: Bone,\r\n        options?: {\r\n            targetMesh?: TransformNode;\r\n            poleTargetMesh?: TransformNode;\r\n            poleTargetBone?: Bone;\r\n            poleTargetLocalOffset?: Vector3;\r\n            poleAngle?: number;\r\n            bendAxis?: Vector3;\r\n            maxAngle?: number;\r\n            slerpAmount?: number;\r\n        }\r\n    ) {\r\n        this._bone2 = bone;\r\n        this._bone1 = bone.getParent();\r\n\r\n        if (!this._bone1) {\r\n            return;\r\n        }\r\n\r\n        this.mesh = mesh;\r\n\r\n        const bonePos = bone.getPosition();\r\n\r\n        if (bone.getAbsoluteTransform().determinant() > 0) {\r\n            this._rightHandedSystem = true;\r\n            this._bendAxis.x = 0;\r\n            this._bendAxis.y = 0;\r\n            this._bendAxis.z = -1;\r\n\r\n            if (bonePos.x > bonePos.y && bonePos.x > bonePos.z) {\r\n                this._adjustRoll = Math.PI * 0.5;\r\n                this._bendAxis.z = 1;\r\n            }\r\n        }\r\n\r\n        if (this._bone1.length) {\r\n            const boneScale1 = this._bone1.getScale();\r\n            const boneScale2 = this._bone2.getScale();\r\n\r\n            this._bone1Length = this._bone1.length * boneScale1.y * this.mesh.scaling.y;\r\n            this._bone2Length = this._bone2.length * boneScale2.y * this.mesh.scaling.y;\r\n        } else if (this._bone1.children[0]) {\r\n            mesh.computeWorldMatrix(true);\r\n\r\n            const pos1 = this._bone2.children[0].getAbsolutePosition(mesh);\r\n            const pos2 = this._bone2.getAbsolutePosition(mesh);\r\n            const pos3 = this._bone1.getAbsolutePosition(mesh);\r\n\r\n            this._bone1Length = Vector3.Distance(pos1, pos2);\r\n            this._bone2Length = Vector3.Distance(pos2, pos3);\r\n        }\r\n\r\n        this._bone1.getRotationMatrixToRef(Space.WORLD, mesh, this._bone1Mat);\r\n        this.maxAngle = Math.PI;\r\n\r\n        if (options) {\r\n            if (options.targetMesh) {\r\n                this.targetMesh = options.targetMesh;\r\n                this.targetMesh.computeWorldMatrix(true);\r\n            }\r\n\r\n            if (options.poleTargetMesh) {\r\n                this.poleTargetMesh = options.poleTargetMesh;\r\n                this.poleTargetMesh.computeWorldMatrix(true);\r\n            } else if (options.poleTargetBone) {\r\n                this.poleTargetBone = options.poleTargetBone;\r\n            } else if (this._bone1.getParent()) {\r\n                this.poleTargetBone = this._bone1.getParent();\r\n            }\r\n\r\n            if (options.poleTargetLocalOffset) {\r\n                this.poleTargetLocalOffset.copyFrom(options.poleTargetLocalOffset);\r\n            }\r\n\r\n            if (options.poleAngle) {\r\n                this.poleAngle = options.poleAngle;\r\n            }\r\n\r\n            if (options.bendAxis) {\r\n                this._bendAxis.copyFrom(options.bendAxis);\r\n            }\r\n\r\n            if (options.maxAngle) {\r\n                this.maxAngle = options.maxAngle;\r\n            }\r\n\r\n            if (options.slerpAmount) {\r\n                this.slerpAmount = options.slerpAmount;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setMaxAngle(ang: number): void {\r\n        if (ang < 0) {\r\n            ang = 0;\r\n        }\r\n\r\n        if (ang > Math.PI || ang == undefined) {\r\n            ang = Math.PI;\r\n        }\r\n\r\n        this._maxAngle = ang;\r\n\r\n        const a = this._bone1Length;\r\n        const b = this._bone2Length;\r\n\r\n        this._maxReach = Math.sqrt(a * a + b * b - 2 * a * b * Math.cos(ang));\r\n    }\r\n\r\n    /**\r\n     * Force the controller to update the bones\r\n     */\r\n    public update(): void {\r\n        const bone1 = this._bone1;\r\n\r\n        if (!bone1) {\r\n            return;\r\n        }\r\n\r\n        const target = this.targetPosition;\r\n        const poleTarget = this.poleTargetPosition;\r\n\r\n        const mat1 = BoneIKController._TmpMats[0];\r\n        const mat2 = BoneIKController._TmpMats[1];\r\n\r\n        if (this.targetMesh) {\r\n            target.copyFrom(this.targetMesh.getAbsolutePosition());\r\n        }\r\n\r\n        if (this.poleTargetBone) {\r\n            this.poleTargetBone.getAbsolutePositionFromLocalToRef(this.poleTargetLocalOffset, this.mesh, poleTarget);\r\n        } else if (this.poleTargetMesh) {\r\n            Vector3.TransformCoordinatesToRef(this.poleTargetLocalOffset, this.poleTargetMesh.getWorldMatrix(), poleTarget);\r\n        }\r\n\r\n        const bonePos = BoneIKController._TmpVecs[0];\r\n        const zaxis = BoneIKController._TmpVecs[1];\r\n        const xaxis = BoneIKController._TmpVecs[2];\r\n        const yaxis = BoneIKController._TmpVecs[3];\r\n        const upAxis = BoneIKController._TmpVecs[4];\r\n\r\n        const tmpQuat = BoneIKController._TmpQuat;\r\n\r\n        bone1.getAbsolutePositionToRef(this.mesh, bonePos);\r\n\r\n        poleTarget.subtractToRef(bonePos, upAxis);\r\n\r\n        if (upAxis.x == 0 && upAxis.y == 0 && upAxis.z == 0) {\r\n            upAxis.y = 1;\r\n        } else {\r\n            upAxis.normalize();\r\n        }\r\n\r\n        target.subtractToRef(bonePos, yaxis);\r\n        yaxis.normalize();\r\n\r\n        Vector3.CrossToRef(yaxis, upAxis, zaxis);\r\n        zaxis.normalize();\r\n\r\n        Vector3.CrossToRef(yaxis, zaxis, xaxis);\r\n        xaxis.normalize();\r\n\r\n        Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, mat1);\r\n\r\n        const a = this._bone1Length;\r\n        const b = this._bone2Length;\r\n\r\n        let c = Vector3.Distance(bonePos, target);\r\n\r\n        if (this._maxReach > 0) {\r\n            c = Math.min(this._maxReach, c);\r\n        }\r\n\r\n        let acosa = (b * b + c * c - a * a) / (2 * b * c);\r\n        let acosb = (c * c + a * a - b * b) / (2 * c * a);\r\n\r\n        if (acosa > 1) {\r\n            acosa = 1;\r\n        }\r\n\r\n        if (acosb > 1) {\r\n            acosb = 1;\r\n        }\r\n\r\n        if (acosa < -1) {\r\n            acosa = -1;\r\n        }\r\n\r\n        if (acosb < -1) {\r\n            acosb = -1;\r\n        }\r\n\r\n        const angA = Math.acos(acosa);\r\n        const angB = Math.acos(acosb);\r\n\r\n        let angC = -angA - angB;\r\n\r\n        if (this._rightHandedSystem) {\r\n            Matrix.RotationYawPitchRollToRef(0, 0, this._adjustRoll, mat2);\r\n            mat2.multiplyToRef(mat1, mat1);\r\n\r\n            Matrix.RotationAxisToRef(this._bendAxis, angB, mat2);\r\n            mat2.multiplyToRef(mat1, mat1);\r\n        } else {\r\n            const _tmpVec = BoneIKController._TmpVecs[5];\r\n\r\n            _tmpVec.copyFrom(this._bendAxis);\r\n            _tmpVec.x *= -1;\r\n\r\n            Matrix.RotationAxisToRef(_tmpVec, -angB, mat2);\r\n            mat2.multiplyToRef(mat1, mat1);\r\n        }\r\n\r\n        if (this.poleAngle) {\r\n            Matrix.RotationAxisToRef(yaxis, this.poleAngle, mat2);\r\n            mat1.multiplyToRef(mat2, mat1);\r\n        }\r\n\r\n        if (this._bone1) {\r\n            if (this.slerpAmount < 1) {\r\n                if (!this._slerping) {\r\n                    Quaternion.FromRotationMatrixToRef(this._bone1Mat, this._bone1Quat);\r\n                }\r\n                Quaternion.FromRotationMatrixToRef(mat1, tmpQuat);\r\n                Quaternion.SlerpToRef(this._bone1Quat, tmpQuat, this.slerpAmount, this._bone1Quat);\r\n                angC = this._bone2Ang * (1.0 - this.slerpAmount) + angC * this.slerpAmount;\r\n\r\n                this._bone1.setRotationQuaternion(this._bone1Quat, Space.WORLD, this.mesh);\r\n                this._slerping = true;\r\n            } else {\r\n                this._bone1.setRotationMatrix(mat1, Space.WORLD, this.mesh);\r\n                this._bone1Mat.copyFrom(mat1);\r\n                this._slerping = false;\r\n            }\r\n            this._updateLinkedTransformRotation(this._bone1);\r\n        }\r\n\r\n        this._bone2.setAxisAngle(this._bendAxis, angC, Space.LOCAL);\r\n        this._updateLinkedTransformRotation(this._bone2);\r\n        this._bone2Ang = angC;\r\n    }\r\n\r\n    private _updateLinkedTransformRotation(bone: Bone): void {\r\n        if (bone._linkedTransformNode) {\r\n            if (!bone._linkedTransformNode.rotationQuaternion) {\r\n                bone._linkedTransformNode.rotationQuaternion = new Quaternion();\r\n            }\r\n            bone.getRotationQuaternionToRef(Space.LOCAL, null, bone._linkedTransformNode.rotationQuaternion);\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}