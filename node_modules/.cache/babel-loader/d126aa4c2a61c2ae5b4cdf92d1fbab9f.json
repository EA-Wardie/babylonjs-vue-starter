{"ast":null,"code":"import \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/web.timers.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/web.url.js\";\nimport \"core-js/modules/web.url-search-params.js\";\nimport { __assign } from \"tslib\";\nimport { Tools } from \"./tools.js\";\n/**\n * This can help with recording videos from BabylonJS.\n * This is based on the available WebRTC functionalities of the browser.\n *\n * @see https://doc.babylonjs.com/how_to/render_scene_on_a_video\n */\n\nvar VideoRecorder =\n/** @class */\nfunction () {\n  /**\n   * Create a new VideoCapture object which can help converting what you see in Babylon to a video file.\n   * @param engine Defines the BabylonJS Engine you wish to record.\n   * @param options Defines options that can be used to customize the capture.\n   */\n  function VideoRecorder(engine, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (!VideoRecorder.IsSupported(engine)) {\n      throw \"Your browser does not support recording so far.\";\n    }\n\n    var canvas = engine.getRenderingCanvas();\n\n    if (!canvas) {\n      throw \"The babylon engine must have a canvas to be recorded\";\n    }\n\n    this._canvas = canvas;\n    this._canvas.isRecording = false;\n    this._options = __assign(__assign({}, VideoRecorder._DefaultOptions), options);\n\n    var stream = this._canvas.captureStream(this._options.fps);\n\n    if (this._options.audioTracks) {\n      for (var _i = 0, _a = this._options.audioTracks; _i < _a.length; _i++) {\n        var track = _a[_i];\n        stream.addTrack(track);\n      }\n    }\n\n    this._mediaRecorder = new MediaRecorder(stream, {\n      mimeType: this._options.mimeType\n    });\n    this._mediaRecorder.ondataavailable = this._handleDataAvailable.bind(this);\n    this._mediaRecorder.onerror = this._handleError.bind(this);\n    this._mediaRecorder.onstop = this._handleStop.bind(this);\n  }\n  /**\n   * Returns whether or not the VideoRecorder is available in your browser.\n   * @param engine Defines the Babylon Engine.\n   * @returns true if supported otherwise false.\n   */\n\n\n  VideoRecorder.IsSupported = function (engine) {\n    var canvas = engine.getRenderingCanvas();\n    return !!canvas && typeof canvas.captureStream === \"function\";\n  };\n\n  Object.defineProperty(VideoRecorder.prototype, \"isRecording\", {\n    /**\n     * True when a recording is already in progress.\n     */\n    get: function get() {\n      return !!this._canvas && this._canvas.isRecording;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Stops the current recording before the default capture timeout passed in the startRecording function.\n   */\n\n  VideoRecorder.prototype.stopRecording = function () {\n    if (!this._canvas || !this._mediaRecorder) {\n      return;\n    }\n\n    if (!this.isRecording) {\n      return;\n    }\n\n    this._canvas.isRecording = false;\n\n    this._mediaRecorder.stop();\n  };\n  /**\n   * Starts recording the canvas for a max duration specified in parameters.\n   * @param fileName Defines the name of the file to be downloaded when the recording stop.\n   * If null no automatic download will start and you can rely on the promise to get the data back.\n   * @param maxDuration Defines the maximum recording time in seconds.\n   * It defaults to 7 seconds. A value of zero will not stop automatically, you would need to call stopRecording manually.\n   * @return A promise callback at the end of the recording with the video data in Blob.\n   */\n\n\n  VideoRecorder.prototype.startRecording = function (fileName, maxDuration) {\n    var _this = this;\n\n    if (fileName === void 0) {\n      fileName = \"babylonjs.webm\";\n    }\n\n    if (maxDuration === void 0) {\n      maxDuration = 7;\n    }\n\n    if (!this._canvas || !this._mediaRecorder) {\n      throw \"Recorder has already been disposed\";\n    }\n\n    if (this.isRecording) {\n      throw \"Recording already in progress\";\n    }\n\n    if (maxDuration > 0) {\n      setTimeout(function () {\n        _this.stopRecording();\n      }, maxDuration * 1000);\n    }\n\n    this._fileName = fileName;\n    this._recordedChunks = [];\n    this._resolve = null;\n    this._reject = null;\n    this._canvas.isRecording = true;\n\n    this._mediaRecorder.start(this._options.recordChunckSize);\n\n    return new Promise(function (resolve, reject) {\n      _this._resolve = resolve;\n      _this._reject = reject;\n    });\n  };\n  /**\n   * Releases internal resources used during the recording.\n   */\n\n\n  VideoRecorder.prototype.dispose = function () {\n    this._canvas = null;\n    this._mediaRecorder = null;\n    this._recordedChunks = [];\n    this._fileName = null;\n    this._resolve = null;\n    this._reject = null;\n  };\n\n  VideoRecorder.prototype._handleDataAvailable = function (event) {\n    if (event.data.size > 0) {\n      this._recordedChunks.push(event.data);\n    }\n  };\n\n  VideoRecorder.prototype._handleError = function (event) {\n    this.stopRecording();\n\n    if (this._reject) {\n      this._reject(event.error);\n    } else {\n      throw new event.error();\n    }\n  };\n\n  VideoRecorder.prototype._handleStop = function () {\n    this.stopRecording();\n    var superBuffer = new Blob(this._recordedChunks);\n\n    if (this._resolve) {\n      this._resolve(superBuffer);\n    }\n\n    window.URL.createObjectURL(superBuffer);\n\n    if (this._fileName) {\n      Tools.Download(superBuffer, this._fileName);\n    }\n  };\n\n  VideoRecorder._DefaultOptions = {\n    mimeType: \"video/webm\",\n    fps: 25,\n    recordChunckSize: 3000\n  };\n  return VideoRecorder;\n}();\n\nexport { VideoRecorder };","map":{"version":3,"mappings":"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","names":["Tools","engine","options","VideoRecorder","IsSupported","canvas","getRenderingCanvas","_canvas","isRecording","_options","__assign","_DefaultOptions","stream","captureStream","fps","audioTracks","_i","track","addTrack","_mediaRecorder","MediaRecorder","mimeType","ondataavailable","_handleDataAvailable","bind","onerror","_handleError","onstop","_handleStop","Object","stop","fileName","maxDuration","setTimeout","_this","stopRecording","_fileName","_recordedChunks","_resolve","_reject","start","recordChunckSize","Promise","resolve","reject","event","data","size","push","error","superBuffer","Blob","window","URL","createObjectURL","Download"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/videoRecorder.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\n/* eslint-disable no-var */\r\nimport type { Nullable } from \"../types\";\r\nimport { Tools } from \"./tools\";\r\nimport type { Engine } from \"../Engines/engine\";\r\n\r\ninterface MediaRecorder {\r\n    /** Starts recording */\r\n    start(timeSlice: number): void;\r\n    /** Stops recording */\r\n    stop(): void;\r\n\r\n    /** Event raised when an error arised. */\r\n    onerror: (event: ErrorEvent) => void;\r\n    /** Event raised when the recording stops. */\r\n    onstop: (event: Event) => void;\r\n    /** Event raised when a new chunk of data is available and should be tracked. */\r\n    ondataavailable: (event: Event) => void;\r\n}\r\n\r\ninterface MediaRecorderOptions {\r\n    /** The mime type you want to use as the recording container for the new MediaRecorder. */\r\n    mimeType?: string;\r\n    /** The chosen bitrate for the audio component of the media. */\r\n    audioBitsPerSecond?: number;\r\n    /** The chosen bitrate for the video component of the media. */\r\n    videoBitsPerSecond?: number;\r\n    /** The chosen bitrate for the audio and video components of the media. This can be specified instead of the above two properties.\r\n     * If this is specified along with one or the other of the above properties, this will be used for the one that isn't specified. */\r\n    bitsPerSecond?: number;\r\n}\r\n\r\ninterface MediaRecorderConstructor {\r\n    /**\r\n     * A reference to the prototype.\r\n     */\r\n    readonly prototype: MediaRecorder;\r\n\r\n    /**\r\n     * Creates a new MediaRecorder.\r\n     * @param stream Defines the stream to record.\r\n     * @param options Defines the options for the recorder available in the type MediaRecorderOptions.\r\n     */\r\n    new (stream: MediaStream, options?: MediaRecorderOptions): MediaRecorder;\r\n}\r\n\r\n/**\r\n * MediaRecorder object available in some browsers.\r\n */\r\ndeclare var MediaRecorder: MediaRecorderConstructor;\r\n\r\n/**\r\n * This represents the different options available for the video capture.\r\n */\r\nexport interface VideoRecorderOptions {\r\n    /** Defines the mime type of the video. */\r\n    mimeType: string;\r\n    /** Defines the FPS the video should be recorded at. */\r\n    fps: number;\r\n    /** Defines the chunk size for the recording data. */\r\n    recordChunckSize: number;\r\n    /** The audio tracks to attach to the recording. */\r\n    audioTracks?: MediaStreamTrack[];\r\n}\r\n\r\n/**\r\n * This can help with recording videos from BabylonJS.\r\n * This is based on the available WebRTC functionalities of the browser.\r\n *\r\n * @see https://doc.babylonjs.com/how_to/render_scene_on_a_video\r\n */\r\nexport class VideoRecorder {\r\n    private static readonly _DefaultOptions = {\r\n        mimeType: \"video/webm\",\r\n        fps: 25,\r\n        recordChunckSize: 3000,\r\n    };\r\n\r\n    /**\r\n     * Returns whether or not the VideoRecorder is available in your browser.\r\n     * @param engine Defines the Babylon Engine.\r\n     * @returns true if supported otherwise false.\r\n     */\r\n    public static IsSupported(engine: Engine): boolean {\r\n        const canvas = engine.getRenderingCanvas();\r\n        return !!canvas && typeof (<any>canvas).captureStream === \"function\";\r\n    }\r\n\r\n    private readonly _options: VideoRecorderOptions;\r\n    private _canvas: Nullable<HTMLCanvasElement>;\r\n    private _mediaRecorder: Nullable<MediaRecorder>;\r\n\r\n    private _recordedChunks: any[];\r\n    private _fileName: Nullable<string>;\r\n    private _resolve: Nullable<(blob: Blob) => void>;\r\n    private _reject: Nullable<(error: any) => void>;\r\n\r\n    /**\r\n     * True when a recording is already in progress.\r\n     */\r\n    public get isRecording(): boolean {\r\n        return !!this._canvas && this._canvas.isRecording;\r\n    }\r\n\r\n    /**\r\n     * Create a new VideoCapture object which can help converting what you see in Babylon to a video file.\r\n     * @param engine Defines the BabylonJS Engine you wish to record.\r\n     * @param options Defines options that can be used to customize the capture.\r\n     */\r\n    constructor(engine: Engine, options: Partial<VideoRecorderOptions> = {}) {\r\n        if (!VideoRecorder.IsSupported(engine)) {\r\n            throw \"Your browser does not support recording so far.\";\r\n        }\r\n\r\n        const canvas = engine.getRenderingCanvas();\r\n        if (!canvas) {\r\n            throw \"The babylon engine must have a canvas to be recorded\";\r\n        }\r\n\r\n        this._canvas = canvas;\r\n        this._canvas.isRecording = false;\r\n\r\n        this._options = {\r\n            ...VideoRecorder._DefaultOptions,\r\n            ...options,\r\n        };\r\n\r\n        const stream = this._canvas.captureStream(this._options.fps);\r\n        if (this._options.audioTracks) {\r\n            for (const track of this._options.audioTracks) {\r\n                stream.addTrack(track);\r\n            }\r\n        }\r\n\r\n        this._mediaRecorder = new MediaRecorder(stream, { mimeType: this._options.mimeType });\r\n        this._mediaRecorder.ondataavailable = this._handleDataAvailable.bind(this);\r\n        this._mediaRecorder.onerror = this._handleError.bind(this);\r\n        this._mediaRecorder.onstop = this._handleStop.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Stops the current recording before the default capture timeout passed in the startRecording function.\r\n     */\r\n    public stopRecording(): void {\r\n        if (!this._canvas || !this._mediaRecorder) {\r\n            return;\r\n        }\r\n\r\n        if (!this.isRecording) {\r\n            return;\r\n        }\r\n\r\n        this._canvas.isRecording = false;\r\n        this._mediaRecorder.stop();\r\n    }\r\n\r\n    /**\r\n     * Starts recording the canvas for a max duration specified in parameters.\r\n     * @param fileName Defines the name of the file to be downloaded when the recording stop.\r\n     * If null no automatic download will start and you can rely on the promise to get the data back.\r\n     * @param maxDuration Defines the maximum recording time in seconds.\r\n     * It defaults to 7 seconds. A value of zero will not stop automatically, you would need to call stopRecording manually.\r\n     * @return A promise callback at the end of the recording with the video data in Blob.\r\n     */\r\n    public startRecording(fileName: Nullable<string> = \"babylonjs.webm\", maxDuration = 7): Promise<Blob> {\r\n        if (!this._canvas || !this._mediaRecorder) {\r\n            throw \"Recorder has already been disposed\";\r\n        }\r\n\r\n        if (this.isRecording) {\r\n            throw \"Recording already in progress\";\r\n        }\r\n\r\n        if (maxDuration > 0) {\r\n            setTimeout(() => {\r\n                this.stopRecording();\r\n            }, maxDuration * 1000);\r\n        }\r\n\r\n        this._fileName = fileName;\r\n        this._recordedChunks = [];\r\n        this._resolve = null;\r\n        this._reject = null;\r\n\r\n        this._canvas.isRecording = true;\r\n        this._mediaRecorder.start(this._options.recordChunckSize);\r\n\r\n        return new Promise<Blob>((resolve, reject) => {\r\n            this._resolve = resolve;\r\n            this._reject = reject;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Releases internal resources used during the recording.\r\n     */\r\n    public dispose() {\r\n        this._canvas = null;\r\n        this._mediaRecorder = null;\r\n\r\n        this._recordedChunks = [];\r\n        this._fileName = null;\r\n        this._resolve = null;\r\n        this._reject = null;\r\n    }\r\n\r\n    private _handleDataAvailable(event: any): void {\r\n        if (event.data.size > 0) {\r\n            this._recordedChunks.push(event.data);\r\n        }\r\n    }\r\n\r\n    private _handleError(event: ErrorEvent): void {\r\n        this.stopRecording();\r\n\r\n        if (this._reject) {\r\n            this._reject(event.error);\r\n        } else {\r\n            throw new event.error();\r\n        }\r\n    }\r\n\r\n    private _handleStop(): void {\r\n        this.stopRecording();\r\n\r\n        const superBuffer = new Blob(this._recordedChunks);\r\n        if (this._resolve) {\r\n            this._resolve(superBuffer);\r\n        }\r\n\r\n        window.URL.createObjectURL(superBuffer);\r\n\r\n        if (this._fileName) {\r\n            Tools.Download(superBuffer, this._fileName);\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}