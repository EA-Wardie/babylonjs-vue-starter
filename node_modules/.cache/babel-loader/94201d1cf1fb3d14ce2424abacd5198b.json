{"ast":null,"code":"import \"core-js/modules/es.function.bind.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { CreateLines } from \"../Meshes/Builders/linesBuilder.js\";\n/**\n * As raycast might be hard to debug, the RayHelper can help rendering the different rays\n * in order to better appreciate the issue one might have.\n * @see https://doc.babylonjs.com/babylon101/raycasts#debugging\n */\n\nvar RayHelper =\n/** @class */\nfunction () {\n  /**\n   * Instantiate a new ray helper.\n   * As raycast might be hard to debug, the RayHelper can help rendering the different rays\n   * in order to better appreciate the issue one might have.\n   * @see https://doc.babylonjs.com/babylon101/raycasts#debugging\n   * @param ray Defines the ray we are currently tryin to visualize\n   */\n  function RayHelper(ray) {\n    this.ray = ray;\n  }\n  /**\n   * Helper function to create a colored helper in a scene in one line.\n   * @param ray Defines the ray we are currently tryin to visualize\n   * @param scene Defines the scene the ray is used in\n   * @param color Defines the color we want to see the ray in\n   * @returns The newly created ray helper.\n   */\n\n\n  RayHelper.CreateAndShow = function (ray, scene, color) {\n    var helper = new RayHelper(ray);\n    helper.show(scene, color);\n    return helper;\n  };\n  /**\n   * Shows the ray we are willing to debug.\n   * @param scene Defines the scene the ray needs to be rendered in\n   * @param color Defines the color the ray needs to be rendered in\n   */\n\n\n  RayHelper.prototype.show = function (scene, color) {\n    if (!this._renderFunction && this.ray) {\n      var ray = this.ray;\n      this._renderFunction = this._render.bind(this);\n      this._scene = scene;\n      this._renderPoints = [ray.origin, ray.origin.add(ray.direction.scale(ray.length))];\n      this._renderLine = CreateLines(\"ray\", {\n        points: this._renderPoints,\n        updatable: true\n      }, scene);\n      this._renderLine.isPickable = false;\n\n      if (this._renderFunction) {\n        this._scene.registerBeforeRender(this._renderFunction);\n      }\n    }\n\n    if (color && this._renderLine) {\n      this._renderLine.color.copyFrom(color);\n    }\n  };\n  /**\n   * Hides the ray we are debugging.\n   */\n\n\n  RayHelper.prototype.hide = function () {\n    if (this._renderFunction && this._scene) {\n      this._scene.unregisterBeforeRender(this._renderFunction);\n\n      this._scene = null;\n      this._renderFunction = null;\n\n      if (this._renderLine) {\n        this._renderLine.dispose();\n\n        this._renderLine = null;\n      }\n\n      this._renderPoints = [];\n    }\n  };\n\n  RayHelper.prototype._render = function () {\n    var _a;\n\n    var ray = this.ray;\n\n    if (!ray) {\n      return;\n    }\n\n    var point = this._renderPoints[1];\n    var len = Math.min(ray.length, 1000000);\n    point.copyFrom(ray.direction);\n    point.scaleInPlace(len);\n    point.addInPlace(ray.origin);\n\n    this._renderPoints[0].copyFrom(ray.origin);\n\n    CreateLines(\"ray\", {\n      points: this._renderPoints,\n      updatable: true,\n      instance: this._renderLine\n    }, this._scene);\n    (_a = this._renderLine) === null || _a === void 0 ? void 0 : _a.refreshBoundingInfo();\n  };\n  /**\n   * Attach a ray helper to a mesh so that we can easily see its orientation for instance or information like its normals.\n   * @param mesh Defines the mesh we want the helper attached to\n   * @param meshSpaceDirection Defines the direction of the Ray in mesh space (local space of the mesh node)\n   * @param meshSpaceOrigin Defines the origin of the Ray in mesh space (local space of the mesh node)\n   * @param length Defines the length of the ray\n   */\n\n\n  RayHelper.prototype.attachToMesh = function (mesh, meshSpaceDirection, meshSpaceOrigin, length) {\n    var _this = this;\n\n    this._attachedToMesh = mesh;\n    var ray = this.ray;\n\n    if (!ray) {\n      return;\n    }\n\n    if (!ray.direction) {\n      ray.direction = Vector3.Zero();\n    }\n\n    if (!ray.origin) {\n      ray.origin = Vector3.Zero();\n    }\n\n    if (length) {\n      ray.length = length;\n    }\n\n    if (!meshSpaceOrigin) {\n      meshSpaceOrigin = Vector3.Zero();\n    }\n\n    if (!meshSpaceDirection) {\n      // -1 so that this will work with Mesh.lookAt\n      meshSpaceDirection = new Vector3(0, 0, -1);\n    }\n\n    if (!this._scene) {\n      this._scene = mesh.getScene();\n    }\n\n    if (!this._meshSpaceDirection) {\n      this._meshSpaceDirection = meshSpaceDirection.clone();\n      this._meshSpaceOrigin = meshSpaceOrigin.clone();\n    } else {\n      this._meshSpaceDirection.copyFrom(meshSpaceDirection);\n\n      this._meshSpaceOrigin.copyFrom(meshSpaceOrigin);\n    }\n\n    if (!this._onAfterRenderObserver) {\n      this._onAfterRenderObserver = this._scene.onBeforeRenderObservable.add(function () {\n        return _this._updateToMesh();\n      });\n      this._onAfterStepObserver = this._scene.onAfterStepObservable.add(function () {\n        return _this._updateToMesh();\n      });\n    } // force world matrix computation before the first ray helper computation\n\n\n    this._attachedToMesh.computeWorldMatrix(true);\n\n    this._updateToMesh();\n  };\n  /**\n   * Detach the ray helper from the mesh it has previously been attached to.\n   */\n\n\n  RayHelper.prototype.detachFromMesh = function () {\n    if (this._attachedToMesh && this._scene) {\n      if (this._onAfterRenderObserver) {\n        this._scene.onBeforeRenderObservable.remove(this._onAfterRenderObserver);\n\n        this._scene.onAfterStepObservable.remove(this._onAfterStepObserver);\n      }\n\n      this._attachedToMesh = null;\n      this._onAfterRenderObserver = null;\n      this._onAfterStepObserver = null;\n      this._scene = null;\n    }\n  };\n\n  RayHelper.prototype._updateToMesh = function () {\n    var ray = this.ray;\n\n    if (!this._attachedToMesh || !ray) {\n      return;\n    }\n\n    if (this._attachedToMesh.isDisposed()) {\n      this.detachFromMesh();\n      return;\n    }\n\n    this._attachedToMesh.getDirectionToRef(this._meshSpaceDirection, ray.direction);\n\n    Vector3.TransformCoordinatesToRef(this._meshSpaceOrigin, this._attachedToMesh.getWorldMatrix(), ray.origin);\n  };\n  /**\n   * Dispose the helper and release its associated resources.\n   */\n\n\n  RayHelper.prototype.dispose = function () {\n    this.hide();\n    this.detachFromMesh();\n    this.ray = null;\n  };\n\n  return RayHelper;\n}();\n\nexport { RayHelper };","map":{"version":3,"mappings":"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","names":["Vector3","CreateLines","ray","RayHelper","scene","color","helper","show","_renderFunction","_render","bind","_scene","_renderPoints","origin","add","direction","scale","length","_renderLine","points","updatable","isPickable","registerBeforeRender","copyFrom","unregisterBeforeRender","dispose","point","len","Math","min","scaleInPlace","addInPlace","instance","_a","refreshBoundingInfo","mesh","meshSpaceDirection","meshSpaceOrigin","_attachedToMesh","Zero","getScene","_meshSpaceDirection","clone","_meshSpaceOrigin","_onAfterRenderObserver","onBeforeRenderObservable","_updateToMesh","_onAfterStepObserver","onAfterStepObservable","computeWorldMatrix","remove","isDisposed","detachFromMesh","getDirectionToRef","TransformCoordinatesToRef","getWorldMatrix","hide"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Debug/rayHelper.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Ray } from \"../Culling/ray\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Color3 } from \"../Maths/math.color\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { LinesMesh } from \"../Meshes/linesMesh\";\r\n\r\nimport { CreateLines } from \"../Meshes/Builders/linesBuilder\";\r\nimport type { Observer } from \"../Misc/observable\";\r\n\r\n/**\r\n * As raycast might be hard to debug, the RayHelper can help rendering the different rays\r\n * in order to better appreciate the issue one might have.\r\n * @see https://doc.babylonjs.com/babylon101/raycasts#debugging\r\n */\r\nexport class RayHelper {\r\n    /**\r\n     * Defines the ray we are currently tryin to visualize.\r\n     */\r\n    public ray: Nullable<Ray>;\r\n\r\n    private _renderPoints: Vector3[];\r\n    private _renderLine: Nullable<LinesMesh>;\r\n    private _renderFunction: Nullable<() => void>;\r\n    private _scene: Nullable<Scene>;\r\n\r\n    private _onAfterRenderObserver: Nullable<Observer<Scene>>;\r\n    private _onAfterStepObserver: Nullable<Observer<Scene>>;\r\n    private _attachedToMesh: Nullable<AbstractMesh>;\r\n    private _meshSpaceDirection: Vector3;\r\n    private _meshSpaceOrigin: Vector3;\r\n\r\n    /**\r\n     * Helper function to create a colored helper in a scene in one line.\r\n     * @param ray Defines the ray we are currently tryin to visualize\r\n     * @param scene Defines the scene the ray is used in\r\n     * @param color Defines the color we want to see the ray in\r\n     * @returns The newly created ray helper.\r\n     */\r\n    public static CreateAndShow(ray: Ray, scene: Scene, color: Color3): RayHelper {\r\n        const helper = new RayHelper(ray);\r\n\r\n        helper.show(scene, color);\r\n\r\n        return helper;\r\n    }\r\n\r\n    /**\r\n     * Instantiate a new ray helper.\r\n     * As raycast might be hard to debug, the RayHelper can help rendering the different rays\r\n     * in order to better appreciate the issue one might have.\r\n     * @see https://doc.babylonjs.com/babylon101/raycasts#debugging\r\n     * @param ray Defines the ray we are currently tryin to visualize\r\n     */\r\n    constructor(ray: Ray) {\r\n        this.ray = ray;\r\n    }\r\n\r\n    /**\r\n     * Shows the ray we are willing to debug.\r\n     * @param scene Defines the scene the ray needs to be rendered in\r\n     * @param color Defines the color the ray needs to be rendered in\r\n     */\r\n    public show(scene: Scene, color?: Color3): void {\r\n        if (!this._renderFunction && this.ray) {\r\n            const ray = this.ray;\r\n\r\n            this._renderFunction = this._render.bind(this);\r\n            this._scene = scene;\r\n            this._renderPoints = [ray.origin, ray.origin.add(ray.direction.scale(ray.length))];\r\n            this._renderLine = CreateLines(\"ray\", { points: this._renderPoints, updatable: true }, scene);\r\n            this._renderLine.isPickable = false;\r\n\r\n            if (this._renderFunction) {\r\n                this._scene.registerBeforeRender(this._renderFunction);\r\n            }\r\n        }\r\n\r\n        if (color && this._renderLine) {\r\n            this._renderLine.color.copyFrom(color);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Hides the ray we are debugging.\r\n     */\r\n    public hide(): void {\r\n        if (this._renderFunction && this._scene) {\r\n            this._scene.unregisterBeforeRender(this._renderFunction);\r\n            this._scene = null;\r\n            this._renderFunction = null;\r\n            if (this._renderLine) {\r\n                this._renderLine.dispose();\r\n                this._renderLine = null;\r\n            }\r\n\r\n            this._renderPoints = [];\r\n        }\r\n    }\r\n\r\n    private _render(): void {\r\n        const ray = this.ray;\r\n\r\n        if (!ray) {\r\n            return;\r\n        }\r\n\r\n        const point = this._renderPoints[1];\r\n        const len = Math.min(ray.length, 1000000);\r\n\r\n        point.copyFrom(ray.direction);\r\n        point.scaleInPlace(len);\r\n        point.addInPlace(ray.origin);\r\n\r\n        this._renderPoints[0].copyFrom(ray.origin);\r\n\r\n        CreateLines(\"ray\", { points: this._renderPoints, updatable: true, instance: this._renderLine }, this._scene);\r\n\r\n        this._renderLine?.refreshBoundingInfo();\r\n    }\r\n\r\n    /**\r\n     * Attach a ray helper to a mesh so that we can easily see its orientation for instance or information like its normals.\r\n     * @param mesh Defines the mesh we want the helper attached to\r\n     * @param meshSpaceDirection Defines the direction of the Ray in mesh space (local space of the mesh node)\r\n     * @param meshSpaceOrigin Defines the origin of the Ray in mesh space (local space of the mesh node)\r\n     * @param length Defines the length of the ray\r\n     */\r\n    public attachToMesh(mesh: AbstractMesh, meshSpaceDirection?: Vector3, meshSpaceOrigin?: Vector3, length?: number): void {\r\n        this._attachedToMesh = mesh;\r\n\r\n        const ray = this.ray;\r\n\r\n        if (!ray) {\r\n            return;\r\n        }\r\n\r\n        if (!ray.direction) {\r\n            ray.direction = Vector3.Zero();\r\n        }\r\n\r\n        if (!ray.origin) {\r\n            ray.origin = Vector3.Zero();\r\n        }\r\n\r\n        if (length) {\r\n            ray.length = length;\r\n        }\r\n\r\n        if (!meshSpaceOrigin) {\r\n            meshSpaceOrigin = Vector3.Zero();\r\n        }\r\n\r\n        if (!meshSpaceDirection) {\r\n            // -1 so that this will work with Mesh.lookAt\r\n            meshSpaceDirection = new Vector3(0, 0, -1);\r\n        }\r\n\r\n        if (!this._scene) {\r\n            this._scene = mesh.getScene();\r\n        }\r\n\r\n        if (!this._meshSpaceDirection) {\r\n            this._meshSpaceDirection = meshSpaceDirection.clone();\r\n            this._meshSpaceOrigin = meshSpaceOrigin.clone();\r\n        } else {\r\n            this._meshSpaceDirection.copyFrom(meshSpaceDirection);\r\n            this._meshSpaceOrigin.copyFrom(meshSpaceOrigin);\r\n        }\r\n\r\n        if (!this._onAfterRenderObserver) {\r\n            this._onAfterRenderObserver = this._scene.onBeforeRenderObservable.add(() => this._updateToMesh());\r\n            this._onAfterStepObserver = this._scene.onAfterStepObservable.add(() => this._updateToMesh());\r\n        }\r\n\r\n        // force world matrix computation before the first ray helper computation\r\n        this._attachedToMesh.computeWorldMatrix(true);\r\n\r\n        this._updateToMesh();\r\n    }\r\n\r\n    /**\r\n     * Detach the ray helper from the mesh it has previously been attached to.\r\n     */\r\n    public detachFromMesh(): void {\r\n        if (this._attachedToMesh && this._scene) {\r\n            if (this._onAfterRenderObserver) {\r\n                this._scene.onBeforeRenderObservable.remove(this._onAfterRenderObserver);\r\n                this._scene.onAfterStepObservable.remove(this._onAfterStepObserver);\r\n            }\r\n            this._attachedToMesh = null;\r\n            this._onAfterRenderObserver = null;\r\n            this._onAfterStepObserver = null;\r\n            this._scene = null;\r\n        }\r\n    }\r\n\r\n    private _updateToMesh(): void {\r\n        const ray = this.ray;\r\n\r\n        if (!this._attachedToMesh || !ray) {\r\n            return;\r\n        }\r\n\r\n        if (this._attachedToMesh.isDisposed()) {\r\n            this.detachFromMesh();\r\n            return;\r\n        }\r\n\r\n        this._attachedToMesh.getDirectionToRef(this._meshSpaceDirection, ray.direction);\r\n        Vector3.TransformCoordinatesToRef(this._meshSpaceOrigin, this._attachedToMesh.getWorldMatrix(), ray.origin);\r\n    }\r\n\r\n    /**\r\n     * Dispose the helper and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        this.hide();\r\n        this.detachFromMesh();\r\n        this.ray = null;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}