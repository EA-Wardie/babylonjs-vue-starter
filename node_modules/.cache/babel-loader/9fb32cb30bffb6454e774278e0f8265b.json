{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport { __extends } from \"tslib\";\nimport { Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { DeepCopier } from \"../Misc/deepCopier.js\";\nimport { TransformNode } from \"./transformNode.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Tools } from \"../Misc/tools.js\";\n\nMesh._instancedMeshFactory = function (name, mesh) {\n  var instance = new InstancedMesh(name, mesh);\n\n  if (mesh.instancedBuffers) {\n    instance.instancedBuffers = {};\n\n    for (var key in mesh.instancedBuffers) {\n      instance.instancedBuffers[key] = mesh.instancedBuffers[key];\n    }\n  }\n\n  return instance;\n};\n/**\n * Creates an instance based on a source mesh.\n */\n\n\nvar InstancedMesh =\n/** @class */\nfunction (_super) {\n  __extends(InstancedMesh, _super);\n\n  function InstancedMesh(name, source) {\n    var _this = _super.call(this, name, source.getScene()) || this;\n    /** @hidden */\n\n\n    _this._indexInSourceMeshInstanceArray = -1;\n    /** @hidden */\n\n    _this._distanceToCamera = 0;\n    source.addInstance(_this);\n    _this._sourceMesh = source;\n    _this._unIndexed = source._unIndexed;\n\n    _this.position.copyFrom(source.position);\n\n    _this.rotation.copyFrom(source.rotation);\n\n    _this.scaling.copyFrom(source.scaling);\n\n    if (source.rotationQuaternion) {\n      _this.rotationQuaternion = source.rotationQuaternion.clone();\n    }\n\n    _this.animations = Tools.Slice(source.animations);\n\n    for (var _i = 0, _a = source.getAnimationRanges(); _i < _a.length; _i++) {\n      var range = _a[_i];\n\n      if (range != null) {\n        _this.createAnimationRange(range.name, range.from, range.to);\n      }\n    }\n\n    _this.infiniteDistance = source.infiniteDistance;\n\n    _this.setPivotMatrix(source.getPivotMatrix());\n\n    _this.refreshBoundingInfo(true, true);\n\n    _this._syncSubMeshes();\n\n    return _this;\n  }\n  /**\n   * Returns the string \"InstancedMesh\".\n   */\n\n\n  InstancedMesh.prototype.getClassName = function () {\n    return \"InstancedMesh\";\n  };\n\n  Object.defineProperty(InstancedMesh.prototype, \"lightSources\", {\n    /** Gets the list of lights affecting that mesh */\n    get: function get() {\n      return this._sourceMesh._lightSources;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  InstancedMesh.prototype._resyncLightSources = function () {// Do nothing as all the work will be done by source mesh\n  };\n\n  InstancedMesh.prototype._resyncLightSource = function () {// Do nothing as all the work will be done by source mesh\n  };\n\n  InstancedMesh.prototype._removeLightSource = function () {// Do nothing as all the work will be done by source mesh\n  };\n\n  Object.defineProperty(InstancedMesh.prototype, \"receiveShadows\", {\n    // Methods\n\n    /**\n     * If the source mesh receives shadows\n     */\n    get: function get() {\n      return this._sourceMesh.receiveShadows;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InstancedMesh.prototype, \"material\", {\n    /**\n     * The material of the source mesh\n     */\n    get: function get() {\n      return this._sourceMesh.material;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InstancedMesh.prototype, \"visibility\", {\n    /**\n     * Visibility of the source mesh\n     */\n    get: function get() {\n      return this._sourceMesh.visibility;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InstancedMesh.prototype, \"skeleton\", {\n    /**\n     * Skeleton of the source mesh\n     */\n    get: function get() {\n      return this._sourceMesh.skeleton;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InstancedMesh.prototype, \"renderingGroupId\", {\n    /**\n     * Rendering ground id of the source mesh\n     */\n    get: function get() {\n      return this._sourceMesh.renderingGroupId;\n    },\n    set: function set(value) {\n      if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {\n        return;\n      } //no-op with warning\n\n\n      Logger.Warn(\"Note - setting renderingGroupId of an instanced mesh has no effect on the scene\");\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Returns the total number of vertices (integer).\n   */\n\n  InstancedMesh.prototype.getTotalVertices = function () {\n    return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;\n  };\n  /**\n   * Returns a positive integer : the total number of indices in this mesh geometry.\n   * @returns the number of indices or zero if the mesh has no geometry.\n   */\n\n\n  InstancedMesh.prototype.getTotalIndices = function () {\n    return this._sourceMesh.getTotalIndices();\n  };\n\n  Object.defineProperty(InstancedMesh.prototype, \"sourceMesh\", {\n    /**\n     * The source mesh of the instance\n     */\n    get: function get() {\n      return this._sourceMesh;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Creates a new InstancedMesh object from the mesh model.\n   * @see https://doc.babylonjs.com/how_to/how_to_use_instances\n   * @param name defines the name of the new instance\n   * @returns a new InstancedMesh\n   */\n\n  InstancedMesh.prototype.createInstance = function (name) {\n    return this._sourceMesh.createInstance(name);\n  };\n  /**\n   * Is this node ready to be used/rendered\n   * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\n   * @return {boolean} is it ready\n   */\n\n\n  InstancedMesh.prototype.isReady = function (completeCheck) {\n    if (completeCheck === void 0) {\n      completeCheck = false;\n    }\n\n    return this._sourceMesh.isReady(completeCheck, true);\n  };\n  /**\n   * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\n   * @param kind kind of verticies to retrieve (eg. positions, normals, uvs, etc.)\n   * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\n   * @returns a float array or a Float32Array of the requested kind of data : positions, normals, uvs, etc.\n   */\n\n\n  InstancedMesh.prototype.getVerticesData = function (kind, copyWhenShared) {\n    return this._sourceMesh.getVerticesData(kind, copyWhenShared);\n  };\n  /**\n   * Sets the vertex data of the mesh geometry for the requested `kind`.\n   * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\n   * The `data` are either a numeric array either a Float32Array.\n   * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initially none) or updater.\n   * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\n   * Note that a new underlying VertexBuffer object is created each call.\n   * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\n   *\n   * Possible `kind` values :\n   * - VertexBuffer.PositionKind\n   * - VertexBuffer.UVKind\n   * - VertexBuffer.UV2Kind\n   * - VertexBuffer.UV3Kind\n   * - VertexBuffer.UV4Kind\n   * - VertexBuffer.UV5Kind\n   * - VertexBuffer.UV6Kind\n   * - VertexBuffer.ColorKind\n   * - VertexBuffer.MatricesIndicesKind\n   * - VertexBuffer.MatricesIndicesExtraKind\n   * - VertexBuffer.MatricesWeightsKind\n   * - VertexBuffer.MatricesWeightsExtraKind\n   *\n   * Returns the Mesh.\n   * @param kind\n   * @param data\n   * @param updatable\n   * @param stride\n   */\n\n\n  InstancedMesh.prototype.setVerticesData = function (kind, data, updatable, stride) {\n    if (this.sourceMesh) {\n      this.sourceMesh.setVerticesData(kind, data, updatable, stride);\n    }\n\n    return this.sourceMesh;\n  };\n  /**\n   * Updates the existing vertex data of the mesh geometry for the requested `kind`.\n   * If the mesh has no geometry, it is simply returned as it is.\n   * The `data` are either a numeric array either a Float32Array.\n   * No new underlying VertexBuffer object is created.\n   * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\n   * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\n   *\n   * Possible `kind` values :\n   * - VertexBuffer.PositionKind\n   * - VertexBuffer.UVKind\n   * - VertexBuffer.UV2Kind\n   * - VertexBuffer.UV3Kind\n   * - VertexBuffer.UV4Kind\n   * - VertexBuffer.UV5Kind\n   * - VertexBuffer.UV6Kind\n   * - VertexBuffer.ColorKind\n   * - VertexBuffer.MatricesIndicesKind\n   * - VertexBuffer.MatricesIndicesExtraKind\n   * - VertexBuffer.MatricesWeightsKind\n   * - VertexBuffer.MatricesWeightsExtraKind\n   *\n   * Returns the Mesh.\n   * @param kind\n   * @param data\n   * @param updateExtends\n   * @param makeItUnique\n   */\n\n\n  InstancedMesh.prototype.updateVerticesData = function (kind, data, updateExtends, makeItUnique) {\n    if (this.sourceMesh) {\n      this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);\n    }\n\n    return this.sourceMesh;\n  };\n  /**\n   * Sets the mesh indices.\n   * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\n   * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\n   * This method creates a new index buffer each call.\n   * Returns the Mesh.\n   * @param indices\n   * @param totalVertices\n   */\n\n\n  InstancedMesh.prototype.setIndices = function (indices, totalVertices) {\n    if (totalVertices === void 0) {\n      totalVertices = null;\n    }\n\n    if (this.sourceMesh) {\n      this.sourceMesh.setIndices(indices, totalVertices);\n    }\n\n    return this.sourceMesh;\n  };\n  /**\n   * Boolean : True if the mesh owns the requested kind of data.\n   * @param kind\n   */\n\n\n  InstancedMesh.prototype.isVerticesDataPresent = function (kind) {\n    return this._sourceMesh.isVerticesDataPresent(kind);\n  };\n  /**\n   * Returns an array of indices (IndicesArray).\n   */\n\n\n  InstancedMesh.prototype.getIndices = function () {\n    return this._sourceMesh.getIndices();\n  };\n\n  Object.defineProperty(InstancedMesh.prototype, \"_positions\", {\n    get: function get() {\n      return this._sourceMesh._positions;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\n   * This means the mesh underlying bounding box and sphere are recomputed.\n   * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\n   * @param applyMorph  defines whether to apply the morph target before computing the bounding info\n   * @returns the current mesh\n   */\n\n  InstancedMesh.prototype.refreshBoundingInfo = function (applySkeleton, applyMorph) {\n    if (applySkeleton === void 0) {\n      applySkeleton = false;\n    }\n\n    if (applyMorph === void 0) {\n      applyMorph = false;\n    }\n\n    if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {\n      return this;\n    }\n\n    var bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;\n\n    this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton, applyMorph), bias);\n\n    return this;\n  };\n  /** @hidden */\n\n\n  InstancedMesh.prototype._preActivate = function () {\n    if (this._currentLOD) {\n      this._currentLOD._preActivate();\n    }\n\n    return this;\n  };\n  /**\n   * @param renderId\n   * @param intermediateRendering\n   * @hidden\n   */\n\n\n  InstancedMesh.prototype._activate = function (renderId, intermediateRendering) {\n    if (!this._sourceMesh.subMeshes) {\n      Logger.Warn(\"Instances should only be created for meshes with geometry.\");\n    }\n\n    if (this._currentLOD) {\n      var differentSign = this._currentLOD._getWorldMatrixDeterminant() >= 0 !== this._getWorldMatrixDeterminant() >= 0;\n\n      if (differentSign) {\n        this._internalAbstractMeshDataInfo._actAsRegularMesh = true;\n        return true;\n      }\n\n      this._internalAbstractMeshDataInfo._actAsRegularMesh = false;\n\n      this._currentLOD._registerInstanceForRenderId(this, renderId);\n\n      if (intermediateRendering) {\n        if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {\n          this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;\n          return true;\n        }\n      } else {\n        if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {\n          this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n  /** @hidden */\n\n\n  InstancedMesh.prototype._postActivate = function () {\n    if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\n      // we are using the edge renderer of the source mesh\n      this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);\n\n      this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());\n    } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\n      // we are using the edge renderer defined for this instance\n      this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);\n    }\n  };\n\n  InstancedMesh.prototype.getWorldMatrix = function () {\n    if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {\n      if (!this._billboardWorldMatrix) {\n        this._billboardWorldMatrix = new Matrix();\n      }\n\n      var tempMaster = this._currentLOD._masterMesh;\n      this._currentLOD._masterMesh = this;\n      TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);\n\n      this._currentLOD.position.set(0, 0, 0);\n\n      this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(true));\n\n      this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);\n\n      this._currentLOD._masterMesh = tempMaster;\n      return this._billboardWorldMatrix;\n    }\n\n    return _super.prototype.getWorldMatrix.call(this);\n  };\n\n  Object.defineProperty(InstancedMesh.prototype, \"isAnInstance\", {\n    get: function get() {\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Returns the current associated LOD AbstractMesh.\n   * @param camera\n   */\n\n  InstancedMesh.prototype.getLOD = function (camera) {\n    if (!camera) {\n      return this;\n    }\n\n    var sourceMeshLODLevels = this.sourceMesh.getLODLevels();\n\n    if (!sourceMeshLODLevels || sourceMeshLODLevels.length === 0) {\n      this._currentLOD = this.sourceMesh;\n    } else {\n      var boundingInfo = this.getBoundingInfo();\n      this._currentLOD = this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);\n    }\n\n    return this._currentLOD;\n  };\n  /**\n   * @param renderId\n   * @hidden\n   */\n\n\n  InstancedMesh.prototype._preActivateForIntermediateRendering = function (renderId) {\n    return this.sourceMesh._preActivateForIntermediateRendering(renderId);\n  };\n  /** @hidden */\n\n\n  InstancedMesh.prototype._syncSubMeshes = function () {\n    this.releaseSubMeshes();\n\n    if (this._sourceMesh.subMeshes) {\n      for (var index = 0; index < this._sourceMesh.subMeshes.length; index++) {\n        this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);\n      }\n    }\n\n    return this;\n  };\n  /** @hidden */\n\n\n  InstancedMesh.prototype._generatePointsArray = function () {\n    return this._sourceMesh._generatePointsArray();\n  };\n  /** @hidden */\n\n\n  InstancedMesh.prototype._updateBoundingInfo = function () {\n    if (this.hasBoundingInfo) {\n      this.getBoundingInfo().update(this.worldMatrixFromCache);\n    } else {\n      this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache);\n    }\n\n    this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\n\n    return this;\n  };\n  /**\n   * Creates a new InstancedMesh from the current mesh.\n   * - name (string) : the cloned mesh name\n   * - newParent (optional Node) : the optional Node to parent the clone to.\n   * - doNotCloneChildren (optional boolean, default `false`) : if `true` the model children aren't cloned.\n   *\n   * Returns the clone.\n   * @param name\n   * @param newParent\n   * @param doNotCloneChildren\n   */\n\n\n  InstancedMesh.prototype.clone = function (name, newParent, doNotCloneChildren) {\n    if (newParent === void 0) {\n      newParent = null;\n    }\n\n    var result = this._sourceMesh.createInstance(name); // Deep copy\n\n\n    DeepCopier.DeepCopy(this, result, [\"name\", \"subMeshes\", \"uniqueId\", \"parent\", \"lightSources\", \"receiveShadows\", \"material\", \"visibility\", \"skeleton\", \"sourceMesh\", \"isAnInstance\", \"facetNb\", \"isFacetDataEnabled\", \"isBlocked\", \"useBones\", \"hasInstances\", \"collider\", \"edgesRenderer\", \"forward\", \"up\", \"right\", \"absolutePosition\", \"absoluteScaling\", \"absoluteRotationQuaternion\", \"isWorldMatrixFrozen\", \"nonUniformScaling\", \"behaviors\", \"worldMatrixFromCache\", \"hasThinInstances\"], []); // Bounding info\n\n    this.refreshBoundingInfo(); // Parent\n\n    if (newParent) {\n      result.parent = newParent;\n    }\n\n    if (!doNotCloneChildren) {\n      // Children\n      for (var index = 0; index < this.getScene().meshes.length; index++) {\n        var mesh = this.getScene().meshes[index];\n\n        if (mesh.parent === this) {\n          mesh.clone(mesh.name, result);\n        }\n      }\n    }\n\n    result.computeWorldMatrix(true);\n    this.onClonedObservable.notifyObservers(result);\n    return result;\n  };\n  /**\n   * Disposes the InstancedMesh.\n   * Returns nothing.\n   * @param doNotRecurse\n   * @param disposeMaterialAndTextures\n   */\n\n\n  InstancedMesh.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {\n    if (disposeMaterialAndTextures === void 0) {\n      disposeMaterialAndTextures = false;\n    } // Remove from mesh\n\n\n    this._sourceMesh.removeInstance(this);\n\n    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);\n  };\n\n  return InstancedMesh;\n}(AbstractMesh);\n\nexport { InstancedMesh };\nMesh.prototype.edgesShareWithInstances = false;\n\nMesh.prototype.registerInstancedBuffer = function (kind, stride) {\n  var _a, _b; // Remove existing one\n\n\n  (_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) === null || _b === void 0 ? void 0 : _b.dispose(); // Creates the instancedBuffer field if not present\n\n  if (!this.instancedBuffers) {\n    this.instancedBuffers = {};\n\n    for (var _i = 0, _c = this.instances; _i < _c.length; _i++) {\n      var instance = _c[_i];\n      instance.instancedBuffers = {};\n    }\n\n    this._userInstancedBuffersStorage = {\n      data: {},\n      vertexBuffers: {},\n      strides: {},\n      sizes: {},\n      vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : undefined\n    };\n  } // Creates an empty property for this kind\n\n\n  this.instancedBuffers[kind] = null;\n  this._userInstancedBuffersStorage.strides[kind] = stride;\n  this._userInstancedBuffersStorage.sizes[kind] = stride * 32; // Initial size\n\n  this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);\n  this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\n\n  for (var _d = 0, _e = this.instances; _d < _e.length; _d++) {\n    var instance = _e[_d];\n    instance.instancedBuffers[kind] = null;\n  }\n\n  this._invalidateInstanceVertexArrayObject();\n};\n\nMesh.prototype._processInstancedBuffers = function (visibleInstances, renderSelf) {\n  var instanceCount = visibleInstances.length;\n\n  for (var kind in this.instancedBuffers) {\n    var size = this._userInstancedBuffersStorage.sizes[kind];\n    var stride = this._userInstancedBuffersStorage.strides[kind]; // Resize if required\n\n    var expectedSize = (instanceCount + 1) * stride;\n\n    while (size < expectedSize) {\n      size *= 2;\n    }\n\n    if (this._userInstancedBuffersStorage.data[kind].length != size) {\n      this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);\n      this._userInstancedBuffersStorage.sizes[kind] = size;\n\n      if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\n        this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();\n\n        this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\n      }\n    }\n\n    var data = this._userInstancedBuffersStorage.data[kind]; // Update data buffer\n\n    var offset = 0;\n\n    if (renderSelf) {\n      var value = this.instancedBuffers[kind];\n\n      if (value.toArray) {\n        value.toArray(data, offset);\n      } else if (value.copyToArray) {\n        value.copyToArray(data, offset);\n      } else {\n        data[offset] = value;\n      }\n\n      offset += stride;\n    }\n\n    for (var instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {\n      var instance = visibleInstances[instanceIndex];\n      var value = instance.instancedBuffers[kind];\n\n      if (value.toArray) {\n        value.toArray(data, offset);\n      } else if (value.copyToArray) {\n        value.copyToArray(data, offset);\n      } else {\n        data[offset] = value;\n      }\n\n      offset += stride;\n    } // Update vertex buffer\n\n\n    if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {\n      this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\n\n      this._invalidateInstanceVertexArrayObject();\n    } else {\n      this._userInstancedBuffersStorage.vertexBuffers[kind].updateDirectly(data, 0);\n    }\n  }\n};\n\nMesh.prototype._invalidateInstanceVertexArrayObject = function () {\n  if (!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === undefined) {\n    return;\n  }\n\n  for (var kind in this._userInstancedBuffersStorage.vertexArrayObjects) {\n    this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[kind]);\n  }\n\n  this._userInstancedBuffersStorage.vertexArrayObjects = {};\n};\n\nMesh.prototype._disposeInstanceSpecificData = function () {\n  if (this._instanceDataStorage.instancesBuffer) {\n    this._instanceDataStorage.instancesBuffer.dispose();\n\n    this._instanceDataStorage.instancesBuffer = null;\n  }\n\n  while (this.instances.length) {\n    this.instances[0].dispose();\n  }\n\n  for (var kind in this.instancedBuffers) {\n    if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\n      this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();\n    }\n  }\n\n  this._invalidateInstanceVertexArrayObject();\n\n  this.instancedBuffers = {};\n};","map":{"version":3,"mappings":"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","names":["Matrix","TmpVectors","Logger","AbstractMesh","Mesh","DeepCopier","TransformNode","VertexBuffer","Tools","_instancedMeshFactory","name","mesh","instance","InstancedMesh","instancedBuffers","key","__extends","source","_super","getScene","_this","addInstance","_sourceMesh","_unIndexed","position","copyFrom","rotation","scaling","rotationQuaternion","clone","animations","Slice","getAnimationRanges","_i","range","createAnimationRange","from","to","infiniteDistance","setPivotMatrix","getPivotMatrix","refreshBoundingInfo","_syncSubMeshes","Object","_lightSources","receiveShadows","material","visibility","skeleton","renderingGroupId","value","Warn","getTotalVertices","getTotalIndices","createInstance","completeCheck","isReady","kind","copyWhenShared","getVerticesData","data","updatable","stride","sourceMesh","setVerticesData","updateExtends","makeItUnique","updateVerticesData","indices","totalVertices","setIndices","isVerticesDataPresent","getIndices","_positions","applySkeleton","applyMorph","hasBoundingInfo","getBoundingInfo","isLocked","bias","geometry","boundingBias","_refreshBoundingInfo","_getPositionData","_currentLOD","_preActivate","renderId","intermediateRendering","subMeshes","differentSign","_getWorldMatrixDeterminant","_internalAbstractMeshDataInfo","_actAsRegularMesh","_registerInstanceForRenderId","_isActiveIntermediate","_onlyForInstancesIntermediate","_isActive","_onlyForInstances","edgesShareWithInstances","_edgesRenderer","isEnabled","_renderingGroup","_edgesRenderers","pushNoDuplicate","customInstances","push","getWorldMatrix","billboardMode","BILLBOARDMODE_NONE","_masterMesh","_billboardWorldMatrix","tempMaster","Vector3","set","computeWorldMatrix","call","camera","sourceMeshLODLevels","getLODLevels","length","boundingInfo","getLOD","boundingSphere","_preActivateForIntermediateRendering","releaseSubMeshes","index","_generatePointsArray","update","worldMatrixFromCache","buildBoundingInfo","absolutePosition","_updateSubMeshesBoundingInfo","newParent","doNotCloneChildren","result","DeepCopy","parent","meshes","onClonedObservable","notifyObservers","doNotRecurse","disposeMaterialAndTextures","removeInstance","dispose","prototype","registerInstancedBuffer","_userInstancedBuffersStorage","_a","vertexBuffers","_b","instances","strides","sizes","vertexArrayObjects","getEngine","getCaps","vertexArrayObject","undefined","Float32Array","_d","_invalidateInstanceVertexArrayObject","_processInstancedBuffers","visibleInstances","renderSelf","instanceCount","size","expectedSize","offset","toArray","copyToArray","instanceIndex","updateDirectly","releaseVertexArrayObject","_disposeInstanceSpecificData","_instanceDataStorage","instancesBuffer"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/instancedMesh.ts"],"sourcesContent":["import type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport { Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Node } from \"../node\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport { TransformNode } from \"./transformNode\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\nMesh._instancedMeshFactory = (name: string, mesh: Mesh): InstancedMesh => {\r\n    const instance = new InstancedMesh(name, mesh);\r\n\r\n    if (mesh.instancedBuffers) {\r\n        instance.instancedBuffers = {};\r\n\r\n        for (const key in mesh.instancedBuffers) {\r\n            instance.instancedBuffers[key] = mesh.instancedBuffers[key];\r\n        }\r\n    }\r\n\r\n    return instance;\r\n};\r\n\r\n/**\r\n * Creates an instance based on a source mesh.\r\n */\r\nexport class InstancedMesh extends AbstractMesh {\r\n    private _sourceMesh: Mesh;\r\n    private _currentLOD: Mesh;\r\n    private _billboardWorldMatrix: Matrix;\r\n\r\n    /** @hidden */\r\n    public _indexInSourceMeshInstanceArray = -1;\r\n    /** @hidden */\r\n    public _distanceToCamera: number = 0;\r\n    /** @hidden */\r\n    public _previousWorldMatrix: Nullable<Matrix>;\r\n\r\n    constructor(name: string, source: Mesh) {\r\n        super(name, source.getScene());\r\n\r\n        source.addInstance(this);\r\n\r\n        this._sourceMesh = source;\r\n\r\n        this._unIndexed = source._unIndexed;\r\n\r\n        this.position.copyFrom(source.position);\r\n        this.rotation.copyFrom(source.rotation);\r\n        this.scaling.copyFrom(source.scaling);\r\n\r\n        if (source.rotationQuaternion) {\r\n            this.rotationQuaternion = source.rotationQuaternion.clone();\r\n        }\r\n\r\n        this.animations = Tools.Slice(source.animations);\r\n        for (const range of source.getAnimationRanges()) {\r\n            if (range != null) {\r\n                this.createAnimationRange(range.name, range.from, range.to);\r\n            }\r\n        }\r\n\r\n        this.infiniteDistance = source.infiniteDistance;\r\n\r\n        this.setPivotMatrix(source.getPivotMatrix());\r\n\r\n        this.refreshBoundingInfo(true, true);\r\n        this._syncSubMeshes();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"InstancedMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"InstancedMesh\";\r\n    }\r\n\r\n    /** Gets the list of lights affecting that mesh */\r\n    public get lightSources(): Light[] {\r\n        return this._sourceMesh._lightSources;\r\n    }\r\n\r\n    public _resyncLightSources(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public _resyncLightSource(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public _removeLightSource(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * If the source mesh receives shadows\r\n     */\r\n    public get receiveShadows(): boolean {\r\n        return this._sourceMesh.receiveShadows;\r\n    }\r\n\r\n    /**\r\n     * The material of the source mesh\r\n     */\r\n    public get material(): Nullable<Material> {\r\n        return this._sourceMesh.material;\r\n    }\r\n\r\n    /**\r\n     * Visibility of the source mesh\r\n     */\r\n    public get visibility(): number {\r\n        return this._sourceMesh.visibility;\r\n    }\r\n\r\n    /**\r\n     * Skeleton of the source mesh\r\n     */\r\n    public get skeleton(): Nullable<Skeleton> {\r\n        return this._sourceMesh.skeleton;\r\n    }\r\n\r\n    /**\r\n     * Rendering ground id of the source mesh\r\n     */\r\n    public get renderingGroupId(): number {\r\n        return this._sourceMesh.renderingGroupId;\r\n    }\r\n\r\n    public set renderingGroupId(value: number) {\r\n        if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {\r\n            return;\r\n        }\r\n\r\n        //no-op with warning\r\n        Logger.Warn(\"Note - setting renderingGroupId of an instanced mesh has no effect on the scene\");\r\n    }\r\n\r\n    /**\r\n     * Returns the total number of vertices (integer).\r\n     */\r\n    public getTotalVertices(): number {\r\n        return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;\r\n    }\r\n\r\n    /**\r\n     * Returns a positive integer : the total number of indices in this mesh geometry.\r\n     * @returns the number of indices or zero if the mesh has no geometry.\r\n     */\r\n    public getTotalIndices(): number {\r\n        return this._sourceMesh.getTotalIndices();\r\n    }\r\n\r\n    /**\r\n     * The source mesh of the instance\r\n     */\r\n    public get sourceMesh(): Mesh {\r\n        return this._sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedMesh\r\n     */\r\n    public createInstance(name: string): InstancedMesh {\r\n        return this._sourceMesh.createInstance(name);\r\n    }\r\n\r\n    /**\r\n     * Is this node ready to be used/rendered\r\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\r\n     * @return {boolean} is it ready\r\n     */\r\n    public isReady(completeCheck = false): boolean {\r\n        return this._sourceMesh.isReady(completeCheck, true);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param kind kind of verticies to retrieve (eg. positions, normals, uvs, etc.)\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @returns a float array or a Float32Array of the requested kind of data : positions, normals, uvs, etc.\r\n     */\r\n    public getVerticesData(kind: string, copyWhenShared?: boolean): Nullable<FloatArray> {\r\n        return this._sourceMesh.getVerticesData(kind, copyWhenShared);\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initially none) or updater.\r\n     * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\r\n     * Note that a new underlying VertexBuffer object is created each call.\r\n     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     * @param kind\r\n     * @param data\r\n     * @param updatable\r\n     * @param stride\r\n     */\r\n    public setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): AbstractMesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setVerticesData(kind, data, updatable, stride);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, it is simply returned as it is.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * No new underlying VertexBuffer object is created.\r\n     * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     * @param kind\r\n     * @param data\r\n     * @param updateExtends\r\n     * @param makeItUnique\r\n     */\r\n    public updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh indices.\r\n     * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\r\n     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n     * This method creates a new index buffer each call.\r\n     * Returns the Mesh.\r\n     * @param indices\r\n     * @param totalVertices\r\n     */\r\n    public setIndices(indices: IndicesArray, totalVertices: Nullable<number> = null): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setIndices(indices, totalVertices);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Boolean : True if the mesh owns the requested kind of data.\r\n     * @param kind\r\n     */\r\n    public isVerticesDataPresent(kind: string): boolean {\r\n        return this._sourceMesh.isVerticesDataPresent(kind);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of indices (IndicesArray).\r\n     */\r\n    public getIndices(): Nullable<IndicesArray> {\r\n        return this._sourceMesh.getIndices();\r\n    }\r\n\r\n    public get _positions(): Nullable<Vector3[]> {\r\n        return this._sourceMesh._positions;\r\n    }\r\n\r\n    /**\r\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n     * This means the mesh underlying bounding box and sphere are recomputed.\r\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n     * @param applyMorph  defines whether to apply the morph target before computing the bounding info\r\n     * @returns the current mesh\r\n     */\r\n    public refreshBoundingInfo(applySkeleton: boolean = false, applyMorph: boolean = false): InstancedMesh {\r\n        if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {\r\n            return this;\r\n        }\r\n\r\n        const bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;\r\n        this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton, applyMorph), bias);\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _preActivate(): InstancedMesh {\r\n        if (this._currentLOD) {\r\n            this._currentLOD._preActivate();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param renderId\r\n     * @param intermediateRendering\r\n     * @hidden\r\n     */\r\n    public _activate(renderId: number, intermediateRendering: boolean): boolean {\r\n        if (!this._sourceMesh.subMeshes) {\r\n            Logger.Warn(\"Instances should only be created for meshes with geometry.\");\r\n        }\r\n\r\n        if (this._currentLOD) {\r\n            const differentSign = this._currentLOD._getWorldMatrixDeterminant() >= 0 !== this._getWorldMatrixDeterminant() >= 0;\r\n            if (differentSign) {\r\n                this._internalAbstractMeshDataInfo._actAsRegularMesh = true;\r\n                return true;\r\n            }\r\n            this._internalAbstractMeshDataInfo._actAsRegularMesh = false;\r\n\r\n            this._currentLOD._registerInstanceForRenderId(this, renderId);\r\n\r\n            if (intermediateRendering) {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;\r\n                    return true;\r\n                }\r\n            } else {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _postActivate(): void {\r\n        if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer of the source mesh\r\n            this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);\r\n            this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());\r\n        } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer defined for this instance\r\n            this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);\r\n        }\r\n    }\r\n\r\n    public getWorldMatrix(): Matrix {\r\n        if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {\r\n            if (!this._billboardWorldMatrix) {\r\n                this._billboardWorldMatrix = new Matrix();\r\n            }\r\n            const tempMaster = this._currentLOD._masterMesh;\r\n            this._currentLOD._masterMesh = this;\r\n            TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);\r\n            this._currentLOD.position.set(0, 0, 0);\r\n            this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(true));\r\n            this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);\r\n            this._currentLOD._masterMesh = tempMaster;\r\n            return this._billboardWorldMatrix;\r\n        }\r\n\r\n        return super.getWorldMatrix();\r\n    }\r\n\r\n    public get isAnInstance(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the current associated LOD AbstractMesh.\r\n     * @param camera\r\n     */\r\n    public getLOD(camera: Camera): AbstractMesh {\r\n        if (!camera) {\r\n            return this;\r\n        }\r\n\r\n        const sourceMeshLODLevels = this.sourceMesh.getLODLevels();\r\n        if (!sourceMeshLODLevels || sourceMeshLODLevels.length === 0) {\r\n            this._currentLOD = this.sourceMesh;\r\n        } else {\r\n            const boundingInfo = this.getBoundingInfo();\r\n            this._currentLOD = <Mesh>this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);\r\n        }\r\n\r\n        return this._currentLOD;\r\n    }\r\n\r\n    /**\r\n     * @param renderId\r\n     * @hidden\r\n     */\r\n    public _preActivateForIntermediateRendering(renderId: number): Mesh {\r\n        return <Mesh>this.sourceMesh._preActivateForIntermediateRendering(renderId);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _syncSubMeshes(): InstancedMesh {\r\n        this.releaseSubMeshes();\r\n        if (this._sourceMesh.subMeshes) {\r\n            for (let index = 0; index < this._sourceMesh.subMeshes.length; index++) {\r\n                this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _generatePointsArray(): boolean {\r\n        return this._sourceMesh._generatePointsArray();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _updateBoundingInfo(): AbstractMesh {\r\n        if (this.hasBoundingInfo) {\r\n            this.getBoundingInfo().update(this.worldMatrixFromCache);\r\n        } else {\r\n            this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache);\r\n        }\r\n        this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh from the current mesh.\r\n     * - name (string) : the cloned mesh name\r\n     * - newParent (optional Node) : the optional Node to parent the clone to.\r\n     * - doNotCloneChildren (optional boolean, default `false`) : if `true` the model children aren't cloned.\r\n     *\r\n     * Returns the clone.\r\n     * @param name\r\n     * @param newParent\r\n     * @param doNotCloneChildren\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean): InstancedMesh {\r\n        const result = this._sourceMesh.createInstance(name);\r\n\r\n        // Deep copy\r\n        DeepCopier.DeepCopy(\r\n            this,\r\n            result,\r\n            [\r\n                \"name\",\r\n                \"subMeshes\",\r\n                \"uniqueId\",\r\n                \"parent\",\r\n                \"lightSources\",\r\n                \"receiveShadows\",\r\n                \"material\",\r\n                \"visibility\",\r\n                \"skeleton\",\r\n                \"sourceMesh\",\r\n                \"isAnInstance\",\r\n                \"facetNb\",\r\n                \"isFacetDataEnabled\",\r\n                \"isBlocked\",\r\n                \"useBones\",\r\n                \"hasInstances\",\r\n                \"collider\",\r\n                \"edgesRenderer\",\r\n                \"forward\",\r\n                \"up\",\r\n                \"right\",\r\n                \"absolutePosition\",\r\n                \"absoluteScaling\",\r\n                \"absoluteRotationQuaternion\",\r\n                \"isWorldMatrixFrozen\",\r\n                \"nonUniformScaling\",\r\n                \"behaviors\",\r\n                \"worldMatrixFromCache\",\r\n                \"hasThinInstances\",\r\n            ],\r\n            []\r\n        );\r\n\r\n        // Bounding info\r\n        this.refreshBoundingInfo();\r\n\r\n        // Parent\r\n        if (newParent) {\r\n            result.parent = newParent;\r\n        }\r\n\r\n        if (!doNotCloneChildren) {\r\n            // Children\r\n            for (let index = 0; index < this.getScene().meshes.length; index++) {\r\n                const mesh = this.getScene().meshes[index];\r\n\r\n                if (mesh.parent === this) {\r\n                    mesh.clone(mesh.name, result);\r\n                }\r\n            }\r\n        }\r\n\r\n        result.computeWorldMatrix(true);\r\n\r\n        this.onClonedObservable.notifyObservers(result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the InstancedMesh.\r\n     * Returns nothing.\r\n     * @param doNotRecurse\r\n     * @param disposeMaterialAndTextures\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        // Remove from mesh\r\n        this._sourceMesh.removeInstance(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n}\r\n\r\ndeclare module \"./mesh\" {\r\n    export interface Mesh {\r\n        /**\r\n         * Register a custom buffer that will be instanced\r\n         * @see https://doc.babylonjs.com/how_to/how_to_use_instances#custom-buffers\r\n         * @param kind defines the buffer kind\r\n         * @param stride defines the stride in floats\r\n         */\r\n        registerInstancedBuffer(kind: string, stride: number): void;\r\n\r\n        /**\r\n         * Invalidate VertexArrayObjects belonging to the mesh (but not to the Geometry of the mesh).\r\n         */\r\n        _invalidateInstanceVertexArrayObject(): void;\r\n\r\n        /**\r\n         * true to use the edge renderer for all instances of this mesh\r\n         */\r\n        edgesShareWithInstances: boolean;\r\n\r\n        /** @hidden */\r\n        _userInstancedBuffersStorage: {\r\n            data: { [key: string]: Float32Array };\r\n            sizes: { [key: string]: number };\r\n            vertexBuffers: { [key: string]: Nullable<VertexBuffer> };\r\n            strides: { [key: string]: number };\r\n            vertexArrayObjects?: { [key: string]: WebGLVertexArrayObject };\r\n        };\r\n    }\r\n}\r\n\r\ndeclare module \"./abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /**\r\n         * Object used to store instanced buffers defined by user\r\n         * @see https://doc.babylonjs.com/how_to/how_to_use_instances#custom-buffers\r\n         */\r\n        instancedBuffers: { [key: string]: any };\r\n    }\r\n}\r\n\r\nMesh.prototype.edgesShareWithInstances = false;\r\n\r\nMesh.prototype.registerInstancedBuffer = function (kind: string, stride: number): void {\r\n    // Remove existing one\r\n    this._userInstancedBuffersStorage?.vertexBuffers[kind]?.dispose();\r\n\r\n    // Creates the instancedBuffer field if not present\r\n    if (!this.instancedBuffers) {\r\n        this.instancedBuffers = {};\r\n\r\n        for (const instance of this.instances) {\r\n            instance.instancedBuffers = {};\r\n        }\r\n\r\n        this._userInstancedBuffersStorage = {\r\n            data: {},\r\n            vertexBuffers: {},\r\n            strides: {},\r\n            sizes: {},\r\n            vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : undefined,\r\n        };\r\n    }\r\n\r\n    // Creates an empty property for this kind\r\n    this.instancedBuffers[kind] = null;\r\n\r\n    this._userInstancedBuffersStorage.strides[kind] = stride;\r\n    this._userInstancedBuffersStorage.sizes[kind] = stride * 32; // Initial size\r\n    this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);\r\n    this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\r\n\r\n    for (const instance of this.instances) {\r\n        instance.instancedBuffers[kind] = null;\r\n    }\r\n\r\n    this._invalidateInstanceVertexArrayObject();\r\n};\r\n\r\nMesh.prototype._processInstancedBuffers = function (visibleInstances: InstancedMesh[], renderSelf: boolean) {\r\n    const instanceCount = visibleInstances.length;\r\n\r\n    for (const kind in this.instancedBuffers) {\r\n        let size = this._userInstancedBuffersStorage.sizes[kind];\r\n        const stride = this._userInstancedBuffersStorage.strides[kind];\r\n\r\n        // Resize if required\r\n        const expectedSize = (instanceCount + 1) * stride;\r\n\r\n        while (size < expectedSize) {\r\n            size *= 2;\r\n        }\r\n\r\n        if (this._userInstancedBuffersStorage.data[kind].length != size) {\r\n            this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);\r\n            this._userInstancedBuffersStorage.sizes[kind] = size;\r\n            if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\r\n            }\r\n        }\r\n\r\n        const data = this._userInstancedBuffersStorage.data[kind];\r\n\r\n        // Update data buffer\r\n        let offset = 0;\r\n        if (renderSelf) {\r\n            const value = this.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else if (value.copyToArray) {\r\n                value.copyToArray(data, offset);\r\n            } else {\r\n                data[offset] = value;\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        for (let instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {\r\n            const instance = visibleInstances[instanceIndex]!;\r\n\r\n            const value = instance.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else if (value.copyToArray) {\r\n                value.copyToArray(data, offset);\r\n            } else {\r\n                data[offset] = value;\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        // Update vertex buffer\r\n        if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(\r\n                this.getEngine(),\r\n                this._userInstancedBuffersStorage.data[kind],\r\n                kind,\r\n                true,\r\n                false,\r\n                stride,\r\n                true\r\n            );\r\n            this._invalidateInstanceVertexArrayObject();\r\n        } else {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.updateDirectly(data, 0);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype._invalidateInstanceVertexArrayObject = function () {\r\n    if (!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === undefined) {\r\n        return;\r\n    }\r\n\r\n    for (const kind in this._userInstancedBuffersStorage.vertexArrayObjects) {\r\n        this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[kind]);\r\n    }\r\n\r\n    this._userInstancedBuffersStorage.vertexArrayObjects = {};\r\n};\r\n\r\nMesh.prototype._disposeInstanceSpecificData = function () {\r\n    if (this._instanceDataStorage.instancesBuffer) {\r\n        this._instanceDataStorage.instancesBuffer.dispose();\r\n        this._instanceDataStorage.instancesBuffer = null;\r\n    }\r\n\r\n    while (this.instances.length) {\r\n        this.instances[0].dispose();\r\n    }\r\n\r\n    for (const kind in this.instancedBuffers) {\r\n        if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n        }\r\n    }\r\n\r\n    this._invalidateInstanceVertexArrayObject();\r\n\r\n    this.instancedBuffers = {};\r\n};\r\n"]},"metadata":{},"sourceType":"module"}