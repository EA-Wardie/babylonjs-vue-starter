{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport { Quaternion, Vector3, Matrix } from \"../Maths/math.vector.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { Light } from \"../Lights/light.js\";\n/**\n * Renders gizmos on top of an existing scene which provide controls for position, rotation, etc.\n */\n\nvar Gizmo =\n/** @class */\nfunction () {\n  /**\n   * Creates a gizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   */\n  function Gizmo(\n  /** The utility layer the gizmo will be added to */\n  gizmoLayer) {\n    if (gizmoLayer === void 0) {\n      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;\n    }\n\n    var _this = this;\n\n    this.gizmoLayer = gizmoLayer;\n    this._attachedMesh = null;\n    this._attachedNode = null;\n    this._customRotationQuaternion = null;\n    /**\n     * Ratio for the scale of the gizmo (Default: 1)\n     */\n\n    this._scaleRatio = 1;\n    /**\n     * boolean updated by pointermove when a gizmo mesh is hovered\n     */\n\n    this._isHovered = false;\n    /**\n     * If a custom mesh has been set (Default: false)\n     */\n\n    this._customMeshSet = false;\n    this._updateGizmoRotationToMatchAttachedMesh = true;\n    /**\n     * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)\n     */\n\n    this.updateGizmoPositionToMatchAttachedMesh = true;\n    /**\n     * When set, the gizmo will always appear the same size no matter where the camera is (default: true)\n     */\n\n    this.updateScale = true;\n    this._interactionsEnabled = true;\n    this._tempQuaternion = new Quaternion(0, 0, 0, 1);\n    this._tempVector = new Vector3();\n    this._tempVector2 = new Vector3();\n    this._tempMatrix1 = new Matrix();\n    this._tempMatrix2 = new Matrix();\n    this._rightHandtoLeftHandMatrix = Matrix.RotationY(Math.PI);\n    this._rootMesh = new Mesh(\"gizmoRootNode\", gizmoLayer.utilityLayerScene);\n    this._rootMesh.rotationQuaternion = Quaternion.Identity();\n    this._beforeRenderObserver = this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(function () {\n      _this._update();\n    });\n  }\n\n  Object.defineProperty(Gizmo.prototype, \"scaleRatio\", {\n    get: function get() {\n      return this._scaleRatio;\n    },\n\n    /**\n     * Ratio for the scale of the gizmo (Default: 1)\n     */\n    set: function set(value) {\n      this._scaleRatio = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Gizmo.prototype, \"isHovered\", {\n    /**\n     * True when the mouse pointer is hovered a gizmo mesh\n     */\n    get: function get() {\n      return this._isHovered;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Gizmo.prototype, \"attachedMesh\", {\n    /**\n     * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)\n     * * When set, interactions will be enabled\n     */\n    get: function get() {\n      return this._attachedMesh;\n    },\n    set: function set(value) {\n      this._attachedMesh = value;\n\n      if (value) {\n        this._attachedNode = value;\n      }\n\n      this._rootMesh.setEnabled(value ? true : false);\n\n      this._attachedNodeChanged(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Gizmo.prototype, \"attachedNode\", {\n    /**\n     * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)\n     * * When set, interactions will be enabled\n     */\n    get: function get() {\n      return this._attachedNode;\n    },\n    set: function set(value) {\n      this._attachedNode = value;\n      this._attachedMesh = null;\n\n      this._rootMesh.setEnabled(value ? true : false);\n\n      this._attachedNodeChanged(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Disposes and replaces the current meshes in the gizmo with the specified mesh\n   * @param mesh The mesh to replace the default mesh of the gizmo\n   */\n\n  Gizmo.prototype.setCustomMesh = function (mesh) {\n    if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {\n      throw \"When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)\";\n    }\n\n    this._rootMesh.getChildMeshes().forEach(function (c) {\n      c.dispose();\n    });\n\n    mesh.parent = this._rootMesh;\n    this._customMeshSet = true;\n  };\n\n  Object.defineProperty(Gizmo.prototype, \"updateGizmoRotationToMatchAttachedMesh\", {\n    get: function get() {\n      return this._updateGizmoRotationToMatchAttachedMesh;\n    },\n\n    /**\n     * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\n     */\n    set: function set(value) {\n      this._updateGizmoRotationToMatchAttachedMesh = value;\n    },\n    enumerable: false,\n    configurable: true\n  }); // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  Gizmo.prototype._attachedNodeChanged = function (value) {};\n\n  Object.defineProperty(Gizmo.prototype, \"customRotationQuaternion\", {\n    /**\n     * posture that the gizmo will be display\n     * When set null, default value will be used (Quaternion(0, 0, 0, 1))\n     */\n    get: function get() {\n      return this._customRotationQuaternion;\n    },\n    set: function set(customRotationQuaternion) {\n      this._customRotationQuaternion = customRotationQuaternion;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Updates the gizmo to match the attached mesh's position/rotation\n   */\n\n  Gizmo.prototype._update = function () {\n    if (this.attachedNode) {\n      var effectiveNode = this.attachedNode;\n\n      if (this.attachedMesh) {\n        effectiveNode = this.attachedMesh || this.attachedNode;\n      } // Position\n\n\n      if (this.updateGizmoPositionToMatchAttachedMesh) {\n        var row = effectiveNode.getWorldMatrix().getRow(3);\n        var position = row ? row.toVector3() : new Vector3(0, 0, 0);\n\n        this._rootMesh.position.copyFrom(position);\n      } // Rotation\n\n\n      if (this.updateGizmoRotationToMatchAttachedMesh) {\n        var transformNode = effectiveNode._isMesh ? effectiveNode : undefined;\n        effectiveNode.getWorldMatrix().decompose(undefined, this._rootMesh.rotationQuaternion, undefined, Gizmo.PreserveScaling ? transformNode : undefined);\n      } else {\n        if (this._customRotationQuaternion) {\n          this._rootMesh.rotationQuaternion.copyFrom(this._customRotationQuaternion);\n        } else {\n          this._rootMesh.rotationQuaternion.set(0, 0, 0, 1);\n        }\n      } // Scale\n\n\n      if (this.updateScale) {\n        var activeCamera = this.gizmoLayer.utilityLayerScene.activeCamera;\n        var cameraPosition = activeCamera.globalPosition;\n\n        if (activeCamera.devicePosition) {\n          cameraPosition = activeCamera.devicePosition;\n        }\n\n        this._rootMesh.position.subtractToRef(cameraPosition, this._tempVector);\n\n        var dist = this._tempVector.length() * this.scaleRatio;\n\n        this._rootMesh.scaling.set(dist, dist, dist); // Account for handedness, similar to Matrix.decompose\n\n\n        if (effectiveNode._getWorldMatrixDeterminant() < 0 && !Gizmo.PreserveScaling) {\n          this._rootMesh.scaling.y *= -1;\n        }\n      } else {\n        this._rootMesh.scaling.setAll(this.scaleRatio);\n      }\n    }\n  };\n  /**\n   * Handle position/translation when using an attached node using pivot\n   */\n\n\n  Gizmo.prototype._handlePivot = function () {\n    var attachedNodeTransform = this._attachedNode; // check there is an active pivot for the TransformNode attached\n\n    if (attachedNodeTransform.isUsingPivotMatrix && attachedNodeTransform.isUsingPivotMatrix() && attachedNodeTransform.position) {\n      // When a TransformNode has an active pivot, even without parenting,\n      // translation from the world matrix is different from TransformNode.position.\n      // Pivot works like a virtual parent that's using the node orientation.\n      // As the world matrix is transformed by the gizmo and then decomposed to TRS\n      // its translation part must be set to the Node's position.\n      attachedNodeTransform.getWorldMatrix().setTranslation(attachedNodeTransform.position);\n    }\n  };\n  /**\n   * computes the rotation/scaling/position of the transform once the Node world matrix has changed.\n   */\n\n\n  Gizmo.prototype._matrixChanged = function () {\n    if (!this._attachedNode) {\n      return;\n    }\n\n    if (this._attachedNode._isCamera) {\n      var camera = this._attachedNode;\n      var worldMatrix = void 0;\n      var worldMatrixUC = void 0;\n\n      if (camera.parent) {\n        var parentInv = this._tempMatrix2;\n\n        camera.parent._worldMatrix.invertToRef(parentInv);\n\n        this._attachedNode._worldMatrix.multiplyToRef(parentInv, this._tempMatrix1);\n\n        worldMatrix = this._tempMatrix1;\n      } else {\n        worldMatrix = this._attachedNode._worldMatrix;\n      }\n\n      if (camera.getScene().useRightHandedSystem) {\n        // avoid desync with RH matrix computation. Otherwise, rotation of PI around Y axis happens each frame resulting in axis flipped because worldMatrix is computed as inverse of viewMatrix.\n        this._rightHandtoLeftHandMatrix.multiplyToRef(worldMatrix, this._tempMatrix2);\n\n        worldMatrixUC = this._tempMatrix2;\n      } else {\n        worldMatrixUC = worldMatrix;\n      }\n\n      worldMatrixUC.decompose(this._tempVector2, this._tempQuaternion, this._tempVector);\n      var inheritsTargetCamera = this._attachedNode.getClassName() === \"FreeCamera\" || this._attachedNode.getClassName() === \"FlyCamera\" || this._attachedNode.getClassName() === \"ArcFollowCamera\" || this._attachedNode.getClassName() === \"TargetCamera\" || this._attachedNode.getClassName() === \"TouchCamera\" || this._attachedNode.getClassName() === \"UniversalCamera\";\n\n      if (inheritsTargetCamera) {\n        var targetCamera = this._attachedNode;\n        targetCamera.rotation = this._tempQuaternion.toEulerAngles();\n\n        if (targetCamera.rotationQuaternion) {\n          targetCamera.rotationQuaternion.copyFrom(this._tempQuaternion);\n          targetCamera.rotationQuaternion.normalize();\n        }\n      }\n\n      camera.position.copyFrom(this._tempVector);\n    } else if (this._attachedNode._isMesh || this._attachedNode.getClassName() === \"AbstractMesh\" || this._attachedNode.getClassName() === \"TransformNode\" || this._attachedNode.getClassName() === \"InstancedMesh\") {\n      var transform = this._attachedNode;\n\n      if (transform.parent) {\n        var parentInv = this._tempMatrix1;\n        var localMat = this._tempMatrix2;\n        transform.parent.getWorldMatrix().invertToRef(parentInv);\n\n        this._attachedNode.getWorldMatrix().multiplyToRef(parentInv, localMat);\n\n        localMat.decompose(this._tempVector, this._tempQuaternion, transform.position, Gizmo.PreserveScaling ? transform : undefined);\n      } else {\n        this._attachedNode._worldMatrix.decompose(this._tempVector, this._tempQuaternion, transform.position, Gizmo.PreserveScaling ? transform : undefined);\n      }\n\n      transform.scaling.copyFrom(this._tempVector);\n\n      if (!transform.billboardMode) {\n        if (transform.rotationQuaternion) {\n          transform.rotationQuaternion.copyFrom(this._tempQuaternion);\n          transform.rotationQuaternion.normalize();\n        } else {\n          transform.rotation = this._tempQuaternion.toEulerAngles();\n        }\n      }\n    } else if (this._attachedNode.getClassName() === \"Bone\") {\n      var bone = this._attachedNode;\n      var parent_1 = bone.getParent();\n\n      if (parent_1) {\n        var invParent = this._tempMatrix1;\n        var boneLocalMatrix = this._tempMatrix2;\n        parent_1.getWorldMatrix().invertToRef(invParent);\n        bone.getWorldMatrix().multiplyToRef(invParent, boneLocalMatrix);\n        var lmat = bone.getLocalMatrix();\n        lmat.copyFrom(boneLocalMatrix);\n      } else {\n        var lmat = bone.getLocalMatrix();\n        lmat.copyFrom(bone.getWorldMatrix());\n      }\n\n      bone.markAsDirty();\n    } else {\n      var light = this._attachedNode;\n\n      if (light.getTypeID) {\n        var type = light.getTypeID();\n\n        if (type === Light.LIGHTTYPEID_DIRECTIONALLIGHT || type === Light.LIGHTTYPEID_SPOTLIGHT || type === Light.LIGHTTYPEID_POINTLIGHT) {\n          var parent_2 = light.parent;\n\n          if (parent_2) {\n            var invParent = this._tempMatrix1;\n            var nodeLocalMatrix = this._tempMatrix2;\n            parent_2.getWorldMatrix().invertToRef(invParent);\n            light.getWorldMatrix().multiplyToRef(invParent, nodeLocalMatrix);\n            nodeLocalMatrix.decompose(undefined, this._tempQuaternion, this._tempVector);\n          } else {\n            this._attachedNode._worldMatrix.decompose(undefined, this._tempQuaternion, this._tempVector);\n          } // setter doesn't copy values. Need a new Vector3\n\n\n          light.position = new Vector3(this._tempVector.x, this._tempVector.y, this._tempVector.z);\n          light.direction = new Vector3(light.direction.x, light.direction.y, light.direction.z);\n        }\n      }\n    }\n  };\n  /**\n   * refresh gizmo mesh material\n   * @param gizmoMeshes\n   * @param material material to apply\n   */\n\n\n  Gizmo.prototype._setGizmoMeshMaterial = function (gizmoMeshes, material) {\n    if (gizmoMeshes) {\n      gizmoMeshes.forEach(function (m) {\n        m.material = material;\n\n        if (m.color) {\n          m.color = material.diffuseColor;\n        }\n      });\n    }\n  };\n  /**\n   * Subscribes to pointer up, down, and hover events. Used for responsive gizmos.\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\n   * @returns {Observer<PointerInfo>} pointerObserver\n   */\n\n\n  Gizmo.GizmoAxisPointerObserver = function (gizmoLayer, gizmoAxisCache) {\n    var dragging = false;\n    var pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function (pointerInfo) {\n      var _a, _b;\n\n      if (pointerInfo.pickInfo) {\n        // On Hover Logic\n        if (pointerInfo.type === PointerEventTypes.POINTERMOVE) {\n          if (dragging) {\n            return;\n          }\n\n          gizmoAxisCache.forEach(function (cache) {\n            var _a, _b;\n\n            if (cache.colliderMeshes && cache.gizmoMeshes) {\n              var isHovered = ((_a = cache.colliderMeshes) === null || _a === void 0 ? void 0 : _a.indexOf((_b = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _b === void 0 ? void 0 : _b.pickedMesh)) != -1;\n              var material_1 = cache.dragBehavior.enabled ? isHovered || cache.active ? cache.hoverMaterial : cache.material : cache.disableMaterial;\n              cache.gizmoMeshes.forEach(function (m) {\n                m.material = material_1;\n\n                if (m.color) {\n                  m.color = material_1.diffuseColor;\n                }\n              });\n            }\n          });\n        } // On Mouse Down\n\n\n        if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\n          // If user Clicked Gizmo\n          if (gizmoAxisCache.has((_a = pointerInfo.pickInfo.pickedMesh) === null || _a === void 0 ? void 0 : _a.parent)) {\n            dragging = true;\n            var statusMap = gizmoAxisCache.get((_b = pointerInfo.pickInfo.pickedMesh) === null || _b === void 0 ? void 0 : _b.parent);\n            statusMap.active = true;\n            gizmoAxisCache.forEach(function (cache) {\n              var _a, _b;\n\n              var isHovered = ((_a = cache.colliderMeshes) === null || _a === void 0 ? void 0 : _a.indexOf((_b = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _b === void 0 ? void 0 : _b.pickedMesh)) != -1;\n              var material = (isHovered || cache.active) && cache.dragBehavior.enabled ? cache.hoverMaterial : cache.disableMaterial;\n              cache.gizmoMeshes.forEach(function (m) {\n                m.material = material;\n\n                if (m.color) {\n                  m.color = material.diffuseColor;\n                }\n              });\n            });\n          }\n        } // On Mouse Up\n\n\n        if (pointerInfo.type === PointerEventTypes.POINTERUP) {\n          gizmoAxisCache.forEach(function (cache) {\n            cache.active = false;\n            dragging = false;\n            cache.gizmoMeshes.forEach(function (m) {\n              m.material = cache.dragBehavior.enabled ? cache.material : cache.disableMaterial;\n\n              if (m.color) {\n                m.color = cache.material.diffuseColor;\n              }\n            });\n          });\n        }\n      }\n    });\n    return pointerObserver;\n  };\n  /**\n   * Disposes of the gizmo\n   */\n\n\n  Gizmo.prototype.dispose = function () {\n    this._rootMesh.dispose();\n\n    if (this._beforeRenderObserver) {\n      this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver);\n    }\n  };\n  /**\n   * When enabled, any gizmo operation will perserve scaling sign. Default is off.\n   * Only valid for TransformNode derived classes (Mesh, AbstractMesh, ...)\n   */\n\n\n  Gizmo.PreserveScaling = false;\n  return Gizmo;\n}();\n\nexport { Gizmo };","map":{"version":3,"mappings":"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","names":["Quaternion","Vector3","Matrix","Mesh","UtilityLayerRenderer","PointerEventTypes","Light","gizmoLayer","DefaultUtilityLayer","RotationY","Math","PI","_rootMesh","utilityLayerScene","rotationQuaternion","Identity","_beforeRenderObserver","onBeforeRenderObservable","add","_this","_update","Object","Gizmo","_scaleRatio","value","_isHovered","_attachedMesh","_attachedNode","setEnabled","_attachedNodeChanged","mesh","getScene","getChildMeshes","forEach","c","dispose","parent","_customMeshSet","_updateGizmoRotationToMatchAttachedMesh","_customRotationQuaternion","customRotationQuaternion","attachedNode","effectiveNode","attachedMesh","updateGizmoPositionToMatchAttachedMesh","row","getWorldMatrix","getRow","position","toVector3","copyFrom","updateGizmoRotationToMatchAttachedMesh","transformNode","_isMesh","undefined","decompose","PreserveScaling","set","updateScale","activeCamera","cameraPosition","globalPosition","devicePosition","subtractToRef","_tempVector","dist","length","scaleRatio","scaling","_getWorldMatrixDeterminant","y","setAll","attachedNodeTransform","isUsingPivotMatrix","setTranslation","_isCamera","camera","worldMatrix","worldMatrixUC","parentInv","_tempMatrix2","_worldMatrix","invertToRef","multiplyToRef","_tempMatrix1","useRightHandedSystem","_rightHandtoLeftHandMatrix","_tempVector2","_tempQuaternion","inheritsTargetCamera","getClassName","targetCamera","rotation","toEulerAngles","normalize","transform","localMat","billboardMode","bone","parent_1","getParent","invParent","boneLocalMatrix","lmat","getLocalMatrix","markAsDirty","light","getTypeID","type","LIGHTTYPEID_DIRECTIONALLIGHT","LIGHTTYPEID_SPOTLIGHT","LIGHTTYPEID_POINTLIGHT","parent_2","nodeLocalMatrix","x","z","direction","gizmoMeshes","material","m","color","diffuseColor","gizmoAxisCache","dragging","pointerObserver","onPointerObservable","pointerInfo","pickInfo","POINTERMOVE","cache","colliderMeshes","isHovered","_a","indexOf","_b","pickedMesh","material_1","dragBehavior","enabled","active","hoverMaterial","disableMaterial","POINTERDOWN","has","statusMap","get","POINTERUP","remove"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Gizmos/gizmo.ts"],"sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { WebVRFreeCamera } from \"../Cameras/VR/webVRCamera\";\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { Quaternion, Vector3, Matrix } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { TargetCamera } from \"../Cameras/targetCamera\";\r\nimport type { Node } from \"../node\";\r\nimport type { Bone } from \"../Bones/bone\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport type { LinesMesh } from \"../Meshes/linesMesh\";\r\nimport type { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\r\nimport type { ShadowLight } from \"../Lights/shadowLight\";\r\nimport { Light } from \"../Lights/light\";\r\n\r\n/**\r\n * Cache built by each axis. Used for managing state between all elements of gizmo for enhanced UI\r\n */\r\nexport interface GizmoAxisCache {\r\n    /** Mesh used to render the Gizmo */\r\n    gizmoMeshes: Mesh[];\r\n    /** Mesh used to detect user interaction with Gizmo */\r\n    colliderMeshes: Mesh[];\r\n    /** Material used to indicate color of gizmo mesh */\r\n    material: StandardMaterial;\r\n    /** Material used to indicate hover state of the Gizmo */\r\n    hoverMaterial: StandardMaterial;\r\n    /** Material used to indicate disabled state of the Gizmo */\r\n    disableMaterial: StandardMaterial;\r\n    /** Used to indicate Active state of the Gizmo */\r\n    active: boolean;\r\n    /** DragBehavior */\r\n    dragBehavior: PointerDragBehavior;\r\n}\r\n/**\r\n * Renders gizmos on top of an existing scene which provide controls for position, rotation, etc.\r\n */\r\nexport class Gizmo implements IDisposable {\r\n    /**\r\n     * The root mesh of the gizmo\r\n     */\r\n    public _rootMesh: Mesh;\r\n    private _attachedMesh: Nullable<AbstractMesh> = null;\r\n    private _attachedNode: Nullable<Node> = null;\r\n    private _customRotationQuaternion: Nullable<Quaternion> = null;\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    protected _scaleRatio = 1;\r\n\r\n    /**\r\n     * boolean updated by pointermove when a gizmo mesh is hovered\r\n     */\r\n    protected _isHovered = false;\r\n\r\n    /**\r\n     * When enabled, any gizmo operation will perserve scaling sign. Default is off.\r\n     * Only valid for TransformNode derived classes (Mesh, AbstractMesh, ...)\r\n     */\r\n    public static PreserveScaling = false;\r\n\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    public set scaleRatio(value: number) {\r\n        this._scaleRatio = value;\r\n    }\r\n\r\n    public get scaleRatio() {\r\n        return this._scaleRatio;\r\n    }\r\n\r\n    /**\r\n     * True when the mouse pointer is hovered a gizmo mesh\r\n     */\r\n    public get isHovered() {\r\n        return this._isHovered;\r\n    }\r\n\r\n    /**\r\n     * If a custom mesh has been set (Default: false)\r\n     */\r\n    protected _customMeshSet = false;\r\n    /**\r\n     * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    public get attachedMesh() {\r\n        return this._attachedMesh;\r\n    }\r\n    public set attachedMesh(value) {\r\n        this._attachedMesh = value;\r\n        if (value) {\r\n            this._attachedNode = value;\r\n        }\r\n        this._rootMesh.setEnabled(value ? true : false);\r\n        this._attachedNodeChanged(value);\r\n    }\r\n    /**\r\n     * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    public get attachedNode() {\r\n        return this._attachedNode;\r\n    }\r\n    public set attachedNode(value) {\r\n        this._attachedNode = value;\r\n        this._attachedMesh = null;\r\n        this._rootMesh.setEnabled(value ? true : false);\r\n        this._attachedNodeChanged(value);\r\n    }\r\n\r\n    /**\r\n     * Disposes and replaces the current meshes in the gizmo with the specified mesh\r\n     * @param mesh The mesh to replace the default mesh of the gizmo\r\n     */\r\n    public setCustomMesh(mesh: Mesh) {\r\n        if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {\r\n            throw \"When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)\";\r\n        }\r\n        this._rootMesh.getChildMeshes().forEach((c) => {\r\n            c.dispose();\r\n        });\r\n        mesh.parent = this._rootMesh;\r\n        this._customMeshSet = true;\r\n    }\r\n\r\n    protected _updateGizmoRotationToMatchAttachedMesh = true;\r\n\r\n    /**\r\n     * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\r\n     */\r\n    public set updateGizmoRotationToMatchAttachedMesh(value: boolean) {\r\n        this._updateGizmoRotationToMatchAttachedMesh = value;\r\n    }\r\n    public get updateGizmoRotationToMatchAttachedMesh() {\r\n        return this._updateGizmoRotationToMatchAttachedMesh;\r\n    }\r\n    /**\r\n     * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)\r\n     */\r\n    public updateGizmoPositionToMatchAttachedMesh = true;\r\n    /**\r\n     * When set, the gizmo will always appear the same size no matter where the camera is (default: true)\r\n     */\r\n    public updateScale = true;\r\n    protected _interactionsEnabled = true;\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _attachedNodeChanged(value: Nullable<Node>) {}\r\n\r\n    private _beforeRenderObserver: Nullable<Observer<Scene>>;\r\n    private _tempQuaternion = new Quaternion(0, 0, 0, 1);\r\n    private _tempVector = new Vector3();\r\n    private _tempVector2 = new Vector3();\r\n    private _tempMatrix1 = new Matrix();\r\n    private _tempMatrix2 = new Matrix();\r\n    private _rightHandtoLeftHandMatrix = Matrix.RotationY(Math.PI);\r\n\r\n    /**\r\n     * Creates a gizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     */\r\n    constructor(\r\n        /** The utility layer the gizmo will be added to */\r\n        public gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer\r\n    ) {\r\n        this._rootMesh = new Mesh(\"gizmoRootNode\", gizmoLayer.utilityLayerScene);\r\n        this._rootMesh.rotationQuaternion = Quaternion.Identity();\r\n\r\n        this._beforeRenderObserver = this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(() => {\r\n            this._update();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * posture that the gizmo will be display\r\n     * When set null, default value will be used (Quaternion(0, 0, 0, 1))\r\n     */\r\n    public get customRotationQuaternion(): Nullable<Quaternion> {\r\n        return this._customRotationQuaternion;\r\n    }\r\n\r\n    public set customRotationQuaternion(customRotationQuaternion: Nullable<Quaternion>) {\r\n        this._customRotationQuaternion = customRotationQuaternion;\r\n    }\r\n\r\n    /**\r\n     * Updates the gizmo to match the attached mesh's position/rotation\r\n     */\r\n    protected _update() {\r\n        if (this.attachedNode) {\r\n            let effectiveNode = this.attachedNode;\r\n            if (this.attachedMesh) {\r\n                effectiveNode = this.attachedMesh || this.attachedNode;\r\n            }\r\n\r\n            // Position\r\n            if (this.updateGizmoPositionToMatchAttachedMesh) {\r\n                const row = effectiveNode.getWorldMatrix().getRow(3);\r\n                const position = row ? row.toVector3() : new Vector3(0, 0, 0);\r\n                this._rootMesh.position.copyFrom(position);\r\n            }\r\n\r\n            // Rotation\r\n            if (this.updateGizmoRotationToMatchAttachedMesh) {\r\n                const transformNode = (<Mesh>effectiveNode)._isMesh ? (effectiveNode as TransformNode) : undefined;\r\n                effectiveNode.getWorldMatrix().decompose(undefined, this._rootMesh.rotationQuaternion!, undefined, Gizmo.PreserveScaling ? transformNode : undefined);\r\n            } else {\r\n                if (this._customRotationQuaternion) {\r\n                    this._rootMesh.rotationQuaternion!.copyFrom(this._customRotationQuaternion);\r\n                } else {\r\n                    this._rootMesh.rotationQuaternion!.set(0, 0, 0, 1);\r\n                }\r\n            }\r\n\r\n            // Scale\r\n            if (this.updateScale) {\r\n                const activeCamera = this.gizmoLayer.utilityLayerScene.activeCamera!;\r\n                let cameraPosition = activeCamera.globalPosition;\r\n                if ((<WebVRFreeCamera>activeCamera).devicePosition) {\r\n                    cameraPosition = (<WebVRFreeCamera>activeCamera).devicePosition;\r\n                }\r\n                this._rootMesh.position.subtractToRef(cameraPosition, this._tempVector);\r\n                const dist = this._tempVector.length() * this.scaleRatio;\r\n                this._rootMesh.scaling.set(dist, dist, dist);\r\n\r\n                // Account for handedness, similar to Matrix.decompose\r\n                if (effectiveNode._getWorldMatrixDeterminant() < 0 && !Gizmo.PreserveScaling) {\r\n                    this._rootMesh.scaling.y *= -1;\r\n                }\r\n            } else {\r\n                this._rootMesh.scaling.setAll(this.scaleRatio);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle position/translation when using an attached node using pivot\r\n     */\r\n    protected _handlePivot() {\r\n        const attachedNodeTransform = this._attachedNode as any;\r\n        // check there is an active pivot for the TransformNode attached\r\n        if (attachedNodeTransform.isUsingPivotMatrix && attachedNodeTransform.isUsingPivotMatrix() && attachedNodeTransform.position) {\r\n            // When a TransformNode has an active pivot, even without parenting,\r\n            // translation from the world matrix is different from TransformNode.position.\r\n            // Pivot works like a virtual parent that's using the node orientation.\r\n            // As the world matrix is transformed by the gizmo and then decomposed to TRS\r\n            // its translation part must be set to the Node's position.\r\n            attachedNodeTransform.getWorldMatrix().setTranslation(attachedNodeTransform.position);\r\n        }\r\n    }\r\n    /**\r\n     * computes the rotation/scaling/position of the transform once the Node world matrix has changed.\r\n     */\r\n    protected _matrixChanged() {\r\n        if (!this._attachedNode) {\r\n            return;\r\n        }\r\n\r\n        if ((<Camera>this._attachedNode)._isCamera) {\r\n            const camera = this._attachedNode as Camera;\r\n            let worldMatrix;\r\n            let worldMatrixUC;\r\n            if (camera.parent) {\r\n                const parentInv = this._tempMatrix2;\r\n                camera.parent._worldMatrix.invertToRef(parentInv);\r\n                this._attachedNode._worldMatrix.multiplyToRef(parentInv, this._tempMatrix1);\r\n                worldMatrix = this._tempMatrix1;\r\n            } else {\r\n                worldMatrix = this._attachedNode._worldMatrix;\r\n            }\r\n\r\n            if (camera.getScene().useRightHandedSystem) {\r\n                // avoid desync with RH matrix computation. Otherwise, rotation of PI around Y axis happens each frame resulting in axis flipped because worldMatrix is computed as inverse of viewMatrix.\r\n                this._rightHandtoLeftHandMatrix.multiplyToRef(worldMatrix, this._tempMatrix2);\r\n                worldMatrixUC = this._tempMatrix2;\r\n            } else {\r\n                worldMatrixUC = worldMatrix;\r\n            }\r\n\r\n            worldMatrixUC.decompose(this._tempVector2, this._tempQuaternion, this._tempVector);\r\n\r\n            const inheritsTargetCamera =\r\n                this._attachedNode.getClassName() === \"FreeCamera\" ||\r\n                this._attachedNode.getClassName() === \"FlyCamera\" ||\r\n                this._attachedNode.getClassName() === \"ArcFollowCamera\" ||\r\n                this._attachedNode.getClassName() === \"TargetCamera\" ||\r\n                this._attachedNode.getClassName() === \"TouchCamera\" ||\r\n                this._attachedNode.getClassName() === \"UniversalCamera\";\r\n\r\n            if (inheritsTargetCamera) {\r\n                const targetCamera = this._attachedNode as TargetCamera;\r\n                targetCamera.rotation = this._tempQuaternion.toEulerAngles();\r\n\r\n                if (targetCamera.rotationQuaternion) {\r\n                    targetCamera.rotationQuaternion.copyFrom(this._tempQuaternion);\r\n                    targetCamera.rotationQuaternion.normalize();\r\n                }\r\n            }\r\n\r\n            camera.position.copyFrom(this._tempVector);\r\n        } else if (\r\n            (<Mesh>this._attachedNode)._isMesh ||\r\n            this._attachedNode.getClassName() === \"AbstractMesh\" ||\r\n            this._attachedNode.getClassName() === \"TransformNode\" ||\r\n            this._attachedNode.getClassName() === \"InstancedMesh\"\r\n        ) {\r\n            const transform = this._attachedNode as TransformNode;\r\n            if (transform.parent) {\r\n                const parentInv = this._tempMatrix1;\r\n                const localMat = this._tempMatrix2;\r\n                transform.parent.getWorldMatrix().invertToRef(parentInv);\r\n                this._attachedNode.getWorldMatrix().multiplyToRef(parentInv, localMat);\r\n                localMat.decompose(this._tempVector, this._tempQuaternion, transform.position, Gizmo.PreserveScaling ? transform : undefined);\r\n            } else {\r\n                this._attachedNode._worldMatrix.decompose(this._tempVector, this._tempQuaternion, transform.position, Gizmo.PreserveScaling ? transform : undefined);\r\n            }\r\n            transform.scaling.copyFrom(this._tempVector);\r\n            if (!transform.billboardMode) {\r\n                if (transform.rotationQuaternion) {\r\n                    transform.rotationQuaternion.copyFrom(this._tempQuaternion);\r\n                    transform.rotationQuaternion.normalize();\r\n                } else {\r\n                    transform.rotation = this._tempQuaternion.toEulerAngles();\r\n                }\r\n            }\r\n        } else if (this._attachedNode.getClassName() === \"Bone\") {\r\n            const bone = this._attachedNode as Bone;\r\n            const parent = bone.getParent();\r\n\r\n            if (parent) {\r\n                const invParent = this._tempMatrix1;\r\n                const boneLocalMatrix = this._tempMatrix2;\r\n                parent.getWorldMatrix().invertToRef(invParent);\r\n                bone.getWorldMatrix().multiplyToRef(invParent, boneLocalMatrix);\r\n                const lmat = bone.getLocalMatrix();\r\n                lmat.copyFrom(boneLocalMatrix);\r\n            } else {\r\n                const lmat = bone.getLocalMatrix();\r\n                lmat.copyFrom(bone.getWorldMatrix());\r\n            }\r\n            bone.markAsDirty();\r\n        } else {\r\n            const light = this._attachedNode as ShadowLight;\r\n            if (light.getTypeID) {\r\n                const type = light.getTypeID();\r\n                if (type === Light.LIGHTTYPEID_DIRECTIONALLIGHT || type === Light.LIGHTTYPEID_SPOTLIGHT || type === Light.LIGHTTYPEID_POINTLIGHT) {\r\n                    const parent = light.parent;\r\n\r\n                    if (parent) {\r\n                        const invParent = this._tempMatrix1;\r\n                        const nodeLocalMatrix = this._tempMatrix2;\r\n                        parent.getWorldMatrix().invertToRef(invParent);\r\n                        light.getWorldMatrix().multiplyToRef(invParent, nodeLocalMatrix);\r\n                        nodeLocalMatrix.decompose(undefined, this._tempQuaternion, this._tempVector);\r\n                    } else {\r\n                        this._attachedNode._worldMatrix.decompose(undefined, this._tempQuaternion, this._tempVector);\r\n                    }\r\n                    // setter doesn't copy values. Need a new Vector3\r\n                    light.position = new Vector3(this._tempVector.x, this._tempVector.y, this._tempVector.z);\r\n                    light.direction = new Vector3(light.direction.x, light.direction.y, light.direction.z);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * refresh gizmo mesh material\r\n     * @param gizmoMeshes\r\n     * @param material material to apply\r\n     */\r\n    protected _setGizmoMeshMaterial(gizmoMeshes: Mesh[], material: StandardMaterial) {\r\n        if (gizmoMeshes) {\r\n            gizmoMeshes.forEach((m: Mesh) => {\r\n                m.material = material;\r\n                if ((<LinesMesh>m).color) {\r\n                    (<LinesMesh>m).color = material.diffuseColor;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Subscribes to pointer up, down, and hover events. Used for responsive gizmos.\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\r\n     * @returns {Observer<PointerInfo>} pointerObserver\r\n     */\r\n    public static GizmoAxisPointerObserver(gizmoLayer: UtilityLayerRenderer, gizmoAxisCache: Map<Mesh, GizmoAxisCache>): Observer<PointerInfo> {\r\n        let dragging = false;\r\n\r\n        const pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\r\n            if (pointerInfo.pickInfo) {\r\n                // On Hover Logic\r\n                if (pointerInfo.type === PointerEventTypes.POINTERMOVE) {\r\n                    if (dragging) {\r\n                        return;\r\n                    }\r\n                    gizmoAxisCache.forEach((cache) => {\r\n                        if (cache.colliderMeshes && cache.gizmoMeshes) {\r\n                            const isHovered = cache.colliderMeshes?.indexOf(pointerInfo?.pickInfo?.pickedMesh as Mesh) != -1;\r\n                            const material = cache.dragBehavior.enabled ? (isHovered || cache.active ? cache.hoverMaterial : cache.material) : cache.disableMaterial;\r\n                            cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                                m.material = material;\r\n                                if ((m as LinesMesh).color) {\r\n                                    (m as LinesMesh).color = material.diffuseColor;\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n\r\n                // On Mouse Down\r\n                if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                    // If user Clicked Gizmo\r\n                    if (gizmoAxisCache.has(pointerInfo.pickInfo.pickedMesh?.parent as Mesh)) {\r\n                        dragging = true;\r\n                        const statusMap = gizmoAxisCache.get(pointerInfo.pickInfo.pickedMesh?.parent as Mesh);\r\n                        statusMap!.active = true;\r\n                        gizmoAxisCache.forEach((cache) => {\r\n                            const isHovered = cache.colliderMeshes?.indexOf(pointerInfo?.pickInfo?.pickedMesh as Mesh) != -1;\r\n                            const material = (isHovered || cache.active) && cache.dragBehavior.enabled ? cache.hoverMaterial : cache.disableMaterial;\r\n                            cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                                m.material = material;\r\n                                if ((m as LinesMesh).color) {\r\n                                    (m as LinesMesh).color = material.diffuseColor;\r\n                                }\r\n                            });\r\n                        });\r\n                    }\r\n                }\r\n\r\n                // On Mouse Up\r\n                if (pointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                    gizmoAxisCache.forEach((cache) => {\r\n                        cache.active = false;\r\n                        dragging = false;\r\n                        cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                            m.material = cache.dragBehavior.enabled ? cache.material : cache.disableMaterial;\r\n                            if ((m as LinesMesh).color) {\r\n                                (m as LinesMesh).color = cache.material.diffuseColor;\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n            }\r\n        });\r\n\r\n        return pointerObserver!;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the gizmo\r\n     */\r\n    public dispose() {\r\n        this._rootMesh.dispose();\r\n        if (this._beforeRenderObserver) {\r\n            this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver);\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}