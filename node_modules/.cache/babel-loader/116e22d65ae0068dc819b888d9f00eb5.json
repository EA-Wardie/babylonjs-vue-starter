{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport { ShadowGenerator } from \"./shadowGenerator.js\";\nimport { CascadedShadowGenerator } from \"./cascadedShadowGenerator.js\";\nimport { SceneComponentConstants } from \"../../sceneComponent.js\";\nimport { AbstractScene } from \"../../abstractScene.js\"; // Adds the parser to the scene parsers.\n\nAbstractScene.AddParser(SceneComponentConstants.NAME_SHADOWGENERATOR, function (parsedData, scene) {\n  // Shadows\n  if (parsedData.shadowGenerators !== undefined && parsedData.shadowGenerators !== null) {\n    for (var index = 0, cache = parsedData.shadowGenerators.length; index < cache; index++) {\n      var parsedShadowGenerator = parsedData.shadowGenerators[index];\n\n      if (parsedShadowGenerator.className === CascadedShadowGenerator.CLASSNAME) {\n        CascadedShadowGenerator.Parse(parsedShadowGenerator, scene);\n      } else {\n        ShadowGenerator.Parse(parsedShadowGenerator, scene);\n      } // SG would be available on their associated lights\n\n    }\n  }\n});\n/**\n * Defines the shadow generator component responsible to manage any shadow generators\n * in a given scene.\n */\n\nvar ShadowGeneratorSceneComponent =\n/** @class */\nfunction () {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  function ShadowGeneratorSceneComponent(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_SHADOWGENERATOR;\n    this.scene = scene;\n  }\n  /**\n   * Registers the component in a given scene\n   */\n\n\n  ShadowGeneratorSceneComponent.prototype.register = function () {\n    this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);\n  };\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n\n\n  ShadowGeneratorSceneComponent.prototype.rebuild = function () {// Nothing To Do Here.\n  };\n  /**\n   * Serializes the component data to the specified json object\n   * @param serializationObject The object to serialize to\n   */\n\n\n  ShadowGeneratorSceneComponent.prototype.serialize = function (serializationObject) {\n    // Shadows\n    serializationObject.shadowGenerators = [];\n    var lights = this.scene.lights;\n\n    for (var _i = 0, lights_1 = lights; _i < lights_1.length; _i++) {\n      var light = lights_1[_i];\n      var shadowGenerator = light.getShadowGenerator();\n\n      if (shadowGenerator) {\n        serializationObject.shadowGenerators.push(shadowGenerator.serialize());\n      }\n    }\n  };\n  /**\n   * Adds all the elements from the container to the scene\n   * @param container the container holding the elements\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  ShadowGeneratorSceneComponent.prototype.addFromContainer = function (container) {// Nothing To Do Here. (directly attached to a light)\n  };\n  /**\n   * Removes all the elements in the container from the scene\n   * @param container contains the elements to remove\n   * @param dispose if the removed element should be disposed (default: false)\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  ShadowGeneratorSceneComponent.prototype.removeFromContainer = function (container, dispose) {// Nothing To Do Here. (directly attached to a light)\n  };\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n\n\n  ShadowGeneratorSceneComponent.prototype.dispose = function () {// Nothing To Do Here.\n  };\n\n  ShadowGeneratorSceneComponent.prototype._gatherRenderTargets = function (renderTargets) {\n    // Shadows\n    var scene = this.scene;\n\n    if (this.scene.shadowsEnabled) {\n      for (var lightIndex = 0; lightIndex < scene.lights.length; lightIndex++) {\n        var light = scene.lights[lightIndex];\n        var shadowGenerator = light.getShadowGenerator();\n\n        if (light.isEnabled() && light.shadowEnabled && shadowGenerator) {\n          var shadowMap = shadowGenerator.getShadowMap();\n\n          if (scene.textures.indexOf(shadowMap) !== -1) {\n            renderTargets.push(shadowMap);\n          }\n        }\n      }\n    }\n  };\n\n  return ShadowGeneratorSceneComponent;\n}();\n\nexport { ShadowGeneratorSceneComponent };\n\nShadowGenerator._SceneComponentInitialization = function (scene) {\n  var component = scene._getComponent(SceneComponentConstants.NAME_SHADOWGENERATOR);\n\n  if (!component) {\n    component = new ShadowGeneratorSceneComponent(scene);\n\n    scene._addComponent(component);\n  }\n};","map":{"version":3,"mappings":"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","names":["ShadowGenerator","CascadedShadowGenerator","SceneComponentConstants","AbstractScene","AddParser","NAME_SHADOWGENERATOR","parsedData","scene","shadowGenerators","undefined","index","cache","length","parsedShadowGenerator","className","CLASSNAME","Parse","ShadowGeneratorSceneComponent","_gatherRenderTargetsStage","registerStep","STEP_GATHERRENDERTARGETS_SHADOWGENERATOR","_gatherRenderTargets","serializationObject","lights","_i","light","shadowGenerator","getShadowGenerator","push","serialize","container","dispose","renderTargets","shadowsEnabled","lightIndex","isEnabled","shadowEnabled","shadowMap","getShadowMap","textures","indexOf","_SceneComponentInitialization","component","_getComponent","_addComponent"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Lights/Shadows/shadowGeneratorSceneComponent.ts"],"sourcesContent":["import type { SmartArrayNoDuplicate } from \"../../Misc/smartArray\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { ShadowGenerator } from \"./shadowGenerator\";\r\nimport { CascadedShadowGenerator } from \"./cascadedShadowGenerator\";\r\nimport type { ISceneSerializableComponent } from \"../../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../../sceneComponent\";\r\nimport { AbstractScene } from \"../../abstractScene\";\r\n// Adds the parser to the scene parsers.\r\nAbstractScene.AddParser(SceneComponentConstants.NAME_SHADOWGENERATOR, (parsedData: any, scene: Scene) => {\r\n    // Shadows\r\n    if (parsedData.shadowGenerators !== undefined && parsedData.shadowGenerators !== null) {\r\n        for (let index = 0, cache = parsedData.shadowGenerators.length; index < cache; index++) {\r\n            const parsedShadowGenerator = parsedData.shadowGenerators[index];\r\n            if (parsedShadowGenerator.className === CascadedShadowGenerator.CLASSNAME) {\r\n                CascadedShadowGenerator.Parse(parsedShadowGenerator, scene);\r\n            } else {\r\n                ShadowGenerator.Parse(parsedShadowGenerator, scene);\r\n            }\r\n            // SG would be available on their associated lights\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Defines the shadow generator component responsible to manage any shadow generators\r\n * in a given scene.\r\n */\r\nexport class ShadowGeneratorSceneComponent implements ISceneSerializableComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_SHADOWGENERATOR;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing To Do Here.\r\n    }\r\n\r\n    /**\r\n     * Serializes the component data to the specified json object\r\n     * @param serializationObject The object to serialize to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        // Shadows\r\n        serializationObject.shadowGenerators = [];\r\n        const lights = this.scene.lights;\r\n        for (const light of lights) {\r\n            const shadowGenerator = light.getShadowGenerator();\r\n            if (shadowGenerator) {\r\n                serializationObject.shadowGenerators.push(shadowGenerator.serialize());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public addFromContainer(container: AbstractScene): void {\r\n        // Nothing To Do Here. (directly attached to a light)\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public removeFromContainer(container: AbstractScene, dispose?: boolean): void {\r\n        // Nothing To Do Here. (directly attached to a light)\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public dispose(): void {\r\n        // Nothing To Do Here.\r\n    }\r\n\r\n    private _gatherRenderTargets(renderTargets: SmartArrayNoDuplicate<RenderTargetTexture>): void {\r\n        // Shadows\r\n        const scene = this.scene;\r\n        if (this.scene.shadowsEnabled) {\r\n            for (let lightIndex = 0; lightIndex < scene.lights.length; lightIndex++) {\r\n                const light = scene.lights[lightIndex];\r\n                const shadowGenerator = light.getShadowGenerator();\r\n\r\n                if (light.isEnabled() && light.shadowEnabled && shadowGenerator) {\r\n                    const shadowMap = <RenderTargetTexture>shadowGenerator.getShadowMap();\r\n                    if (scene.textures.indexOf(shadowMap) !== -1) {\r\n                        renderTargets.push(shadowMap);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nShadowGenerator._SceneComponentInitialization = (scene: Scene) => {\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_SHADOWGENERATOR);\r\n    if (!component) {\r\n        component = new ShadowGeneratorSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}