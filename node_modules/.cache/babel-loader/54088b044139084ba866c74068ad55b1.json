{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.date.now.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.string.substr.js\";\nimport \"core-js/modules/es.typed-array.int8-array.js\";\nimport \"core-js/modules/es.typed-array.int16-array.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport { Deferred } from \"@babylonjs/core/Misc/deferred.js\";\nimport { Quaternion, Vector3, Matrix, TmpVectors } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { Camera } from \"@babylonjs/core/Cameras/camera.js\";\nimport { FreeCamera } from \"@babylonjs/core/Cameras/freeCamera.js\";\nimport { AnimationGroup } from \"@babylonjs/core/Animations/animationGroup.js\";\nimport { Animation } from \"@babylonjs/core/Animations/animation.js\";\nimport { Bone } from \"@babylonjs/core/Bones/bone.js\";\nimport { Skeleton } from \"@babylonjs/core/Bones/skeleton.js\";\nimport { Material } from \"@babylonjs/core/Materials/material.js\";\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial.js\";\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture.js\";\nimport { TransformNode } from \"@babylonjs/core/Meshes/transformNode.js\";\nimport { Buffer, VertexBuffer } from \"@babylonjs/core/Buffers/buffer.js\";\nimport { Geometry } from \"@babylonjs/core/Meshes/geometry.js\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh.js\";\nimport { MorphTarget } from \"@babylonjs/core/Morph/morphTarget.js\";\nimport { MorphTargetManager } from \"@babylonjs/core/Morph/morphTargetManager.js\";\nimport { GLTFFileLoader, GLTFLoaderState, GLTFLoaderCoordinateSystemMode, GLTFLoaderAnimationStartMode } from \"../glTFFileLoader.js\";\nimport { AnimationKeyInterpolation } from \"@babylonjs/core/Animations/animationKey.js\";\nimport { DecodeBase64UrlToBinary, IsBase64DataUrl, LoadFileError } from \"@babylonjs/core/Misc/fileTools.js\";\nimport { Logger } from \"@babylonjs/core/Misc/logger.js\";\nimport { BoundingInfo } from \"@babylonjs/core/Culling/boundingInfo.js\";\nimport { StringTools } from \"@babylonjs/core/Misc/stringTools.js\";\n/**\n * Helper class for working with arrays when loading the glTF asset\n */\n\nvar ArrayItem =\n/** @class */\nfunction () {\n  function ArrayItem() {}\n  /**\n   * Gets an item from the given array.\n   * @param context The context when loading the asset\n   * @param array The array to get the item from\n   * @param index The index to the array\n   * @returns The array item\n   */\n\n\n  ArrayItem.Get = function (context, array, index) {\n    if (!array || index == undefined || !array[index]) {\n      throw new Error(\"\".concat(context, \": Failed to find index (\").concat(index, \")\"));\n    }\n\n    return array[index];\n  };\n  /**\n   * Assign an `index` field to each item of the given array.\n   * @param array The array of items\n   */\n\n\n  ArrayItem.Assign = function (array) {\n    if (array) {\n      for (var index = 0; index < array.length; index++) {\n        array[index].index = index;\n      }\n    }\n  };\n\n  return ArrayItem;\n}();\n\nexport { ArrayItem };\n/**\n * The glTF 2.0 loader\n */\n\nvar GLTFLoader =\n/** @class */\nfunction () {\n  /**\n   * @param parent\n   * @hidden\n   */\n  function GLTFLoader(parent) {\n    /** @hidden */\n    this._completePromises = new Array();\n    /** @hidden */\n\n    this._assetContainer = null;\n    /** Storage */\n\n    this._babylonLights = [];\n    /** @hidden */\n\n    this._disableInstancedMesh = 0;\n    this._extensions = new Array();\n    this._disposed = false;\n    this._rootUrl = null;\n    this._fileName = null;\n    this._uniqueRootUrl = null;\n    this._bin = null;\n    this._rootBabylonMesh = null;\n    this._defaultBabylonMaterialData = {};\n    this._postSceneLoadActions = new Array();\n    this._parent = parent;\n  }\n  /**\n   * Registers a loader extension.\n   * @param name The name of the loader extension.\n   * @param factory The factory function that creates the loader extension.\n   */\n\n\n  GLTFLoader.RegisterExtension = function (name, factory) {\n    if (GLTFLoader.UnregisterExtension(name)) {\n      Logger.Warn(\"Extension with the name '\".concat(name, \"' already exists\"));\n    }\n\n    GLTFLoader._RegisteredExtensions[name] = {\n      factory: factory\n    };\n  };\n  /**\n   * Unregisters a loader extension.\n   * @param name The name of the loader extension.\n   * @returns A boolean indicating whether the extension has been unregistered\n   */\n\n\n  GLTFLoader.UnregisterExtension = function (name) {\n    if (!GLTFLoader._RegisteredExtensions[name]) {\n      return false;\n    }\n\n    delete GLTFLoader._RegisteredExtensions[name];\n    return true;\n  };\n\n  Object.defineProperty(GLTFLoader.prototype, \"gltf\", {\n    /**\n     * The object that represents the glTF JSON.\n     */\n    get: function get() {\n      if (!this._gltf) {\n        throw new Error(\"glTF JSON is not available\");\n      }\n\n      return this._gltf;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFLoader.prototype, \"bin\", {\n    /**\n     * The BIN chunk of a binary glTF.\n     */\n    get: function get() {\n      return this._bin;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFLoader.prototype, \"parent\", {\n    /**\n     * The parent file loader.\n     */\n    get: function get() {\n      return this._parent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFLoader.prototype, \"babylonScene\", {\n    /**\n     * The Babylon scene when loading the asset.\n     */\n    get: function get() {\n      if (!this._babylonScene) {\n        throw new Error(\"Scene is not available\");\n      }\n\n      return this._babylonScene;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFLoader.prototype, \"rootBabylonMesh\", {\n    /**\n     * The root Babylon mesh when loading the asset.\n     */\n    get: function get() {\n      return this._rootBabylonMesh;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  GLTFLoader.prototype.dispose = function () {\n    if (this._disposed) {\n      return;\n    }\n\n    this._disposed = true;\n    this._completePromises.length = 0;\n\n    this._extensions.forEach(function (extension) {\n      return extension.dispose && extension.dispose();\n    });\n\n    this._extensions.length = 0;\n    this._gltf = null; // TODO\n\n    this._bin = null;\n    this._babylonScene = null; // TODO\n\n    this._rootBabylonMesh = null;\n    this._defaultBabylonMaterialData = {};\n    this._postSceneLoadActions.length = 0;\n\n    this._parent.dispose();\n  };\n  /**\n   * @param meshesNames\n   * @param scene\n   * @param container\n   * @param data\n   * @param rootUrl\n   * @param onProgress\n   * @param fileName\n   * @hidden\n   */\n\n\n  GLTFLoader.prototype.importMeshAsync = function (meshesNames, scene, container, data, rootUrl, onProgress, fileName) {\n    var _this = this;\n\n    if (fileName === void 0) {\n      fileName = \"\";\n    }\n\n    return Promise.resolve().then(function () {\n      _this._babylonScene = scene;\n      _this._assetContainer = container;\n\n      _this._loadData(data);\n\n      var nodes = null;\n\n      if (meshesNames) {\n        var nodeMap_1 = {};\n\n        if (_this._gltf.nodes) {\n          for (var _i = 0, _a = _this._gltf.nodes; _i < _a.length; _i++) {\n            var node = _a[_i];\n\n            if (node.name) {\n              nodeMap_1[node.name] = node.index;\n            }\n          }\n        }\n\n        var names = meshesNames instanceof Array ? meshesNames : [meshesNames];\n        nodes = names.map(function (name) {\n          var node = nodeMap_1[name];\n\n          if (node === undefined) {\n            throw new Error(\"Failed to find node '\".concat(name, \"'\"));\n          }\n\n          return node;\n        });\n      }\n\n      return _this._loadAsync(rootUrl, fileName, nodes, function () {\n        return {\n          meshes: _this._getMeshes(),\n          particleSystems: [],\n          skeletons: _this._getSkeletons(),\n          animationGroups: _this._getAnimationGroups(),\n          lights: _this._babylonLights,\n          transformNodes: _this._getTransformNodes(),\n          geometries: _this._getGeometries()\n        };\n      });\n    });\n  };\n  /**\n   * @param scene\n   * @param data\n   * @param rootUrl\n   * @param onProgress\n   * @param fileName\n   * @hidden\n   */\n\n\n  GLTFLoader.prototype.loadAsync = function (scene, data, rootUrl, onProgress, fileName) {\n    var _this = this;\n\n    if (fileName === void 0) {\n      fileName = \"\";\n    }\n\n    return Promise.resolve().then(function () {\n      _this._babylonScene = scene;\n\n      _this._loadData(data);\n\n      return _this._loadAsync(rootUrl, fileName, null, function () {\n        return undefined;\n      });\n    });\n  };\n\n  GLTFLoader.prototype._loadAsync = function (rootUrl, fileName, nodes, resultFunc) {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      _this._rootUrl = rootUrl;\n      _this._uniqueRootUrl = !StringTools.StartsWith(rootUrl, \"file:\") && fileName ? rootUrl : \"\".concat(rootUrl).concat(Date.now(), \"/\");\n      _this._fileName = fileName;\n\n      _this._loadExtensions();\n\n      _this._checkExtensions();\n\n      var loadingToReadyCounterName = \"\".concat(GLTFLoaderState[GLTFLoaderState.LOADING], \" => \").concat(GLTFLoaderState[GLTFLoaderState.READY]);\n      var loadingToCompleteCounterName = \"\".concat(GLTFLoaderState[GLTFLoaderState.LOADING], \" => \").concat(GLTFLoaderState[GLTFLoaderState.COMPLETE]);\n\n      _this._parent._startPerformanceCounter(loadingToReadyCounterName);\n\n      _this._parent._startPerformanceCounter(loadingToCompleteCounterName);\n\n      _this._parent._setState(GLTFLoaderState.LOADING);\n\n      _this._extensionsOnLoading();\n\n      var promises = new Array(); // Block the marking of materials dirty until the scene is loaded.\n\n      var oldBlockMaterialDirtyMechanism = _this._babylonScene.blockMaterialDirtyMechanism;\n      _this._babylonScene.blockMaterialDirtyMechanism = true;\n\n      if (!_this.parent.loadOnlyMaterials) {\n        if (nodes) {\n          promises.push(_this.loadSceneAsync(\"/nodes\", {\n            nodes: nodes,\n            index: -1\n          }));\n        } else if (_this._gltf.scene != undefined || _this._gltf.scenes && _this._gltf.scenes[0]) {\n          var scene = ArrayItem.Get(\"/scene\", _this._gltf.scenes, _this._gltf.scene || 0);\n          promises.push(_this.loadSceneAsync(\"/scenes/\".concat(scene.index), scene));\n        }\n      }\n\n      if (!_this.parent.skipMaterials && _this.parent.loadAllMaterials && _this._gltf.materials) {\n        for (var m = 0; m < _this._gltf.materials.length; ++m) {\n          var material = _this._gltf.materials[m];\n          var context_1 = \"/materials/\" + m;\n          var babylonDrawMode = Material.TriangleFillMode;\n          promises.push(_this._loadMaterialAsync(context_1, material, null, babylonDrawMode, function () {}));\n        }\n      } // Restore the blocking of material dirty.\n\n\n      _this._babylonScene.blockMaterialDirtyMechanism = oldBlockMaterialDirtyMechanism;\n\n      if (_this._parent.compileMaterials) {\n        promises.push(_this._compileMaterialsAsync());\n      }\n\n      if (_this._parent.compileShadowGenerators) {\n        promises.push(_this._compileShadowGeneratorsAsync());\n      }\n\n      var resultPromise = Promise.all(promises).then(function () {\n        if (_this._rootBabylonMesh) {\n          _this._rootBabylonMesh.setEnabled(true);\n        }\n\n        _this._extensionsOnReady();\n\n        _this._parent._setState(GLTFLoaderState.READY);\n\n        _this._startAnimations();\n\n        return resultFunc();\n      });\n      return resultPromise.then(function (result) {\n        _this._parent._endPerformanceCounter(loadingToReadyCounterName);\n\n        Tools.SetImmediate(function () {\n          if (!_this._disposed) {\n            Promise.all(_this._completePromises).then(function () {\n              _this._parent._endPerformanceCounter(loadingToCompleteCounterName);\n\n              _this._parent._setState(GLTFLoaderState.COMPLETE);\n\n              _this._parent.onCompleteObservable.notifyObservers(undefined);\n\n              _this._parent.onCompleteObservable.clear();\n\n              _this.dispose();\n            }, function (error) {\n              _this._parent.onErrorObservable.notifyObservers(error);\n\n              _this._parent.onErrorObservable.clear();\n\n              _this.dispose();\n            });\n          }\n        });\n        return result;\n      });\n    })[\"catch\"](function (error) {\n      if (!_this._disposed) {\n        _this._parent.onErrorObservable.notifyObservers(error);\n\n        _this._parent.onErrorObservable.clear();\n\n        _this.dispose();\n      }\n\n      throw error;\n    });\n  };\n\n  GLTFLoader.prototype._loadData = function (data) {\n    this._gltf = data.json;\n\n    this._setupData();\n\n    if (data.bin) {\n      var buffers = this._gltf.buffers;\n\n      if (buffers && buffers[0] && !buffers[0].uri) {\n        var binaryBuffer = buffers[0];\n\n        if (binaryBuffer.byteLength < data.bin.byteLength - 3 || binaryBuffer.byteLength > data.bin.byteLength) {\n          Logger.Warn(\"Binary buffer length (\".concat(binaryBuffer.byteLength, \") from JSON does not match chunk length (\").concat(data.bin.byteLength, \")\"));\n        }\n\n        this._bin = data.bin;\n      } else {\n        Logger.Warn(\"Unexpected BIN chunk\");\n      }\n    }\n  };\n\n  GLTFLoader.prototype._setupData = function () {\n    ArrayItem.Assign(this._gltf.accessors);\n    ArrayItem.Assign(this._gltf.animations);\n    ArrayItem.Assign(this._gltf.buffers);\n    ArrayItem.Assign(this._gltf.bufferViews);\n    ArrayItem.Assign(this._gltf.cameras);\n    ArrayItem.Assign(this._gltf.images);\n    ArrayItem.Assign(this._gltf.materials);\n    ArrayItem.Assign(this._gltf.meshes);\n    ArrayItem.Assign(this._gltf.nodes);\n    ArrayItem.Assign(this._gltf.samplers);\n    ArrayItem.Assign(this._gltf.scenes);\n    ArrayItem.Assign(this._gltf.skins);\n    ArrayItem.Assign(this._gltf.textures);\n\n    if (this._gltf.nodes) {\n      var nodeParents = {};\n\n      for (var _i = 0, _a = this._gltf.nodes; _i < _a.length; _i++) {\n        var node = _a[_i];\n\n        if (node.children) {\n          for (var _b = 0, _c = node.children; _b < _c.length; _b++) {\n            var index = _c[_b];\n            nodeParents[index] = node.index;\n          }\n        }\n      }\n\n      var rootNode = this._createRootNode();\n\n      for (var _d = 0, _e = this._gltf.nodes; _d < _e.length; _d++) {\n        var node = _e[_d];\n        var parentIndex = nodeParents[node.index];\n        node.parent = parentIndex === undefined ? rootNode : this._gltf.nodes[parentIndex];\n      }\n    }\n  };\n\n  GLTFLoader.prototype._loadExtensions = function () {\n    for (var name_1 in GLTFLoader._RegisteredExtensions) {\n      var extension = GLTFLoader._RegisteredExtensions[name_1].factory(this);\n\n      if (extension.name !== name_1) {\n        Logger.Warn(\"The name of the glTF loader extension instance does not match the registered name: \".concat(extension.name, \" !== \").concat(name_1));\n      }\n\n      this._extensions.push(extension);\n\n      this._parent.onExtensionLoadedObservable.notifyObservers(extension);\n    }\n\n    this._extensions.sort(function (a, b) {\n      return (a.order || Number.MAX_VALUE) - (b.order || Number.MAX_VALUE);\n    });\n\n    this._parent.onExtensionLoadedObservable.clear();\n  };\n\n  GLTFLoader.prototype._checkExtensions = function () {\n    if (this._gltf.extensionsRequired) {\n      var _loop_1 = function _loop_1(name_2) {\n        var available = this_1._extensions.some(function (extension) {\n          return extension.name === name_2 && extension.enabled;\n        });\n\n        if (!available) {\n          throw new Error(\"Require extension \".concat(name_2, \" is not available\"));\n        }\n      };\n\n      var this_1 = this;\n\n      for (var _i = 0, _a = this._gltf.extensionsRequired; _i < _a.length; _i++) {\n        var name_2 = _a[_i];\n\n        _loop_1(name_2);\n      }\n    }\n  };\n\n  GLTFLoader.prototype._createRootNode = function () {\n    this._babylonScene._blockEntityCollection = !!this._assetContainer;\n    this._rootBabylonMesh = new Mesh(\"__root__\", this._babylonScene);\n    this._rootBabylonMesh._parentContainer = this._assetContainer;\n    this._babylonScene._blockEntityCollection = false;\n\n    this._rootBabylonMesh.setEnabled(false);\n\n    var rootNode = {\n      _babylonTransformNode: this._rootBabylonMesh,\n      index: -1\n    };\n\n    switch (this._parent.coordinateSystemMode) {\n      case GLTFLoaderCoordinateSystemMode.AUTO:\n        {\n          if (!this._babylonScene.useRightHandedSystem) {\n            rootNode.rotation = [0, 1, 0, 0];\n            rootNode.scale = [1, 1, -1];\n\n            GLTFLoader._LoadTransform(rootNode, this._rootBabylonMesh);\n          }\n\n          break;\n        }\n\n      case GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED:\n        {\n          this._babylonScene.useRightHandedSystem = true;\n          break;\n        }\n\n      default:\n        {\n          throw new Error(\"Invalid coordinate system mode (\".concat(this._parent.coordinateSystemMode, \")\"));\n        }\n    }\n\n    this._parent.onMeshLoadedObservable.notifyObservers(this._rootBabylonMesh);\n\n    return rootNode;\n  };\n  /**\n   * Loads a glTF scene.\n   * @param context The context when loading the asset\n   * @param scene The glTF scene property\n   * @returns A promise that resolves when the load is complete\n   */\n\n\n  GLTFLoader.prototype.loadSceneAsync = function (context, scene) {\n    var _this = this;\n\n    var extensionPromise = this._extensionsLoadSceneAsync(context, scene);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    var promises = new Array();\n    this.logOpen(\"\".concat(context, \" \").concat(scene.name || \"\"));\n\n    if (scene.nodes) {\n      for (var _i = 0, _a = scene.nodes; _i < _a.length; _i++) {\n        var index = _a[_i];\n        var node = ArrayItem.Get(\"\".concat(context, \"/nodes/\").concat(index), this._gltf.nodes, index);\n        promises.push(this.loadNodeAsync(\"/nodes/\".concat(node.index), node, function (babylonMesh) {\n          babylonMesh.parent = _this._rootBabylonMesh;\n        }));\n      }\n    }\n\n    for (var _b = 0, _c = this._postSceneLoadActions; _b < _c.length; _b++) {\n      var action = _c[_b];\n      action();\n    }\n\n    promises.push(this._loadAnimationsAsync());\n    this.logClose();\n    return Promise.all(promises).then(function () {});\n  };\n\n  GLTFLoader.prototype._forEachPrimitive = function (node, callback) {\n    if (node._primitiveBabylonMeshes) {\n      for (var _i = 0, _a = node._primitiveBabylonMeshes; _i < _a.length; _i++) {\n        var babylonMesh = _a[_i];\n        callback(babylonMesh);\n      }\n    }\n  };\n\n  GLTFLoader.prototype._getGeometries = function () {\n    var geometries = new Array();\n    var nodes = this._gltf.nodes;\n\n    if (nodes) {\n      for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n        var node = nodes_1[_i];\n\n        this._forEachPrimitive(node, function (babylonMesh) {\n          var geometry = babylonMesh.geometry;\n\n          if (geometry && geometries.indexOf(geometry) === -1) {\n            geometries.push(geometry);\n          }\n        });\n      }\n    }\n\n    return geometries;\n  };\n\n  GLTFLoader.prototype._getMeshes = function () {\n    var meshes = new Array(); // Root mesh is always first, if available.\n\n    if (this._rootBabylonMesh) {\n      meshes.push(this._rootBabylonMesh);\n    }\n\n    var nodes = this._gltf.nodes;\n\n    if (nodes) {\n      for (var _i = 0, nodes_2 = nodes; _i < nodes_2.length; _i++) {\n        var node = nodes_2[_i];\n\n        this._forEachPrimitive(node, function (babylonMesh) {\n          meshes.push(babylonMesh);\n        });\n      }\n    }\n\n    return meshes;\n  };\n\n  GLTFLoader.prototype._getTransformNodes = function () {\n    var transformNodes = new Array();\n    var nodes = this._gltf.nodes;\n\n    if (nodes) {\n      for (var _i = 0, nodes_3 = nodes; _i < nodes_3.length; _i++) {\n        var node = nodes_3[_i];\n\n        if (node._babylonTransformNode && node._babylonTransformNode.getClassName() === \"TransformNode\") {\n          transformNodes.push(node._babylonTransformNode);\n        }\n\n        if (node._babylonTransformNodeForSkin) {\n          transformNodes.push(node._babylonTransformNodeForSkin);\n        }\n      }\n    }\n\n    return transformNodes;\n  };\n\n  GLTFLoader.prototype._getSkeletons = function () {\n    var skeletons = new Array();\n    var skins = this._gltf.skins;\n\n    if (skins) {\n      for (var _i = 0, skins_1 = skins; _i < skins_1.length; _i++) {\n        var skin = skins_1[_i];\n\n        if (skin._data) {\n          skeletons.push(skin._data.babylonSkeleton);\n        }\n      }\n    }\n\n    return skeletons;\n  };\n\n  GLTFLoader.prototype._getAnimationGroups = function () {\n    var animationGroups = new Array();\n    var animations = this._gltf.animations;\n\n    if (animations) {\n      for (var _i = 0, animations_1 = animations; _i < animations_1.length; _i++) {\n        var animation = animations_1[_i];\n\n        if (animation._babylonAnimationGroup) {\n          animationGroups.push(animation._babylonAnimationGroup);\n        }\n      }\n    }\n\n    return animationGroups;\n  };\n\n  GLTFLoader.prototype._startAnimations = function () {\n    switch (this._parent.animationStartMode) {\n      case GLTFLoaderAnimationStartMode.NONE:\n        {\n          // do nothing\n          break;\n        }\n\n      case GLTFLoaderAnimationStartMode.FIRST:\n        {\n          var babylonAnimationGroups = this._getAnimationGroups();\n\n          if (babylonAnimationGroups.length !== 0) {\n            babylonAnimationGroups[0].start(true);\n          }\n\n          break;\n        }\n\n      case GLTFLoaderAnimationStartMode.ALL:\n        {\n          var babylonAnimationGroups = this._getAnimationGroups();\n\n          for (var _i = 0, babylonAnimationGroups_1 = babylonAnimationGroups; _i < babylonAnimationGroups_1.length; _i++) {\n            var babylonAnimationGroup = babylonAnimationGroups_1[_i];\n            babylonAnimationGroup.start(true);\n          }\n\n          break;\n        }\n\n      default:\n        {\n          Logger.Error(\"Invalid animation start mode (\".concat(this._parent.animationStartMode, \")\"));\n          return;\n        }\n    }\n  };\n  /**\n   * Loads a glTF node.\n   * @param context The context when loading the asset\n   * @param node The glTF node property\n   * @param assign A function called synchronously after parsing the glTF properties\n   * @returns A promise that resolves with the loaded Babylon mesh when the load is complete\n   */\n\n\n  GLTFLoader.prototype.loadNodeAsync = function (context, node, assign) {\n    var _this = this;\n\n    if (assign === void 0) {\n      assign = function assign() {};\n    }\n\n    var extensionPromise = this._extensionsLoadNodeAsync(context, node, assign);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    if (node._babylonTransformNode) {\n      throw new Error(\"\".concat(context, \": Invalid recursive node hierarchy\"));\n    }\n\n    var promises = new Array();\n    this.logOpen(\"\".concat(context, \" \").concat(node.name || \"\"));\n\n    var loadNode = function loadNode(babylonTransformNode) {\n      GLTFLoader.AddPointerMetadata(babylonTransformNode, context);\n\n      GLTFLoader._LoadTransform(node, babylonTransformNode);\n\n      if (node.camera != undefined) {\n        var camera = ArrayItem.Get(\"\".concat(context, \"/camera\"), _this._gltf.cameras, node.camera);\n        promises.push(_this.loadCameraAsync(\"/cameras/\".concat(camera.index), camera, function (babylonCamera) {\n          babylonCamera.parent = babylonTransformNode;\n        }));\n      }\n\n      if (node.children) {\n        for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n          var index = _a[_i];\n          var childNode = ArrayItem.Get(\"\".concat(context, \"/children/\").concat(index), _this._gltf.nodes, index);\n          promises.push(_this.loadNodeAsync(\"/nodes/\".concat(childNode.index), childNode, function (childBabylonMesh) {\n            childBabylonMesh.parent = babylonTransformNode;\n          }));\n        }\n      }\n\n      assign(babylonTransformNode);\n    };\n\n    if (node.mesh == undefined || node.skin != undefined) {\n      var nodeName = node.name || \"node\".concat(node.index);\n      this._babylonScene._blockEntityCollection = !!this._assetContainer;\n      var transformNode = new TransformNode(nodeName, this._babylonScene);\n      transformNode._parentContainer = this._assetContainer;\n      this._babylonScene._blockEntityCollection = false;\n\n      if (node.mesh == undefined) {\n        node._babylonTransformNode = transformNode;\n      } else {\n        node._babylonTransformNodeForSkin = transformNode;\n      }\n\n      loadNode(transformNode);\n    }\n\n    if (node.mesh != undefined) {\n      if (node.skin == undefined) {\n        var mesh = ArrayItem.Get(\"\".concat(context, \"/mesh\"), this._gltf.meshes, node.mesh);\n        promises.push(this._loadMeshAsync(\"/meshes/\".concat(mesh.index), node, mesh, loadNode));\n      } else {\n        // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\n        // This code path will place the skinned mesh as a sibling of the skeleton root node without loading the\n        // transform, which effectively ignores the transform of the skinned mesh, as per spec.\n        var mesh = ArrayItem.Get(\"\".concat(context, \"/mesh\"), this._gltf.meshes, node.mesh);\n        promises.push(this._loadMeshAsync(\"/meshes/\".concat(mesh.index), node, mesh, function (babylonTransformNode) {\n          // Duplicate the metadata from the skin node to the skinned mesh in case any loader extension added metadata.\n          babylonTransformNode.metadata = node._babylonTransformNodeForSkin.metadata;\n          var skin = ArrayItem.Get(\"\".concat(context, \"/skin\"), _this._gltf.skins, node.skin);\n          promises.push(_this._loadSkinAsync(\"/skins/\".concat(skin.index), node, skin, function (babylonSkeleton) {\n            _this._forEachPrimitive(node, function (babylonMesh) {\n              babylonMesh.skeleton = babylonSkeleton;\n            }); // Wait until the scene is loaded to ensure the skeleton root node has been loaded.\n\n\n            _this._postSceneLoadActions.push(function () {\n              if (skin.skeleton != undefined) {\n                // Place the skinned mesh node as a sibling of the skeleton root node.\n                var skeletonRootNode = ArrayItem.Get(\"/skins/\".concat(skin.index, \"/skeleton\"), _this._gltf.nodes, skin.skeleton);\n                babylonTransformNode.parent = skeletonRootNode.parent._babylonTransformNode;\n              } else {\n                babylonTransformNode.parent = _this._rootBabylonMesh;\n              }\n            });\n          }));\n        }));\n      }\n    }\n\n    this.logClose();\n    return Promise.all(promises).then(function () {\n      _this._forEachPrimitive(node, function (babylonMesh) {\n        if (babylonMesh.geometry && babylonMesh.geometry.useBoundingInfoFromGeometry) {\n          // simply apply the world matrices to the bounding info - the extends are already ok\n          babylonMesh._updateBoundingInfo();\n        } else {\n          babylonMesh.refreshBoundingInfo(true);\n        }\n      });\n\n      return node._babylonTransformNode;\n    });\n  };\n\n  GLTFLoader.prototype._loadMeshAsync = function (context, node, mesh, assign) {\n    var primitives = mesh.primitives;\n\n    if (!primitives || !primitives.length) {\n      throw new Error(\"\".concat(context, \": Primitives are missing\"));\n    }\n\n    if (primitives[0].index == undefined) {\n      ArrayItem.Assign(primitives);\n    }\n\n    var promises = new Array();\n    this.logOpen(\"\".concat(context, \" \").concat(mesh.name || \"\"));\n    var name = node.name || \"node\".concat(node.index);\n\n    if (primitives.length === 1) {\n      var primitive = mesh.primitives[0];\n      promises.push(this._loadMeshPrimitiveAsync(\"\".concat(context, \"/primitives/\").concat(primitive.index), name, node, mesh, primitive, function (babylonMesh) {\n        node._babylonTransformNode = babylonMesh;\n        node._primitiveBabylonMeshes = [babylonMesh];\n      }));\n    } else {\n      this._babylonScene._blockEntityCollection = !!this._assetContainer;\n      node._babylonTransformNode = new TransformNode(name, this._babylonScene);\n      node._babylonTransformNode._parentContainer = this._assetContainer;\n      this._babylonScene._blockEntityCollection = false;\n      node._primitiveBabylonMeshes = [];\n\n      for (var _i = 0, primitives_1 = primitives; _i < primitives_1.length; _i++) {\n        var primitive = primitives_1[_i];\n        promises.push(this._loadMeshPrimitiveAsync(\"\".concat(context, \"/primitives/\").concat(primitive.index), \"\".concat(name, \"_primitive\").concat(primitive.index), node, mesh, primitive, function (babylonMesh) {\n          babylonMesh.parent = node._babylonTransformNode;\n\n          node._primitiveBabylonMeshes.push(babylonMesh);\n        }));\n      }\n    }\n\n    assign(node._babylonTransformNode);\n    this.logClose();\n    return Promise.all(promises).then(function () {\n      return node._babylonTransformNode;\n    });\n  };\n  /**\n   * @hidden Define this method to modify the default behavior when loading data for mesh primitives.\n   * @param context The context when loading the asset\n   * @param name The mesh name when loading the asset\n   * @param node The glTF node when loading the asset\n   * @param mesh The glTF mesh when loading the asset\n   * @param primitive The glTF mesh primitive property\n   * @param assign A function called synchronously after parsing the glTF properties\n   * @returns A promise that resolves with the loaded mesh when the load is complete or null if not handled\n   */\n\n\n  GLTFLoader.prototype._loadMeshPrimitiveAsync = function (context, name, node, mesh, primitive, assign) {\n    var _this = this;\n\n    var extensionPromise = this._extensionsLoadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    this.logOpen(\"\".concat(context));\n    var shouldInstance = this._disableInstancedMesh === 0 && this._parent.createInstances && node.skin == undefined && !mesh.primitives[0].targets;\n    var babylonAbstractMesh;\n    var promise;\n\n    if (shouldInstance && primitive._instanceData) {\n      this._babylonScene._blockEntityCollection = !!this._assetContainer;\n      babylonAbstractMesh = primitive._instanceData.babylonSourceMesh.createInstance(name);\n      babylonAbstractMesh._parentContainer = this._assetContainer;\n      this._babylonScene._blockEntityCollection = false;\n      promise = primitive._instanceData.promise;\n    } else {\n      var promises = new Array();\n      this._babylonScene._blockEntityCollection = !!this._assetContainer;\n      var babylonMesh_1 = new Mesh(name, this._babylonScene);\n      babylonMesh_1._parentContainer = this._assetContainer;\n      this._babylonScene._blockEntityCollection = false;\n      babylonMesh_1.overrideMaterialSideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n\n      this._createMorphTargets(context, node, mesh, primitive, babylonMesh_1);\n\n      promises.push(this._loadVertexDataAsync(context, primitive, babylonMesh_1).then(function (babylonGeometry) {\n        return _this._loadMorphTargetsAsync(context, primitive, babylonMesh_1, babylonGeometry).then(function () {\n          _this._babylonScene._blockEntityCollection = !!_this._assetContainer;\n          babylonGeometry.applyToMesh(babylonMesh_1);\n          babylonGeometry._parentContainer = _this._assetContainer;\n          _this._babylonScene._blockEntityCollection = false;\n        });\n      }));\n\n      var babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\n\n      if (primitive.material == undefined) {\n        var babylonMaterial = this._defaultBabylonMaterialData[babylonDrawMode];\n\n        if (!babylonMaterial) {\n          babylonMaterial = this._createDefaultMaterial(\"__GLTFLoader._default\", babylonDrawMode);\n\n          this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\n\n          this._defaultBabylonMaterialData[babylonDrawMode] = babylonMaterial;\n        }\n\n        babylonMesh_1.material = babylonMaterial;\n      } else if (!this.parent.skipMaterials) {\n        var material = ArrayItem.Get(\"\".concat(context, \"/material\"), this._gltf.materials, primitive.material);\n        promises.push(this._loadMaterialAsync(\"/materials/\".concat(material.index), material, babylonMesh_1, babylonDrawMode, function (babylonMaterial) {\n          babylonMesh_1.material = babylonMaterial;\n        }));\n      }\n\n      promise = Promise.all(promises);\n\n      if (shouldInstance) {\n        primitive._instanceData = {\n          babylonSourceMesh: babylonMesh_1,\n          promise: promise\n        };\n      }\n\n      babylonAbstractMesh = babylonMesh_1;\n    }\n\n    GLTFLoader.AddPointerMetadata(babylonAbstractMesh, context);\n\n    this._parent.onMeshLoadedObservable.notifyObservers(babylonAbstractMesh);\n\n    assign(babylonAbstractMesh);\n    this.logClose();\n    return promise.then(function () {\n      return babylonAbstractMesh;\n    });\n  };\n\n  GLTFLoader.prototype._loadVertexDataAsync = function (context, primitive, babylonMesh) {\n    var _this = this;\n\n    var extensionPromise = this._extensionsLoadVertexDataAsync(context, primitive, babylonMesh);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    var attributes = primitive.attributes;\n\n    if (!attributes) {\n      throw new Error(\"\".concat(context, \": Attributes are missing\"));\n    }\n\n    var promises = new Array();\n    var babylonGeometry = new Geometry(babylonMesh.name, this._babylonScene);\n\n    if (primitive.indices == undefined) {\n      babylonMesh.isUnIndexed = true;\n    } else {\n      var accessor = ArrayItem.Get(\"\".concat(context, \"/indices\"), this._gltf.accessors, primitive.indices);\n      promises.push(this._loadIndicesAccessorAsync(\"/accessors/\".concat(accessor.index), accessor).then(function (data) {\n        babylonGeometry.setIndices(data);\n      }));\n    }\n\n    var loadAttribute = function loadAttribute(attribute, kind, callback) {\n      if (attributes[attribute] == undefined) {\n        return;\n      }\n\n      babylonMesh._delayInfo = babylonMesh._delayInfo || [];\n\n      if (babylonMesh._delayInfo.indexOf(kind) === -1) {\n        babylonMesh._delayInfo.push(kind);\n      }\n\n      var accessor = ArrayItem.Get(\"\".concat(context, \"/attributes/\").concat(attribute), _this._gltf.accessors, attributes[attribute]);\n      promises.push(_this._loadVertexAccessorAsync(\"/accessors/\".concat(accessor.index), accessor, kind).then(function (babylonVertexBuffer) {\n        if (babylonVertexBuffer.getKind() === VertexBuffer.PositionKind && !_this.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton) {\n          var mmin = accessor.min,\n              mmax = accessor.max;\n\n          if (mmin !== undefined && mmax !== undefined) {\n            if (accessor.normalized && accessor.componentType !== 5126\n            /* FLOAT */\n            ) {\n              var divider = 1;\n\n              switch (accessor.componentType) {\n                case 5120\n                /* BYTE */\n                :\n                  divider = 127.0;\n                  break;\n\n                case 5121\n                /* UNSIGNED_BYTE */\n                :\n                  divider = 255.0;\n                  break;\n\n                case 5122\n                /* SHORT */\n                :\n                  divider = 32767.0;\n                  break;\n\n                case 5123\n                /* UNSIGNED_SHORT */\n                :\n                  divider = 65535.0;\n                  break;\n              }\n\n              for (var i = 0; i < 3; ++i) {\n                mmin[i] = Math.max(mmin[i] / divider, -1.0);\n                mmax[i] = Math.max(mmax[i] / divider, -1.0);\n              }\n            }\n\n            var min = TmpVectors.Vector3[0],\n                max = TmpVectors.Vector3[1];\n            min.copyFromFloats.apply(min, mmin);\n            max.copyFromFloats.apply(max, mmax);\n            babylonGeometry._boundingInfo = new BoundingInfo(min, max);\n            babylonGeometry.useBoundingInfoFromGeometry = true;\n          }\n        }\n\n        babylonGeometry.setVerticesBuffer(babylonVertexBuffer, accessor.count);\n      }));\n\n      if (kind == VertexBuffer.MatricesIndicesExtraKind) {\n        babylonMesh.numBoneInfluencers = 8;\n      }\n\n      if (callback) {\n        callback(accessor);\n      }\n    };\n\n    loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\n    loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\n    loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\n    loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\n    loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\n    loadAttribute(\"TEXCOORD_2\", VertexBuffer.UV3Kind);\n    loadAttribute(\"TEXCOORD_3\", VertexBuffer.UV4Kind);\n    loadAttribute(\"TEXCOORD_4\", VertexBuffer.UV5Kind);\n    loadAttribute(\"TEXCOORD_5\", VertexBuffer.UV6Kind);\n    loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\n    loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\n    loadAttribute(\"JOINTS_1\", VertexBuffer.MatricesIndicesExtraKind);\n    loadAttribute(\"WEIGHTS_1\", VertexBuffer.MatricesWeightsExtraKind);\n    loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind, function (accessor) {\n      if (accessor.type === \"VEC4\"\n      /* VEC4 */\n      ) {\n        babylonMesh.hasVertexAlpha = true;\n      }\n    });\n    return Promise.all(promises).then(function () {\n      return babylonGeometry;\n    });\n  };\n\n  GLTFLoader.prototype._createMorphTargets = function (context, node, mesh, primitive, babylonMesh) {\n    if (!primitive.targets) {\n      return;\n    }\n\n    if (node._numMorphTargets == undefined) {\n      node._numMorphTargets = primitive.targets.length;\n    } else if (primitive.targets.length !== node._numMorphTargets) {\n      throw new Error(\"\".concat(context, \": Primitives do not have the same number of targets\"));\n    }\n\n    var targetNames = mesh.extras ? mesh.extras.targetNames : null;\n    babylonMesh.morphTargetManager = new MorphTargetManager(babylonMesh.getScene());\n    babylonMesh.morphTargetManager.areUpdatesFrozen = true;\n\n    for (var index = 0; index < primitive.targets.length; index++) {\n      var weight = node.weights ? node.weights[index] : mesh.weights ? mesh.weights[index] : 0;\n      var name_3 = targetNames ? targetNames[index] : \"morphTarget\".concat(index);\n      babylonMesh.morphTargetManager.addTarget(new MorphTarget(name_3, weight, babylonMesh.getScene())); // TODO: tell the target whether it has positions, normals, tangents\n    }\n  };\n\n  GLTFLoader.prototype._loadMorphTargetsAsync = function (context, primitive, babylonMesh, babylonGeometry) {\n    if (!primitive.targets) {\n      return Promise.resolve();\n    }\n\n    var promises = new Array();\n    var morphTargetManager = babylonMesh.morphTargetManager;\n\n    for (var index = 0; index < morphTargetManager.numTargets; index++) {\n      var babylonMorphTarget = morphTargetManager.getTarget(index);\n      promises.push(this._loadMorphTargetVertexDataAsync(\"\".concat(context, \"/targets/\").concat(index), babylonGeometry, primitive.targets[index], babylonMorphTarget));\n    }\n\n    return Promise.all(promises).then(function () {\n      morphTargetManager.areUpdatesFrozen = false;\n    });\n  };\n\n  GLTFLoader.prototype._loadMorphTargetVertexDataAsync = function (context, babylonGeometry, attributes, babylonMorphTarget) {\n    var _this = this;\n\n    var promises = new Array();\n\n    var loadAttribute = function loadAttribute(attribute, kind, setData) {\n      if (attributes[attribute] == undefined) {\n        return;\n      }\n\n      var babylonVertexBuffer = babylonGeometry.getVertexBuffer(kind);\n\n      if (!babylonVertexBuffer) {\n        return;\n      }\n\n      var accessor = ArrayItem.Get(\"\".concat(context, \"/\").concat(attribute), _this._gltf.accessors, attributes[attribute]);\n      promises.push(_this._loadFloatAccessorAsync(\"/accessors/\".concat(accessor.index), accessor).then(function (data) {\n        setData(babylonVertexBuffer, data);\n      }));\n    };\n\n    loadAttribute(\"POSITION\", VertexBuffer.PositionKind, function (babylonVertexBuffer, data) {\n      var positions = new Float32Array(data.length);\n      babylonVertexBuffer.forEach(data.length, function (value, index) {\n        positions[index] = data[index] + value;\n      });\n      babylonMorphTarget.setPositions(positions);\n    });\n    loadAttribute(\"NORMAL\", VertexBuffer.NormalKind, function (babylonVertexBuffer, data) {\n      var normals = new Float32Array(data.length);\n      babylonVertexBuffer.forEach(normals.length, function (value, index) {\n        normals[index] = data[index] + value;\n      });\n      babylonMorphTarget.setNormals(normals);\n    });\n    loadAttribute(\"TANGENT\", VertexBuffer.TangentKind, function (babylonVertexBuffer, data) {\n      var tangents = new Float32Array(data.length / 3 * 4);\n      var dataIndex = 0;\n      babylonVertexBuffer.forEach(data.length / 3 * 4, function (value, index) {\n        // Tangent data for morph targets is stored as xyz delta.\n        // The vertexData.tangent is stored as xyzw.\n        // So we need to skip every fourth vertexData.tangent.\n        if ((index + 1) % 4 !== 0) {\n          tangents[dataIndex] = data[dataIndex] + value;\n          dataIndex++;\n        }\n      });\n      babylonMorphTarget.setTangents(tangents);\n    });\n    return Promise.all(promises).then(function () {});\n  };\n\n  GLTFLoader._LoadTransform = function (node, babylonNode) {\n    // Ignore the TRS of skinned nodes.\n    // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\n    if (node.skin != undefined) {\n      return;\n    }\n\n    var position = Vector3.Zero();\n    var rotation = Quaternion.Identity();\n    var scaling = Vector3.One();\n\n    if (node.matrix) {\n      var matrix = Matrix.FromArray(node.matrix);\n      matrix.decompose(scaling, rotation, position);\n    } else {\n      if (node.translation) {\n        position = Vector3.FromArray(node.translation);\n      }\n\n      if (node.rotation) {\n        rotation = Quaternion.FromArray(node.rotation);\n      }\n\n      if (node.scale) {\n        scaling = Vector3.FromArray(node.scale);\n      }\n    }\n\n    babylonNode.position = position;\n    babylonNode.rotationQuaternion = rotation;\n    babylonNode.scaling = scaling;\n  };\n\n  GLTFLoader.prototype._loadSkinAsync = function (context, node, skin, assign) {\n    var _this = this;\n\n    var extensionPromise = this._extensionsLoadSkinAsync(context, node, skin);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    if (skin._data) {\n      assign(skin._data.babylonSkeleton);\n      return skin._data.promise;\n    }\n\n    var skeletonId = \"skeleton\".concat(skin.index);\n    this._babylonScene._blockEntityCollection = !!this._assetContainer;\n    var babylonSkeleton = new Skeleton(skin.name || skeletonId, skeletonId, this._babylonScene);\n    babylonSkeleton._parentContainer = this._assetContainer;\n    this._babylonScene._blockEntityCollection = false;\n\n    this._loadBones(context, skin, babylonSkeleton);\n\n    var promise = this._loadSkinInverseBindMatricesDataAsync(context, skin).then(function (inverseBindMatricesData) {\n      _this._updateBoneMatrices(babylonSkeleton, inverseBindMatricesData);\n    });\n\n    skin._data = {\n      babylonSkeleton: babylonSkeleton,\n      promise: promise\n    };\n    assign(babylonSkeleton);\n    return promise;\n  };\n\n  GLTFLoader.prototype._loadBones = function (context, skin, babylonSkeleton) {\n    if (skin.skeleton == undefined || this._parent.alwaysComputeSkeletonRootNode) {\n      var rootNode = this._findSkeletonRootNode(\"\".concat(context, \"/joints\"), skin.joints);\n\n      if (rootNode) {\n        if (skin.skeleton === undefined) {\n          skin.skeleton = rootNode.index;\n        } else {\n          var isParent = function isParent(a, b) {\n            for (; b.parent; b = b.parent) {\n              if (b.parent === a) {\n                return true;\n              }\n            }\n\n            return false;\n          };\n\n          var skeletonNode = ArrayItem.Get(\"\".concat(context, \"/skeleton\"), this._gltf.nodes, skin.skeleton);\n\n          if (skeletonNode !== rootNode && !isParent(skeletonNode, rootNode)) {\n            Logger.Warn(\"\".concat(context, \"/skeleton: Overriding with nearest common ancestor as skeleton node is not a common root\"));\n            skin.skeleton = rootNode.index;\n          }\n        }\n      } else {\n        Logger.Warn(\"\".concat(context, \": Failed to find common root\"));\n      }\n    }\n\n    var babylonBones = {};\n\n    for (var _i = 0, _a = skin.joints; _i < _a.length; _i++) {\n      var index = _a[_i];\n      var node = ArrayItem.Get(\"\".concat(context, \"/joints/\").concat(index), this._gltf.nodes, index);\n\n      this._loadBone(node, skin, babylonSkeleton, babylonBones);\n    }\n  };\n\n  GLTFLoader.prototype._findSkeletonRootNode = function (context, joints) {\n    if (joints.length === 0) {\n      return null;\n    }\n\n    var paths = {};\n\n    for (var _i = 0, joints_1 = joints; _i < joints_1.length; _i++) {\n      var index = joints_1[_i];\n      var path = new Array();\n      var node = ArrayItem.Get(\"\".concat(context, \"/\").concat(index), this._gltf.nodes, index);\n\n      while (node.index !== -1) {\n        path.unshift(node);\n        node = node.parent;\n      }\n\n      paths[index] = path;\n    }\n\n    var rootNode = null;\n\n    for (var i = 0;; ++i) {\n      var path = paths[joints[0]];\n\n      if (i >= path.length) {\n        return rootNode;\n      }\n\n      var node = path[i];\n\n      for (var j = 1; j < joints.length; ++j) {\n        path = paths[joints[j]];\n\n        if (i >= path.length || node !== path[i]) {\n          return rootNode;\n        }\n      }\n\n      rootNode = node;\n    }\n  };\n\n  GLTFLoader.prototype._loadBone = function (node, skin, babylonSkeleton, babylonBones) {\n    var babylonBone = babylonBones[node.index];\n\n    if (babylonBone) {\n      return babylonBone;\n    }\n\n    var parentBabylonBone = null;\n\n    if (node.index !== skin.skeleton) {\n      if (node.parent && node.parent.index !== -1) {\n        parentBabylonBone = this._loadBone(node.parent, skin, babylonSkeleton, babylonBones);\n      } else if (skin.skeleton !== undefined) {\n        Logger.Warn(\"/skins/\".concat(skin.index, \"/skeleton: Skeleton node is not a common root\"));\n      }\n    }\n\n    var boneIndex = skin.joints.indexOf(node.index);\n    babylonBone = new Bone(node.name || \"joint\".concat(node.index), babylonSkeleton, parentBabylonBone, this._getNodeMatrix(node), null, null, boneIndex);\n    babylonBones[node.index] = babylonBone; // Wait until the scene is loaded to ensure the transform nodes are loaded.\n\n    this._postSceneLoadActions.push(function () {\n      // Link the Babylon bone with the corresponding Babylon transform node.\n      // A glTF joint is a pointer to a glTF node in the glTF node hierarchy similar to Unity3D.\n      babylonBone.linkTransformNode(node._babylonTransformNode);\n    });\n\n    return babylonBone;\n  };\n\n  GLTFLoader.prototype._loadSkinInverseBindMatricesDataAsync = function (context, skin) {\n    if (skin.inverseBindMatrices == undefined) {\n      return Promise.resolve(null);\n    }\n\n    var accessor = ArrayItem.Get(\"\".concat(context, \"/inverseBindMatrices\"), this._gltf.accessors, skin.inverseBindMatrices);\n    return this._loadFloatAccessorAsync(\"/accessors/\".concat(accessor.index), accessor);\n  };\n\n  GLTFLoader.prototype._updateBoneMatrices = function (babylonSkeleton, inverseBindMatricesData) {\n    for (var _i = 0, _a = babylonSkeleton.bones; _i < _a.length; _i++) {\n      var babylonBone = _a[_i];\n      var baseMatrix = Matrix.Identity();\n      var boneIndex = babylonBone._index;\n\n      if (inverseBindMatricesData && boneIndex !== -1) {\n        Matrix.FromArrayToRef(inverseBindMatricesData, boneIndex * 16, baseMatrix);\n        baseMatrix.invertToRef(baseMatrix);\n      }\n\n      var babylonParentBone = babylonBone.getParent();\n\n      if (babylonParentBone) {\n        baseMatrix.multiplyToRef(babylonParentBone.getInvertedAbsoluteTransform(), baseMatrix);\n      }\n\n      babylonBone.updateMatrix(baseMatrix, false, false);\n\n      babylonBone._updateDifferenceMatrix(undefined, false);\n    }\n  };\n\n  GLTFLoader.prototype._getNodeMatrix = function (node) {\n    return node.matrix ? Matrix.FromArray(node.matrix) : Matrix.Compose(node.scale ? Vector3.FromArray(node.scale) : Vector3.One(), node.rotation ? Quaternion.FromArray(node.rotation) : Quaternion.Identity(), node.translation ? Vector3.FromArray(node.translation) : Vector3.Zero());\n  };\n  /**\n   * Loads a glTF camera.\n   * @param context The context when loading the asset\n   * @param camera The glTF camera property\n   * @param assign A function called synchronously after parsing the glTF properties\n   * @returns A promise that resolves with the loaded Babylon camera when the load is complete\n   */\n\n\n  GLTFLoader.prototype.loadCameraAsync = function (context, camera, assign) {\n    if (assign === void 0) {\n      assign = function assign() {};\n    }\n\n    var extensionPromise = this._extensionsLoadCameraAsync(context, camera, assign);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    var promises = new Array();\n    this.logOpen(\"\".concat(context, \" \").concat(camera.name || \"\"));\n    this._babylonScene._blockEntityCollection = !!this._assetContainer;\n    var babylonCamera = new FreeCamera(camera.name || \"camera\".concat(camera.index), Vector3.Zero(), this._babylonScene, false);\n    babylonCamera._parentContainer = this._assetContainer;\n    this._babylonScene._blockEntityCollection = false;\n    babylonCamera.ignoreParentScaling = true;\n    babylonCamera.rotation = new Vector3(0, Math.PI, 0);\n\n    switch (camera.type) {\n      case \"perspective\"\n      /* PERSPECTIVE */\n      :\n        {\n          var perspective = camera.perspective;\n\n          if (!perspective) {\n            throw new Error(\"\".concat(context, \": Camera perspective properties are missing\"));\n          }\n\n          babylonCamera.fov = perspective.yfov;\n          babylonCamera.minZ = perspective.znear;\n          babylonCamera.maxZ = perspective.zfar || 0;\n          break;\n        }\n\n      case \"orthographic\"\n      /* ORTHOGRAPHIC */\n      :\n        {\n          if (!camera.orthographic) {\n            throw new Error(\"\".concat(context, \": Camera orthographic properties are missing\"));\n          }\n\n          babylonCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\n          babylonCamera.orthoLeft = -camera.orthographic.xmag;\n          babylonCamera.orthoRight = camera.orthographic.xmag;\n          babylonCamera.orthoBottom = -camera.orthographic.ymag;\n          babylonCamera.orthoTop = camera.orthographic.ymag;\n          babylonCamera.minZ = camera.orthographic.znear;\n          babylonCamera.maxZ = camera.orthographic.zfar;\n          break;\n        }\n\n      default:\n        {\n          throw new Error(\"\".concat(context, \": Invalid camera type (\").concat(camera.type, \")\"));\n        }\n    }\n\n    GLTFLoader.AddPointerMetadata(babylonCamera, context);\n\n    this._parent.onCameraLoadedObservable.notifyObservers(babylonCamera);\n\n    assign(babylonCamera);\n    this.logClose();\n    return Promise.all(promises).then(function () {\n      return babylonCamera;\n    });\n  };\n\n  GLTFLoader.prototype._loadAnimationsAsync = function () {\n    var animations = this._gltf.animations;\n\n    if (!animations) {\n      return Promise.resolve();\n    }\n\n    var promises = new Array();\n\n    for (var index = 0; index < animations.length; index++) {\n      var animation = animations[index];\n      promises.push(this.loadAnimationAsync(\"/animations/\".concat(animation.index), animation).then(function (animationGroup) {\n        // Delete the animation group if it ended up not having any animations in it.\n        if (animationGroup.targetedAnimations.length === 0) {\n          animationGroup.dispose();\n        }\n      }));\n    }\n\n    return Promise.all(promises).then(function () {});\n  };\n  /**\n   * Loads a glTF animation.\n   * @param context The context when loading the asset\n   * @param animation The glTF animation property\n   * @returns A promise that resolves with the loaded Babylon animation group when the load is complete\n   */\n\n\n  GLTFLoader.prototype.loadAnimationAsync = function (context, animation) {\n    var promise = this._extensionsLoadAnimationAsync(context, animation);\n\n    if (promise) {\n      return promise;\n    }\n\n    this._babylonScene._blockEntityCollection = !!this._assetContainer;\n    var babylonAnimationGroup = new AnimationGroup(animation.name || \"animation\".concat(animation.index), this._babylonScene);\n    babylonAnimationGroup._parentContainer = this._assetContainer;\n    this._babylonScene._blockEntityCollection = false;\n    animation._babylonAnimationGroup = babylonAnimationGroup;\n    var promises = new Array();\n    ArrayItem.Assign(animation.channels);\n    ArrayItem.Assign(animation.samplers);\n\n    for (var _i = 0, _a = animation.channels; _i < _a.length; _i++) {\n      var channel = _a[_i];\n      promises.push(this._loadAnimationChannelAsync(\"\".concat(context, \"/channels/\").concat(channel.index), context, animation, channel, babylonAnimationGroup));\n    }\n\n    return Promise.all(promises).then(function () {\n      babylonAnimationGroup.normalize(0);\n      return babylonAnimationGroup;\n    });\n  };\n  /**\n   * @hidden Loads a glTF animation channel.\n   * @param context The context when loading the asset\n   * @param animationContext The context of the animation when loading the asset\n   * @param animation The glTF animation property\n   * @param channel The glTF animation channel property\n   * @param babylonAnimationGroup The babylon animation group property\n   * @param animationTargetOverride The babylon animation channel target override property. My be null.\n   * @returns A void promise when the channel load is complete\n   */\n\n\n  GLTFLoader.prototype._loadAnimationChannelAsync = function (context, animationContext, animation, channel, babylonAnimationGroup, animationTargetOverride) {\n    var _this = this;\n\n    if (animationTargetOverride === void 0) {\n      animationTargetOverride = null;\n    }\n\n    if (channel.target.node == undefined) {\n      return Promise.resolve();\n    }\n\n    var targetNode = ArrayItem.Get(\"\".concat(context, \"/target/node\"), this._gltf.nodes, channel.target.node); // Ignore animations that have no animation targets.\n\n    if (channel.target.path === \"weights\"\n    /* WEIGHTS */\n    && !targetNode._numMorphTargets || channel.target.path !== \"weights\"\n    /* WEIGHTS */\n    && !targetNode._babylonTransformNode) {\n      return Promise.resolve();\n    }\n\n    var sampler = ArrayItem.Get(\"\".concat(context, \"/sampler\"), animation.samplers, channel.sampler);\n    return this._loadAnimationSamplerAsync(\"\".concat(animationContext, \"/samplers/\").concat(channel.sampler), sampler).then(function (data) {\n      var targetPath;\n      var animationType;\n\n      switch (channel.target.path) {\n        case \"translation\"\n        /* TRANSLATION */\n        :\n          {\n            targetPath = \"position\";\n            animationType = Animation.ANIMATIONTYPE_VECTOR3;\n            break;\n          }\n\n        case \"rotation\"\n        /* ROTATION */\n        :\n          {\n            targetPath = \"rotationQuaternion\";\n            animationType = Animation.ANIMATIONTYPE_QUATERNION;\n            break;\n          }\n\n        case \"scale\"\n        /* SCALE */\n        :\n          {\n            targetPath = \"scaling\";\n            animationType = Animation.ANIMATIONTYPE_VECTOR3;\n            break;\n          }\n\n        case \"weights\"\n        /* WEIGHTS */\n        :\n          {\n            targetPath = \"influence\";\n            animationType = Animation.ANIMATIONTYPE_FLOAT;\n            break;\n          }\n\n        default:\n          {\n            throw new Error(\"\".concat(context, \"/target/path: Invalid value (\").concat(channel.target.path, \")\"));\n          }\n      }\n\n      var outputBufferOffset = 0;\n      var getNextOutputValue;\n\n      switch (targetPath) {\n        case \"position\":\n          {\n            getNextOutputValue = function getNextOutputValue(scale) {\n              var value = Vector3.FromArray(data.output, outputBufferOffset).scaleInPlace(scale);\n              outputBufferOffset += 3;\n              return value;\n            };\n\n            break;\n          }\n\n        case \"rotationQuaternion\":\n          {\n            getNextOutputValue = function getNextOutputValue(scale) {\n              var value = Quaternion.FromArray(data.output, outputBufferOffset).scaleInPlace(scale);\n              outputBufferOffset += 4;\n              return value;\n            };\n\n            break;\n          }\n\n        case \"scaling\":\n          {\n            getNextOutputValue = function getNextOutputValue(scale) {\n              var value = Vector3.FromArray(data.output, outputBufferOffset).scaleInPlace(scale);\n              outputBufferOffset += 3;\n              return value;\n            };\n\n            break;\n          }\n\n        case \"influence\":\n          {\n            getNextOutputValue = function getNextOutputValue(scale) {\n              var value = new Array(targetNode._numMorphTargets);\n\n              for (var i = 0; i < targetNode._numMorphTargets; i++) {\n                value[i] = data.output[outputBufferOffset++] * scale;\n              }\n\n              return value;\n            };\n\n            break;\n          }\n      }\n\n      var getNextKey;\n\n      switch (data.interpolation) {\n        case \"STEP\"\n        /* STEP */\n        :\n          {\n            getNextKey = function getNextKey(frameIndex) {\n              return {\n                frame: data.input[frameIndex] * _this.parent.targetFps,\n                value: getNextOutputValue(1),\n                interpolation: AnimationKeyInterpolation.STEP\n              };\n            };\n\n            break;\n          }\n\n        case \"LINEAR\"\n        /* LINEAR */\n        :\n          {\n            getNextKey = function getNextKey(frameIndex) {\n              return {\n                frame: data.input[frameIndex] * _this.parent.targetFps,\n                value: getNextOutputValue(1)\n              };\n            };\n\n            break;\n          }\n\n        case \"CUBICSPLINE\"\n        /* CUBICSPLINE */\n        :\n          {\n            var invTargetFps_1 = 1 / _this.parent.targetFps;\n\n            getNextKey = function getNextKey(frameIndex) {\n              return {\n                frame: data.input[frameIndex] * _this.parent.targetFps,\n                inTangent: getNextOutputValue(invTargetFps_1),\n                value: getNextOutputValue(1),\n                outTangent: getNextOutputValue(invTargetFps_1)\n              };\n            };\n\n            break;\n          }\n      }\n\n      var keys = new Array(data.input.length);\n\n      for (var frameIndex = 0; frameIndex < data.input.length; frameIndex++) {\n        keys[frameIndex] = getNextKey(frameIndex);\n      }\n\n      if (targetPath === \"influence\") {\n        var _loop_2 = function _loop_2(targetIndex) {\n          var animationName = \"\".concat(babylonAnimationGroup.name, \"_channel\").concat(babylonAnimationGroup.targetedAnimations.length);\n          var babylonAnimation = new Animation(animationName, targetPath, _this.parent.targetFps, animationType);\n          babylonAnimation.setKeys(keys.map(function (key) {\n            return {\n              frame: key.frame,\n              inTangent: key.inTangent ? key.inTangent[targetIndex] : undefined,\n              value: key.value[targetIndex],\n              outTangent: key.outTangent ? key.outTangent[targetIndex] : undefined\n            };\n          }));\n\n          _this._forEachPrimitive(targetNode, function (babylonAbstractMesh) {\n            var babylonMesh = babylonAbstractMesh;\n            var morphTarget = babylonMesh.morphTargetManager.getTarget(targetIndex);\n            var babylonAnimationClone = babylonAnimation.clone();\n            morphTarget.animations.push(babylonAnimationClone);\n            babylonAnimationGroup.addTargetedAnimation(babylonAnimationClone, morphTarget);\n          });\n        };\n\n        for (var targetIndex = 0; targetIndex < targetNode._numMorphTargets; targetIndex++) {\n          _loop_2(targetIndex);\n        }\n      } else {\n        var animationName = \"\".concat(babylonAnimationGroup.name, \"_channel\").concat(babylonAnimationGroup.targetedAnimations.length);\n        var babylonAnimation = new Animation(animationName, targetPath, _this.parent.targetFps, animationType);\n        babylonAnimation.setKeys(keys);\n\n        if (animationTargetOverride != null && animationTargetOverride.animations != null) {\n          animationTargetOverride.animations.push(babylonAnimation);\n          babylonAnimationGroup.addTargetedAnimation(babylonAnimation, animationTargetOverride);\n        } else {\n          targetNode._babylonTransformNode.animations.push(babylonAnimation);\n\n          babylonAnimationGroup.addTargetedAnimation(babylonAnimation, targetNode._babylonTransformNode);\n        }\n      }\n    });\n  };\n\n  GLTFLoader.prototype._loadAnimationSamplerAsync = function (context, sampler) {\n    if (sampler._data) {\n      return sampler._data;\n    }\n\n    var interpolation = sampler.interpolation || \"LINEAR\"\n    /* LINEAR */\n    ;\n\n    switch (interpolation) {\n      case \"STEP\"\n      /* STEP */\n      :\n      case \"LINEAR\"\n      /* LINEAR */\n      :\n      case \"CUBICSPLINE\"\n      /* CUBICSPLINE */\n      :\n        {\n          break;\n        }\n\n      default:\n        {\n          throw new Error(\"\".concat(context, \"/interpolation: Invalid value (\").concat(sampler.interpolation, \")\"));\n        }\n    }\n\n    var inputAccessor = ArrayItem.Get(\"\".concat(context, \"/input\"), this._gltf.accessors, sampler.input);\n    var outputAccessor = ArrayItem.Get(\"\".concat(context, \"/output\"), this._gltf.accessors, sampler.output);\n    sampler._data = Promise.all([this._loadFloatAccessorAsync(\"/accessors/\".concat(inputAccessor.index), inputAccessor), this._loadFloatAccessorAsync(\"/accessors/\".concat(outputAccessor.index), outputAccessor)]).then(function (_a) {\n      var inputData = _a[0],\n          outputData = _a[1];\n      return {\n        input: inputData,\n        interpolation: interpolation,\n        output: outputData\n      };\n    });\n    return sampler._data;\n  };\n  /**\n   * Loads a glTF buffer.\n   * @param context The context when loading the asset\n   * @param buffer The glTF buffer property\n   * @param byteOffset The byte offset to use\n   * @param byteLength The byte length to use\n   * @returns A promise that resolves with the loaded data when the load is complete\n   */\n\n\n  GLTFLoader.prototype.loadBufferAsync = function (context, buffer, byteOffset, byteLength) {\n    var extensionPromise = this._extensionsLoadBufferAsync(context, buffer, byteOffset, byteLength);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    if (!buffer._data) {\n      if (buffer.uri) {\n        buffer._data = this.loadUriAsync(\"\".concat(context, \"/uri\"), buffer, buffer.uri);\n      } else {\n        if (!this._bin) {\n          throw new Error(\"\".concat(context, \": Uri is missing or the binary glTF is missing its binary chunk\"));\n        }\n\n        buffer._data = this._bin.readAsync(0, buffer.byteLength);\n      }\n    }\n\n    return buffer._data.then(function (data) {\n      try {\n        return new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);\n      } catch (e) {\n        throw new Error(\"\".concat(context, \": \").concat(e.message));\n      }\n    });\n  };\n  /**\n   * Loads a glTF buffer view.\n   * @param context The context when loading the asset\n   * @param bufferView The glTF buffer view property\n   * @returns A promise that resolves with the loaded data when the load is complete\n   */\n\n\n  GLTFLoader.prototype.loadBufferViewAsync = function (context, bufferView) {\n    var extensionPromise = this._extensionsLoadBufferViewAsync(context, bufferView);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    if (bufferView._data) {\n      return bufferView._data;\n    }\n\n    var buffer = ArrayItem.Get(\"\".concat(context, \"/buffer\"), this._gltf.buffers, bufferView.buffer);\n    bufferView._data = this.loadBufferAsync(\"/buffers/\".concat(buffer.index), buffer, bufferView.byteOffset || 0, bufferView.byteLength);\n    return bufferView._data;\n  };\n\n  GLTFLoader.prototype._loadAccessorAsync = function (context, accessor, constructor) {\n    var _this = this;\n\n    if (accessor._data) {\n      return accessor._data;\n    }\n\n    var numComponents = GLTFLoader._GetNumComponents(context, accessor.type);\n\n    var byteStride = numComponents * VertexBuffer.GetTypeByteLength(accessor.componentType);\n    var length = numComponents * accessor.count;\n\n    if (accessor.bufferView == undefined) {\n      accessor._data = Promise.resolve(new constructor(length));\n    } else {\n      var bufferView_1 = ArrayItem.Get(\"\".concat(context, \"/bufferView\"), this._gltf.bufferViews, accessor.bufferView);\n      accessor._data = this.loadBufferViewAsync(\"/bufferViews/\".concat(bufferView_1.index), bufferView_1).then(function (data) {\n        if (accessor.componentType === 5126\n        /* FLOAT */\n        && !accessor.normalized && (!bufferView_1.byteStride || bufferView_1.byteStride === byteStride)) {\n          return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, length);\n        } else {\n          var typedArray_1 = new constructor(length);\n          VertexBuffer.ForEach(data, accessor.byteOffset || 0, bufferView_1.byteStride || byteStride, numComponents, accessor.componentType, typedArray_1.length, accessor.normalized || false, function (value, index) {\n            typedArray_1[index] = value;\n          });\n          return typedArray_1;\n        }\n      });\n    }\n\n    if (accessor.sparse) {\n      var sparse_1 = accessor.sparse;\n      accessor._data = accessor._data.then(function (data) {\n        var typedArray = data;\n        var indicesBufferView = ArrayItem.Get(\"\".concat(context, \"/sparse/indices/bufferView\"), _this._gltf.bufferViews, sparse_1.indices.bufferView);\n        var valuesBufferView = ArrayItem.Get(\"\".concat(context, \"/sparse/values/bufferView\"), _this._gltf.bufferViews, sparse_1.values.bufferView);\n        return Promise.all([_this.loadBufferViewAsync(\"/bufferViews/\".concat(indicesBufferView.index), indicesBufferView), _this.loadBufferViewAsync(\"/bufferViews/\".concat(valuesBufferView.index), valuesBufferView)]).then(function (_a) {\n          var indicesData = _a[0],\n              valuesData = _a[1];\n\n          var indices = GLTFLoader._GetTypedArray(\"\".concat(context, \"/sparse/indices\"), sparse_1.indices.componentType, indicesData, sparse_1.indices.byteOffset, sparse_1.count);\n\n          var sparseLength = numComponents * sparse_1.count;\n          var values;\n\n          if (accessor.componentType === 5126\n          /* FLOAT */\n          && !accessor.normalized) {\n            values = GLTFLoader._GetTypedArray(\"\".concat(context, \"/sparse/values\"), accessor.componentType, valuesData, sparse_1.values.byteOffset, sparseLength);\n          } else {\n            var sparseData = GLTFLoader._GetTypedArray(\"\".concat(context, \"/sparse/values\"), accessor.componentType, valuesData, sparse_1.values.byteOffset, sparseLength);\n\n            values = new constructor(sparseLength);\n            VertexBuffer.ForEach(sparseData, 0, byteStride, numComponents, accessor.componentType, values.length, accessor.normalized || false, function (value, index) {\n              values[index] = value;\n            });\n          }\n\n          var valuesIndex = 0;\n\n          for (var indicesIndex = 0; indicesIndex < indices.length; indicesIndex++) {\n            var dataIndex = indices[indicesIndex] * numComponents;\n\n            for (var componentIndex = 0; componentIndex < numComponents; componentIndex++) {\n              typedArray[dataIndex++] = values[valuesIndex++];\n            }\n          }\n\n          return typedArray;\n        });\n      });\n    }\n\n    return accessor._data;\n  };\n  /**\n   * @param context\n   * @param accessor\n   * @hidden\n   */\n\n\n  GLTFLoader.prototype._loadFloatAccessorAsync = function (context, accessor) {\n    return this._loadAccessorAsync(context, accessor, Float32Array);\n  };\n\n  GLTFLoader.prototype._loadIndicesAccessorAsync = function (context, accessor) {\n    if (accessor.type !== \"SCALAR\"\n    /* SCALAR */\n    ) {\n      throw new Error(\"\".concat(context, \"/type: Invalid value \").concat(accessor.type));\n    }\n\n    if (accessor.componentType !== 5121\n    /* UNSIGNED_BYTE */\n    && accessor.componentType !== 5123\n    /* UNSIGNED_SHORT */\n    && accessor.componentType !== 5125\n    /* UNSIGNED_INT */\n    ) {\n      throw new Error(\"\".concat(context, \"/componentType: Invalid value \").concat(accessor.componentType));\n    }\n\n    if (accessor._data) {\n      return accessor._data;\n    }\n\n    if (accessor.sparse) {\n      var constructor = GLTFLoader._GetTypedArrayConstructor(\"\".concat(context, \"/componentType\"), accessor.componentType);\n\n      accessor._data = this._loadAccessorAsync(context, accessor, constructor);\n    } else {\n      var bufferView = ArrayItem.Get(\"\".concat(context, \"/bufferView\"), this._gltf.bufferViews, accessor.bufferView);\n      accessor._data = this.loadBufferViewAsync(\"/bufferViews/\".concat(bufferView.index), bufferView).then(function (data) {\n        return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, accessor.count);\n      });\n    }\n\n    return accessor._data;\n  };\n\n  GLTFLoader.prototype._loadVertexBufferViewAsync = function (bufferView) {\n    var _this = this;\n\n    if (bufferView._babylonBuffer) {\n      return bufferView._babylonBuffer;\n    }\n\n    bufferView._babylonBuffer = this.loadBufferViewAsync(\"/bufferViews/\".concat(bufferView.index), bufferView).then(function (data) {\n      return new Buffer(_this._babylonScene.getEngine(), data, false);\n    });\n    return bufferView._babylonBuffer;\n  };\n\n  GLTFLoader.prototype._loadVertexAccessorAsync = function (context, accessor, kind) {\n    var _this = this;\n\n    var _a;\n\n    if ((_a = accessor._babylonVertexBuffer) === null || _a === void 0 ? void 0 : _a[kind]) {\n      return accessor._babylonVertexBuffer[kind];\n    }\n\n    if (!accessor._babylonVertexBuffer) {\n      accessor._babylonVertexBuffer = {};\n    }\n\n    if (accessor.sparse) {\n      accessor._babylonVertexBuffer[kind] = this._loadFloatAccessorAsync(context, accessor).then(function (data) {\n        return new VertexBuffer(_this._babylonScene.getEngine(), data, kind, false);\n      });\n    } // Load joint indices as a float array since the shaders expect float data but glTF uses unsigned byte/short.\n    // This prevents certain platforms (e.g. D3D) from having to convert the data to float on the fly.\n    else if (kind === VertexBuffer.MatricesIndicesKind || kind === VertexBuffer.MatricesIndicesExtraKind) {\n      accessor._babylonVertexBuffer[kind] = this._loadFloatAccessorAsync(context, accessor).then(function (data) {\n        return new VertexBuffer(_this._babylonScene.getEngine(), data, kind, false);\n      });\n    } else {\n      var bufferView_2 = ArrayItem.Get(\"\".concat(context, \"/bufferView\"), this._gltf.bufferViews, accessor.bufferView);\n      accessor._babylonVertexBuffer[kind] = this._loadVertexBufferViewAsync(bufferView_2).then(function (babylonBuffer) {\n        var size = GLTFLoader._GetNumComponents(context, accessor.type);\n\n        return new VertexBuffer(_this._babylonScene.getEngine(), babylonBuffer, kind, false, false, bufferView_2.byteStride, false, accessor.byteOffset, size, accessor.componentType, accessor.normalized, true, 1, true);\n      });\n    }\n\n    return accessor._babylonVertexBuffer[kind];\n  };\n\n  GLTFLoader.prototype._loadMaterialMetallicRoughnessPropertiesAsync = function (context, properties, babylonMaterial) {\n    if (!(babylonMaterial instanceof PBRMaterial)) {\n      throw new Error(\"\".concat(context, \": Material type not supported\"));\n    }\n\n    var promises = new Array();\n\n    if (properties) {\n      if (properties.baseColorFactor) {\n        babylonMaterial.albedoColor = Color3.FromArray(properties.baseColorFactor);\n        babylonMaterial.alpha = properties.baseColorFactor[3];\n      } else {\n        babylonMaterial.albedoColor = Color3.White();\n      }\n\n      babylonMaterial.metallic = properties.metallicFactor == undefined ? 1 : properties.metallicFactor;\n      babylonMaterial.roughness = properties.roughnessFactor == undefined ? 1 : properties.roughnessFactor;\n\n      if (properties.baseColorTexture) {\n        promises.push(this.loadTextureInfoAsync(\"\".concat(context, \"/baseColorTexture\"), properties.baseColorTexture, function (texture) {\n          texture.name = \"\".concat(babylonMaterial.name, \" (Base Color)\");\n          babylonMaterial.albedoTexture = texture;\n        }));\n      }\n\n      if (properties.metallicRoughnessTexture) {\n        properties.metallicRoughnessTexture.nonColorData = true;\n        promises.push(this.loadTextureInfoAsync(\"\".concat(context, \"/metallicRoughnessTexture\"), properties.metallicRoughnessTexture, function (texture) {\n          texture.name = \"\".concat(babylonMaterial.name, \" (Metallic Roughness)\");\n          babylonMaterial.metallicTexture = texture;\n        }));\n        babylonMaterial.useMetallnessFromMetallicTextureBlue = true;\n        babylonMaterial.useRoughnessFromMetallicTextureGreen = true;\n        babylonMaterial.useRoughnessFromMetallicTextureAlpha = false;\n      }\n    }\n\n    return Promise.all(promises).then(function () {});\n  };\n  /**\n   * @param context\n   * @param material\n   * @param babylonMesh\n   * @param babylonDrawMode\n   * @param assign\n   * @hidden\n   */\n\n\n  GLTFLoader.prototype._loadMaterialAsync = function (context, material, babylonMesh, babylonDrawMode, assign) {\n    if (assign === void 0) {\n      assign = function assign() {};\n    }\n\n    var extensionPromise = this._extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    material._data = material._data || {};\n    var babylonData = material._data[babylonDrawMode];\n\n    if (!babylonData) {\n      this.logOpen(\"\".concat(context, \" \").concat(material.name || \"\"));\n      var babylonMaterial = this.createMaterial(context, material, babylonDrawMode);\n      babylonData = {\n        babylonMaterial: babylonMaterial,\n        babylonMeshes: [],\n        promise: this.loadMaterialPropertiesAsync(context, material, babylonMaterial)\n      };\n      material._data[babylonDrawMode] = babylonData;\n      GLTFLoader.AddPointerMetadata(babylonMaterial, context);\n\n      this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\n\n      this.logClose();\n    }\n\n    if (babylonMesh) {\n      babylonData.babylonMeshes.push(babylonMesh);\n      babylonMesh.onDisposeObservable.addOnce(function () {\n        var index = babylonData.babylonMeshes.indexOf(babylonMesh);\n\n        if (index !== -1) {\n          babylonData.babylonMeshes.splice(index, 1);\n        }\n      });\n    }\n\n    assign(babylonData.babylonMaterial);\n    return babylonData.promise.then(function () {\n      return babylonData.babylonMaterial;\n    });\n  };\n\n  GLTFLoader.prototype._createDefaultMaterial = function (name, babylonDrawMode) {\n    this._babylonScene._blockEntityCollection = !!this._assetContainer;\n    var babylonMaterial = new PBRMaterial(name, this._babylonScene);\n    babylonMaterial._parentContainer = this._assetContainer;\n    this._babylonScene._blockEntityCollection = false; // Moved to mesh so user can change materials on gltf meshes: babylonMaterial.sideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n\n    babylonMaterial.fillMode = babylonDrawMode;\n    babylonMaterial.enableSpecularAntiAliasing = true;\n    babylonMaterial.useRadianceOverAlpha = !this._parent.transparencyAsCoverage;\n    babylonMaterial.useSpecularOverAlpha = !this._parent.transparencyAsCoverage;\n    babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\n    babylonMaterial.metallic = 1;\n    babylonMaterial.roughness = 1;\n    return babylonMaterial;\n  };\n  /**\n   * Creates a Babylon material from a glTF material.\n   * @param context The context when loading the asset\n   * @param material The glTF material property\n   * @param babylonDrawMode The draw mode for the Babylon material\n   * @returns The Babylon material\n   */\n\n\n  GLTFLoader.prototype.createMaterial = function (context, material, babylonDrawMode) {\n    var extensionPromise = this._extensionsCreateMaterial(context, material, babylonDrawMode);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    var name = material.name || \"material\".concat(material.index);\n\n    var babylonMaterial = this._createDefaultMaterial(name, babylonDrawMode);\n\n    return babylonMaterial;\n  };\n  /**\n   * Loads properties from a glTF material into a Babylon material.\n   * @param context The context when loading the asset\n   * @param material The glTF material property\n   * @param babylonMaterial The Babylon material\n   * @returns A promise that resolves when the load is complete\n   */\n\n\n  GLTFLoader.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {\n    var extensionPromise = this._extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    var promises = new Array();\n    promises.push(this.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\n\n    if (material.pbrMetallicRoughness) {\n      promises.push(this._loadMaterialMetallicRoughnessPropertiesAsync(\"\".concat(context, \"/pbrMetallicRoughness\"), material.pbrMetallicRoughness, babylonMaterial));\n    }\n\n    this.loadMaterialAlphaProperties(context, material, babylonMaterial);\n    return Promise.all(promises).then(function () {});\n  };\n  /**\n   * Loads the normal, occlusion, and emissive properties from a glTF material into a Babylon material.\n   * @param context The context when loading the asset\n   * @param material The glTF material property\n   * @param babylonMaterial The Babylon material\n   * @returns A promise that resolves when the load is complete\n   */\n\n\n  GLTFLoader.prototype.loadMaterialBasePropertiesAsync = function (context, material, babylonMaterial) {\n    if (!(babylonMaterial instanceof PBRMaterial)) {\n      throw new Error(\"\".concat(context, \": Material type not supported\"));\n    }\n\n    var promises = new Array();\n    babylonMaterial.emissiveColor = material.emissiveFactor ? Color3.FromArray(material.emissiveFactor) : new Color3(0, 0, 0);\n\n    if (material.doubleSided) {\n      babylonMaterial.backFaceCulling = false;\n      babylonMaterial.twoSidedLighting = true;\n    }\n\n    if (material.normalTexture) {\n      material.normalTexture.nonColorData = true;\n      promises.push(this.loadTextureInfoAsync(\"\".concat(context, \"/normalTexture\"), material.normalTexture, function (texture) {\n        texture.name = \"\".concat(babylonMaterial.name, \" (Normal)\");\n        babylonMaterial.bumpTexture = texture;\n      }));\n      babylonMaterial.invertNormalMapX = !this._babylonScene.useRightHandedSystem;\n      babylonMaterial.invertNormalMapY = this._babylonScene.useRightHandedSystem;\n\n      if (material.normalTexture.scale != undefined) {\n        babylonMaterial.bumpTexture.level = material.normalTexture.scale;\n      }\n\n      babylonMaterial.forceIrradianceInFragment = true;\n    }\n\n    if (material.occlusionTexture) {\n      material.occlusionTexture.nonColorData = true;\n      promises.push(this.loadTextureInfoAsync(\"\".concat(context, \"/occlusionTexture\"), material.occlusionTexture, function (texture) {\n        texture.name = \"\".concat(babylonMaterial.name, \" (Occlusion)\");\n        babylonMaterial.ambientTexture = texture;\n      }));\n      babylonMaterial.useAmbientInGrayScale = true;\n\n      if (material.occlusionTexture.strength != undefined) {\n        babylonMaterial.ambientTextureStrength = material.occlusionTexture.strength;\n      }\n    }\n\n    if (material.emissiveTexture) {\n      promises.push(this.loadTextureInfoAsync(\"\".concat(context, \"/emissiveTexture\"), material.emissiveTexture, function (texture) {\n        texture.name = \"\".concat(babylonMaterial.name, \" (Emissive)\");\n        babylonMaterial.emissiveTexture = texture;\n      }));\n    }\n\n    return Promise.all(promises).then(function () {});\n  };\n  /**\n   * Loads the alpha properties from a glTF material into a Babylon material.\n   * Must be called after the setting the albedo texture of the Babylon material when the material has an albedo texture.\n   * @param context The context when loading the asset\n   * @param material The glTF material property\n   * @param babylonMaterial The Babylon material\n   */\n\n\n  GLTFLoader.prototype.loadMaterialAlphaProperties = function (context, material, babylonMaterial) {\n    if (!(babylonMaterial instanceof PBRMaterial)) {\n      throw new Error(\"\".concat(context, \": Material type not supported\"));\n    }\n\n    var alphaMode = material.alphaMode || \"OPAQUE\"\n    /* OPAQUE */\n    ;\n\n    switch (alphaMode) {\n      case \"OPAQUE\"\n      /* OPAQUE */\n      :\n        {\n          babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\n          break;\n        }\n\n      case \"MASK\"\n      /* MASK */\n      :\n        {\n          babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHATEST;\n          babylonMaterial.alphaCutOff = material.alphaCutoff == undefined ? 0.5 : material.alphaCutoff;\n\n          if (babylonMaterial.albedoTexture) {\n            babylonMaterial.albedoTexture.hasAlpha = true;\n          }\n\n          break;\n        }\n\n      case \"BLEND\"\n      /* BLEND */\n      :\n        {\n          babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHABLEND;\n\n          if (babylonMaterial.albedoTexture) {\n            babylonMaterial.albedoTexture.hasAlpha = true;\n            babylonMaterial.useAlphaFromAlbedoTexture = true;\n          }\n\n          break;\n        }\n\n      default:\n        {\n          throw new Error(\"\".concat(context, \"/alphaMode: Invalid value (\").concat(material.alphaMode, \")\"));\n        }\n    }\n  };\n  /**\n   * Loads a glTF texture info.\n   * @param context The context when loading the asset\n   * @param textureInfo The glTF texture info property\n   * @param assign A function called synchronously after parsing the glTF properties\n   * @returns A promise that resolves with the loaded Babylon texture when the load is complete\n   */\n\n\n  GLTFLoader.prototype.loadTextureInfoAsync = function (context, textureInfo, assign) {\n    var _this = this;\n\n    if (assign === void 0) {\n      assign = function assign() {};\n    }\n\n    var extensionPromise = this._extensionsLoadTextureInfoAsync(context, textureInfo, assign);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    this.logOpen(\"\".concat(context));\n\n    if (textureInfo.texCoord >= 6) {\n      throw new Error(\"\".concat(context, \"/texCoord: Invalid value (\").concat(textureInfo.texCoord, \")\"));\n    }\n\n    var texture = ArrayItem.Get(\"\".concat(context, \"/index\"), this._gltf.textures, textureInfo.index);\n    texture._textureInfo = textureInfo;\n\n    var promise = this._loadTextureAsync(\"/textures/\".concat(textureInfo.index), texture, function (babylonTexture) {\n      babylonTexture.coordinatesIndex = textureInfo.texCoord || 0;\n      GLTFLoader.AddPointerMetadata(babylonTexture, context);\n\n      _this._parent.onTextureLoadedObservable.notifyObservers(babylonTexture);\n\n      assign(babylonTexture);\n    });\n\n    this.logClose();\n    return promise;\n  };\n  /**\n   * @param context\n   * @param texture\n   * @param assign\n   * @hidden\n   */\n\n\n  GLTFLoader.prototype._loadTextureAsync = function (context, texture, assign) {\n    if (assign === void 0) {\n      assign = function assign() {};\n    }\n\n    var extensionPromise = this._extensionsLoadTextureAsync(context, texture, assign);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    this.logOpen(\"\".concat(context, \" \").concat(texture.name || \"\"));\n    var sampler = texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get(\"\".concat(context, \"/sampler\"), this._gltf.samplers, texture.sampler);\n    var image = ArrayItem.Get(\"\".concat(context, \"/source\"), this._gltf.images, texture.source);\n\n    var promise = this._createTextureAsync(context, sampler, image, assign, undefined, !texture._textureInfo.nonColorData);\n\n    this.logClose();\n    return promise;\n  };\n  /**\n   * @param context\n   * @param sampler\n   * @param image\n   * @param assign\n   * @param textureLoaderOptions\n   * @param useSRGBBuffer\n   * @hidden\n   */\n\n\n  GLTFLoader.prototype._createTextureAsync = function (context, sampler, image, assign, textureLoaderOptions, useSRGBBuffer) {\n    var _this = this;\n\n    if (assign === void 0) {\n      assign = function assign() {};\n    }\n\n    var samplerData = this._loadSampler(\"/samplers/\".concat(sampler.index), sampler);\n\n    var promises = new Array();\n    var deferred = new Deferred();\n    this._babylonScene._blockEntityCollection = !!this._assetContainer;\n    var textureCreationOptions = {\n      noMipmap: samplerData.noMipMaps,\n      invertY: false,\n      samplingMode: samplerData.samplingMode,\n      onLoad: function onLoad() {\n        if (!_this._disposed) {\n          deferred.resolve();\n        }\n      },\n      onError: function onError(message, exception) {\n        if (!_this._disposed) {\n          deferred.reject(new Error(\"\".concat(context, \": \").concat(exception && exception.message ? exception.message : message || \"Failed to load texture\")));\n        }\n      },\n      mimeType: image.mimeType,\n      loaderOptions: textureLoaderOptions,\n      useSRGBBuffer: !!useSRGBBuffer && this._parent.useSRGBBuffers\n    };\n    var babylonTexture = new Texture(null, this._babylonScene, textureCreationOptions);\n    babylonTexture._parentContainer = this._assetContainer;\n    this._babylonScene._blockEntityCollection = false;\n    promises.push(deferred.promise);\n    promises.push(this.loadImageAsync(\"/images/\".concat(image.index), image).then(function (data) {\n      var name = image.uri || \"\".concat(_this._fileName, \"#image\").concat(image.index);\n      var dataUrl = \"data:\".concat(_this._uniqueRootUrl).concat(name);\n      babylonTexture.updateURL(dataUrl, data);\n    }));\n    babylonTexture.wrapU = samplerData.wrapU;\n    babylonTexture.wrapV = samplerData.wrapV;\n    assign(babylonTexture);\n    return Promise.all(promises).then(function () {\n      return babylonTexture;\n    });\n  };\n\n  GLTFLoader.prototype._loadSampler = function (context, sampler) {\n    if (!sampler._data) {\n      sampler._data = {\n        noMipMaps: sampler.minFilter === 9728\n        /* NEAREST */\n        || sampler.minFilter === 9729\n        /* LINEAR */\n        ,\n        samplingMode: GLTFLoader._GetTextureSamplingMode(context, sampler),\n        wrapU: GLTFLoader._GetTextureWrapMode(\"\".concat(context, \"/wrapS\"), sampler.wrapS),\n        wrapV: GLTFLoader._GetTextureWrapMode(\"\".concat(context, \"/wrapT\"), sampler.wrapT)\n      };\n    }\n\n    return sampler._data;\n  };\n  /**\n   * Loads a glTF image.\n   * @param context The context when loading the asset\n   * @param image The glTF image property\n   * @returns A promise that resolves with the loaded data when the load is complete\n   */\n\n\n  GLTFLoader.prototype.loadImageAsync = function (context, image) {\n    if (!image._data) {\n      this.logOpen(\"\".concat(context, \" \").concat(image.name || \"\"));\n\n      if (image.uri) {\n        image._data = this.loadUriAsync(\"\".concat(context, \"/uri\"), image, image.uri);\n      } else {\n        var bufferView = ArrayItem.Get(\"\".concat(context, \"/bufferView\"), this._gltf.bufferViews, image.bufferView);\n        image._data = this.loadBufferViewAsync(\"/bufferViews/\".concat(bufferView.index), bufferView);\n      }\n\n      this.logClose();\n    }\n\n    return image._data;\n  };\n  /**\n   * Loads a glTF uri.\n   * @param context The context when loading the asset\n   * @param property The glTF property associated with the uri\n   * @param uri The base64 or relative uri\n   * @returns A promise that resolves with the loaded data when the load is complete\n   */\n\n\n  GLTFLoader.prototype.loadUriAsync = function (context, property, uri) {\n    var _this = this;\n\n    var extensionPromise = this._extensionsLoadUriAsync(context, property, uri);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    if (!GLTFLoader._ValidateUri(uri)) {\n      throw new Error(\"\".concat(context, \": '\").concat(uri, \"' is invalid\"));\n    }\n\n    if (IsBase64DataUrl(uri)) {\n      var data = new Uint8Array(DecodeBase64UrlToBinary(uri));\n      this.log(\"\".concat(context, \": Decoded \").concat(uri.substr(0, 64), \"... (\").concat(data.length, \" bytes)\"));\n      return Promise.resolve(data);\n    }\n\n    this.log(\"\".concat(context, \": Loading \").concat(uri));\n    return this._parent.preprocessUrlAsync(this._rootUrl + uri).then(function (url) {\n      return new Promise(function (resolve, reject) {\n        _this._parent._loadFile(_this._babylonScene, url, function (data) {\n          if (!_this._disposed) {\n            _this.log(\"\".concat(context, \": Loaded \").concat(uri, \" (\").concat(data.byteLength, \" bytes)\"));\n\n            resolve(new Uint8Array(data));\n          }\n        }, true, function (request) {\n          reject(new LoadFileError(\"\".concat(context, \": Failed to load '\").concat(uri, \"'\").concat(request ? \": \" + request.status + \" \" + request.statusText : \"\"), request));\n        });\n      });\n    });\n  };\n  /**\n   * Adds a JSON pointer to the metadata of the Babylon object at `<object>.metadata.gltf.pointers`.\n   * @param babylonObject the Babylon object with metadata\n   * @param babylonObject.metadata\n   * @param pointer the JSON pointer\n   */\n\n\n  GLTFLoader.AddPointerMetadata = function (babylonObject, pointer) {\n    var metadata = babylonObject.metadata = babylonObject.metadata || {};\n    var gltf = metadata.gltf = metadata.gltf || {};\n    var pointers = gltf.pointers = gltf.pointers || [];\n    pointers.push(pointer);\n  };\n\n  GLTFLoader._GetTextureWrapMode = function (context, mode) {\n    // Set defaults if undefined\n    mode = mode == undefined ? 10497\n    /* REPEAT */\n    : mode;\n\n    switch (mode) {\n      case 33071\n      /* CLAMP_TO_EDGE */\n      :\n        return Texture.CLAMP_ADDRESSMODE;\n\n      case 33648\n      /* MIRRORED_REPEAT */\n      :\n        return Texture.MIRROR_ADDRESSMODE;\n\n      case 10497\n      /* REPEAT */\n      :\n        return Texture.WRAP_ADDRESSMODE;\n\n      default:\n        Logger.Warn(\"\".concat(context, \": Invalid value (\").concat(mode, \")\"));\n        return Texture.WRAP_ADDRESSMODE;\n    }\n  };\n\n  GLTFLoader._GetTextureSamplingMode = function (context, sampler) {\n    // Set defaults if undefined\n    var magFilter = sampler.magFilter == undefined ? 9729\n    /* LINEAR */\n    : sampler.magFilter;\n    var minFilter = sampler.minFilter == undefined ? 9987\n    /* LINEAR_MIPMAP_LINEAR */\n    : sampler.minFilter;\n\n    if (magFilter === 9729\n    /* LINEAR */\n    ) {\n      switch (minFilter) {\n        case 9728\n        /* NEAREST */\n        :\n          return Texture.LINEAR_NEAREST;\n\n        case 9729\n        /* LINEAR */\n        :\n          return Texture.LINEAR_LINEAR;\n\n        case 9984\n        /* NEAREST_MIPMAP_NEAREST */\n        :\n          return Texture.LINEAR_NEAREST_MIPNEAREST;\n\n        case 9985\n        /* LINEAR_MIPMAP_NEAREST */\n        :\n          return Texture.LINEAR_LINEAR_MIPNEAREST;\n\n        case 9986\n        /* NEAREST_MIPMAP_LINEAR */\n        :\n          return Texture.LINEAR_NEAREST_MIPLINEAR;\n\n        case 9987\n        /* LINEAR_MIPMAP_LINEAR */\n        :\n          return Texture.LINEAR_LINEAR_MIPLINEAR;\n\n        default:\n          Logger.Warn(\"\".concat(context, \"/minFilter: Invalid value (\").concat(minFilter, \")\"));\n          return Texture.LINEAR_LINEAR_MIPLINEAR;\n      }\n    } else {\n      if (magFilter !== 9728\n      /* NEAREST */\n      ) {\n        Logger.Warn(\"\".concat(context, \"/magFilter: Invalid value (\").concat(magFilter, \")\"));\n      }\n\n      switch (minFilter) {\n        case 9728\n        /* NEAREST */\n        :\n          return Texture.NEAREST_NEAREST;\n\n        case 9729\n        /* LINEAR */\n        :\n          return Texture.NEAREST_LINEAR;\n\n        case 9984\n        /* NEAREST_MIPMAP_NEAREST */\n        :\n          return Texture.NEAREST_NEAREST_MIPNEAREST;\n\n        case 9985\n        /* LINEAR_MIPMAP_NEAREST */\n        :\n          return Texture.NEAREST_LINEAR_MIPNEAREST;\n\n        case 9986\n        /* NEAREST_MIPMAP_LINEAR */\n        :\n          return Texture.NEAREST_NEAREST_MIPLINEAR;\n\n        case 9987\n        /* LINEAR_MIPMAP_LINEAR */\n        :\n          return Texture.NEAREST_LINEAR_MIPLINEAR;\n\n        default:\n          Logger.Warn(\"\".concat(context, \"/minFilter: Invalid value (\").concat(minFilter, \")\"));\n          return Texture.NEAREST_NEAREST_MIPNEAREST;\n      }\n    }\n  };\n\n  GLTFLoader._GetTypedArrayConstructor = function (context, componentType) {\n    switch (componentType) {\n      case 5120\n      /* BYTE */\n      :\n        return Int8Array;\n\n      case 5121\n      /* UNSIGNED_BYTE */\n      :\n        return Uint8Array;\n\n      case 5122\n      /* SHORT */\n      :\n        return Int16Array;\n\n      case 5123\n      /* UNSIGNED_SHORT */\n      :\n        return Uint16Array;\n\n      case 5125\n      /* UNSIGNED_INT */\n      :\n        return Uint32Array;\n\n      case 5126\n      /* FLOAT */\n      :\n        return Float32Array;\n\n      default:\n        throw new Error(\"\".concat(context, \": Invalid component type \").concat(componentType));\n    }\n  };\n\n  GLTFLoader._GetTypedArray = function (context, componentType, bufferView, byteOffset, length) {\n    var buffer = bufferView.buffer;\n    byteOffset = bufferView.byteOffset + (byteOffset || 0);\n\n    var constructor = GLTFLoader._GetTypedArrayConstructor(\"\".concat(context, \"/componentType\"), componentType);\n\n    var componentTypeLength = VertexBuffer.GetTypeByteLength(componentType);\n\n    if (byteOffset % componentTypeLength !== 0) {\n      // HACK: Copy the buffer if byte offset is not a multiple of component type byte length.\n      Logger.Warn(\"\".concat(context, \": Copying buffer as byte offset (\").concat(byteOffset, \") is not a multiple of component type byte length (\").concat(componentTypeLength, \")\"));\n      return new constructor(buffer.slice(byteOffset, byteOffset + length * componentTypeLength), 0);\n    }\n\n    return new constructor(buffer, byteOffset, length);\n  };\n\n  GLTFLoader._GetNumComponents = function (context, type) {\n    switch (type) {\n      case \"SCALAR\":\n        return 1;\n\n      case \"VEC2\":\n        return 2;\n\n      case \"VEC3\":\n        return 3;\n\n      case \"VEC4\":\n        return 4;\n\n      case \"MAT2\":\n        return 4;\n\n      case \"MAT3\":\n        return 9;\n\n      case \"MAT4\":\n        return 16;\n    }\n\n    throw new Error(\"\".concat(context, \": Invalid type (\").concat(type, \")\"));\n  };\n\n  GLTFLoader._ValidateUri = function (uri) {\n    return Tools.IsBase64(uri) || uri.indexOf(\"..\") === -1;\n  };\n  /**\n   * @param context\n   * @param mode\n   * @hidden\n   */\n\n\n  GLTFLoader._GetDrawMode = function (context, mode) {\n    if (mode == undefined) {\n      mode = 4\n      /* TRIANGLES */\n      ;\n    }\n\n    switch (mode) {\n      case 0\n      /* POINTS */\n      :\n        return Material.PointListDrawMode;\n\n      case 1\n      /* LINES */\n      :\n        return Material.LineListDrawMode;\n\n      case 2\n      /* LINE_LOOP */\n      :\n        return Material.LineLoopDrawMode;\n\n      case 3\n      /* LINE_STRIP */\n      :\n        return Material.LineStripDrawMode;\n\n      case 4\n      /* TRIANGLES */\n      :\n        return Material.TriangleFillMode;\n\n      case 5\n      /* TRIANGLE_STRIP */\n      :\n        return Material.TriangleStripDrawMode;\n\n      case 6\n      /* TRIANGLE_FAN */\n      :\n        return Material.TriangleFanDrawMode;\n    }\n\n    throw new Error(\"\".concat(context, \": Invalid mesh primitive mode (\").concat(mode, \")\"));\n  };\n\n  GLTFLoader.prototype._compileMaterialsAsync = function () {\n    var _this = this;\n\n    this._parent._startPerformanceCounter(\"Compile materials\");\n\n    var promises = new Array();\n\n    if (this._gltf.materials) {\n      for (var _i = 0, _a = this._gltf.materials; _i < _a.length; _i++) {\n        var material = _a[_i];\n\n        if (material._data) {\n          for (var babylonDrawMode in material._data) {\n            var babylonData = material._data[babylonDrawMode];\n\n            for (var _b = 0, _c = babylonData.babylonMeshes; _b < _c.length; _b++) {\n              var babylonMesh = _c[_b]; // Ensure nonUniformScaling is set if necessary.\n\n              babylonMesh.computeWorldMatrix(true);\n              var babylonMaterial = babylonData.babylonMaterial;\n              promises.push(babylonMaterial.forceCompilationAsync(babylonMesh));\n              promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, {\n                useInstances: true\n              }));\n\n              if (this._parent.useClipPlane) {\n                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, {\n                  clipPlane: true\n                }));\n                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, {\n                  clipPlane: true,\n                  useInstances: true\n                }));\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return Promise.all(promises).then(function () {\n      _this._parent._endPerformanceCounter(\"Compile materials\");\n    });\n  };\n\n  GLTFLoader.prototype._compileShadowGeneratorsAsync = function () {\n    var _this = this;\n\n    this._parent._startPerformanceCounter(\"Compile shadow generators\");\n\n    var promises = new Array();\n    var lights = this._babylonScene.lights;\n\n    for (var _i = 0, lights_1 = lights; _i < lights_1.length; _i++) {\n      var light = lights_1[_i];\n      var generator = light.getShadowGenerator();\n\n      if (generator) {\n        promises.push(generator.forceCompilationAsync());\n      }\n    }\n\n    return Promise.all(promises).then(function () {\n      _this._parent._endPerformanceCounter(\"Compile shadow generators\");\n    });\n  };\n\n  GLTFLoader.prototype._forEachExtensions = function (action) {\n    for (var _i = 0, _a = this._extensions; _i < _a.length; _i++) {\n      var extension = _a[_i];\n\n      if (extension.enabled) {\n        action(extension);\n      }\n    }\n  };\n\n  GLTFLoader.prototype._applyExtensions = function (property, functionName, actionAsync) {\n    for (var _i = 0, _a = this._extensions; _i < _a.length; _i++) {\n      var extension = _a[_i];\n\n      if (extension.enabled) {\n        var id = \"\".concat(extension.name, \".\").concat(functionName);\n        var loaderProperty = property;\n        loaderProperty._activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions || {};\n        var activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions;\n\n        if (!activeLoaderExtensionFunctions[id]) {\n          activeLoaderExtensionFunctions[id] = true;\n\n          try {\n            var result = actionAsync(extension);\n\n            if (result) {\n              return result;\n            }\n          } finally {\n            delete activeLoaderExtensionFunctions[id];\n          }\n        }\n      }\n    }\n\n    return null;\n  };\n\n  GLTFLoader.prototype._extensionsOnLoading = function () {\n    this._forEachExtensions(function (extension) {\n      return extension.onLoading && extension.onLoading();\n    });\n  };\n\n  GLTFLoader.prototype._extensionsOnReady = function () {\n    this._forEachExtensions(function (extension) {\n      return extension.onReady && extension.onReady();\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadSceneAsync = function (context, scene) {\n    return this._applyExtensions(scene, \"loadScene\", function (extension) {\n      return extension.loadSceneAsync && extension.loadSceneAsync(context, scene);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadNodeAsync = function (context, node, assign) {\n    return this._applyExtensions(node, \"loadNode\", function (extension) {\n      return extension.loadNodeAsync && extension.loadNodeAsync(context, node, assign);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadCameraAsync = function (context, camera, assign) {\n    return this._applyExtensions(camera, \"loadCamera\", function (extension) {\n      return extension.loadCameraAsync && extension.loadCameraAsync(context, camera, assign);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadVertexDataAsync = function (context, primitive, babylonMesh) {\n    return this._applyExtensions(primitive, \"loadVertexData\", function (extension) {\n      return extension._loadVertexDataAsync && extension._loadVertexDataAsync(context, primitive, babylonMesh);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadMeshPrimitiveAsync = function (context, name, node, mesh, primitive, assign) {\n    return this._applyExtensions(primitive, \"loadMeshPrimitive\", function (extension) {\n      return extension._loadMeshPrimitiveAsync && extension._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadMaterialAsync = function (context, material, babylonMesh, babylonDrawMode, assign) {\n    return this._applyExtensions(material, \"loadMaterial\", function (extension) {\n      return extension._loadMaterialAsync && extension._loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsCreateMaterial = function (context, material, babylonDrawMode) {\n    return this._applyExtensions(material, \"createMaterial\", function (extension) {\n      return extension.createMaterial && extension.createMaterial(context, material, babylonDrawMode);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadMaterialPropertiesAsync = function (context, material, babylonMaterial) {\n    return this._applyExtensions(material, \"loadMaterialProperties\", function (extension) {\n      return extension.loadMaterialPropertiesAsync && extension.loadMaterialPropertiesAsync(context, material, babylonMaterial);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadTextureInfoAsync = function (context, textureInfo, assign) {\n    return this._applyExtensions(textureInfo, \"loadTextureInfo\", function (extension) {\n      return extension.loadTextureInfoAsync && extension.loadTextureInfoAsync(context, textureInfo, assign);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadTextureAsync = function (context, texture, assign) {\n    return this._applyExtensions(texture, \"loadTexture\", function (extension) {\n      return extension._loadTextureAsync && extension._loadTextureAsync(context, texture, assign);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadAnimationAsync = function (context, animation) {\n    return this._applyExtensions(animation, \"loadAnimation\", function (extension) {\n      return extension.loadAnimationAsync && extension.loadAnimationAsync(context, animation);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadSkinAsync = function (context, node, skin) {\n    return this._applyExtensions(skin, \"loadSkin\", function (extension) {\n      return extension._loadSkinAsync && extension._loadSkinAsync(context, node, skin);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadUriAsync = function (context, property, uri) {\n    return this._applyExtensions(property, \"loadUri\", function (extension) {\n      return extension._loadUriAsync && extension._loadUriAsync(context, property, uri);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadBufferViewAsync = function (context, bufferView) {\n    return this._applyExtensions(bufferView, \"loadBufferView\", function (extension) {\n      return extension.loadBufferViewAsync && extension.loadBufferViewAsync(context, bufferView);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadBufferAsync = function (context, buffer, byteOffset, byteLength) {\n    return this._applyExtensions(buffer, \"loadBuffer\", function (extension) {\n      return extension.loadBufferAsync && extension.loadBufferAsync(context, buffer, byteOffset, byteLength);\n    });\n  };\n  /**\n   * Helper method called by a loader extension to load an glTF extension.\n   * @param context The context when loading the asset\n   * @param property The glTF property to load the extension from\n   * @param extensionName The name of the extension to load\n   * @param actionAsync The action to run\n   * @returns The promise returned by actionAsync or null if the extension does not exist\n   */\n\n\n  GLTFLoader.LoadExtensionAsync = function (context, property, extensionName, actionAsync) {\n    if (!property.extensions) {\n      return null;\n    }\n\n    var extensions = property.extensions;\n    var extension = extensions[extensionName];\n\n    if (!extension) {\n      return null;\n    }\n\n    return actionAsync(\"\".concat(context, \"/extensions/\").concat(extensionName), extension);\n  };\n  /**\n   * Helper method called by a loader extension to load a glTF extra.\n   * @param context The context when loading the asset\n   * @param property The glTF property to load the extra from\n   * @param extensionName The name of the extension to load\n   * @param actionAsync The action to run\n   * @returns The promise returned by actionAsync or null if the extra does not exist\n   */\n\n\n  GLTFLoader.LoadExtraAsync = function (context, property, extensionName, actionAsync) {\n    if (!property.extras) {\n      return null;\n    }\n\n    var extras = property.extras;\n    var extra = extras[extensionName];\n\n    if (!extra) {\n      return null;\n    }\n\n    return actionAsync(\"\".concat(context, \"/extras/\").concat(extensionName), extra);\n  };\n  /**\n   * Checks for presence of an extension.\n   * @param name The name of the extension to check\n   * @returns A boolean indicating the presence of the given extension name in `extensionsUsed`\n   */\n\n\n  GLTFLoader.prototype.isExtensionUsed = function (name) {\n    return !!this._gltf.extensionsUsed && this._gltf.extensionsUsed.indexOf(name) !== -1;\n  };\n  /**\n   * Increments the indentation level and logs a message.\n   * @param message The message to log\n   */\n\n\n  GLTFLoader.prototype.logOpen = function (message) {\n    this._parent._logOpen(message);\n  };\n  /**\n   * Decrements the indentation level.\n   */\n\n\n  GLTFLoader.prototype.logClose = function () {\n    this._parent._logClose();\n  };\n  /**\n   * Logs a message\n   * @param message The message to log\n   */\n\n\n  GLTFLoader.prototype.log = function (message) {\n    this._parent._log(message);\n  };\n  /**\n   * Starts a performance counter.\n   * @param counterName The name of the performance counter\n   */\n\n\n  GLTFLoader.prototype.startPerformanceCounter = function (counterName) {\n    this._parent._startPerformanceCounter(counterName);\n  };\n  /**\n   * Ends a performance counter.\n   * @param counterName The name of the performance counter\n   */\n\n\n  GLTFLoader.prototype.endPerformanceCounter = function (counterName) {\n    this._parent._endPerformanceCounter(counterName);\n  };\n\n  GLTFLoader._RegisteredExtensions = {};\n  /**\n   * The default glTF sampler.\n   */\n\n  GLTFLoader.DefaultSampler = {\n    index: -1\n  };\n  return GLTFLoader;\n}();\n\nexport { GLTFLoader };\n\nGLTFFileLoader._CreateGLTF2Loader = function (parent) {\n  return new GLTFLoader(parent);\n};","map":{"version":3,"mappings":"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","names":["Deferred","Quaternion","Vector3","Matrix","TmpVectors","Color3","Tools","Camera","FreeCamera","AnimationGroup","Animation","Bone","Skeleton","Material","PBRMaterial","Texture","TransformNode","Buffer","VertexBuffer","Geometry","Mesh","MorphTarget","MorphTargetManager","GLTFFileLoader","GLTFLoaderState","GLTFLoaderCoordinateSystemMode","GLTFLoaderAnimationStartMode","AnimationKeyInterpolation","DecodeBase64UrlToBinary","IsBase64DataUrl","LoadFileError","Logger","BoundingInfo","StringTools","ArrayItem","context","array","index","undefined","Error","concat","length","parent","Array","_parent","GLTFLoader","name","factory","UnregisterExtension","Warn","_RegisteredExtensions","Object","_gltf","_bin","_babylonScene","_rootBabylonMesh","_disposed","_completePromises","_extensions","forEach","extension","dispose","_defaultBabylonMaterialData","_postSceneLoadActions","meshesNames","scene","container","data","rootUrl","onProgress","fileName","Promise","resolve","then","_this","_assetContainer","_loadData","nodes","nodeMap_1","_i","node","names","map","_loadAsync","meshes","_getMeshes","particleSystems","skeletons","_getSkeletons","animationGroups","_getAnimationGroups","lights","_babylonLights","transformNodes","_getTransformNodes","geometries","_getGeometries","resultFunc","_rootUrl","_uniqueRootUrl","StartsWith","Date","now","_fileName","_loadExtensions","_checkExtensions","loadingToReadyCounterName","LOADING","READY","loadingToCompleteCounterName","COMPLETE","_startPerformanceCounter","_setState","_extensionsOnLoading","promises","oldBlockMaterialDirtyMechanism","blockMaterialDirtyMechanism","loadOnlyMaterials","push","loadSceneAsync","scenes","Get","skipMaterials","loadAllMaterials","materials","m","material","context_1","babylonDrawMode","TriangleFillMode","_loadMaterialAsync","compileMaterials","_compileMaterialsAsync","compileShadowGenerators","_compileShadowGeneratorsAsync","resultPromise","all","setEnabled","_extensionsOnReady","_startAnimations","result","_endPerformanceCounter","SetImmediate","onCompleteObservable","notifyObservers","clear","error","onErrorObservable","json","_setupData","bin","buffers","uri","binaryBuffer","byteLength","Assign","accessors","animations","bufferViews","cameras","images","samplers","skins","textures","nodeParents","children","_b","rootNode","_createRootNode","_d","parentIndex","name_1","onExtensionLoadedObservable","sort","a","b","order","Number","MAX_VALUE","extensionsRequired","name_2","available","this_1","some","enabled","_blockEntityCollection","_parentContainer","_babylonTransformNode","coordinateSystemMode","AUTO","useRightHandedSystem","rotation","scale","_LoadTransform","FORCE_RIGHT_HANDED","onMeshLoadedObservable","extensionPromise","_extensionsLoadSceneAsync","logOpen","loadNodeAsync","babylonMesh","action","_loadAnimationsAsync","logClose","callback","_primitiveBabylonMeshes","_forEachPrimitive","geometry","indexOf","getClassName","_babylonTransformNodeForSkin","skin","_data","babylonSkeleton","animation","_babylonAnimationGroup","animationStartMode","NONE","FIRST","babylonAnimationGroups","start","ALL","babylonAnimationGroup","assign","_extensionsLoadNodeAsync","loadNode","babylonTransformNode","AddPointerMetadata","camera","loadCameraAsync","babylonCamera","childNode","childBabylonMesh","mesh","nodeName","transformNode","_loadMeshAsync","metadata","_loadSkinAsync","skeleton","skeletonRootNode","useBoundingInfoFromGeometry","_updateBoundingInfo","refreshBoundingInfo","primitives","primitive","_loadMeshPrimitiveAsync","_extensionsLoadMeshPrimitiveAsync","shouldInstance","_disableInstancedMesh","createInstances","targets","babylonAbstractMesh","promise","_instanceData","babylonSourceMesh","createInstance","babylonMesh_1","overrideMaterialSideOrientation","CounterClockWiseSideOrientation","ClockWiseSideOrientation","_createMorphTargets","_loadVertexDataAsync","babylonGeometry","_loadMorphTargetsAsync","applyToMesh","_GetDrawMode","mode","babylonMaterial","_createDefaultMaterial","onMaterialLoadedObservable","_extensionsLoadVertexDataAsync","attributes","indices","isUnIndexed","accessor","_loadIndicesAccessorAsync","setIndices","loadAttribute","attribute","kind","_delayInfo","_loadVertexAccessorAsync","babylonVertexBuffer","getKind","PositionKind","alwaysComputeBoundingBox","mmin","min","mmax","max","normalized","componentType","divider","i","Math","copyFromFloats","apply","_boundingInfo","setVerticesBuffer","count","MatricesIndicesExtraKind","numBoneInfluencers","NormalKind","TangentKind","UVKind","UV2Kind","UV3Kind","UV4Kind","UV5Kind","UV6Kind","MatricesIndicesKind","MatricesWeightsKind","MatricesWeightsExtraKind","ColorKind","type","hasVertexAlpha","_numMorphTargets","targetNames","extras","morphTargetManager","getScene","areUpdatesFrozen","weight","weights","name_3","addTarget","numTargets","babylonMorphTarget","getTarget","_loadMorphTargetVertexDataAsync","setData","getVertexBuffer","_loadFloatAccessorAsync","positions","Float32Array","value","setPositions","normals","setNormals","tangents","dataIndex","setTangents","babylonNode","position","Zero","Identity","scaling","One","matrix","FromArray","decompose","translation","rotationQuaternion","_extensionsLoadSkinAsync","skeletonId","_loadBones","_loadSkinInverseBindMatricesDataAsync","inverseBindMatricesData","_updateBoneMatrices","alwaysComputeSkeletonRootNode","_findSkeletonRootNode","joints","isParent","skeletonNode","babylonBones","_loadBone","paths","path","unshift","j","babylonBone","parentBabylonBone","boneIndex","_getNodeMatrix","linkTransformNode","inverseBindMatrices","bones","baseMatrix","_index","FromArrayToRef","invertToRef","babylonParentBone","getParent","multiplyToRef","getInvertedAbsoluteTransform","updateMatrix","_updateDifferenceMatrix","Compose","_extensionsLoadCameraAsync","ignoreParentScaling","PI","perspective","fov","yfov","minZ","znear","maxZ","zfar","orthographic","ORTHOGRAPHIC_CAMERA","orthoLeft","xmag","orthoRight","orthoBottom","ymag","orthoTop","onCameraLoadedObservable","loadAnimationAsync","animationGroup","targetedAnimations","_extensionsLoadAnimationAsync","channels","channel","_loadAnimationChannelAsync","normalize","animationContext","animationTargetOverride","target","targetNode","sampler","_loadAnimationSamplerAsync","targetPath","animationType","ANIMATIONTYPE_VECTOR3","ANIMATIONTYPE_QUATERNION","ANIMATIONTYPE_FLOAT","outputBufferOffset","getNextOutputValue","output","scaleInPlace","getNextKey","interpolation","frameIndex","frame","input","targetFps","STEP","invTargetFps_1","inTangent","outTangent","keys","targetIndex","animationName","babylonAnimation","setKeys","key","morphTarget","babylonAnimationClone","clone","addTargetedAnimation","inputAccessor","outputAccessor","_a","inputData","outputData","buffer","byteOffset","_extensionsLoadBufferAsync","loadUriAsync","readAsync","Uint8Array","e","message","bufferView","_extensionsLoadBufferViewAsync","loadBufferAsync","constructor","numComponents","_GetNumComponents","byteStride","GetTypeByteLength","bufferView_1","loadBufferViewAsync","_GetTypedArray","typedArray_1","ForEach","sparse","sparse_1","typedArray","indicesBufferView","valuesBufferView","values","indicesData","valuesData","sparseLength","sparseData","valuesIndex","indicesIndex","componentIndex","_loadAccessorAsync","_GetTypedArrayConstructor","_babylonBuffer","getEngine","_babylonVertexBuffer","bufferView_2","_loadVertexBufferViewAsync","babylonBuffer","size","properties","baseColorFactor","albedoColor","alpha","White","metallic","metallicFactor","roughness","roughnessFactor","baseColorTexture","loadTextureInfoAsync","texture","albedoTexture","metallicRoughnessTexture","nonColorData","metallicTexture","useMetallnessFromMetallicTextureBlue","useRoughnessFromMetallicTextureGreen","useRoughnessFromMetallicTextureAlpha","_extensionsLoadMaterialAsync","babylonData","createMaterial","babylonMeshes","loadMaterialPropertiesAsync","onDisposeObservable","addOnce","splice","fillMode","enableSpecularAntiAliasing","useRadianceOverAlpha","transparencyAsCoverage","useSpecularOverAlpha","transparencyMode","PBRMATERIAL_OPAQUE","_extensionsCreateMaterial","_extensionsLoadMaterialPropertiesAsync","loadMaterialBasePropertiesAsync","pbrMetallicRoughness","_loadMaterialMetallicRoughnessPropertiesAsync","loadMaterialAlphaProperties","emissiveColor","emissiveFactor","doubleSided","backFaceCulling","twoSidedLighting","normalTexture","bumpTexture","invertNormalMapX","invertNormalMapY","level","forceIrradianceInFragment","occlusionTexture","ambientTexture","useAmbientInGrayScale","strength","ambientTextureStrength","emissiveTexture","alphaMode","PBRMATERIAL_ALPHATEST","alphaCutOff","alphaCutoff","hasAlpha","PBRMATERIAL_ALPHABLEND","useAlphaFromAlbedoTexture","textureInfo","_extensionsLoadTextureInfoAsync","texCoord","_textureInfo","_loadTextureAsync","babylonTexture","coordinatesIndex","onTextureLoadedObservable","_extensionsLoadTextureAsync","DefaultSampler","image","source","_createTextureAsync","textureLoaderOptions","useSRGBBuffer","samplerData","_loadSampler","deferred","textureCreationOptions","noMipmap","noMipMaps","invertY","samplingMode","onLoad","onError","exception","reject","mimeType","loaderOptions","useSRGBBuffers","loadImageAsync","dataUrl","updateURL","wrapU","wrapV","minFilter","_GetTextureSamplingMode","_GetTextureWrapMode","wrapS","wrapT","property","_extensionsLoadUriAsync","_ValidateUri","log","substr","preprocessUrlAsync","url","_loadFile","request","status","statusText","babylonObject","pointer","gltf","pointers","CLAMP_ADDRESSMODE","MIRROR_ADDRESSMODE","WRAP_ADDRESSMODE","magFilter","LINEAR_NEAREST","LINEAR_LINEAR","LINEAR_NEAREST_MIPNEAREST","LINEAR_LINEAR_MIPNEAREST","LINEAR_NEAREST_MIPLINEAR","LINEAR_LINEAR_MIPLINEAR","NEAREST_NEAREST","NEAREST_LINEAR","NEAREST_NEAREST_MIPNEAREST","NEAREST_LINEAR_MIPNEAREST","NEAREST_NEAREST_MIPLINEAR","NEAREST_LINEAR_MIPLINEAR","Int8Array","Int16Array","Uint16Array","Uint32Array","componentTypeLength","slice","IsBase64","PointListDrawMode","LineListDrawMode","LineLoopDrawMode","LineStripDrawMode","TriangleStripDrawMode","TriangleFanDrawMode","computeWorldMatrix","forceCompilationAsync","useInstances","useClipPlane","clipPlane","light","generator","getShadowGenerator","functionName","actionAsync","id","loaderProperty","_activeLoaderExtensionFunctions","activeLoaderExtensionFunctions","_forEachExtensions","onLoading","onReady","_applyExtensions","_loadUriAsync","extensionName","extensions","extra","extensionsUsed","_logOpen","_logClose","_log","counterName","_CreateGLTF2Loader"],"sourceRoot":"","sources":["../../../../../../lts/loaders/generated/glTF/2.0/glTFLoader.ts"],"sourcesContent":["import type { IndicesArray, Nullable } from \"core/types\";\r\nimport { Deferred } from \"core/Misc/deferred\";\r\nimport { Quaternion, Vector3, Matrix, TmpVectors } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { FreeCamera } from \"core/Cameras/freeCamera\";\r\nimport { AnimationGroup } from \"core/Animations/animationGroup\";\r\nimport { Animation } from \"core/Animations/animation\";\r\nimport { Bone } from \"core/Bones/bone\";\r\nimport { Skeleton } from \"core/Bones/skeleton\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { ITextureCreationOptions } from \"core/Materials/Textures/texture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { Buffer, VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Geometry } from \"core/Meshes/geometry\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { InstancedMesh } from \"core/Meshes/instancedMesh\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { MorphTarget } from \"core/Morph/morphTarget\";\r\nimport { MorphTargetManager } from \"core/Morph/morphTargetManager\";\r\nimport type { ISceneLoaderAsyncResult, ISceneLoaderProgressEvent } from \"core/Loading/sceneLoader\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { IProperty } from \"babylonjs-gltf2interface\";\r\nimport {\r\n    AccessorType,\r\n    CameraType,\r\n    AnimationChannelTargetPath,\r\n    AnimationSamplerInterpolation,\r\n    AccessorComponentType,\r\n    MaterialAlphaMode,\r\n    TextureMinFilter,\r\n    TextureWrapMode,\r\n    TextureMagFilter,\r\n    MeshPrimitiveMode,\r\n} from \"babylonjs-gltf2interface\";\r\nimport type {\r\n    _IAnimationSamplerData,\r\n    IGLTF,\r\n    ISampler,\r\n    INode,\r\n    IScene,\r\n    IMesh,\r\n    IAccessor,\r\n    ISkin,\r\n    ICamera,\r\n    IAnimation,\r\n    IAnimationChannel,\r\n    IAnimationSampler,\r\n    IBuffer,\r\n    IBufferView,\r\n    IMaterialPbrMetallicRoughness,\r\n    IMaterial,\r\n    ITextureInfo,\r\n    ITexture,\r\n    IImage,\r\n    IMeshPrimitive,\r\n    IArrayItem as IArrItem,\r\n    _ISamplerData,\r\n} from \"./glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"./glTFLoaderExtension\";\r\nimport type { IGLTFLoader, IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport { GLTFFileLoader, GLTFLoaderState, GLTFLoaderCoordinateSystemMode, GLTFLoaderAnimationStartMode } from \"../glTFFileLoader\";\r\nimport type { IAnimationKey } from \"core/Animations/animationKey\";\r\nimport { AnimationKeyInterpolation } from \"core/Animations/animationKey\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { IDataBuffer } from \"core/Misc/dataReader\";\r\nimport { DecodeBase64UrlToBinary, IsBase64DataUrl, LoadFileError } from \"core/Misc/fileTools\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { Light } from \"core/Lights/light\";\r\n\r\nimport { BoundingInfo } from \"core/Culling/boundingInfo\";\r\nimport { StringTools } from \"core/Misc/stringTools\";\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\n\r\ninterface TypedArrayLike extends ArrayBufferView {\r\n    readonly length: number;\r\n    [n: number]: number;\r\n}\r\n\r\ninterface TypedArrayConstructor {\r\n    new (length: number): TypedArrayLike;\r\n    new (buffer: ArrayBufferLike, byteOffset: number, length?: number): TypedArrayLike;\r\n}\r\n\r\ninterface ILoaderProperty extends IProperty {\r\n    _activeLoaderExtensionFunctions: {\r\n        [id: string]: boolean;\r\n    };\r\n}\r\n\r\ninterface IRegisteredExtension {\r\n    factory: (loader: GLTFLoader) => IGLTFLoaderExtension;\r\n}\r\n\r\n/**\r\n * Helper class for working with arrays when loading the glTF asset\r\n */\r\nexport class ArrayItem {\r\n    /**\r\n     * Gets an item from the given array.\r\n     * @param context The context when loading the asset\r\n     * @param array The array to get the item from\r\n     * @param index The index to the array\r\n     * @returns The array item\r\n     */\r\n    public static Get<T>(context: string, array: ArrayLike<T> | undefined, index: number | undefined): T {\r\n        if (!array || index == undefined || !array[index]) {\r\n            throw new Error(`${context}: Failed to find index (${index})`);\r\n        }\r\n\r\n        return array[index];\r\n    }\r\n\r\n    /**\r\n     * Assign an `index` field to each item of the given array.\r\n     * @param array The array of items\r\n     */\r\n    public static Assign(array?: IArrItem[]): void {\r\n        if (array) {\r\n            for (let index = 0; index < array.length; index++) {\r\n                array[index].index = index;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * The glTF 2.0 loader\r\n */\r\nexport class GLTFLoader implements IGLTFLoader {\r\n    /** @hidden */\r\n    public _completePromises = new Array<Promise<any>>();\r\n\r\n    /** @hidden */\r\n    public _assetContainer: Nullable<AssetContainer> = null;\r\n\r\n    /** Storage */\r\n    public _babylonLights: Light[] = [];\r\n\r\n    /** @hidden */\r\n    public _disableInstancedMesh = 0;\r\n\r\n    private readonly _parent: GLTFFileLoader;\r\n    private readonly _extensions = new Array<IGLTFLoaderExtension>();\r\n    private _disposed = false;\r\n    private _rootUrl: Nullable<string> = null;\r\n    private _fileName: Nullable<string> = null;\r\n    private _uniqueRootUrl: Nullable<string> = null;\r\n    private _gltf: IGLTF;\r\n    private _bin: Nullable<IDataBuffer> = null;\r\n    private _babylonScene: Scene;\r\n    private _rootBabylonMesh: Nullable<Mesh> = null;\r\n    private _defaultBabylonMaterialData: { [drawMode: number]: Material } = {};\r\n    private _postSceneLoadActions = new Array<() => void>();\r\n\r\n    private static _RegisteredExtensions: { [name: string]: IRegisteredExtension } = {};\r\n\r\n    /**\r\n     * The default glTF sampler.\r\n     */\r\n    public static readonly DefaultSampler: ISampler = { index: -1 };\r\n\r\n    /**\r\n     * Registers a loader extension.\r\n     * @param name The name of the loader extension.\r\n     * @param factory The factory function that creates the loader extension.\r\n     */\r\n    public static RegisterExtension(name: string, factory: (loader: GLTFLoader) => IGLTFLoaderExtension): void {\r\n        if (GLTFLoader.UnregisterExtension(name)) {\r\n            Logger.Warn(`Extension with the name '${name}' already exists`);\r\n        }\r\n\r\n        GLTFLoader._RegisteredExtensions[name] = {\r\n            factory: factory,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Unregisters a loader extension.\r\n     * @param name The name of the loader extension.\r\n     * @returns A boolean indicating whether the extension has been unregistered\r\n     */\r\n    public static UnregisterExtension(name: string): boolean {\r\n        if (!GLTFLoader._RegisteredExtensions[name]) {\r\n            return false;\r\n        }\r\n\r\n        delete GLTFLoader._RegisteredExtensions[name];\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * The object that represents the glTF JSON.\r\n     */\r\n    public get gltf(): IGLTF {\r\n        if (!this._gltf) {\r\n            throw new Error(\"glTF JSON is not available\");\r\n        }\r\n\r\n        return this._gltf;\r\n    }\r\n\r\n    /**\r\n     * The BIN chunk of a binary glTF.\r\n     */\r\n    public get bin(): Nullable<IDataBuffer> {\r\n        return this._bin;\r\n    }\r\n\r\n    /**\r\n     * The parent file loader.\r\n     */\r\n    public get parent(): GLTFFileLoader {\r\n        return this._parent;\r\n    }\r\n\r\n    /**\r\n     * The Babylon scene when loading the asset.\r\n     */\r\n    public get babylonScene(): Scene {\r\n        if (!this._babylonScene) {\r\n            throw new Error(\"Scene is not available\");\r\n        }\r\n\r\n        return this._babylonScene;\r\n    }\r\n\r\n    /**\r\n     * The root Babylon mesh when loading the asset.\r\n     */\r\n    public get rootBabylonMesh(): Nullable<Mesh> {\r\n        return this._rootBabylonMesh;\r\n    }\r\n\r\n    /**\r\n     * @param parent\r\n     * @hidden\r\n     */\r\n    constructor(parent: GLTFFileLoader) {\r\n        this._parent = parent;\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose(): void {\r\n        if (this._disposed) {\r\n            return;\r\n        }\r\n\r\n        this._disposed = true;\r\n\r\n        this._completePromises.length = 0;\r\n\r\n        this._extensions.forEach((extension) => extension.dispose && extension.dispose());\r\n        this._extensions.length = 0;\r\n\r\n        (this._gltf as Nullable<IGLTF>) = null; // TODO\r\n        this._bin = null;\r\n        (this._babylonScene as Nullable<Scene>) = null; // TODO\r\n        this._rootBabylonMesh = null;\r\n        this._defaultBabylonMaterialData = {};\r\n        this._postSceneLoadActions.length = 0;\r\n\r\n        this._parent.dispose();\r\n    }\r\n\r\n    /**\r\n     * @param meshesNames\r\n     * @param scene\r\n     * @param container\r\n     * @param data\r\n     * @param rootUrl\r\n     * @param onProgress\r\n     * @param fileName\r\n     * @hidden\r\n     */\r\n    public importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        container: Nullable<AssetContainer>,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName = \"\"\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        return Promise.resolve().then(() => {\r\n            this._babylonScene = scene;\r\n            this._assetContainer = container;\r\n            this._loadData(data);\r\n\r\n            let nodes: Nullable<Array<number>> = null;\r\n\r\n            if (meshesNames) {\r\n                const nodeMap: { [name: string]: number } = {};\r\n                if (this._gltf.nodes) {\r\n                    for (const node of this._gltf.nodes) {\r\n                        if (node.name) {\r\n                            nodeMap[node.name] = node.index;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                const names = meshesNames instanceof Array ? meshesNames : [meshesNames];\r\n                nodes = names.map((name) => {\r\n                    const node = nodeMap[name];\r\n                    if (node === undefined) {\r\n                        throw new Error(`Failed to find node '${name}'`);\r\n                    }\r\n\r\n                    return node;\r\n                });\r\n            }\r\n\r\n            return this._loadAsync(rootUrl, fileName, nodes, () => {\r\n                return {\r\n                    meshes: this._getMeshes(),\r\n                    particleSystems: [],\r\n                    skeletons: this._getSkeletons(),\r\n                    animationGroups: this._getAnimationGroups(),\r\n                    lights: this._babylonLights,\r\n                    transformNodes: this._getTransformNodes(),\r\n                    geometries: this._getGeometries(),\r\n                };\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param scene\r\n     * @param data\r\n     * @param rootUrl\r\n     * @param onProgress\r\n     * @param fileName\r\n     * @hidden\r\n     */\r\n    public loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName = \"\"): Promise<void> {\r\n        return Promise.resolve().then(() => {\r\n            this._babylonScene = scene;\r\n            this._loadData(data);\r\n            return this._loadAsync(rootUrl, fileName, null, () => undefined);\r\n        });\r\n    }\r\n\r\n    private _loadAsync<T>(rootUrl: string, fileName: string, nodes: Nullable<Array<number>>, resultFunc: () => T): Promise<T> {\r\n        return Promise.resolve()\r\n            .then(() => {\r\n                this._rootUrl = rootUrl;\r\n                this._uniqueRootUrl = !StringTools.StartsWith(rootUrl, \"file:\") && fileName ? rootUrl : `${rootUrl}${Date.now()}/`;\r\n                this._fileName = fileName;\r\n\r\n                this._loadExtensions();\r\n                this._checkExtensions();\r\n\r\n                const loadingToReadyCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.READY]}`;\r\n                const loadingToCompleteCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.COMPLETE]}`;\r\n\r\n                this._parent._startPerformanceCounter(loadingToReadyCounterName);\r\n                this._parent._startPerformanceCounter(loadingToCompleteCounterName);\r\n\r\n                this._parent._setState(GLTFLoaderState.LOADING);\r\n                this._extensionsOnLoading();\r\n\r\n                const promises = new Array<Promise<any>>();\r\n\r\n                // Block the marking of materials dirty until the scene is loaded.\r\n                const oldBlockMaterialDirtyMechanism = this._babylonScene.blockMaterialDirtyMechanism;\r\n                this._babylonScene.blockMaterialDirtyMechanism = true;\r\n\r\n                if (!this.parent.loadOnlyMaterials) {\r\n                    if (nodes) {\r\n                        promises.push(this.loadSceneAsync(\"/nodes\", { nodes: nodes, index: -1 }));\r\n                    } else if (this._gltf.scene != undefined || (this._gltf.scenes && this._gltf.scenes[0])) {\r\n                        const scene = ArrayItem.Get(`/scene`, this._gltf.scenes, this._gltf.scene || 0);\r\n                        promises.push(this.loadSceneAsync(`/scenes/${scene.index}`, scene));\r\n                    }\r\n                }\r\n\r\n                if (!this.parent.skipMaterials && this.parent.loadAllMaterials && this._gltf.materials) {\r\n                    for (let m = 0; m < this._gltf.materials.length; ++m) {\r\n                        const material = this._gltf.materials[m];\r\n                        const context = \"/materials/\" + m;\r\n                        const babylonDrawMode = Material.TriangleFillMode;\r\n\r\n                        promises.push(this._loadMaterialAsync(context, material, null, babylonDrawMode, () => {}));\r\n                    }\r\n                }\r\n\r\n                // Restore the blocking of material dirty.\r\n                this._babylonScene.blockMaterialDirtyMechanism = oldBlockMaterialDirtyMechanism;\r\n\r\n                if (this._parent.compileMaterials) {\r\n                    promises.push(this._compileMaterialsAsync());\r\n                }\r\n\r\n                if (this._parent.compileShadowGenerators) {\r\n                    promises.push(this._compileShadowGeneratorsAsync());\r\n                }\r\n\r\n                const resultPromise = Promise.all(promises).then(() => {\r\n                    if (this._rootBabylonMesh) {\r\n                        this._rootBabylonMesh.setEnabled(true);\r\n                    }\r\n\r\n                    this._extensionsOnReady();\r\n                    this._parent._setState(GLTFLoaderState.READY);\r\n\r\n                    this._startAnimations();\r\n\r\n                    return resultFunc();\r\n                });\r\n\r\n                return resultPromise.then((result) => {\r\n                    this._parent._endPerformanceCounter(loadingToReadyCounterName);\r\n\r\n                    Tools.SetImmediate(() => {\r\n                        if (!this._disposed) {\r\n                            Promise.all(this._completePromises).then(\r\n                                () => {\r\n                                    this._parent._endPerformanceCounter(loadingToCompleteCounterName);\r\n\r\n                                    this._parent._setState(GLTFLoaderState.COMPLETE);\r\n\r\n                                    this._parent.onCompleteObservable.notifyObservers(undefined);\r\n                                    this._parent.onCompleteObservable.clear();\r\n\r\n                                    this.dispose();\r\n                                },\r\n                                (error) => {\r\n                                    this._parent.onErrorObservable.notifyObservers(error);\r\n                                    this._parent.onErrorObservable.clear();\r\n\r\n                                    this.dispose();\r\n                                }\r\n                            );\r\n                        }\r\n                    });\r\n\r\n                    return result;\r\n                });\r\n            })\r\n            .catch((error) => {\r\n                if (!this._disposed) {\r\n                    this._parent.onErrorObservable.notifyObservers(error);\r\n                    this._parent.onErrorObservable.clear();\r\n\r\n                    this.dispose();\r\n                }\r\n\r\n                throw error;\r\n            });\r\n    }\r\n\r\n    private _loadData(data: IGLTFLoaderData): void {\r\n        this._gltf = data.json as IGLTF;\r\n        this._setupData();\r\n\r\n        if (data.bin) {\r\n            const buffers = this._gltf.buffers;\r\n            if (buffers && buffers[0] && !buffers[0].uri) {\r\n                const binaryBuffer = buffers[0];\r\n                if (binaryBuffer.byteLength < data.bin.byteLength - 3 || binaryBuffer.byteLength > data.bin.byteLength) {\r\n                    Logger.Warn(`Binary buffer length (${binaryBuffer.byteLength}) from JSON does not match chunk length (${data.bin.byteLength})`);\r\n                }\r\n\r\n                this._bin = data.bin;\r\n            } else {\r\n                Logger.Warn(\"Unexpected BIN chunk\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setupData(): void {\r\n        ArrayItem.Assign(this._gltf.accessors);\r\n        ArrayItem.Assign(this._gltf.animations);\r\n        ArrayItem.Assign(this._gltf.buffers);\r\n        ArrayItem.Assign(this._gltf.bufferViews);\r\n        ArrayItem.Assign(this._gltf.cameras);\r\n        ArrayItem.Assign(this._gltf.images);\r\n        ArrayItem.Assign(this._gltf.materials);\r\n        ArrayItem.Assign(this._gltf.meshes);\r\n        ArrayItem.Assign(this._gltf.nodes);\r\n        ArrayItem.Assign(this._gltf.samplers);\r\n        ArrayItem.Assign(this._gltf.scenes);\r\n        ArrayItem.Assign(this._gltf.skins);\r\n        ArrayItem.Assign(this._gltf.textures);\r\n\r\n        if (this._gltf.nodes) {\r\n            const nodeParents: { [index: number]: number } = {};\r\n            for (const node of this._gltf.nodes) {\r\n                if (node.children) {\r\n                    for (const index of node.children) {\r\n                        nodeParents[index] = node.index;\r\n                    }\r\n                }\r\n            }\r\n\r\n            const rootNode = this._createRootNode();\r\n            for (const node of this._gltf.nodes) {\r\n                const parentIndex = nodeParents[node.index];\r\n                node.parent = parentIndex === undefined ? rootNode : this._gltf.nodes[parentIndex];\r\n            }\r\n        }\r\n    }\r\n\r\n    private _loadExtensions(): void {\r\n        for (const name in GLTFLoader._RegisteredExtensions) {\r\n            const extension = GLTFLoader._RegisteredExtensions[name].factory(this);\r\n            if (extension.name !== name) {\r\n                Logger.Warn(`The name of the glTF loader extension instance does not match the registered name: ${extension.name} !== ${name}`);\r\n            }\r\n\r\n            this._extensions.push(extension);\r\n            this._parent.onExtensionLoadedObservable.notifyObservers(extension);\r\n        }\r\n\r\n        this._extensions.sort((a, b) => (a.order || Number.MAX_VALUE) - (b.order || Number.MAX_VALUE));\r\n        this._parent.onExtensionLoadedObservable.clear();\r\n    }\r\n\r\n    private _checkExtensions(): void {\r\n        if (this._gltf.extensionsRequired) {\r\n            for (const name of this._gltf.extensionsRequired) {\r\n                const available = this._extensions.some((extension) => extension.name === name && extension.enabled);\r\n                if (!available) {\r\n                    throw new Error(`Require extension ${name} is not available`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _createRootNode(): INode {\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        this._rootBabylonMesh = new Mesh(\"__root__\", this._babylonScene);\r\n        this._rootBabylonMesh._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        this._rootBabylonMesh.setEnabled(false);\r\n\r\n        const rootNode: INode = {\r\n            _babylonTransformNode: this._rootBabylonMesh,\r\n            index: -1,\r\n        };\r\n\r\n        switch (this._parent.coordinateSystemMode) {\r\n            case GLTFLoaderCoordinateSystemMode.AUTO: {\r\n                if (!this._babylonScene.useRightHandedSystem) {\r\n                    rootNode.rotation = [0, 1, 0, 0];\r\n                    rootNode.scale = [1, 1, -1];\r\n                    GLTFLoader._LoadTransform(rootNode, this._rootBabylonMesh);\r\n                }\r\n                break;\r\n            }\r\n            case GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED: {\r\n                this._babylonScene.useRightHandedSystem = true;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`Invalid coordinate system mode (${this._parent.coordinateSystemMode})`);\r\n            }\r\n        }\r\n\r\n        this._parent.onMeshLoadedObservable.notifyObservers(this._rootBabylonMesh);\r\n        return rootNode;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF scene.\r\n     * @param context The context when loading the asset\r\n     * @param scene The glTF scene property\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public loadSceneAsync(context: string, scene: IScene): Promise<void> {\r\n        const extensionPromise = this._extensionsLoadSceneAsync(context, scene);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context} ${scene.name || \"\"}`);\r\n\r\n        if (scene.nodes) {\r\n            for (const index of scene.nodes) {\r\n                const node = ArrayItem.Get(`${context}/nodes/${index}`, this._gltf.nodes, index);\r\n                promises.push(\r\n                    this.loadNodeAsync(`/nodes/${node.index}`, node, (babylonMesh) => {\r\n                        babylonMesh.parent = this._rootBabylonMesh;\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        for (const action of this._postSceneLoadActions) {\r\n            action();\r\n        }\r\n\r\n        promises.push(this._loadAnimationsAsync());\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    private _forEachPrimitive(node: INode, callback: (babylonMesh: AbstractMesh) => void): void {\r\n        if (node._primitiveBabylonMeshes) {\r\n            for (const babylonMesh of node._primitiveBabylonMeshes) {\r\n                callback(babylonMesh);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getGeometries(): Geometry[] {\r\n        const geometries = new Array<Geometry>();\r\n\r\n        const nodes = this._gltf.nodes;\r\n        if (nodes) {\r\n            for (const node of nodes) {\r\n                this._forEachPrimitive(node, (babylonMesh) => {\r\n                    const geometry = (babylonMesh as Mesh).geometry;\r\n                    if (geometry && geometries.indexOf(geometry) === -1) {\r\n                        geometries.push(geometry);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        return geometries;\r\n    }\r\n\r\n    private _getMeshes(): AbstractMesh[] {\r\n        const meshes = new Array<AbstractMesh>();\r\n\r\n        // Root mesh is always first, if available.\r\n        if (this._rootBabylonMesh) {\r\n            meshes.push(this._rootBabylonMesh);\r\n        }\r\n\r\n        const nodes = this._gltf.nodes;\r\n        if (nodes) {\r\n            for (const node of nodes) {\r\n                this._forEachPrimitive(node, (babylonMesh) => {\r\n                    meshes.push(babylonMesh);\r\n                });\r\n            }\r\n        }\r\n\r\n        return meshes;\r\n    }\r\n\r\n    private _getTransformNodes(): TransformNode[] {\r\n        const transformNodes = new Array<TransformNode>();\r\n\r\n        const nodes = this._gltf.nodes;\r\n        if (nodes) {\r\n            for (const node of nodes) {\r\n                if (node._babylonTransformNode && node._babylonTransformNode.getClassName() === \"TransformNode\") {\r\n                    transformNodes.push(node._babylonTransformNode);\r\n                }\r\n                if (node._babylonTransformNodeForSkin) {\r\n                    transformNodes.push(node._babylonTransformNodeForSkin);\r\n                }\r\n            }\r\n        }\r\n\r\n        return transformNodes;\r\n    }\r\n\r\n    private _getSkeletons(): Skeleton[] {\r\n        const skeletons = new Array<Skeleton>();\r\n\r\n        const skins = this._gltf.skins;\r\n        if (skins) {\r\n            for (const skin of skins) {\r\n                if (skin._data) {\r\n                    skeletons.push(skin._data.babylonSkeleton);\r\n                }\r\n            }\r\n        }\r\n\r\n        return skeletons;\r\n    }\r\n\r\n    private _getAnimationGroups(): AnimationGroup[] {\r\n        const animationGroups = new Array<AnimationGroup>();\r\n\r\n        const animations = this._gltf.animations;\r\n        if (animations) {\r\n            for (const animation of animations) {\r\n                if (animation._babylonAnimationGroup) {\r\n                    animationGroups.push(animation._babylonAnimationGroup);\r\n                }\r\n            }\r\n        }\r\n\r\n        return animationGroups;\r\n    }\r\n\r\n    private _startAnimations(): void {\r\n        switch (this._parent.animationStartMode) {\r\n            case GLTFLoaderAnimationStartMode.NONE: {\r\n                // do nothing\r\n                break;\r\n            }\r\n            case GLTFLoaderAnimationStartMode.FIRST: {\r\n                const babylonAnimationGroups = this._getAnimationGroups();\r\n                if (babylonAnimationGroups.length !== 0) {\r\n                    babylonAnimationGroups[0].start(true);\r\n                }\r\n                break;\r\n            }\r\n            case GLTFLoaderAnimationStartMode.ALL: {\r\n                const babylonAnimationGroups = this._getAnimationGroups();\r\n                for (const babylonAnimationGroup of babylonAnimationGroups) {\r\n                    babylonAnimationGroup.start(true);\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                Logger.Error(`Invalid animation start mode (${this._parent.animationStartMode})`);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF node.\r\n     * @param context The context when loading the asset\r\n     * @param node The glTF node property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon mesh when the load is complete\r\n     */\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void = () => {}): Promise<TransformNode> {\r\n        const extensionPromise = this._extensionsLoadNodeAsync(context, node, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (node._babylonTransformNode) {\r\n            throw new Error(`${context}: Invalid recursive node hierarchy`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context} ${node.name || \"\"}`);\r\n\r\n        const loadNode = (babylonTransformNode: TransformNode) => {\r\n            GLTFLoader.AddPointerMetadata(babylonTransformNode, context);\r\n            GLTFLoader._LoadTransform(node, babylonTransformNode);\r\n\r\n            if (node.camera != undefined) {\r\n                const camera = ArrayItem.Get(`${context}/camera`, this._gltf.cameras, node.camera);\r\n                promises.push(\r\n                    this.loadCameraAsync(`/cameras/${camera.index}`, camera, (babylonCamera) => {\r\n                        babylonCamera.parent = babylonTransformNode;\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (node.children) {\r\n                for (const index of node.children) {\r\n                    const childNode = ArrayItem.Get(`${context}/children/${index}`, this._gltf.nodes, index);\r\n                    promises.push(\r\n                        this.loadNodeAsync(`/nodes/${childNode.index}`, childNode, (childBabylonMesh) => {\r\n                            childBabylonMesh.parent = babylonTransformNode;\r\n                        })\r\n                    );\r\n                }\r\n            }\r\n\r\n            assign(babylonTransformNode);\r\n        };\r\n\r\n        if (node.mesh == undefined || node.skin != undefined) {\r\n            const nodeName = node.name || `node${node.index}`;\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            const transformNode = new TransformNode(nodeName, this._babylonScene);\r\n            transformNode._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            if (node.mesh == undefined) {\r\n                node._babylonTransformNode = transformNode;\r\n            } else {\r\n                node._babylonTransformNodeForSkin = transformNode;\r\n            }\r\n            loadNode(transformNode);\r\n        }\r\n\r\n        if (node.mesh != undefined) {\r\n            if (node.skin == undefined) {\r\n                const mesh = ArrayItem.Get(`${context}/mesh`, this._gltf.meshes, node.mesh);\r\n                promises.push(this._loadMeshAsync(`/meshes/${mesh.index}`, node, mesh, loadNode));\r\n            } else {\r\n                // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\r\n                // This code path will place the skinned mesh as a sibling of the skeleton root node without loading the\r\n                // transform, which effectively ignores the transform of the skinned mesh, as per spec.\r\n\r\n                const mesh = ArrayItem.Get(`${context}/mesh`, this._gltf.meshes, node.mesh);\r\n                promises.push(\r\n                    this._loadMeshAsync(`/meshes/${mesh.index}`, node, mesh, (babylonTransformNode) => {\r\n                        // Duplicate the metadata from the skin node to the skinned mesh in case any loader extension added metadata.\r\n                        babylonTransformNode.metadata = node._babylonTransformNodeForSkin!.metadata;\r\n\r\n                        const skin = ArrayItem.Get(`${context}/skin`, this._gltf.skins, node.skin);\r\n                        promises.push(\r\n                            this._loadSkinAsync(`/skins/${skin.index}`, node, skin, (babylonSkeleton) => {\r\n                                this._forEachPrimitive(node, (babylonMesh) => {\r\n                                    babylonMesh.skeleton = babylonSkeleton;\r\n                                });\r\n\r\n                                // Wait until the scene is loaded to ensure the skeleton root node has been loaded.\r\n                                this._postSceneLoadActions.push(() => {\r\n                                    if (skin.skeleton != undefined) {\r\n                                        // Place the skinned mesh node as a sibling of the skeleton root node.\r\n                                        const skeletonRootNode = ArrayItem.Get(`/skins/${skin.index}/skeleton`, this._gltf.nodes, skin.skeleton);\r\n                                        babylonTransformNode.parent = skeletonRootNode.parent!._babylonTransformNode!;\r\n                                    } else {\r\n                                        babylonTransformNode.parent = this._rootBabylonMesh;\r\n                                    }\r\n                                });\r\n                            })\r\n                        );\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._forEachPrimitive(node, (babylonMesh) => {\r\n                if ((babylonMesh as Mesh).geometry && (babylonMesh as Mesh).geometry!.useBoundingInfoFromGeometry) {\r\n                    // simply apply the world matrices to the bounding info - the extends are already ok\r\n                    babylonMesh._updateBoundingInfo();\r\n                } else {\r\n                    babylonMesh.refreshBoundingInfo(true);\r\n                }\r\n            });\r\n\r\n            return node._babylonTransformNode!;\r\n        });\r\n    }\r\n\r\n    private _loadMeshAsync(context: string, node: INode, mesh: IMesh, assign: (babylonTransformNode: TransformNode) => void): Promise<TransformNode> {\r\n        const primitives = mesh.primitives;\r\n        if (!primitives || !primitives.length) {\r\n            throw new Error(`${context}: Primitives are missing`);\r\n        }\r\n\r\n        if (primitives[0].index == undefined) {\r\n            ArrayItem.Assign(primitives);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context} ${mesh.name || \"\"}`);\r\n\r\n        const name = node.name || `node${node.index}`;\r\n\r\n        if (primitives.length === 1) {\r\n            const primitive = mesh.primitives[0];\r\n            promises.push(\r\n                this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, name, node, mesh, primitive, (babylonMesh) => {\r\n                    node._babylonTransformNode = babylonMesh;\r\n                    node._primitiveBabylonMeshes = [babylonMesh];\r\n                })\r\n            );\r\n        } else {\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            node._babylonTransformNode = new TransformNode(name, this._babylonScene);\r\n            node._babylonTransformNode._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            node._primitiveBabylonMeshes = [];\r\n            for (const primitive of primitives) {\r\n                promises.push(\r\n                    this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, `${name}_primitive${primitive.index}`, node, mesh, primitive, (babylonMesh) => {\r\n                        babylonMesh.parent = node._babylonTransformNode!;\r\n                        node._primitiveBabylonMeshes!.push(babylonMesh);\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        assign(node._babylonTransformNode!);\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return node._babylonTransformNode!;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @hidden Define this method to modify the default behavior when loading data for mesh primitives.\r\n     * @param context The context when loading the asset\r\n     * @param name The mesh name when loading the asset\r\n     * @param node The glTF node when loading the asset\r\n     * @param mesh The glTF mesh when loading the asset\r\n     * @param primitive The glTF mesh primitive property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded mesh when the load is complete or null if not handled\r\n     */\r\n    public _loadMeshPrimitiveAsync(\r\n        context: string,\r\n        name: string,\r\n        node: INode,\r\n        mesh: IMesh,\r\n        primitive: IMeshPrimitive,\r\n        assign: (babylonMesh: AbstractMesh) => void\r\n    ): Promise<AbstractMesh> {\r\n        const extensionPromise = this._extensionsLoadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        this.logOpen(`${context}`);\r\n\r\n        const shouldInstance = this._disableInstancedMesh === 0 && this._parent.createInstances && node.skin == undefined && !mesh.primitives[0].targets;\r\n\r\n        let babylonAbstractMesh: AbstractMesh;\r\n        let promise: Promise<any>;\r\n\r\n        if (shouldInstance && primitive._instanceData) {\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            babylonAbstractMesh = primitive._instanceData.babylonSourceMesh.createInstance(name) as InstancedMesh;\r\n            babylonAbstractMesh._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            promise = primitive._instanceData.promise;\r\n        } else {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            const babylonMesh = new Mesh(name, this._babylonScene);\r\n            babylonMesh._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            babylonMesh.overrideMaterialSideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n\r\n            this._createMorphTargets(context, node, mesh, primitive, babylonMesh);\r\n            promises.push(\r\n                this._loadVertexDataAsync(context, primitive, babylonMesh).then((babylonGeometry) => {\r\n                    return this._loadMorphTargetsAsync(context, primitive, babylonMesh, babylonGeometry).then(() => {\r\n                        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n                        babylonGeometry.applyToMesh(babylonMesh);\r\n                        babylonGeometry._parentContainer = this._assetContainer;\r\n                        this._babylonScene._blockEntityCollection = false;\r\n                    });\r\n                })\r\n            );\r\n\r\n            const babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\r\n            if (primitive.material == undefined) {\r\n                let babylonMaterial = this._defaultBabylonMaterialData[babylonDrawMode];\r\n                if (!babylonMaterial) {\r\n                    babylonMaterial = this._createDefaultMaterial(\"__GLTFLoader._default\", babylonDrawMode);\r\n                    this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\r\n                    this._defaultBabylonMaterialData[babylonDrawMode] = babylonMaterial;\r\n                }\r\n                babylonMesh.material = babylonMaterial;\r\n            } else if (!this.parent.skipMaterials) {\r\n                const material = ArrayItem.Get(`${context}/material`, this._gltf.materials, primitive.material);\r\n                promises.push(\r\n                    this._loadMaterialAsync(`/materials/${material.index}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {\r\n                        babylonMesh.material = babylonMaterial;\r\n                    })\r\n                );\r\n            }\r\n\r\n            promise = Promise.all(promises);\r\n\r\n            if (shouldInstance) {\r\n                primitive._instanceData = {\r\n                    babylonSourceMesh: babylonMesh,\r\n                    promise: promise,\r\n                };\r\n            }\r\n\r\n            babylonAbstractMesh = babylonMesh;\r\n        }\r\n\r\n        GLTFLoader.AddPointerMetadata(babylonAbstractMesh, context);\r\n        this._parent.onMeshLoadedObservable.notifyObservers(babylonAbstractMesh);\r\n        assign(babylonAbstractMesh);\r\n\r\n        this.logClose();\r\n\r\n        return promise.then(() => {\r\n            return babylonAbstractMesh;\r\n        });\r\n    }\r\n\r\n    private _loadVertexDataAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh): Promise<Geometry> {\r\n        const extensionPromise = this._extensionsLoadVertexDataAsync(context, primitive, babylonMesh);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const attributes = primitive.attributes;\r\n        if (!attributes) {\r\n            throw new Error(`${context}: Attributes are missing`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const babylonGeometry = new Geometry(babylonMesh.name, this._babylonScene);\r\n\r\n        if (primitive.indices == undefined) {\r\n            babylonMesh.isUnIndexed = true;\r\n        } else {\r\n            const accessor = ArrayItem.Get(`${context}/indices`, this._gltf.accessors, primitive.indices);\r\n            promises.push(\r\n                this._loadIndicesAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\r\n                    babylonGeometry.setIndices(data);\r\n                })\r\n            );\r\n        }\r\n\r\n        const loadAttribute = (attribute: string, kind: string, callback?: (accessor: IAccessor) => void) => {\r\n            if (attributes[attribute] == undefined) {\r\n                return;\r\n            }\r\n\r\n            babylonMesh._delayInfo = babylonMesh._delayInfo || [];\r\n            if (babylonMesh._delayInfo.indexOf(kind) === -1) {\r\n                babylonMesh._delayInfo.push(kind);\r\n            }\r\n\r\n            const accessor = ArrayItem.Get(`${context}/attributes/${attribute}`, this._gltf.accessors, attributes[attribute]);\r\n            promises.push(\r\n                this._loadVertexAccessorAsync(`/accessors/${accessor.index}`, accessor, kind).then((babylonVertexBuffer) => {\r\n                    if (babylonVertexBuffer.getKind() === VertexBuffer.PositionKind && !this.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton) {\r\n                        const mmin = accessor.min as [number, number, number],\r\n                            mmax = accessor.max as [number, number, number];\r\n                        if (mmin !== undefined && mmax !== undefined) {\r\n                            if (accessor.normalized && accessor.componentType !== AccessorComponentType.FLOAT) {\r\n                                let divider = 1;\r\n                                switch (accessor.componentType) {\r\n                                    case AccessorComponentType.BYTE:\r\n                                        divider = 127.0;\r\n                                        break;\r\n                                    case AccessorComponentType.UNSIGNED_BYTE:\r\n                                        divider = 255.0;\r\n                                        break;\r\n                                    case AccessorComponentType.SHORT:\r\n                                        divider = 32767.0;\r\n                                        break;\r\n                                    case AccessorComponentType.UNSIGNED_SHORT:\r\n                                        divider = 65535.0;\r\n                                        break;\r\n                                }\r\n                                for (let i = 0; i < 3; ++i) {\r\n                                    mmin[i] = Math.max(mmin[i] / divider, -1.0);\r\n                                    mmax[i] = Math.max(mmax[i] / divider, -1.0);\r\n                                }\r\n                            }\r\n                            const min = TmpVectors.Vector3[0],\r\n                                max = TmpVectors.Vector3[1];\r\n                            min.copyFromFloats(...mmin);\r\n                            max.copyFromFloats(...mmax);\r\n                            babylonGeometry._boundingInfo = new BoundingInfo(min, max);\r\n                            babylonGeometry.useBoundingInfoFromGeometry = true;\r\n                        }\r\n                    }\r\n                    babylonGeometry.setVerticesBuffer(babylonVertexBuffer, accessor.count);\r\n                })\r\n            );\r\n\r\n            if (kind == VertexBuffer.MatricesIndicesExtraKind) {\r\n                babylonMesh.numBoneInfluencers = 8;\r\n            }\r\n\r\n            if (callback) {\r\n                callback(accessor);\r\n            }\r\n        };\r\n\r\n        loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\r\n        loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\r\n        loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\r\n        loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\r\n        loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\r\n        loadAttribute(\"TEXCOORD_2\", VertexBuffer.UV3Kind);\r\n        loadAttribute(\"TEXCOORD_3\", VertexBuffer.UV4Kind);\r\n        loadAttribute(\"TEXCOORD_4\", VertexBuffer.UV5Kind);\r\n        loadAttribute(\"TEXCOORD_5\", VertexBuffer.UV6Kind);\r\n        loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\r\n        loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\r\n        loadAttribute(\"JOINTS_1\", VertexBuffer.MatricesIndicesExtraKind);\r\n        loadAttribute(\"WEIGHTS_1\", VertexBuffer.MatricesWeightsExtraKind);\r\n        loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind, (accessor) => {\r\n            if (accessor.type === AccessorType.VEC4) {\r\n                babylonMesh.hasVertexAlpha = true;\r\n            }\r\n        });\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonGeometry;\r\n        });\r\n    }\r\n\r\n    private _createMorphTargets(context: string, node: INode, mesh: IMesh, primitive: IMeshPrimitive, babylonMesh: Mesh): void {\r\n        if (!primitive.targets) {\r\n            return;\r\n        }\r\n\r\n        if (node._numMorphTargets == undefined) {\r\n            node._numMorphTargets = primitive.targets.length;\r\n        } else if (primitive.targets.length !== node._numMorphTargets) {\r\n            throw new Error(`${context}: Primitives do not have the same number of targets`);\r\n        }\r\n\r\n        const targetNames = mesh.extras ? mesh.extras.targetNames : null;\r\n\r\n        babylonMesh.morphTargetManager = new MorphTargetManager(babylonMesh.getScene());\r\n        babylonMesh.morphTargetManager.areUpdatesFrozen = true;\r\n\r\n        for (let index = 0; index < primitive.targets.length; index++) {\r\n            const weight = node.weights ? node.weights[index] : mesh.weights ? mesh.weights[index] : 0;\r\n            const name = targetNames ? targetNames[index] : `morphTarget${index}`;\r\n            babylonMesh.morphTargetManager.addTarget(new MorphTarget(name, weight, babylonMesh.getScene()));\r\n            // TODO: tell the target whether it has positions, normals, tangents\r\n        }\r\n    }\r\n\r\n    private _loadMorphTargetsAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh, babylonGeometry: Geometry): Promise<void> {\r\n        if (!primitive.targets) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const morphTargetManager = babylonMesh.morphTargetManager!;\r\n        for (let index = 0; index < morphTargetManager.numTargets; index++) {\r\n            const babylonMorphTarget = morphTargetManager.getTarget(index);\r\n            promises.push(this._loadMorphTargetVertexDataAsync(`${context}/targets/${index}`, babylonGeometry, primitive.targets[index], babylonMorphTarget));\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            morphTargetManager.areUpdatesFrozen = false;\r\n        });\r\n    }\r\n\r\n    private _loadMorphTargetVertexDataAsync(context: string, babylonGeometry: Geometry, attributes: { [name: string]: number }, babylonMorphTarget: MorphTarget): Promise<void> {\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const loadAttribute = (attribute: string, kind: string, setData: (babylonVertexBuffer: VertexBuffer, data: Float32Array) => void) => {\r\n            if (attributes[attribute] == undefined) {\r\n                return;\r\n            }\r\n\r\n            const babylonVertexBuffer = babylonGeometry.getVertexBuffer(kind);\r\n            if (!babylonVertexBuffer) {\r\n                return;\r\n            }\r\n\r\n            const accessor = ArrayItem.Get(`${context}/${attribute}`, this._gltf.accessors, attributes[attribute]);\r\n            promises.push(\r\n                this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\r\n                    setData(babylonVertexBuffer, data);\r\n                })\r\n            );\r\n        };\r\n\r\n        loadAttribute(\"POSITION\", VertexBuffer.PositionKind, (babylonVertexBuffer, data) => {\r\n            const positions = new Float32Array(data.length);\r\n            babylonVertexBuffer.forEach(data.length, (value, index) => {\r\n                positions[index] = data[index] + value;\r\n            });\r\n\r\n            babylonMorphTarget.setPositions(positions);\r\n        });\r\n\r\n        loadAttribute(\"NORMAL\", VertexBuffer.NormalKind, (babylonVertexBuffer, data) => {\r\n            const normals = new Float32Array(data.length);\r\n            babylonVertexBuffer.forEach(normals.length, (value, index) => {\r\n                normals[index] = data[index] + value;\r\n            });\r\n\r\n            babylonMorphTarget.setNormals(normals);\r\n        });\r\n\r\n        loadAttribute(\"TANGENT\", VertexBuffer.TangentKind, (babylonVertexBuffer, data) => {\r\n            const tangents = new Float32Array((data.length / 3) * 4);\r\n            let dataIndex = 0;\r\n            babylonVertexBuffer.forEach((data.length / 3) * 4, (value, index) => {\r\n                // Tangent data for morph targets is stored as xyz delta.\r\n                // The vertexData.tangent is stored as xyzw.\r\n                // So we need to skip every fourth vertexData.tangent.\r\n                if ((index + 1) % 4 !== 0) {\r\n                    tangents[dataIndex] = data[dataIndex] + value;\r\n                    dataIndex++;\r\n                }\r\n            });\r\n            babylonMorphTarget.setTangents(tangents);\r\n        });\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    private static _LoadTransform(node: INode, babylonNode: TransformNode): void {\r\n        // Ignore the TRS of skinned nodes.\r\n        // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\r\n        if (node.skin != undefined) {\r\n            return;\r\n        }\r\n\r\n        let position = Vector3.Zero();\r\n        let rotation = Quaternion.Identity();\r\n        let scaling = Vector3.One();\r\n\r\n        if (node.matrix) {\r\n            const matrix = Matrix.FromArray(node.matrix);\r\n            matrix.decompose(scaling, rotation, position);\r\n        } else {\r\n            if (node.translation) {\r\n                position = Vector3.FromArray(node.translation);\r\n            }\r\n            if (node.rotation) {\r\n                rotation = Quaternion.FromArray(node.rotation);\r\n            }\r\n            if (node.scale) {\r\n                scaling = Vector3.FromArray(node.scale);\r\n            }\r\n        }\r\n\r\n        babylonNode.position = position;\r\n        babylonNode.rotationQuaternion = rotation;\r\n        babylonNode.scaling = scaling;\r\n    }\r\n\r\n    private _loadSkinAsync(context: string, node: INode, skin: ISkin, assign: (babylonSkeleton: Skeleton) => void): Promise<void> {\r\n        const extensionPromise = this._extensionsLoadSkinAsync(context, node, skin);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (skin._data) {\r\n            assign(skin._data.babylonSkeleton);\r\n            return skin._data.promise;\r\n        }\r\n\r\n        const skeletonId = `skeleton${skin.index}`;\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const babylonSkeleton = new Skeleton(skin.name || skeletonId, skeletonId, this._babylonScene);\r\n        babylonSkeleton._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n\r\n        this._loadBones(context, skin, babylonSkeleton);\r\n        const promise = this._loadSkinInverseBindMatricesDataAsync(context, skin).then((inverseBindMatricesData) => {\r\n            this._updateBoneMatrices(babylonSkeleton, inverseBindMatricesData);\r\n        });\r\n\r\n        skin._data = {\r\n            babylonSkeleton: babylonSkeleton,\r\n            promise: promise,\r\n        };\r\n\r\n        assign(babylonSkeleton);\r\n\r\n        return promise;\r\n    }\r\n\r\n    private _loadBones(context: string, skin: ISkin, babylonSkeleton: Skeleton): void {\r\n        if (skin.skeleton == undefined || this._parent.alwaysComputeSkeletonRootNode) {\r\n            const rootNode = this._findSkeletonRootNode(`${context}/joints`, skin.joints);\r\n            if (rootNode) {\r\n                if (skin.skeleton === undefined) {\r\n                    skin.skeleton = rootNode.index;\r\n                } else {\r\n                    const isParent = (a: INode, b: INode): boolean => {\r\n                        for (; b.parent; b = b.parent) {\r\n                            if (b.parent === a) {\r\n                                return true;\r\n                            }\r\n                        }\r\n\r\n                        return false;\r\n                    };\r\n\r\n                    const skeletonNode = ArrayItem.Get(`${context}/skeleton`, this._gltf.nodes, skin.skeleton);\r\n                    if (skeletonNode !== rootNode && !isParent(skeletonNode, rootNode)) {\r\n                        Logger.Warn(`${context}/skeleton: Overriding with nearest common ancestor as skeleton node is not a common root`);\r\n                        skin.skeleton = rootNode.index;\r\n                    }\r\n                }\r\n            } else {\r\n                Logger.Warn(`${context}: Failed to find common root`);\r\n            }\r\n        }\r\n\r\n        const babylonBones: { [index: number]: Bone } = {};\r\n        for (const index of skin.joints) {\r\n            const node = ArrayItem.Get(`${context}/joints/${index}`, this._gltf.nodes, index);\r\n            this._loadBone(node, skin, babylonSkeleton, babylonBones);\r\n        }\r\n    }\r\n\r\n    private _findSkeletonRootNode(context: string, joints: Array<number>): Nullable<INode> {\r\n        if (joints.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        const paths: { [joint: number]: Array<INode> } = {};\r\n        for (const index of joints) {\r\n            const path = new Array<INode>();\r\n            let node = ArrayItem.Get(`${context}/${index}`, this._gltf.nodes, index);\r\n            while (node.index !== -1) {\r\n                path.unshift(node);\r\n                node = node.parent!;\r\n            }\r\n            paths[index] = path;\r\n        }\r\n\r\n        let rootNode: Nullable<INode> = null;\r\n        for (let i = 0; ; ++i) {\r\n            let path = paths[joints[0]];\r\n            if (i >= path.length) {\r\n                return rootNode;\r\n            }\r\n\r\n            const node = path[i];\r\n            for (let j = 1; j < joints.length; ++j) {\r\n                path = paths[joints[j]];\r\n                if (i >= path.length || node !== path[i]) {\r\n                    return rootNode;\r\n                }\r\n            }\r\n\r\n            rootNode = node;\r\n        }\r\n    }\r\n\r\n    private _loadBone(node: INode, skin: ISkin, babylonSkeleton: Skeleton, babylonBones: { [index: number]: Bone }): Bone {\r\n        let babylonBone = babylonBones[node.index];\r\n        if (babylonBone) {\r\n            return babylonBone;\r\n        }\r\n\r\n        let parentBabylonBone: Nullable<Bone> = null;\r\n        if (node.index !== skin.skeleton) {\r\n            if (node.parent && node.parent.index !== -1) {\r\n                parentBabylonBone = this._loadBone(node.parent, skin, babylonSkeleton, babylonBones);\r\n            } else if (skin.skeleton !== undefined) {\r\n                Logger.Warn(`/skins/${skin.index}/skeleton: Skeleton node is not a common root`);\r\n            }\r\n        }\r\n\r\n        const boneIndex = skin.joints.indexOf(node.index);\r\n        babylonBone = new Bone(node.name || `joint${node.index}`, babylonSkeleton, parentBabylonBone, this._getNodeMatrix(node), null, null, boneIndex);\r\n        babylonBones[node.index] = babylonBone;\r\n\r\n        // Wait until the scene is loaded to ensure the transform nodes are loaded.\r\n        this._postSceneLoadActions.push(() => {\r\n            // Link the Babylon bone with the corresponding Babylon transform node.\r\n            // A glTF joint is a pointer to a glTF node in the glTF node hierarchy similar to Unity3D.\r\n            babylonBone.linkTransformNode(node._babylonTransformNode!);\r\n        });\r\n\r\n        return babylonBone;\r\n    }\r\n\r\n    private _loadSkinInverseBindMatricesDataAsync(context: string, skin: ISkin): Promise<Nullable<Float32Array>> {\r\n        if (skin.inverseBindMatrices == undefined) {\r\n            return Promise.resolve(null);\r\n        }\r\n\r\n        const accessor = ArrayItem.Get(`${context}/inverseBindMatrices`, this._gltf.accessors, skin.inverseBindMatrices);\r\n        return this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor);\r\n    }\r\n\r\n    private _updateBoneMatrices(babylonSkeleton: Skeleton, inverseBindMatricesData: Nullable<Float32Array>): void {\r\n        for (const babylonBone of babylonSkeleton.bones) {\r\n            const baseMatrix = Matrix.Identity();\r\n            const boneIndex = babylonBone._index!;\r\n            if (inverseBindMatricesData && boneIndex !== -1) {\r\n                Matrix.FromArrayToRef(inverseBindMatricesData, boneIndex * 16, baseMatrix);\r\n                baseMatrix.invertToRef(baseMatrix);\r\n            }\r\n\r\n            const babylonParentBone = babylonBone.getParent();\r\n            if (babylonParentBone) {\r\n                baseMatrix.multiplyToRef(babylonParentBone.getInvertedAbsoluteTransform(), baseMatrix);\r\n            }\r\n\r\n            babylonBone.updateMatrix(baseMatrix, false, false);\r\n            babylonBone._updateDifferenceMatrix(undefined, false);\r\n        }\r\n    }\r\n\r\n    private _getNodeMatrix(node: INode): Matrix {\r\n        return node.matrix\r\n            ? Matrix.FromArray(node.matrix)\r\n            : Matrix.Compose(\r\n                  node.scale ? Vector3.FromArray(node.scale) : Vector3.One(),\r\n                  node.rotation ? Quaternion.FromArray(node.rotation) : Quaternion.Identity(),\r\n                  node.translation ? Vector3.FromArray(node.translation) : Vector3.Zero()\r\n              );\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF camera.\r\n     * @param context The context when loading the asset\r\n     * @param camera The glTF camera property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon camera when the load is complete\r\n     */\r\n    public loadCameraAsync(context: string, camera: ICamera, assign: (babylonCamera: Camera) => void = () => {}): Promise<Camera> {\r\n        const extensionPromise = this._extensionsLoadCameraAsync(context, camera, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context} ${camera.name || \"\"}`);\r\n\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const babylonCamera = new FreeCamera(camera.name || `camera${camera.index}`, Vector3.Zero(), this._babylonScene, false);\r\n        babylonCamera._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        babylonCamera.ignoreParentScaling = true;\r\n\r\n        babylonCamera.rotation = new Vector3(0, Math.PI, 0);\r\n\r\n        switch (camera.type) {\r\n            case CameraType.PERSPECTIVE: {\r\n                const perspective = camera.perspective;\r\n                if (!perspective) {\r\n                    throw new Error(`${context}: Camera perspective properties are missing`);\r\n                }\r\n\r\n                babylonCamera.fov = perspective.yfov;\r\n                babylonCamera.minZ = perspective.znear;\r\n                babylonCamera.maxZ = perspective.zfar || 0;\r\n                break;\r\n            }\r\n            case CameraType.ORTHOGRAPHIC: {\r\n                if (!camera.orthographic) {\r\n                    throw new Error(`${context}: Camera orthographic properties are missing`);\r\n                }\r\n\r\n                babylonCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\r\n                babylonCamera.orthoLeft = -camera.orthographic.xmag;\r\n                babylonCamera.orthoRight = camera.orthographic.xmag;\r\n                babylonCamera.orthoBottom = -camera.orthographic.ymag;\r\n                babylonCamera.orthoTop = camera.orthographic.ymag;\r\n                babylonCamera.minZ = camera.orthographic.znear;\r\n                babylonCamera.maxZ = camera.orthographic.zfar;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}: Invalid camera type (${camera.type})`);\r\n            }\r\n        }\r\n\r\n        GLTFLoader.AddPointerMetadata(babylonCamera, context);\r\n        this._parent.onCameraLoadedObservable.notifyObservers(babylonCamera);\r\n        assign(babylonCamera);\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonCamera;\r\n        });\r\n    }\r\n\r\n    private _loadAnimationsAsync(): Promise<void> {\r\n        const animations = this._gltf.animations;\r\n        if (!animations) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const promises = new Array<Promise<void>>();\r\n\r\n        for (let index = 0; index < animations.length; index++) {\r\n            const animation = animations[index];\r\n            promises.push(\r\n                this.loadAnimationAsync(`/animations/${animation.index}`, animation).then((animationGroup) => {\r\n                    // Delete the animation group if it ended up not having any animations in it.\r\n                    if (animationGroup.targetedAnimations.length === 0) {\r\n                        animationGroup.dispose();\r\n                    }\r\n                })\r\n            );\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF animation.\r\n     * @param context The context when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @returns A promise that resolves with the loaded Babylon animation group when the load is complete\r\n     */\r\n    public loadAnimationAsync(context: string, animation: IAnimation): Promise<AnimationGroup> {\r\n        const promise = this._extensionsLoadAnimationAsync(context, animation);\r\n        if (promise) {\r\n            return promise;\r\n        }\r\n\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const babylonAnimationGroup = new AnimationGroup(animation.name || `animation${animation.index}`, this._babylonScene);\r\n        babylonAnimationGroup._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        animation._babylonAnimationGroup = babylonAnimationGroup;\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        ArrayItem.Assign(animation.channels);\r\n        ArrayItem.Assign(animation.samplers);\r\n\r\n        for (const channel of animation.channels) {\r\n            promises.push(this._loadAnimationChannelAsync(`${context}/channels/${channel.index}`, context, animation, channel, babylonAnimationGroup));\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            babylonAnimationGroup.normalize(0);\r\n            return babylonAnimationGroup;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @hidden Loads a glTF animation channel.\r\n     * @param context The context when loading the asset\r\n     * @param animationContext The context of the animation when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @param channel The glTF animation channel property\r\n     * @param babylonAnimationGroup The babylon animation group property\r\n     * @param animationTargetOverride The babylon animation channel target override property. My be null.\r\n     * @returns A void promise when the channel load is complete\r\n     */\r\n    public _loadAnimationChannelAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        channel: IAnimationChannel,\r\n        babylonAnimationGroup: AnimationGroup,\r\n        animationTargetOverride: Nullable<IAnimatable> = null\r\n    ): Promise<void> {\r\n        if (channel.target.node == undefined) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const targetNode = ArrayItem.Get(`${context}/target/node`, this._gltf.nodes, channel.target.node);\r\n\r\n        // Ignore animations that have no animation targets.\r\n        if (\r\n            (channel.target.path === AnimationChannelTargetPath.WEIGHTS && !targetNode._numMorphTargets) ||\r\n            (channel.target.path !== AnimationChannelTargetPath.WEIGHTS && !targetNode._babylonTransformNode)\r\n        ) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const sampler = ArrayItem.Get(`${context}/sampler`, animation.samplers, channel.sampler);\r\n        return this._loadAnimationSamplerAsync(`${animationContext}/samplers/${channel.sampler}`, sampler).then((data) => {\r\n            let targetPath: string;\r\n            let animationType: number;\r\n            switch (channel.target.path) {\r\n                case AnimationChannelTargetPath.TRANSLATION: {\r\n                    targetPath = \"position\";\r\n                    animationType = Animation.ANIMATIONTYPE_VECTOR3;\r\n                    break;\r\n                }\r\n                case AnimationChannelTargetPath.ROTATION: {\r\n                    targetPath = \"rotationQuaternion\";\r\n                    animationType = Animation.ANIMATIONTYPE_QUATERNION;\r\n                    break;\r\n                }\r\n                case AnimationChannelTargetPath.SCALE: {\r\n                    targetPath = \"scaling\";\r\n                    animationType = Animation.ANIMATIONTYPE_VECTOR3;\r\n                    break;\r\n                }\r\n                case AnimationChannelTargetPath.WEIGHTS: {\r\n                    targetPath = \"influence\";\r\n                    animationType = Animation.ANIMATIONTYPE_FLOAT;\r\n                    break;\r\n                }\r\n                default: {\r\n                    throw new Error(`${context}/target/path: Invalid value (${channel.target.path})`);\r\n                }\r\n            }\r\n\r\n            let outputBufferOffset = 0;\r\n            let getNextOutputValue: (scale: number) => Vector3 | Quaternion | Array<number>;\r\n            switch (targetPath) {\r\n                case \"position\": {\r\n                    getNextOutputValue = (scale) => {\r\n                        const value = Vector3.FromArray(data.output, outputBufferOffset).scaleInPlace(scale);\r\n                        outputBufferOffset += 3;\r\n                        return value;\r\n                    };\r\n                    break;\r\n                }\r\n                case \"rotationQuaternion\": {\r\n                    getNextOutputValue = (scale) => {\r\n                        const value = Quaternion.FromArray(data.output, outputBufferOffset).scaleInPlace(scale);\r\n                        outputBufferOffset += 4;\r\n                        return value;\r\n                    };\r\n                    break;\r\n                }\r\n                case \"scaling\": {\r\n                    getNextOutputValue = (scale) => {\r\n                        const value = Vector3.FromArray(data.output, outputBufferOffset).scaleInPlace(scale);\r\n                        outputBufferOffset += 3;\r\n                        return value;\r\n                    };\r\n                    break;\r\n                }\r\n                case \"influence\": {\r\n                    getNextOutputValue = (scale) => {\r\n                        const value = new Array<number>(targetNode._numMorphTargets!);\r\n                        for (let i = 0; i < targetNode._numMorphTargets!; i++) {\r\n                            value[i] = data.output[outputBufferOffset++] * scale;\r\n                        }\r\n                        return value;\r\n                    };\r\n                    break;\r\n                }\r\n            }\r\n\r\n            let getNextKey: (frameIndex: number) => IAnimationKey;\r\n            switch (data.interpolation) {\r\n                case AnimationSamplerInterpolation.STEP: {\r\n                    getNextKey = (frameIndex) => ({\r\n                        frame: data.input[frameIndex] * this.parent.targetFps,\r\n                        value: getNextOutputValue(1),\r\n                        interpolation: AnimationKeyInterpolation.STEP,\r\n                    });\r\n                    break;\r\n                }\r\n                case AnimationSamplerInterpolation.LINEAR: {\r\n                    getNextKey = (frameIndex) => ({\r\n                        frame: data.input[frameIndex] * this.parent.targetFps,\r\n                        value: getNextOutputValue(1),\r\n                    });\r\n                    break;\r\n                }\r\n                case AnimationSamplerInterpolation.CUBICSPLINE: {\r\n                    const invTargetFps = 1 / this.parent.targetFps;\r\n                    getNextKey = (frameIndex) => ({\r\n                        frame: data.input[frameIndex] * this.parent.targetFps,\r\n                        inTangent: getNextOutputValue(invTargetFps),\r\n                        value: getNextOutputValue(1),\r\n                        outTangent: getNextOutputValue(invTargetFps),\r\n                    });\r\n                    break;\r\n                }\r\n            }\r\n\r\n            const keys = new Array(data.input.length);\r\n            for (let frameIndex = 0; frameIndex < data.input.length; frameIndex++) {\r\n                keys[frameIndex] = getNextKey!(frameIndex);\r\n            }\r\n\r\n            if (targetPath === \"influence\") {\r\n                for (let targetIndex = 0; targetIndex < targetNode._numMorphTargets!; targetIndex++) {\r\n                    const animationName = `${babylonAnimationGroup.name}_channel${babylonAnimationGroup.targetedAnimations.length}`;\r\n                    const babylonAnimation = new Animation(animationName, targetPath, this.parent.targetFps, animationType);\r\n                    babylonAnimation.setKeys(\r\n                        keys.map((key) => ({\r\n                            frame: key.frame,\r\n                            inTangent: key.inTangent ? key.inTangent[targetIndex] : undefined,\r\n                            value: key.value[targetIndex],\r\n                            outTangent: key.outTangent ? key.outTangent[targetIndex] : undefined,\r\n                        }))\r\n                    );\r\n\r\n                    this._forEachPrimitive(targetNode, (babylonAbstractMesh: AbstractMesh) => {\r\n                        const babylonMesh = babylonAbstractMesh as Mesh;\r\n                        const morphTarget = babylonMesh.morphTargetManager!.getTarget(targetIndex);\r\n                        const babylonAnimationClone = babylonAnimation.clone();\r\n                        morphTarget.animations.push(babylonAnimationClone);\r\n                        babylonAnimationGroup.addTargetedAnimation(babylonAnimationClone, morphTarget);\r\n                    });\r\n                }\r\n            } else {\r\n                const animationName = `${babylonAnimationGroup.name}_channel${babylonAnimationGroup.targetedAnimations.length}`;\r\n                const babylonAnimation = new Animation(animationName, targetPath, this.parent.targetFps, animationType);\r\n                babylonAnimation.setKeys(keys);\r\n\r\n                if (animationTargetOverride != null && animationTargetOverride.animations != null) {\r\n                    animationTargetOverride.animations.push(babylonAnimation);\r\n                    babylonAnimationGroup.addTargetedAnimation(babylonAnimation, animationTargetOverride);\r\n                } else {\r\n                    targetNode._babylonTransformNode!.animations.push(babylonAnimation);\r\n                    babylonAnimationGroup.addTargetedAnimation(babylonAnimation, targetNode._babylonTransformNode!);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private _loadAnimationSamplerAsync(context: string, sampler: IAnimationSampler): Promise<_IAnimationSamplerData> {\r\n        if (sampler._data) {\r\n            return sampler._data;\r\n        }\r\n\r\n        const interpolation = sampler.interpolation || AnimationSamplerInterpolation.LINEAR;\r\n        switch (interpolation) {\r\n            case AnimationSamplerInterpolation.STEP:\r\n            case AnimationSamplerInterpolation.LINEAR:\r\n            case AnimationSamplerInterpolation.CUBICSPLINE: {\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}/interpolation: Invalid value (${sampler.interpolation})`);\r\n            }\r\n        }\r\n\r\n        const inputAccessor = ArrayItem.Get(`${context}/input`, this._gltf.accessors, sampler.input);\r\n        const outputAccessor = ArrayItem.Get(`${context}/output`, this._gltf.accessors, sampler.output);\r\n        sampler._data = Promise.all([\r\n            this._loadFloatAccessorAsync(`/accessors/${inputAccessor.index}`, inputAccessor),\r\n            this._loadFloatAccessorAsync(`/accessors/${outputAccessor.index}`, outputAccessor),\r\n        ]).then(([inputData, outputData]) => {\r\n            return {\r\n                input: inputData,\r\n                interpolation: interpolation,\r\n                output: outputData,\r\n            };\r\n        });\r\n\r\n        return sampler._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF buffer.\r\n     * @param context The context when loading the asset\r\n     * @param buffer The glTF buffer property\r\n     * @param byteOffset The byte offset to use\r\n     * @param byteLength The byte length to use\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Promise<ArrayBufferView> {\r\n        const extensionPromise = this._extensionsLoadBufferAsync(context, buffer, byteOffset, byteLength);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (!buffer._data) {\r\n            if (buffer.uri) {\r\n                buffer._data = this.loadUriAsync(`${context}/uri`, buffer, buffer.uri);\r\n            } else {\r\n                if (!this._bin) {\r\n                    throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);\r\n                }\r\n\r\n                buffer._data = this._bin.readAsync(0, buffer.byteLength);\r\n            }\r\n        }\r\n\r\n        return buffer._data.then((data) => {\r\n            try {\r\n                return new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);\r\n            } catch (e) {\r\n                throw new Error(`${context}: ${e.message}`);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF buffer view.\r\n     * @param context The context when loading the asset\r\n     * @param bufferView The glTF buffer view property\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadBufferViewAsync(context: string, bufferView: IBufferView): Promise<ArrayBufferView> {\r\n        const extensionPromise = this._extensionsLoadBufferViewAsync(context, bufferView);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (bufferView._data) {\r\n            return bufferView._data;\r\n        }\r\n\r\n        const buffer = ArrayItem.Get(`${context}/buffer`, this._gltf.buffers, bufferView.buffer);\r\n        bufferView._data = this.loadBufferAsync(`/buffers/${buffer.index}`, buffer, bufferView.byteOffset || 0, bufferView.byteLength);\r\n\r\n        return bufferView._data;\r\n    }\r\n\r\n    private _loadAccessorAsync(context: string, accessor: IAccessor, constructor: TypedArrayConstructor): Promise<ArrayBufferView> {\r\n        if (accessor._data) {\r\n            return accessor._data;\r\n        }\r\n\r\n        const numComponents = GLTFLoader._GetNumComponents(context, accessor.type);\r\n        const byteStride = numComponents * VertexBuffer.GetTypeByteLength(accessor.componentType);\r\n        const length = numComponents * accessor.count;\r\n\r\n        if (accessor.bufferView == undefined) {\r\n            accessor._data = Promise.resolve(new constructor(length));\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\r\n            accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n                if (accessor.componentType === AccessorComponentType.FLOAT && !accessor.normalized && (!bufferView.byteStride || bufferView.byteStride === byteStride)) {\r\n                    return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, length);\r\n                } else {\r\n                    const typedArray = new constructor(length);\r\n                    VertexBuffer.ForEach(\r\n                        data,\r\n                        accessor.byteOffset || 0,\r\n                        bufferView.byteStride || byteStride,\r\n                        numComponents,\r\n                        accessor.componentType,\r\n                        typedArray.length,\r\n                        accessor.normalized || false,\r\n                        (value, index) => {\r\n                            typedArray[index] = value;\r\n                        }\r\n                    );\r\n                    return typedArray;\r\n                }\r\n            });\r\n        }\r\n\r\n        if (accessor.sparse) {\r\n            const sparse = accessor.sparse;\r\n            accessor._data = accessor._data.then((data) => {\r\n                const typedArray = data as TypedArrayLike;\r\n                const indicesBufferView = ArrayItem.Get(`${context}/sparse/indices/bufferView`, this._gltf.bufferViews, sparse.indices.bufferView);\r\n                const valuesBufferView = ArrayItem.Get(`${context}/sparse/values/bufferView`, this._gltf.bufferViews, sparse.values.bufferView);\r\n                return Promise.all([\r\n                    this.loadBufferViewAsync(`/bufferViews/${indicesBufferView.index}`, indicesBufferView),\r\n                    this.loadBufferViewAsync(`/bufferViews/${valuesBufferView.index}`, valuesBufferView),\r\n                ]).then(([indicesData, valuesData]) => {\r\n                    const indices = GLTFLoader._GetTypedArray(\r\n                        `${context}/sparse/indices`,\r\n                        sparse.indices.componentType,\r\n                        indicesData,\r\n                        sparse.indices.byteOffset,\r\n                        sparse.count\r\n                    ) as IndicesArray;\r\n\r\n                    const sparseLength = numComponents * sparse.count;\r\n                    let values: TypedArrayLike;\r\n\r\n                    if (accessor.componentType === AccessorComponentType.FLOAT && !accessor.normalized) {\r\n                        values = GLTFLoader._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);\r\n                    } else {\r\n                        const sparseData = GLTFLoader._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);\r\n                        values = new constructor(sparseLength);\r\n                        VertexBuffer.ForEach(sparseData, 0, byteStride, numComponents, accessor.componentType, values.length, accessor.normalized || false, (value, index) => {\r\n                            values[index] = value;\r\n                        });\r\n                    }\r\n\r\n                    let valuesIndex = 0;\r\n                    for (let indicesIndex = 0; indicesIndex < indices.length; indicesIndex++) {\r\n                        let dataIndex = indices[indicesIndex] * numComponents;\r\n                        for (let componentIndex = 0; componentIndex < numComponents; componentIndex++) {\r\n                            typedArray[dataIndex++] = values[valuesIndex++];\r\n                        }\r\n                    }\r\n\r\n                    return typedArray;\r\n                });\r\n            });\r\n        }\r\n\r\n        return accessor._data;\r\n    }\r\n\r\n    /**\r\n     * @param context\r\n     * @param accessor\r\n     * @hidden\r\n     */\r\n    public _loadFloatAccessorAsync(context: string, accessor: IAccessor): Promise<Float32Array> {\r\n        return this._loadAccessorAsync(context, accessor, Float32Array) as Promise<Float32Array>;\r\n    }\r\n\r\n    private _loadIndicesAccessorAsync(context: string, accessor: IAccessor): Promise<IndicesArray> {\r\n        if (accessor.type !== AccessorType.SCALAR) {\r\n            throw new Error(`${context}/type: Invalid value ${accessor.type}`);\r\n        }\r\n\r\n        if (\r\n            accessor.componentType !== AccessorComponentType.UNSIGNED_BYTE &&\r\n            accessor.componentType !== AccessorComponentType.UNSIGNED_SHORT &&\r\n            accessor.componentType !== AccessorComponentType.UNSIGNED_INT\r\n        ) {\r\n            throw new Error(`${context}/componentType: Invalid value ${accessor.componentType}`);\r\n        }\r\n\r\n        if (accessor._data) {\r\n            return accessor._data as Promise<IndicesArray>;\r\n        }\r\n\r\n        if (accessor.sparse) {\r\n            const constructor = GLTFLoader._GetTypedArrayConstructor(`${context}/componentType`, accessor.componentType);\r\n            accessor._data = this._loadAccessorAsync(context, accessor, constructor);\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\r\n            accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n                return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, accessor.count);\r\n            });\r\n        }\r\n\r\n        return accessor._data as Promise<IndicesArray>;\r\n    }\r\n\r\n    private _loadVertexBufferViewAsync(bufferView: IBufferView): Promise<Buffer> {\r\n        if (bufferView._babylonBuffer) {\r\n            return bufferView._babylonBuffer;\r\n        }\r\n\r\n        bufferView._babylonBuffer = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n            return new Buffer(this._babylonScene.getEngine(), data, false);\r\n        });\r\n\r\n        return bufferView._babylonBuffer;\r\n    }\r\n\r\n    private _loadVertexAccessorAsync(context: string, accessor: IAccessor, kind: string): Promise<VertexBuffer> {\r\n        if (accessor._babylonVertexBuffer?.[kind]) {\r\n            return accessor._babylonVertexBuffer[kind];\r\n        }\r\n\r\n        if (!accessor._babylonVertexBuffer) {\r\n            accessor._babylonVertexBuffer = {};\r\n        }\r\n\r\n        if (accessor.sparse) {\r\n            accessor._babylonVertexBuffer[kind] = this._loadFloatAccessorAsync(context, accessor).then((data) => {\r\n                return new VertexBuffer(this._babylonScene.getEngine(), data, kind, false);\r\n            });\r\n        }\r\n        // Load joint indices as a float array since the shaders expect float data but glTF uses unsigned byte/short.\r\n        // This prevents certain platforms (e.g. D3D) from having to convert the data to float on the fly.\r\n        else if (kind === VertexBuffer.MatricesIndicesKind || kind === VertexBuffer.MatricesIndicesExtraKind) {\r\n            accessor._babylonVertexBuffer[kind] = this._loadFloatAccessorAsync(context, accessor).then((data) => {\r\n                return new VertexBuffer(this._babylonScene.getEngine(), data, kind, false);\r\n            });\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\r\n            accessor._babylonVertexBuffer[kind] = this._loadVertexBufferViewAsync(bufferView).then((babylonBuffer) => {\r\n                const size = GLTFLoader._GetNumComponents(context, accessor.type);\r\n                return new VertexBuffer(\r\n                    this._babylonScene.getEngine(),\r\n                    babylonBuffer,\r\n                    kind,\r\n                    false,\r\n                    false,\r\n                    bufferView.byteStride,\r\n                    false,\r\n                    accessor.byteOffset,\r\n                    size,\r\n                    accessor.componentType,\r\n                    accessor.normalized,\r\n                    true,\r\n                    1,\r\n                    true\r\n                );\r\n            });\r\n        }\r\n\r\n        return accessor._babylonVertexBuffer[kind];\r\n    }\r\n\r\n    private _loadMaterialMetallicRoughnessPropertiesAsync(context: string, properties: IMaterialPbrMetallicRoughness, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        if (properties) {\r\n            if (properties.baseColorFactor) {\r\n                babylonMaterial.albedoColor = Color3.FromArray(properties.baseColorFactor);\r\n                babylonMaterial.alpha = properties.baseColorFactor[3];\r\n            } else {\r\n                babylonMaterial.albedoColor = Color3.White();\r\n            }\r\n\r\n            babylonMaterial.metallic = properties.metallicFactor == undefined ? 1 : properties.metallicFactor;\r\n            babylonMaterial.roughness = properties.roughnessFactor == undefined ? 1 : properties.roughnessFactor;\r\n\r\n            if (properties.baseColorTexture) {\r\n                promises.push(\r\n                    this.loadTextureInfoAsync(`${context}/baseColorTexture`, properties.baseColorTexture, (texture) => {\r\n                        texture.name = `${babylonMaterial.name} (Base Color)`;\r\n                        babylonMaterial.albedoTexture = texture;\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (properties.metallicRoughnessTexture) {\r\n                properties.metallicRoughnessTexture.nonColorData = true;\r\n                promises.push(\r\n                    this.loadTextureInfoAsync(`${context}/metallicRoughnessTexture`, properties.metallicRoughnessTexture, (texture) => {\r\n                        texture.name = `${babylonMaterial.name} (Metallic Roughness)`;\r\n                        babylonMaterial.metallicTexture = texture;\r\n                    })\r\n                );\r\n\r\n                babylonMaterial.useMetallnessFromMetallicTextureBlue = true;\r\n                babylonMaterial.useRoughnessFromMetallicTextureGreen = true;\r\n                babylonMaterial.useRoughnessFromMetallicTextureAlpha = false;\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    /**\r\n     * @param context\r\n     * @param material\r\n     * @param babylonMesh\r\n     * @param babylonDrawMode\r\n     * @param assign\r\n     * @hidden\r\n     */\r\n    public _loadMaterialAsync(\r\n        context: string,\r\n        material: IMaterial,\r\n        babylonMesh: Nullable<Mesh>,\r\n        babylonDrawMode: number,\r\n        assign: (babylonMaterial: Material) => void = () => {}\r\n    ): Promise<Material> {\r\n        const extensionPromise = this._extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        material._data = material._data || {};\r\n        let babylonData = material._data[babylonDrawMode];\r\n        if (!babylonData) {\r\n            this.logOpen(`${context} ${material.name || \"\"}`);\r\n\r\n            const babylonMaterial = this.createMaterial(context, material, babylonDrawMode);\r\n\r\n            babylonData = {\r\n                babylonMaterial: babylonMaterial,\r\n                babylonMeshes: [],\r\n                promise: this.loadMaterialPropertiesAsync(context, material, babylonMaterial),\r\n            };\r\n\r\n            material._data[babylonDrawMode] = babylonData;\r\n\r\n            GLTFLoader.AddPointerMetadata(babylonMaterial, context);\r\n            this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\r\n\r\n            this.logClose();\r\n        }\r\n\r\n        if (babylonMesh) {\r\n            babylonData.babylonMeshes.push(babylonMesh);\r\n\r\n            babylonMesh.onDisposeObservable.addOnce(() => {\r\n                const index = babylonData.babylonMeshes.indexOf(babylonMesh);\r\n                if (index !== -1) {\r\n                    babylonData.babylonMeshes.splice(index, 1);\r\n                }\r\n            });\r\n        }\r\n\r\n        assign(babylonData.babylonMaterial);\r\n\r\n        return babylonData.promise.then(() => {\r\n            return babylonData.babylonMaterial;\r\n        });\r\n    }\r\n\r\n    private _createDefaultMaterial(name: string, babylonDrawMode: number): Material {\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const babylonMaterial = new PBRMaterial(name, this._babylonScene);\r\n        babylonMaterial._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        // Moved to mesh so user can change materials on gltf meshes: babylonMaterial.sideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n        babylonMaterial.fillMode = babylonDrawMode;\r\n        babylonMaterial.enableSpecularAntiAliasing = true;\r\n        babylonMaterial.useRadianceOverAlpha = !this._parent.transparencyAsCoverage;\r\n        babylonMaterial.useSpecularOverAlpha = !this._parent.transparencyAsCoverage;\r\n        babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\r\n        babylonMaterial.metallic = 1;\r\n        babylonMaterial.roughness = 1;\r\n        return babylonMaterial;\r\n    }\r\n\r\n    /**\r\n     * Creates a Babylon material from a glTF material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonDrawMode The draw mode for the Babylon material\r\n     * @returns The Babylon material\r\n     */\r\n    public createMaterial(context: string, material: IMaterial, babylonDrawMode: number): Material {\r\n        const extensionPromise = this._extensionsCreateMaterial(context, material, babylonDrawMode);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const name = material.name || `material${material.index}`;\r\n        const babylonMaterial = this._createDefaultMaterial(name, babylonDrawMode);\r\n\r\n        return babylonMaterial;\r\n    }\r\n\r\n    /**\r\n     * Loads properties from a glTF material into a Babylon material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<void> {\r\n        const extensionPromise = this._extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        promises.push(this.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\r\n\r\n        if (material.pbrMetallicRoughness) {\r\n            promises.push(this._loadMaterialMetallicRoughnessPropertiesAsync(`${context}/pbrMetallicRoughness`, material.pbrMetallicRoughness, babylonMaterial));\r\n        }\r\n\r\n        this.loadMaterialAlphaProperties(context, material, babylonMaterial);\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    /**\r\n     * Loads the normal, occlusion, and emissive properties from a glTF material into a Babylon material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public loadMaterialBasePropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        babylonMaterial.emissiveColor = material.emissiveFactor ? Color3.FromArray(material.emissiveFactor) : new Color3(0, 0, 0);\r\n        if (material.doubleSided) {\r\n            babylonMaterial.backFaceCulling = false;\r\n            babylonMaterial.twoSidedLighting = true;\r\n        }\r\n\r\n        if (material.normalTexture) {\r\n            material.normalTexture.nonColorData = true;\r\n            promises.push(\r\n                this.loadTextureInfoAsync(`${context}/normalTexture`, material.normalTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Normal)`;\r\n                    babylonMaterial.bumpTexture = texture;\r\n                })\r\n            );\r\n\r\n            babylonMaterial.invertNormalMapX = !this._babylonScene.useRightHandedSystem;\r\n            babylonMaterial.invertNormalMapY = this._babylonScene.useRightHandedSystem;\r\n            if (material.normalTexture.scale != undefined) {\r\n                babylonMaterial.bumpTexture.level = material.normalTexture.scale;\r\n            }\r\n\r\n            babylonMaterial.forceIrradianceInFragment = true;\r\n        }\r\n\r\n        if (material.occlusionTexture) {\r\n            material.occlusionTexture.nonColorData = true;\r\n            promises.push(\r\n                this.loadTextureInfoAsync(`${context}/occlusionTexture`, material.occlusionTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Occlusion)`;\r\n                    babylonMaterial.ambientTexture = texture;\r\n                })\r\n            );\r\n\r\n            babylonMaterial.useAmbientInGrayScale = true;\r\n            if (material.occlusionTexture.strength != undefined) {\r\n                babylonMaterial.ambientTextureStrength = material.occlusionTexture.strength;\r\n            }\r\n        }\r\n\r\n        if (material.emissiveTexture) {\r\n            promises.push(\r\n                this.loadTextureInfoAsync(`${context}/emissiveTexture`, material.emissiveTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Emissive)`;\r\n                    babylonMaterial.emissiveTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    /**\r\n     * Loads the alpha properties from a glTF material into a Babylon material.\r\n     * Must be called after the setting the albedo texture of the Babylon material when the material has an albedo texture.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     */\r\n    public loadMaterialAlphaProperties(context: string, material: IMaterial, babylonMaterial: Material): void {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const alphaMode = material.alphaMode || MaterialAlphaMode.OPAQUE;\r\n        switch (alphaMode) {\r\n            case MaterialAlphaMode.OPAQUE: {\r\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\r\n                break;\r\n            }\r\n            case MaterialAlphaMode.MASK: {\r\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHATEST;\r\n                babylonMaterial.alphaCutOff = material.alphaCutoff == undefined ? 0.5 : material.alphaCutoff;\r\n                if (babylonMaterial.albedoTexture) {\r\n                    babylonMaterial.albedoTexture.hasAlpha = true;\r\n                }\r\n                break;\r\n            }\r\n            case MaterialAlphaMode.BLEND: {\r\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHABLEND;\r\n                if (babylonMaterial.albedoTexture) {\r\n                    babylonMaterial.albedoTexture.hasAlpha = true;\r\n                    babylonMaterial.useAlphaFromAlbedoTexture = true;\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}/alphaMode: Invalid value (${material.alphaMode})`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF texture info.\r\n     * @param context The context when loading the asset\r\n     * @param textureInfo The glTF texture info property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon texture when the load is complete\r\n     */\r\n    public loadTextureInfoAsync(context: string, textureInfo: ITextureInfo, assign: (babylonTexture: BaseTexture) => void = () => {}): Promise<BaseTexture> {\r\n        const extensionPromise = this._extensionsLoadTextureInfoAsync(context, textureInfo, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        this.logOpen(`${context}`);\r\n\r\n        if (textureInfo.texCoord! >= 6) {\r\n            throw new Error(`${context}/texCoord: Invalid value (${textureInfo.texCoord})`);\r\n        }\r\n\r\n        const texture = ArrayItem.Get(`${context}/index`, this._gltf.textures, textureInfo.index);\r\n        texture._textureInfo = textureInfo;\r\n\r\n        const promise = this._loadTextureAsync(`/textures/${textureInfo.index}`, texture, (babylonTexture) => {\r\n            babylonTexture.coordinatesIndex = textureInfo.texCoord || 0;\r\n            GLTFLoader.AddPointerMetadata(babylonTexture, context);\r\n            this._parent.onTextureLoadedObservable.notifyObservers(babylonTexture);\r\n            assign(babylonTexture);\r\n        });\r\n\r\n        this.logClose();\r\n\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * @param context\r\n     * @param texture\r\n     * @param assign\r\n     * @hidden\r\n     */\r\n    public _loadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void = () => {}): Promise<BaseTexture> {\r\n        const extensionPromise = this._extensionsLoadTextureAsync(context, texture, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        this.logOpen(`${context} ${texture.name || \"\"}`);\r\n\r\n        const sampler = texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._gltf.samplers, texture.sampler);\r\n        const image = ArrayItem.Get(`${context}/source`, this._gltf.images, texture.source);\r\n        const promise = this._createTextureAsync(context, sampler, image, assign, undefined, !texture._textureInfo.nonColorData);\r\n\r\n        this.logClose();\r\n\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * @param context\r\n     * @param sampler\r\n     * @param image\r\n     * @param assign\r\n     * @param textureLoaderOptions\r\n     * @param useSRGBBuffer\r\n     * @hidden\r\n     */\r\n    public _createTextureAsync(\r\n        context: string,\r\n        sampler: ISampler,\r\n        image: IImage,\r\n        assign: (babylonTexture: BaseTexture) => void = () => {},\r\n        textureLoaderOptions?: any,\r\n        useSRGBBuffer?: boolean\r\n    ): Promise<BaseTexture> {\r\n        const samplerData = this._loadSampler(`/samplers/${sampler.index}`, sampler);\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const deferred = new Deferred<void>();\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const textureCreationOptions: ITextureCreationOptions = {\r\n            noMipmap: samplerData.noMipMaps,\r\n            invertY: false,\r\n            samplingMode: samplerData.samplingMode,\r\n            onLoad: () => {\r\n                if (!this._disposed) {\r\n                    deferred.resolve();\r\n                }\r\n            },\r\n            onError: (message?: string, exception?: any) => {\r\n                if (!this._disposed) {\r\n                    deferred.reject(new Error(`${context}: ${exception && exception.message ? exception.message : message || \"Failed to load texture\"}`));\r\n                }\r\n            },\r\n            mimeType: image.mimeType,\r\n            loaderOptions: textureLoaderOptions,\r\n            useSRGBBuffer: !!useSRGBBuffer && this._parent.useSRGBBuffers,\r\n        };\r\n        const babylonTexture = new Texture(null, this._babylonScene, textureCreationOptions);\r\n        babylonTexture._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        promises.push(deferred.promise);\r\n\r\n        promises.push(\r\n            this.loadImageAsync(`/images/${image.index}`, image).then((data) => {\r\n                const name = image.uri || `${this._fileName}#image${image.index}`;\r\n                const dataUrl = `data:${this._uniqueRootUrl}${name}`;\r\n                babylonTexture.updateURL(dataUrl, data);\r\n            })\r\n        );\r\n\r\n        babylonTexture.wrapU = samplerData.wrapU;\r\n        babylonTexture.wrapV = samplerData.wrapV;\r\n        assign(babylonTexture);\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonTexture;\r\n        });\r\n    }\r\n\r\n    private _loadSampler(context: string, sampler: ISampler): _ISamplerData {\r\n        if (!sampler._data) {\r\n            sampler._data = {\r\n                noMipMaps: sampler.minFilter === TextureMinFilter.NEAREST || sampler.minFilter === TextureMinFilter.LINEAR,\r\n                samplingMode: GLTFLoader._GetTextureSamplingMode(context, sampler),\r\n                wrapU: GLTFLoader._GetTextureWrapMode(`${context}/wrapS`, sampler.wrapS),\r\n                wrapV: GLTFLoader._GetTextureWrapMode(`${context}/wrapT`, sampler.wrapT),\r\n            };\r\n        }\r\n\r\n        return sampler._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF image.\r\n     * @param context The context when loading the asset\r\n     * @param image The glTF image property\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadImageAsync(context: string, image: IImage): Promise<ArrayBufferView> {\r\n        if (!image._data) {\r\n            this.logOpen(`${context} ${image.name || \"\"}`);\r\n\r\n            if (image.uri) {\r\n                image._data = this.loadUriAsync(`${context}/uri`, image, image.uri);\r\n            } else {\r\n                const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, image.bufferView);\r\n                image._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\r\n            }\r\n\r\n            this.logClose();\r\n        }\r\n\r\n        return image._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF uri.\r\n     * @param context The context when loading the asset\r\n     * @param property The glTF property associated with the uri\r\n     * @param uri The base64 or relative uri\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadUriAsync(context: string, property: IProperty, uri: string): Promise<ArrayBufferView> {\r\n        const extensionPromise = this._extensionsLoadUriAsync(context, property, uri);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (!GLTFLoader._ValidateUri(uri)) {\r\n            throw new Error(`${context}: '${uri}' is invalid`);\r\n        }\r\n\r\n        if (IsBase64DataUrl(uri)) {\r\n            const data = new Uint8Array(DecodeBase64UrlToBinary(uri));\r\n            this.log(`${context}: Decoded ${uri.substr(0, 64)}... (${data.length} bytes)`);\r\n            return Promise.resolve(data);\r\n        }\r\n\r\n        this.log(`${context}: Loading ${uri}`);\r\n\r\n        return this._parent.preprocessUrlAsync(this._rootUrl + uri).then((url) => {\r\n            return new Promise((resolve, reject) => {\r\n                this._parent._loadFile(\r\n                    this._babylonScene,\r\n                    url,\r\n                    (data) => {\r\n                        if (!this._disposed) {\r\n                            this.log(`${context}: Loaded ${uri} (${(data as ArrayBuffer).byteLength} bytes)`);\r\n                            resolve(new Uint8Array(data as ArrayBuffer));\r\n                        }\r\n                    },\r\n                    true,\r\n                    (request) => {\r\n                        reject(new LoadFileError(`${context}: Failed to load '${uri}'${request ? \": \" + request.status + \" \" + request.statusText : \"\"}`, request));\r\n                    }\r\n                );\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds a JSON pointer to the metadata of the Babylon object at `<object>.metadata.gltf.pointers`.\r\n     * @param babylonObject the Babylon object with metadata\r\n     * @param babylonObject.metadata\r\n     * @param pointer the JSON pointer\r\n     */\r\n    public static AddPointerMetadata(babylonObject: { metadata: any }, pointer: string): void {\r\n        const metadata = (babylonObject.metadata = babylonObject.metadata || {});\r\n        const gltf = (metadata.gltf = metadata.gltf || {});\r\n        const pointers = (gltf.pointers = gltf.pointers || []);\r\n        pointers.push(pointer);\r\n    }\r\n\r\n    private static _GetTextureWrapMode(context: string, mode: TextureWrapMode | undefined): number {\r\n        // Set defaults if undefined\r\n        mode = mode == undefined ? TextureWrapMode.REPEAT : mode;\r\n\r\n        switch (mode) {\r\n            case TextureWrapMode.CLAMP_TO_EDGE:\r\n                return Texture.CLAMP_ADDRESSMODE;\r\n            case TextureWrapMode.MIRRORED_REPEAT:\r\n                return Texture.MIRROR_ADDRESSMODE;\r\n            case TextureWrapMode.REPEAT:\r\n                return Texture.WRAP_ADDRESSMODE;\r\n            default:\r\n                Logger.Warn(`${context}: Invalid value (${mode})`);\r\n                return Texture.WRAP_ADDRESSMODE;\r\n        }\r\n    }\r\n\r\n    private static _GetTextureSamplingMode(context: string, sampler: ISampler): number {\r\n        // Set defaults if undefined\r\n        const magFilter = sampler.magFilter == undefined ? TextureMagFilter.LINEAR : sampler.magFilter;\r\n        const minFilter = sampler.minFilter == undefined ? TextureMinFilter.LINEAR_MIPMAP_LINEAR : sampler.minFilter;\r\n\r\n        if (magFilter === TextureMagFilter.LINEAR) {\r\n            switch (minFilter) {\r\n                case TextureMinFilter.NEAREST:\r\n                    return Texture.LINEAR_NEAREST;\r\n                case TextureMinFilter.LINEAR:\r\n                    return Texture.LINEAR_LINEAR;\r\n                case TextureMinFilter.NEAREST_MIPMAP_NEAREST:\r\n                    return Texture.LINEAR_NEAREST_MIPNEAREST;\r\n                case TextureMinFilter.LINEAR_MIPMAP_NEAREST:\r\n                    return Texture.LINEAR_LINEAR_MIPNEAREST;\r\n                case TextureMinFilter.NEAREST_MIPMAP_LINEAR:\r\n                    return Texture.LINEAR_NEAREST_MIPLINEAR;\r\n                case TextureMinFilter.LINEAR_MIPMAP_LINEAR:\r\n                    return Texture.LINEAR_LINEAR_MIPLINEAR;\r\n                default:\r\n                    Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\r\n                    return Texture.LINEAR_LINEAR_MIPLINEAR;\r\n            }\r\n        } else {\r\n            if (magFilter !== TextureMagFilter.NEAREST) {\r\n                Logger.Warn(`${context}/magFilter: Invalid value (${magFilter})`);\r\n            }\r\n\r\n            switch (minFilter) {\r\n                case TextureMinFilter.NEAREST:\r\n                    return Texture.NEAREST_NEAREST;\r\n                case TextureMinFilter.LINEAR:\r\n                    return Texture.NEAREST_LINEAR;\r\n                case TextureMinFilter.NEAREST_MIPMAP_NEAREST:\r\n                    return Texture.NEAREST_NEAREST_MIPNEAREST;\r\n                case TextureMinFilter.LINEAR_MIPMAP_NEAREST:\r\n                    return Texture.NEAREST_LINEAR_MIPNEAREST;\r\n                case TextureMinFilter.NEAREST_MIPMAP_LINEAR:\r\n                    return Texture.NEAREST_NEAREST_MIPLINEAR;\r\n                case TextureMinFilter.LINEAR_MIPMAP_LINEAR:\r\n                    return Texture.NEAREST_LINEAR_MIPLINEAR;\r\n                default:\r\n                    Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\r\n                    return Texture.NEAREST_NEAREST_MIPNEAREST;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _GetTypedArrayConstructor(context: string, componentType: AccessorComponentType): TypedArrayConstructor {\r\n        switch (componentType) {\r\n            case AccessorComponentType.BYTE:\r\n                return Int8Array;\r\n            case AccessorComponentType.UNSIGNED_BYTE:\r\n                return Uint8Array;\r\n            case AccessorComponentType.SHORT:\r\n                return Int16Array;\r\n            case AccessorComponentType.UNSIGNED_SHORT:\r\n                return Uint16Array;\r\n            case AccessorComponentType.UNSIGNED_INT:\r\n                return Uint32Array;\r\n            case AccessorComponentType.FLOAT:\r\n                return Float32Array;\r\n            default:\r\n                throw new Error(`${context}: Invalid component type ${componentType}`);\r\n        }\r\n    }\r\n\r\n    private static _GetTypedArray(\r\n        context: string,\r\n        componentType: AccessorComponentType,\r\n        bufferView: ArrayBufferView,\r\n        byteOffset: number | undefined,\r\n        length: number\r\n    ): TypedArrayLike {\r\n        const buffer = bufferView.buffer;\r\n        byteOffset = bufferView.byteOffset + (byteOffset || 0);\r\n\r\n        const constructor = GLTFLoader._GetTypedArrayConstructor(`${context}/componentType`, componentType);\r\n\r\n        const componentTypeLength = VertexBuffer.GetTypeByteLength(componentType);\r\n        if (byteOffset % componentTypeLength !== 0) {\r\n            // HACK: Copy the buffer if byte offset is not a multiple of component type byte length.\r\n            Logger.Warn(`${context}: Copying buffer as byte offset (${byteOffset}) is not a multiple of component type byte length (${componentTypeLength})`);\r\n            return new constructor(buffer.slice(byteOffset, byteOffset + length * componentTypeLength), 0);\r\n        }\r\n\r\n        return new constructor(buffer, byteOffset, length);\r\n    }\r\n\r\n    private static _GetNumComponents(context: string, type: string): number {\r\n        switch (type) {\r\n            case \"SCALAR\":\r\n                return 1;\r\n            case \"VEC2\":\r\n                return 2;\r\n            case \"VEC3\":\r\n                return 3;\r\n            case \"VEC4\":\r\n                return 4;\r\n            case \"MAT2\":\r\n                return 4;\r\n            case \"MAT3\":\r\n                return 9;\r\n            case \"MAT4\":\r\n                return 16;\r\n        }\r\n\r\n        throw new Error(`${context}: Invalid type (${type})`);\r\n    }\r\n\r\n    private static _ValidateUri(uri: string): boolean {\r\n        return Tools.IsBase64(uri) || uri.indexOf(\"..\") === -1;\r\n    }\r\n\r\n    /**\r\n     * @param context\r\n     * @param mode\r\n     * @hidden\r\n     */\r\n    public static _GetDrawMode(context: string, mode: number | undefined): number {\r\n        if (mode == undefined) {\r\n            mode = MeshPrimitiveMode.TRIANGLES;\r\n        }\r\n\r\n        switch (mode) {\r\n            case MeshPrimitiveMode.POINTS:\r\n                return Material.PointListDrawMode;\r\n            case MeshPrimitiveMode.LINES:\r\n                return Material.LineListDrawMode;\r\n            case MeshPrimitiveMode.LINE_LOOP:\r\n                return Material.LineLoopDrawMode;\r\n            case MeshPrimitiveMode.LINE_STRIP:\r\n                return Material.LineStripDrawMode;\r\n            case MeshPrimitiveMode.TRIANGLES:\r\n                return Material.TriangleFillMode;\r\n            case MeshPrimitiveMode.TRIANGLE_STRIP:\r\n                return Material.TriangleStripDrawMode;\r\n            case MeshPrimitiveMode.TRIANGLE_FAN:\r\n                return Material.TriangleFanDrawMode;\r\n        }\r\n\r\n        throw new Error(`${context}: Invalid mesh primitive mode (${mode})`);\r\n    }\r\n\r\n    private _compileMaterialsAsync(): Promise<void> {\r\n        this._parent._startPerformanceCounter(\"Compile materials\");\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        if (this._gltf.materials) {\r\n            for (const material of this._gltf.materials) {\r\n                if (material._data) {\r\n                    for (const babylonDrawMode in material._data) {\r\n                        const babylonData = material._data[babylonDrawMode];\r\n                        for (const babylonMesh of babylonData.babylonMeshes) {\r\n                            // Ensure nonUniformScaling is set if necessary.\r\n                            babylonMesh.computeWorldMatrix(true);\r\n\r\n                            const babylonMaterial = babylonData.babylonMaterial;\r\n                            promises.push(babylonMaterial.forceCompilationAsync(babylonMesh));\r\n                            promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { useInstances: true }));\r\n                            if (this._parent.useClipPlane) {\r\n                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true }));\r\n                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true, useInstances: true }));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._parent._endPerformanceCounter(\"Compile materials\");\r\n        });\r\n    }\r\n\r\n    private _compileShadowGeneratorsAsync(): Promise<void> {\r\n        this._parent._startPerformanceCounter(\"Compile shadow generators\");\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const lights = this._babylonScene.lights;\r\n        for (const light of lights) {\r\n            const generator = light.getShadowGenerator();\r\n            if (generator) {\r\n                promises.push(generator.forceCompilationAsync());\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._parent._endPerformanceCounter(\"Compile shadow generators\");\r\n        });\r\n    }\r\n\r\n    private _forEachExtensions(action: (extension: IGLTFLoaderExtension) => void): void {\r\n        for (const extension of this._extensions) {\r\n            if (extension.enabled) {\r\n                action(extension);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _applyExtensions<T>(property: IProperty, functionName: string, actionAsync: (extension: IGLTFLoaderExtension) => Nullable<T> | undefined): Nullable<T> {\r\n        for (const extension of this._extensions) {\r\n            if (extension.enabled) {\r\n                const id = `${extension.name}.${functionName}`;\r\n                const loaderProperty = property as ILoaderProperty;\r\n                loaderProperty._activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions || {};\r\n                const activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions;\r\n                if (!activeLoaderExtensionFunctions[id]) {\r\n                    activeLoaderExtensionFunctions[id] = true;\r\n\r\n                    try {\r\n                        const result = actionAsync(extension);\r\n                        if (result) {\r\n                            return result;\r\n                        }\r\n                    } finally {\r\n                        delete activeLoaderExtensionFunctions[id];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _extensionsOnLoading(): void {\r\n        this._forEachExtensions((extension) => extension.onLoading && extension.onLoading());\r\n    }\r\n\r\n    private _extensionsOnReady(): void {\r\n        this._forEachExtensions((extension) => extension.onReady && extension.onReady());\r\n    }\r\n\r\n    private _extensionsLoadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        return this._applyExtensions(scene, \"loadScene\", (extension) => extension.loadSceneAsync && extension.loadSceneAsync(context, scene));\r\n    }\r\n\r\n    private _extensionsLoadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return this._applyExtensions(node, \"loadNode\", (extension) => extension.loadNodeAsync && extension.loadNodeAsync(context, node, assign));\r\n    }\r\n\r\n    private _extensionsLoadCameraAsync(context: string, camera: ICamera, assign: (babylonCamera: Camera) => void): Nullable<Promise<Camera>> {\r\n        return this._applyExtensions(camera, \"loadCamera\", (extension) => extension.loadCameraAsync && extension.loadCameraAsync(context, camera, assign));\r\n    }\r\n\r\n    private _extensionsLoadVertexDataAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh): Nullable<Promise<Geometry>> {\r\n        return this._applyExtensions(primitive, \"loadVertexData\", (extension) => extension._loadVertexDataAsync && extension._loadVertexDataAsync(context, primitive, babylonMesh));\r\n    }\r\n\r\n    private _extensionsLoadMeshPrimitiveAsync(\r\n        context: string,\r\n        name: string,\r\n        node: INode,\r\n        mesh: IMesh,\r\n        primitive: IMeshPrimitive,\r\n        assign: (babylonMesh: AbstractMesh) => void\r\n    ): Nullable<Promise<AbstractMesh>> {\r\n        return this._applyExtensions(\r\n            primitive,\r\n            \"loadMeshPrimitive\",\r\n            (extension) => extension._loadMeshPrimitiveAsync && extension._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign)\r\n        );\r\n    }\r\n\r\n    private _extensionsLoadMaterialAsync(\r\n        context: string,\r\n        material: IMaterial,\r\n        babylonMesh: Nullable<Mesh>,\r\n        babylonDrawMode: number,\r\n        assign: (babylonMaterial: Material) => void\r\n    ): Nullable<Promise<Material>> {\r\n        return this._applyExtensions(\r\n            material,\r\n            \"loadMaterial\",\r\n            (extension) => extension._loadMaterialAsync && extension._loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign)\r\n        );\r\n    }\r\n\r\n    private _extensionsCreateMaterial(context: string, material: IMaterial, babylonDrawMode: number): Nullable<Material> {\r\n        return this._applyExtensions(material, \"createMaterial\", (extension) => extension.createMaterial && extension.createMaterial(context, material, babylonDrawMode));\r\n    }\r\n\r\n    private _extensionsLoadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return this._applyExtensions(\r\n            material,\r\n            \"loadMaterialProperties\",\r\n            (extension) => extension.loadMaterialPropertiesAsync && extension.loadMaterialPropertiesAsync(context, material, babylonMaterial)\r\n        );\r\n    }\r\n\r\n    private _extensionsLoadTextureInfoAsync(context: string, textureInfo: ITextureInfo, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return this._applyExtensions(textureInfo, \"loadTextureInfo\", (extension) => extension.loadTextureInfoAsync && extension.loadTextureInfoAsync(context, textureInfo, assign));\r\n    }\r\n\r\n    private _extensionsLoadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return this._applyExtensions(texture, \"loadTexture\", (extension) => extension._loadTextureAsync && extension._loadTextureAsync(context, texture, assign));\r\n    }\r\n\r\n    private _extensionsLoadAnimationAsync(context: string, animation: IAnimation): Nullable<Promise<AnimationGroup>> {\r\n        return this._applyExtensions(animation, \"loadAnimation\", (extension) => extension.loadAnimationAsync && extension.loadAnimationAsync(context, animation));\r\n    }\r\n\r\n    private _extensionsLoadSkinAsync(context: string, node: INode, skin: ISkin): Nullable<Promise<void>> {\r\n        return this._applyExtensions(skin, \"loadSkin\", (extension) => extension._loadSkinAsync && extension._loadSkinAsync(context, node, skin));\r\n    }\r\n\r\n    private _extensionsLoadUriAsync(context: string, property: IProperty, uri: string): Nullable<Promise<ArrayBufferView>> {\r\n        return this._applyExtensions(property, \"loadUri\", (extension) => extension._loadUriAsync && extension._loadUriAsync(context, property, uri));\r\n    }\r\n\r\n    private _extensionsLoadBufferViewAsync(context: string, bufferView: IBufferView): Nullable<Promise<ArrayBufferView>> {\r\n        return this._applyExtensions(bufferView, \"loadBufferView\", (extension) => extension.loadBufferViewAsync && extension.loadBufferViewAsync(context, bufferView));\r\n    }\r\n\r\n    private _extensionsLoadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Nullable<Promise<ArrayBufferView>> {\r\n        return this._applyExtensions(buffer, \"loadBuffer\", (extension) => extension.loadBufferAsync && extension.loadBufferAsync(context, buffer, byteOffset, byteLength));\r\n    }\r\n\r\n    /**\r\n     * Helper method called by a loader extension to load an glTF extension.\r\n     * @param context The context when loading the asset\r\n     * @param property The glTF property to load the extension from\r\n     * @param extensionName The name of the extension to load\r\n     * @param actionAsync The action to run\r\n     * @returns The promise returned by actionAsync or null if the extension does not exist\r\n     */\r\n    public static LoadExtensionAsync<TExtension = any, TResult = void>(\r\n        context: string,\r\n        property: IProperty,\r\n        extensionName: string,\r\n        actionAsync: (extensionContext: string, extension: TExtension) => Nullable<Promise<TResult>>\r\n    ): Nullable<Promise<TResult>> {\r\n        if (!property.extensions) {\r\n            return null;\r\n        }\r\n\r\n        const extensions = property.extensions;\r\n\r\n        const extension = extensions[extensionName] as TExtension;\r\n        if (!extension) {\r\n            return null;\r\n        }\r\n\r\n        return actionAsync(`${context}/extensions/${extensionName}`, extension);\r\n    }\r\n\r\n    /**\r\n     * Helper method called by a loader extension to load a glTF extra.\r\n     * @param context The context when loading the asset\r\n     * @param property The glTF property to load the extra from\r\n     * @param extensionName The name of the extension to load\r\n     * @param actionAsync The action to run\r\n     * @returns The promise returned by actionAsync or null if the extra does not exist\r\n     */\r\n    public static LoadExtraAsync<TExtra = any, TResult = void>(\r\n        context: string,\r\n        property: IProperty,\r\n        extensionName: string,\r\n        actionAsync: (extraContext: string, extra: TExtra) => Nullable<Promise<TResult>>\r\n    ): Nullable<Promise<TResult>> {\r\n        if (!property.extras) {\r\n            return null;\r\n        }\r\n\r\n        const extras = property.extras;\r\n\r\n        const extra = extras[extensionName] as TExtra;\r\n        if (!extra) {\r\n            return null;\r\n        }\r\n\r\n        return actionAsync(`${context}/extras/${extensionName}`, extra);\r\n    }\r\n\r\n    /**\r\n     * Checks for presence of an extension.\r\n     * @param name The name of the extension to check\r\n     * @returns A boolean indicating the presence of the given extension name in `extensionsUsed`\r\n     */\r\n    public isExtensionUsed(name: string): boolean {\r\n        return !!this._gltf.extensionsUsed && this._gltf.extensionsUsed.indexOf(name) !== -1;\r\n    }\r\n\r\n    /**\r\n     * Increments the indentation level and logs a message.\r\n     * @param message The message to log\r\n     */\r\n    public logOpen(message: string): void {\r\n        this._parent._logOpen(message);\r\n    }\r\n\r\n    /**\r\n     * Decrements the indentation level.\r\n     */\r\n    public logClose(): void {\r\n        this._parent._logClose();\r\n    }\r\n\r\n    /**\r\n     * Logs a message\r\n     * @param message The message to log\r\n     */\r\n    public log(message: string): void {\r\n        this._parent._log(message);\r\n    }\r\n\r\n    /**\r\n     * Starts a performance counter.\r\n     * @param counterName The name of the performance counter\r\n     */\r\n    public startPerformanceCounter(counterName: string): void {\r\n        this._parent._startPerformanceCounter(counterName);\r\n    }\r\n\r\n    /**\r\n     * Ends a performance counter.\r\n     * @param counterName The name of the performance counter\r\n     */\r\n    public endPerformanceCounter(counterName: string): void {\r\n        this._parent._endPerformanceCounter(counterName);\r\n    }\r\n}\r\n\r\nGLTFFileLoader._CreateGLTF2Loader = (parent) => new GLTFLoader(parent);\r\n"]},"metadata":{},"sourceType":"module"}