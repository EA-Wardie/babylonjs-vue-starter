{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Texture } from \"./texture.js\";\nimport \"../../Engines/Extensions/engine.rawTexture.js\";\n/**\n * Raw texture can help creating a texture directly from an array of data.\n * This can be super useful if you either get the data from an uncompressed source or\n * if you wish to create your texture pixel by pixel.\n */\n\nvar RawTexture =\n/** @class */\nfunction (_super) {\n  __extends(RawTexture, _super);\n  /**\n   * Instantiates a new RawTexture.\n   * Raw texture can help creating a texture directly from an array of data.\n   * This can be super useful if you either get the data from an uncompressed source or\n   * if you wish to create your texture pixel by pixel.\n   * @param data define the array of data to use to create the texture (null to create an empty texture)\n   * @param width define the width of the texture\n   * @param height define the height of the texture\n   * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps define whether mip maps should be generated or not\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n   */\n\n\n  function RawTexture(data, width, height,\n  /**\n   * Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\n   */\n  format, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    if (type === void 0) {\n      type = 0;\n    }\n\n    var _this = _super.call(this, null, sceneOrEngine, !generateMipMaps, invertY, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, creationFlags) || this;\n\n    _this.format = format;\n\n    if (!_this._engine) {\n      return _this;\n    }\n\n    if (!_this._engine._caps.textureFloatLinearFiltering && type === 1) {\n      samplingMode = 1;\n    }\n\n    if (!_this._engine._caps.textureHalfFloatLinearFiltering && type === 2) {\n      samplingMode = 1;\n    }\n\n    _this._texture = _this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type, creationFlags !== null && creationFlags !== void 0 ? creationFlags : 0);\n    _this.wrapU = Texture.CLAMP_ADDRESSMODE;\n    _this.wrapV = Texture.CLAMP_ADDRESSMODE;\n    return _this;\n  }\n  /**\n   * Updates the texture underlying data.\n   * @param data Define the new data of the texture\n   */\n\n\n  RawTexture.prototype.update = function (data) {\n    this._getEngine().updateRawTexture(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);\n  };\n  /**\n   * Creates a luminance texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @returns the luminance texture\n   */\n\n\n  RawTexture.CreateLuminanceTexture = function (data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    return new RawTexture(data, width, height, 1, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n  };\n  /**\n   * Creates a luminance alpha texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @returns the luminance alpha texture\n   */\n\n\n  RawTexture.CreateLuminanceAlphaTexture = function (data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    return new RawTexture(data, width, height, 2, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n  };\n  /**\n   * Creates an alpha texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @returns the alpha texture\n   */\n\n\n  RawTexture.CreateAlphaTexture = function (data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    return new RawTexture(data, width, height, 0, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n  };\n  /**\n   * Creates a RGB texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n   * @returns the RGB alpha texture\n   */\n\n\n  RawTexture.CreateRGBTexture = function (data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    if (type === void 0) {\n      type = 0;\n    }\n\n    return new RawTexture(data, width, height, 4, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\n  };\n  /**\n   * Creates a RGBA texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n   * @returns the RGBA texture\n   */\n\n\n  RawTexture.CreateRGBATexture = function (data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    if (type === void 0) {\n      type = 0;\n    }\n\n    return new RawTexture(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\n  };\n  /**\n   * Creates a RGBA storage texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n   * @returns the RGBA texture\n   */\n\n\n  RawTexture.CreateRGBAStorageTexture = function (data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    if (type === void 0) {\n      type = 0;\n    }\n\n    return new RawTexture(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1);\n  };\n  /**\n   * Creates a R texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n   * @returns the R texture\n   */\n\n\n  RawTexture.CreateRTexture = function (data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;\n    }\n\n    if (type === void 0) {\n      type = 1;\n    }\n\n    return new RawTexture(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\n  };\n  /**\n   * Creates a R storage texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n   * @returns the R texture\n   */\n\n\n  RawTexture.CreateRStorageTexture = function (data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;\n    }\n\n    if (type === void 0) {\n      type = 1;\n    }\n\n    return new RawTexture(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1);\n  };\n\n  return RawTexture;\n}(Texture);\n\nexport { RawTexture };","map":{"version":3,"mappings":"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","names":["Texture","__extends","data","width","height","format","sceneOrEngine","generateMipMaps","invertY","samplingMode","type","creationFlags","_super","undefined","_this","_engine","_caps","textureFloatLinearFiltering","textureHalfFloatLinearFiltering","_texture","createRawTexture","wrapU","CLAMP_ADDRESSMODE","wrapV","RawTexture","_getEngine","updateRawTexture","TRILINEAR_SAMPLINGMODE"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/rawTexture.ts"],"sourcesContent":["import { Texture } from \"./texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\n\r\ndeclare type Scene = import(\"../../scene\").Scene;\r\n\r\n/**\r\n * Raw texture can help creating a texture directly from an array of data.\r\n * This can be super useful if you either get the data from an uncompressed source or\r\n * if you wish to create your texture pixel by pixel.\r\n */\r\nexport class RawTexture extends Texture {\r\n    /**\r\n     * Instantiates a new RawTexture.\r\n     * Raw texture can help creating a texture directly from an array of data.\r\n     * This can be super useful if you either get the data from an uncompressed source or\r\n     * if you wish to create your texture pixel by pixel.\r\n     * @param data define the array of data to use to create the texture (null to create an empty texture)\r\n     * @param width define the width of the texture\r\n     * @param height define the height of the texture\r\n     * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps define whether mip maps should be generated or not\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     */\r\n    constructor(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        /**\r\n         * Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n         */\r\n        public format: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags?: number\r\n    ) {\r\n        super(null, sceneOrEngine, !generateMipMaps, invertY, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, creationFlags);\r\n\r\n        if (!this._engine) {\r\n            return;\r\n        }\r\n\r\n        if (!this._engine._caps.textureFloatLinearFiltering && type === Constants.TEXTURETYPE_FLOAT) {\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n        if (!this._engine._caps.textureHalfFloatLinearFiltering && type === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n\r\n        this._texture = this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type, creationFlags ?? 0);\r\n\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n    }\r\n\r\n    /**\r\n     * Updates the texture underlying data.\r\n     * @param data Define the new data of the texture\r\n     */\r\n    public update(data: ArrayBufferView): void {\r\n        this._getEngine()!.updateRawTexture(this._texture, data, this._texture!.format, this._texture!.invertY, null, this._texture!.type);\r\n    }\r\n\r\n    /**\r\n     * Creates a luminance texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the luminance texture\r\n     */\r\n    public static CreateLuminanceTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates a luminance alpha texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the luminance alpha texture\r\n     */\r\n    public static CreateLuminanceAlphaTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE_ALPHA, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates an alpha texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the alpha texture\r\n     */\r\n    public static CreateAlphaTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_ALPHA, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGB texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the RGB alpha texture\r\n     */\r\n    public static CreateRGBTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_RGB, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBATexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_RGBA, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA storage texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBAStorageTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ): RawTexture {\r\n        return new RawTexture(\r\n            data,\r\n            width,\r\n            height,\r\n            Constants.TEXTUREFORMAT_RGBA,\r\n            sceneOrEngine,\r\n            generateMipMaps,\r\n            invertY,\r\n            samplingMode,\r\n            type,\r\n            Constants.TEXTURE_CREATIONFLAG_STORAGE\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a R texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the R texture\r\n     */\r\n    public static CreateRTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_FLOAT\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_R, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\r\n    }\r\n\r\n    /**\r\n     * Creates a R storage texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the R texture\r\n     */\r\n    public static CreateRStorageTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_FLOAT\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_R, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, Constants.TEXTURE_CREATIONFLAG_STORAGE);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}