{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { PhysicsImpostor } from \"../../Physics/physicsImpostor.js\";\nimport { PhysicsJoint } from \"../../Physics/physicsJoint.js\";\nimport { PhysicsEngine } from \"../../Physics/physicsEngine.js\";\nimport { PhysicsRaycastResult } from \"../physicsRaycastResult.js\";\n/** @hidden */\n\nvar CannonJSPlugin =\n/** @class */\nfunction () {\n  function CannonJSPlugin(_useDeltaForWorldStep, iterations, cannonInjection) {\n    if (_useDeltaForWorldStep === void 0) {\n      _useDeltaForWorldStep = true;\n    }\n\n    if (iterations === void 0) {\n      iterations = 10;\n    }\n\n    if (cannonInjection === void 0) {\n      cannonInjection = CANNON;\n    }\n\n    this._useDeltaForWorldStep = _useDeltaForWorldStep;\n    this.name = \"CannonJSPlugin\";\n    this._physicsMaterials = new Array();\n    this._fixedTimeStep = 1 / 60;\n    this._physicsBodysToRemoveAfterStep = new Array();\n    this._firstFrame = true;\n    this._tmpQuaternion = new Quaternion();\n    this._minus90X = new Quaternion(-0.7071067811865475, 0, 0, 0.7071067811865475);\n    this._plus90X = new Quaternion(0.7071067811865475, 0, 0, 0.7071067811865475);\n    this._tmpPosition = Vector3.Zero();\n    this._tmpDeltaPosition = Vector3.Zero();\n    this._tmpUnityRotation = new Quaternion();\n    this.BJSCANNON = cannonInjection;\n\n    if (!this.isSupported()) {\n      Logger.Error(\"CannonJS is not available. Please make sure you included the js file.\");\n      return;\n    }\n\n    this._extendNamespace();\n\n    this.world = new this.BJSCANNON.World();\n    this.world.broadphase = new this.BJSCANNON.NaiveBroadphase();\n    this.world.solver.iterations = iterations;\n    this._cannonRaycastResult = new this.BJSCANNON.RaycastResult();\n    this._raycastResult = new PhysicsRaycastResult();\n  }\n\n  CannonJSPlugin.prototype.setGravity = function (gravity) {\n    var vec = gravity;\n    this.world.gravity.set(vec.x, vec.y, vec.z);\n  };\n\n  CannonJSPlugin.prototype.setTimeStep = function (timeStep) {\n    this._fixedTimeStep = timeStep;\n  };\n\n  CannonJSPlugin.prototype.getTimeStep = function () {\n    return this._fixedTimeStep;\n  };\n\n  CannonJSPlugin.prototype.executeStep = function (delta, impostors) {\n    // due to cannon's architecture, the first frame's before-step is skipped.\n    if (this._firstFrame) {\n      this._firstFrame = false;\n\n      for (var _i = 0, impostors_1 = impostors; _i < impostors_1.length; _i++) {\n        var impostor = impostors_1[_i];\n\n        if (!(impostor.type == PhysicsImpostor.HeightmapImpostor || impostor.type === PhysicsImpostor.PlaneImpostor)) {\n          impostor.beforeStep();\n        }\n      }\n    }\n\n    this.world.step(this._useDeltaForWorldStep ? delta : this._fixedTimeStep);\n\n    this._removeMarkedPhysicsBodiesFromWorld();\n  };\n\n  CannonJSPlugin.prototype._removeMarkedPhysicsBodiesFromWorld = function () {\n    var _this = this;\n\n    if (this._physicsBodysToRemoveAfterStep.length > 0) {\n      this._physicsBodysToRemoveAfterStep.forEach(function (physicsBody) {\n        if (typeof _this.world.removeBody === \"function\") {\n          _this.world.removeBody(physicsBody);\n        } else {\n          _this.world.remove(physicsBody);\n        }\n      });\n\n      this._physicsBodysToRemoveAfterStep = [];\n    }\n  };\n\n  CannonJSPlugin.prototype.applyImpulse = function (impostor, force, contactPoint) {\n    var worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\n    var impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);\n    impostor.physicsBody.applyImpulse(impulse, worldPoint);\n  };\n\n  CannonJSPlugin.prototype.applyForce = function (impostor, force, contactPoint) {\n    var worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\n    var impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);\n    impostor.physicsBody.applyForce(impulse, worldPoint);\n  };\n\n  CannonJSPlugin.prototype.generatePhysicsBody = function (impostor) {\n    // When calling forceUpdate generatePhysicsBody is called again, ensure that the updated body does not instantly collide with removed body\n    this._removeMarkedPhysicsBodiesFromWorld(); //parent-child relationship. Does this impostor has a parent impostor?\n\n\n    if (impostor.parent) {\n      if (impostor.physicsBody) {\n        this.removePhysicsBody(impostor); //TODO is that needed?\n\n        impostor.forceUpdate();\n      }\n\n      return;\n    } //should a new body be created for this impostor?\n\n\n    if (impostor.isBodyInitRequired()) {\n      var shape = this._createShape(impostor);\n\n      if (!shape) {\n        Logger.Warn(\"It was not possible to create a physics body for this object.\");\n        return;\n      } //unregister events, if body is being changed\n\n\n      var oldBody_1 = impostor.physicsBody;\n\n      if (oldBody_1) {\n        this.removePhysicsBody(impostor);\n      } //create the body and material\n\n\n      var material = this._addMaterial(\"mat-\" + impostor.uniqueId, impostor.getParam(\"friction\"), impostor.getParam(\"restitution\"));\n\n      var bodyCreationObject = {\n        mass: impostor.getParam(\"mass\"),\n        material: material\n      }; // A simple extend, in case native options were used.\n\n      var nativeOptions = impostor.getParam(\"nativeOptions\");\n\n      for (var key in nativeOptions) {\n        if (Object.prototype.hasOwnProperty.call(nativeOptions, key)) {\n          bodyCreationObject[key] = nativeOptions[key];\n        }\n      }\n\n      impostor.physicsBody = new this.BJSCANNON.Body(bodyCreationObject);\n      impostor.physicsBody.addEventListener(\"collide\", impostor.onCollide);\n      this.world.addEventListener(\"preStep\", impostor.beforeStep);\n      this.world.addEventListener(\"postStep\", impostor.afterStep);\n      impostor.physicsBody.addShape(shape);\n\n      if (typeof this.world.addBody === \"function\") {\n        this.world.addBody(impostor.physicsBody);\n      } else {\n        this.world.add(impostor.physicsBody);\n      } //try to keep the body moving in the right direction by taking old properties.\n      //Should be tested!\n\n\n      if (oldBody_1) {\n        [\"force\", \"torque\", \"velocity\", \"angularVelocity\"].forEach(function (param) {\n          var vec = oldBody_1[param];\n          impostor.physicsBody[param].set(vec.x, vec.y, vec.z);\n        });\n      }\n\n      this._processChildMeshes(impostor);\n    } //now update the body's transformation\n\n\n    this._updatePhysicsBodyTransformation(impostor);\n  };\n\n  CannonJSPlugin.prototype._processChildMeshes = function (mainImpostor) {\n    var _this = this;\n\n    var meshChildren = mainImpostor.object.getChildMeshes ? mainImpostor.object.getChildMeshes(true) : [];\n    var mainRotation = mainImpostor.object.rotationQuaternion;\n\n    if (mainRotation) {\n      mainRotation.conjugateToRef(this._tmpQuaternion);\n    } else {\n      this._tmpQuaternion.set(0, 0, 0, 1);\n    }\n\n    if (meshChildren.length) {\n      var processMesh_1 = function processMesh_1(mesh) {\n        if (!mesh.rotationQuaternion) {\n          return;\n        }\n\n        var childImpostor = mesh.getPhysicsImpostor();\n\n        if (childImpostor) {\n          var parent_1 = childImpostor.parent;\n\n          if (parent_1 !== mainImpostor && mesh.parent) {\n            var pPosition = mesh.getAbsolutePosition().subtract(mesh.parent.getAbsolutePosition());\n            var q = mesh.rotationQuaternion.multiply(_this._tmpQuaternion);\n\n            if (childImpostor.physicsBody) {\n              _this.removePhysicsBody(childImpostor);\n\n              childImpostor.physicsBody = null;\n            }\n\n            childImpostor.parent = mainImpostor;\n            childImpostor.resetUpdateFlags();\n            mainImpostor.physicsBody.addShape(_this._createShape(childImpostor), new _this.BJSCANNON.Vec3(pPosition.x, pPosition.y, pPosition.z), new _this.BJSCANNON.Quaternion(q.x, q.y, q.z, q.w)); //Add the mass of the children.\n\n            mainImpostor.physicsBody.mass += childImpostor.getParam(\"mass\");\n          }\n        }\n\n        mesh.getChildMeshes(true).filter(function (m) {\n          return !!m.physicsImpostor;\n        }).forEach(processMesh_1);\n      };\n\n      meshChildren.filter(function (m) {\n        return !!m.physicsImpostor;\n      }).forEach(processMesh_1);\n    }\n  };\n\n  CannonJSPlugin.prototype.removePhysicsBody = function (impostor) {\n    impostor.physicsBody.removeEventListener(\"collide\", impostor.onCollide);\n    this.world.removeEventListener(\"preStep\", impostor.beforeStep);\n    this.world.removeEventListener(\"postStep\", impostor.afterStep); // Only remove the physics body after the physics step to avoid disrupting cannon's internal state\n\n    if (this._physicsBodysToRemoveAfterStep.indexOf(impostor.physicsBody) === -1) {\n      this._physicsBodysToRemoveAfterStep.push(impostor.physicsBody);\n    }\n  };\n\n  CannonJSPlugin.prototype.generateJoint = function (impostorJoint) {\n    var mainBody = impostorJoint.mainImpostor.physicsBody;\n    var connectedBody = impostorJoint.connectedImpostor.physicsBody;\n\n    if (!mainBody || !connectedBody) {\n      return;\n    }\n\n    var constraint;\n    var jointData = impostorJoint.joint.jointData; //TODO - https://github.com/schteppe/this.BJSCANNON.js/blob/gh-pages/demos/collisionFilter.html\n\n    var constraintData = {\n      pivotA: jointData.mainPivot ? new this.BJSCANNON.Vec3().set(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z) : null,\n      pivotB: jointData.connectedPivot ? new this.BJSCANNON.Vec3().set(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z) : null,\n      axisA: jointData.mainAxis ? new this.BJSCANNON.Vec3().set(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z) : null,\n      axisB: jointData.connectedAxis ? new this.BJSCANNON.Vec3().set(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z) : null,\n      maxForce: jointData.nativeParams.maxForce,\n      collideConnected: !!jointData.collision\n    };\n\n    switch (impostorJoint.joint.type) {\n      case PhysicsJoint.HingeJoint:\n      case PhysicsJoint.Hinge2Joint:\n        constraint = new this.BJSCANNON.HingeConstraint(mainBody, connectedBody, constraintData);\n        break;\n\n      case PhysicsJoint.DistanceJoint:\n        constraint = new this.BJSCANNON.DistanceConstraint(mainBody, connectedBody, jointData.maxDistance || 2);\n        break;\n\n      case PhysicsJoint.SpringJoint:\n        {\n          var springData = jointData;\n          constraint = new this.BJSCANNON.Spring(mainBody, connectedBody, {\n            restLength: springData.length,\n            stiffness: springData.stiffness,\n            damping: springData.damping,\n            localAnchorA: constraintData.pivotA,\n            localAnchorB: constraintData.pivotB\n          });\n          break;\n        }\n\n      case PhysicsJoint.LockJoint:\n        constraint = new this.BJSCANNON.LockConstraint(mainBody, connectedBody, constraintData);\n        break;\n\n      case PhysicsJoint.PointToPointJoint:\n      case PhysicsJoint.BallAndSocketJoint:\n      default:\n        constraint = new this.BJSCANNON.PointToPointConstraint(mainBody, constraintData.pivotA, connectedBody, constraintData.pivotB, constraintData.maxForce);\n        break;\n    } //set the collideConnected flag after the creation, since DistanceJoint ignores it.\n\n\n    constraint.collideConnected = !!jointData.collision;\n    impostorJoint.joint.physicsJoint = constraint; //don't add spring as constraint, as it is not one.\n\n    if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {\n      this.world.addConstraint(constraint);\n    } else {\n      impostorJoint.joint.jointData.forceApplicationCallback = impostorJoint.joint.jointData.forceApplicationCallback || function () {\n        constraint.applyForce();\n      };\n\n      impostorJoint.mainImpostor.registerAfterPhysicsStep(impostorJoint.joint.jointData.forceApplicationCallback);\n    }\n  };\n\n  CannonJSPlugin.prototype.removeJoint = function (impostorJoint) {\n    if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {\n      this.world.removeConstraint(impostorJoint.joint.physicsJoint);\n    } else {\n      impostorJoint.mainImpostor.unregisterAfterPhysicsStep(impostorJoint.joint.jointData.forceApplicationCallback);\n    }\n  };\n\n  CannonJSPlugin.prototype._addMaterial = function (name, friction, restitution) {\n    var index;\n    var mat;\n\n    for (index = 0; index < this._physicsMaterials.length; index++) {\n      mat = this._physicsMaterials[index];\n\n      if (mat.friction === friction && mat.restitution === restitution) {\n        return mat;\n      }\n    }\n\n    var currentMat = new this.BJSCANNON.Material(name);\n    currentMat.friction = friction;\n    currentMat.restitution = restitution;\n\n    this._physicsMaterials.push(currentMat);\n\n    return currentMat;\n  };\n\n  CannonJSPlugin.prototype._checkWithEpsilon = function (value) {\n    return value < PhysicsEngine.Epsilon ? PhysicsEngine.Epsilon : value;\n  };\n\n  CannonJSPlugin.prototype._createShape = function (impostor) {\n    var object = impostor.object;\n    var returnValue;\n    var extendSize = impostor.getObjectExtendSize();\n\n    switch (impostor.type) {\n      case PhysicsImpostor.SphereImpostor:\n        {\n          var radiusX = extendSize.x;\n          var radiusY = extendSize.y;\n          var radiusZ = extendSize.z;\n          returnValue = new this.BJSCANNON.Sphere(Math.max(this._checkWithEpsilon(radiusX), this._checkWithEpsilon(radiusY), this._checkWithEpsilon(radiusZ)) / 2);\n          break;\n        }\n      //TMP also for cylinder - TODO Cannon supports cylinder natively.\n\n      case PhysicsImpostor.CylinderImpostor:\n        {\n          var nativeParams = impostor.getParam(\"nativeOptions\");\n\n          if (!nativeParams) {\n            nativeParams = {};\n          }\n\n          var radiusTop = nativeParams.radiusTop !== undefined ? nativeParams.radiusTop : this._checkWithEpsilon(extendSize.x) / 2;\n          var radiusBottom = nativeParams.radiusBottom !== undefined ? nativeParams.radiusBottom : this._checkWithEpsilon(extendSize.x) / 2;\n          var height = nativeParams.height !== undefined ? nativeParams.height : this._checkWithEpsilon(extendSize.y);\n          var numSegments = nativeParams.numSegments !== undefined ? nativeParams.numSegments : 16;\n          returnValue = new this.BJSCANNON.Cylinder(radiusTop, radiusBottom, height, numSegments); // Rotate 90 degrees as this shape is horizontal in cannon\n\n          var quat = new this.BJSCANNON.Quaternion();\n          quat.setFromAxisAngle(new this.BJSCANNON.Vec3(1, 0, 0), -Math.PI / 2);\n          var translation = new this.BJSCANNON.Vec3(0, 0, 0);\n          returnValue.transformAllPoints(translation, quat);\n          break;\n        }\n\n      case PhysicsImpostor.BoxImpostor:\n        {\n          var box = extendSize.scale(0.5);\n          returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(this._checkWithEpsilon(box.x), this._checkWithEpsilon(box.y), this._checkWithEpsilon(box.z)));\n          break;\n        }\n\n      case PhysicsImpostor.PlaneImpostor:\n        Logger.Warn(\"Attention, PlaneImposter might not behave as you expect. Consider using BoxImposter instead\");\n        returnValue = new this.BJSCANNON.Plane();\n        break;\n\n      case PhysicsImpostor.MeshImpostor:\n        {\n          // should transform the vertex data to world coordinates!!\n          var rawVerts = object.getVerticesData ? object.getVerticesData(VertexBuffer.PositionKind) : [];\n          var rawFaces = object.getIndices ? object.getIndices() : [];\n\n          if (!rawVerts) {\n            Logger.Warn(\"Tried to create a MeshImpostor for an object without vertices. This will fail.\");\n            return;\n          } // get only scale! so the object could transform correctly.\n\n\n          var oldPosition = object.position.clone();\n          var oldRotation = object.rotation && object.rotation.clone();\n          var oldQuaternion = object.rotationQuaternion && object.rotationQuaternion.clone();\n          object.position.copyFromFloats(0, 0, 0);\n          object.rotation && object.rotation.copyFromFloats(0, 0, 0);\n          object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());\n          object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();\n          var transform = object.computeWorldMatrix(true); // convert rawVerts to object space\n\n          var temp = new Array();\n          var index = void 0;\n\n          for (index = 0; index < rawVerts.length; index += 3) {\n            Vector3.TransformCoordinates(Vector3.FromArray(rawVerts, index), transform).toArray(temp, index);\n          }\n\n          Logger.Warn(\"MeshImpostor only collides against spheres.\");\n          returnValue = new this.BJSCANNON.Trimesh(temp, rawFaces); //now set back the transformation!\n\n          object.position.copyFrom(oldPosition);\n          oldRotation && object.rotation && object.rotation.copyFrom(oldRotation);\n          oldQuaternion && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion);\n          break;\n        }\n\n      case PhysicsImpostor.HeightmapImpostor:\n        {\n          var oldPosition2 = object.position.clone();\n          var oldRotation2 = object.rotation && object.rotation.clone();\n          var oldQuaternion2 = object.rotationQuaternion && object.rotationQuaternion.clone();\n          object.position.copyFromFloats(0, 0, 0);\n          object.rotation && object.rotation.copyFromFloats(0, 0, 0);\n          object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());\n          object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();\n          object.rotationQuaternion && object.rotationQuaternion.multiplyInPlace(this._minus90X);\n          returnValue = this._createHeightmap(object);\n          object.position.copyFrom(oldPosition2);\n          oldRotation2 && object.rotation && object.rotation.copyFrom(oldRotation2);\n          oldQuaternion2 && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion2);\n          object.computeWorldMatrix(true);\n          break;\n        }\n\n      case PhysicsImpostor.ParticleImpostor:\n        returnValue = new this.BJSCANNON.Particle();\n        break;\n\n      case PhysicsImpostor.NoImpostor:\n        returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(0, 0, 0));\n        break;\n    }\n\n    return returnValue;\n  };\n\n  CannonJSPlugin.prototype._createHeightmap = function (object, pointDepth) {\n    var pos = object.getVerticesData(VertexBuffer.PositionKind);\n    var transform = object.computeWorldMatrix(true); // convert rawVerts to object space\n\n    var temp = new Array();\n    var index;\n\n    for (index = 0; index < pos.length; index += 3) {\n      Vector3.TransformCoordinates(Vector3.FromArray(pos, index), transform).toArray(temp, index);\n    }\n\n    pos = temp;\n    var matrix = new Array(); //For now pointDepth will not be used and will be automatically calculated.\n    //Future reference - try and find the best place to add a reference to the pointDepth variable.\n\n    var arraySize = pointDepth || ~~(Math.sqrt(pos.length / 3) - 1);\n    var boundingInfo = object.getBoundingInfo();\n    var dim = Math.min(boundingInfo.boundingBox.extendSizeWorld.x, boundingInfo.boundingBox.extendSizeWorld.y);\n    var minY = boundingInfo.boundingBox.extendSizeWorld.z;\n    var elementSize = dim * 2 / arraySize;\n\n    for (var i = 0; i < pos.length; i = i + 3) {\n      var x = Math.round(pos[i + 0] / elementSize + arraySize / 2);\n      var z = Math.round((pos[i + 1] / elementSize - arraySize / 2) * -1);\n      var y = -pos[i + 2] + minY;\n\n      if (!matrix[x]) {\n        matrix[x] = [];\n      }\n\n      if (!matrix[x][z]) {\n        matrix[x][z] = y;\n      }\n\n      matrix[x][z] = Math.max(y, matrix[x][z]);\n    }\n\n    for (var x = 0; x <= arraySize; ++x) {\n      if (!matrix[x]) {\n        var loc = 1;\n\n        while (!matrix[(x + loc) % arraySize]) {\n          loc++;\n        }\n\n        matrix[x] = matrix[(x + loc) % arraySize].slice(); //console.log(\"missing x\", x);\n      }\n\n      for (var z = 0; z <= arraySize; ++z) {\n        if (!matrix[x][z]) {\n          var loc = 1;\n          var newValue = void 0;\n\n          while (newValue === undefined) {\n            newValue = matrix[x][(z + loc++) % arraySize];\n          }\n\n          matrix[x][z] = newValue;\n        }\n      }\n    }\n\n    var shape = new this.BJSCANNON.Heightfield(matrix, {\n      elementSize: elementSize\n    }); //For future reference, needed for body transformation\n\n    shape.minY = minY;\n    return shape;\n  };\n\n  CannonJSPlugin.prototype._updatePhysicsBodyTransformation = function (impostor) {\n    var object = impostor.object; //make sure it is updated...\n\n    object.computeWorldMatrix && object.computeWorldMatrix(true); // The delta between the mesh position and the mesh bounding box center\n\n    if (!object.getBoundingInfo()) {\n      return;\n    }\n\n    var center = impostor.getObjectCenter(); //m.getAbsolutePosition().subtract(m.getBoundingInfo().boundingBox.centerWorld)\n\n    this._tmpDeltaPosition.copyFrom(object.getAbsolutePivotPoint().subtract(center));\n\n    this._tmpDeltaPosition.divideInPlace(impostor.object.scaling);\n\n    this._tmpPosition.copyFrom(center);\n\n    var quaternion = object.rotationQuaternion;\n\n    if (!quaternion) {\n      return;\n    } //is shape is a plane or a heightmap, it must be rotated 90 degs in the X axis.\n    //ideally these would be rotated at time of creation like cylinder but they dont extend ConvexPolyhedron\n\n\n    if (impostor.type === PhysicsImpostor.PlaneImpostor || impostor.type === PhysicsImpostor.HeightmapImpostor) {\n      //-90 DEG in X, precalculated\n      quaternion = quaternion.multiply(this._minus90X); //Invert! (Precalculated, 90 deg in X)\n      //No need to clone. this will never change.\n\n      impostor.setDeltaRotation(this._plus90X);\n    } //If it is a heightfield, if should be centered.\n\n\n    if (impostor.type === PhysicsImpostor.HeightmapImpostor) {\n      var mesh = object;\n      var boundingInfo = mesh.getBoundingInfo(); //calculate the correct body position:\n\n      var rotationQuaternion = mesh.rotationQuaternion;\n      mesh.rotationQuaternion = this._tmpUnityRotation;\n      mesh.computeWorldMatrix(true); //get original center with no rotation\n\n      var c = center.clone();\n      var oldPivot = mesh.getPivotMatrix();\n\n      if (oldPivot) {\n        // create a copy the pivot Matrix as it is modified in place\n        oldPivot = oldPivot.clone();\n      } else {\n        oldPivot = Matrix.Identity();\n      } //calculate the new center using a pivot (since this.BJSCANNON.js doesn't center height maps)\n\n\n      var p = Matrix.Translation(boundingInfo.boundingBox.extendSizeWorld.x, 0, -boundingInfo.boundingBox.extendSizeWorld.z);\n      mesh.setPreTransformMatrix(p);\n      mesh.computeWorldMatrix(true); // force bounding box recomputation\n\n      boundingInfo = mesh.getBoundingInfo(); //calculate the translation\n\n      var translation = boundingInfo.boundingBox.centerWorld.subtract(center).subtract(mesh.position).negate();\n\n      this._tmpPosition.copyFromFloats(translation.x, translation.y - boundingInfo.boundingBox.extendSizeWorld.y, translation.z); //add it inverted to the delta\n\n\n      this._tmpDeltaPosition.copyFrom(boundingInfo.boundingBox.centerWorld.subtract(c));\n\n      this._tmpDeltaPosition.y += boundingInfo.boundingBox.extendSizeWorld.y; //rotation is back\n\n      mesh.rotationQuaternion = rotationQuaternion;\n      mesh.setPreTransformMatrix(oldPivot);\n      mesh.computeWorldMatrix(true);\n    } else if (impostor.type === PhysicsImpostor.MeshImpostor) {\n      this._tmpDeltaPosition.copyFromFloats(0, 0, 0);\n    }\n\n    impostor.setDeltaPosition(this._tmpDeltaPosition); //Now update the impostor object\n\n    impostor.physicsBody.position.set(this._tmpPosition.x, this._tmpPosition.y, this._tmpPosition.z);\n    impostor.physicsBody.quaternion.set(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n  };\n\n  CannonJSPlugin.prototype.setTransformationFromPhysicsBody = function (impostor) {\n    impostor.object.position.set(impostor.physicsBody.position.x, impostor.physicsBody.position.y, impostor.physicsBody.position.z);\n\n    if (impostor.object.rotationQuaternion) {\n      var q = impostor.physicsBody.quaternion;\n      impostor.object.rotationQuaternion.set(q.x, q.y, q.z, q.w);\n    }\n  };\n\n  CannonJSPlugin.prototype.setPhysicsBodyTransformation = function (impostor, newPosition, newRotation) {\n    impostor.physicsBody.position.set(newPosition.x, newPosition.y, newPosition.z);\n    impostor.physicsBody.quaternion.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\n  };\n\n  CannonJSPlugin.prototype.isSupported = function () {\n    return this.BJSCANNON !== undefined;\n  };\n\n  CannonJSPlugin.prototype.setLinearVelocity = function (impostor, velocity) {\n    impostor.physicsBody.velocity.set(velocity.x, velocity.y, velocity.z);\n  };\n\n  CannonJSPlugin.prototype.setAngularVelocity = function (impostor, velocity) {\n    impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);\n  };\n\n  CannonJSPlugin.prototype.getLinearVelocity = function (impostor) {\n    var v = impostor.physicsBody.velocity;\n\n    if (!v) {\n      return null;\n    }\n\n    return new Vector3(v.x, v.y, v.z);\n  };\n\n  CannonJSPlugin.prototype.getAngularVelocity = function (impostor) {\n    var v = impostor.physicsBody.angularVelocity;\n\n    if (!v) {\n      return null;\n    }\n\n    return new Vector3(v.x, v.y, v.z);\n  };\n\n  CannonJSPlugin.prototype.setBodyMass = function (impostor, mass) {\n    impostor.physicsBody.mass = mass;\n    impostor.physicsBody.updateMassProperties();\n  };\n\n  CannonJSPlugin.prototype.getBodyMass = function (impostor) {\n    return impostor.physicsBody.mass;\n  };\n\n  CannonJSPlugin.prototype.getBodyFriction = function (impostor) {\n    return impostor.physicsBody.material.friction;\n  };\n\n  CannonJSPlugin.prototype.setBodyFriction = function (impostor, friction) {\n    impostor.physicsBody.material.friction = friction;\n  };\n\n  CannonJSPlugin.prototype.getBodyRestitution = function (impostor) {\n    return impostor.physicsBody.material.restitution;\n  };\n\n  CannonJSPlugin.prototype.setBodyRestitution = function (impostor, restitution) {\n    impostor.physicsBody.material.restitution = restitution;\n  };\n\n  CannonJSPlugin.prototype.sleepBody = function (impostor) {\n    impostor.physicsBody.sleep();\n  };\n\n  CannonJSPlugin.prototype.wakeUpBody = function (impostor) {\n    impostor.physicsBody.wakeUp();\n  };\n\n  CannonJSPlugin.prototype.updateDistanceJoint = function (joint, maxDistance) {\n    joint.physicsJoint.distance = maxDistance;\n  };\n\n  CannonJSPlugin.prototype.setMotor = function (joint, speed, maxForce, motorIndex) {\n    if (!motorIndex) {\n      joint.physicsJoint.enableMotor();\n      joint.physicsJoint.setMotorSpeed(speed);\n\n      if (maxForce) {\n        this.setLimit(joint, maxForce);\n      }\n    }\n  };\n\n  CannonJSPlugin.prototype.setLimit = function (joint, upperLimit, lowerLimit) {\n    joint.physicsJoint.motorEquation.maxForce = upperLimit;\n    joint.physicsJoint.motorEquation.minForce = lowerLimit === void 0 ? -upperLimit : lowerLimit;\n  };\n\n  CannonJSPlugin.prototype.syncMeshWithImpostor = function (mesh, impostor) {\n    var body = impostor.physicsBody;\n    mesh.position.x = body.position.x;\n    mesh.position.y = body.position.y;\n    mesh.position.z = body.position.z;\n\n    if (mesh.rotationQuaternion) {\n      mesh.rotationQuaternion.x = body.quaternion.x;\n      mesh.rotationQuaternion.y = body.quaternion.y;\n      mesh.rotationQuaternion.z = body.quaternion.z;\n      mesh.rotationQuaternion.w = body.quaternion.w;\n    }\n  };\n\n  CannonJSPlugin.prototype.getRadius = function (impostor) {\n    var shape = impostor.physicsBody.shapes[0];\n    return shape.boundingSphereRadius;\n  };\n\n  CannonJSPlugin.prototype.getBoxSizeToRef = function (impostor, result) {\n    var shape = impostor.physicsBody.shapes[0];\n    result.x = shape.halfExtents.x * 2;\n    result.y = shape.halfExtents.y * 2;\n    result.z = shape.halfExtents.z * 2;\n  };\n\n  CannonJSPlugin.prototype.dispose = function () {};\n\n  CannonJSPlugin.prototype._extendNamespace = function () {\n    //this will force cannon to execute at least one step when using interpolation\n    var step_tmp1 = new this.BJSCANNON.Vec3();\n    var engine = this.BJSCANNON;\n\n    this.BJSCANNON.World.prototype.step = function (dt, timeSinceLastCalled, maxSubSteps) {\n      maxSubSteps = maxSubSteps || 10;\n      timeSinceLastCalled = timeSinceLastCalled || 0;\n\n      if (timeSinceLastCalled === 0) {\n        this.internalStep(dt);\n        this.time += dt;\n      } else {\n        var internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);\n        internalSteps = Math.min(internalSteps, maxSubSteps) || 1;\n        var t0 = performance.now();\n\n        for (var i = 0; i !== internalSteps; i++) {\n          this.internalStep(dt);\n\n          if (performance.now() - t0 > dt * 1000) {\n            break;\n          }\n        }\n\n        this.time += timeSinceLastCalled;\n        var h = this.time % dt;\n        var h_div_dt = h / dt;\n        var interpvelo = step_tmp1;\n        var bodies = this.bodies;\n\n        for (var j = 0; j !== bodies.length; j++) {\n          var b = bodies[j];\n\n          if (b.type !== engine.Body.STATIC && b.sleepState !== engine.Body.SLEEPING) {\n            b.position.vsub(b.previousPosition, interpvelo);\n            interpvelo.scale(h_div_dt, interpvelo);\n            b.position.vadd(interpvelo, b.interpolatedPosition);\n          } else {\n            b.interpolatedPosition.set(b.position.x, b.position.y, b.position.z);\n            b.interpolatedQuaternion.set(b.quaternion.x, b.quaternion.y, b.quaternion.z, b.quaternion.w);\n          }\n        }\n      }\n    };\n  };\n  /**\n   * Does a raycast in the physics world\n   * @param from when should the ray start?\n   * @param to when should the ray end?\n   * @returns PhysicsRaycastResult\n   */\n\n\n  CannonJSPlugin.prototype.raycast = function (from, to) {\n    this._cannonRaycastResult.reset();\n\n    this.world.raycastClosest(from, to, {}, this._cannonRaycastResult);\n\n    this._raycastResult.reset(from, to);\n\n    if (this._cannonRaycastResult.hasHit) {\n      // TODO: do we also want to get the body it hit?\n      this._raycastResult.setHitData({\n        x: this._cannonRaycastResult.hitNormalWorld.x,\n        y: this._cannonRaycastResult.hitNormalWorld.y,\n        z: this._cannonRaycastResult.hitNormalWorld.z\n      }, {\n        x: this._cannonRaycastResult.hitPointWorld.x,\n        y: this._cannonRaycastResult.hitPointWorld.y,\n        z: this._cannonRaycastResult.hitPointWorld.z\n      });\n\n      this._raycastResult.setHitDistance(this._cannonRaycastResult.distance);\n    }\n\n    return this._raycastResult;\n  };\n\n  return CannonJSPlugin;\n}();\n\nexport { CannonJSPlugin };\n\nPhysicsEngine.DefaultPluginFactory = function () {\n  return new CannonJSPlugin();\n};","map":{"version":3,"mappings":"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","names":["Logger","Vector3","Matrix","Quaternion","VertexBuffer","PhysicsImpostor","PhysicsJoint","PhysicsEngine","PhysicsRaycastResult","_useDeltaForWorldStep","iterations","cannonInjection","Array","Zero","BJSCANNON","isSupported","Error","_extendNamespace","world","World","broadphase","NaiveBroadphase","solver","_cannonRaycastResult","RaycastResult","_raycastResult","CannonJSPlugin","gravity","vec","set","x","y","z","timeStep","_fixedTimeStep","delta","impostors","_firstFrame","_i","impostor","type","HeightmapImpostor","PlaneImpostor","beforeStep","step","_removeMarkedPhysicsBodiesFromWorld","_physicsBodysToRemoveAfterStep","length","forEach","physicsBody","_this","removeBody","remove","force","contactPoint","worldPoint","Vec3","impulse","applyImpulse","applyForce","parent","removePhysicsBody","forceUpdate","isBodyInitRequired","shape","_createShape","Warn","oldBody_1","material","_addMaterial","uniqueId","getParam","bodyCreationObject","mass","nativeOptions","key","Object","prototype","hasOwnProperty","call","Body","addEventListener","onCollide","afterStep","addShape","addBody","add","param","_processChildMeshes","_updatePhysicsBodyTransformation","mainImpostor","meshChildren","object","getChildMeshes","mainRotation","rotationQuaternion","conjugateToRef","_tmpQuaternion","processMesh_1","mesh","childImpostor","getPhysicsImpostor","parent_1","pPosition","getAbsolutePosition","subtract","q","multiply","resetUpdateFlags","w","filter","m","physicsImpostor","removeEventListener","indexOf","push","impostorJoint","mainBody","connectedBody","connectedImpostor","constraint","jointData","joint","constraintData","pivotA","mainPivot","pivotB","connectedPivot","axisA","mainAxis","axisB","connectedAxis","maxForce","nativeParams","collideConnected","collision","HingeJoint","Hinge2Joint","HingeConstraint","DistanceJoint","DistanceConstraint","maxDistance","SpringJoint","springData","Spring","restLength","stiffness","damping","localAnchorA","localAnchorB","LockJoint","LockConstraint","PointToPointJoint","BallAndSocketJoint","PointToPointConstraint","physicsJoint","addConstraint","forceApplicationCallback","registerAfterPhysicsStep","removeConstraint","unregisterAfterPhysicsStep","name","friction","restitution","index","mat","_physicsMaterials","currentMat","Material","value","Epsilon","returnValue","extendSize","getObjectExtendSize","SphereImpostor","radiusX","radiusY","radiusZ","Sphere","Math","max","_checkWithEpsilon","CylinderImpostor","radiusTop","undefined","radiusBottom","height","numSegments","Cylinder","quat","setFromAxisAngle","PI","translation","transformAllPoints","BoxImpostor","box","scale","Box","Plane","MeshImpostor","rawVerts","getVerticesData","PositionKind","rawFaces","getIndices","oldPosition","position","clone","oldRotation","rotation","oldQuaternion","copyFromFloats","copyFrom","getParentsRotation","conjugateInPlace","transform","computeWorldMatrix","temp","TransformCoordinates","FromArray","toArray","Trimesh","oldPosition2","oldRotation2","oldQuaternion2","multiplyInPlace","_minus90X","_createHeightmap","ParticleImpostor","Particle","NoImpostor","pointDepth","pos","matrix","arraySize","sqrt","boundingInfo","getBoundingInfo","dim","min","boundingBox","extendSizeWorld","minY","elementSize","i","round","loc","slice","newValue","Heightfield","center","getObjectCenter","_tmpDeltaPosition","getAbsolutePivotPoint","divideInPlace","scaling","_tmpPosition","quaternion","setDeltaRotation","_plus90X","_tmpUnityRotation","c","oldPivot","getPivotMatrix","Identity","p","Translation","setPreTransformMatrix","centerWorld","negate","setDeltaPosition","newPosition","newRotation","velocity","angularVelocity","v","updateMassProperties","sleep","wakeUp","distance","speed","motorIndex","enableMotor","setMotorSpeed","setLimit","upperLimit","lowerLimit","motorEquation","minForce","body","shapes","boundingSphereRadius","result","halfExtents","step_tmp1","engine","dt","timeSinceLastCalled","maxSubSteps","internalStep","time","internalSteps","floor","t0","performance","now","h","h_div_dt","interpvelo","bodies","j","b","STATIC","sleepState","SLEEPING","vsub","previousPosition","vadd","interpolatedPosition","interpolatedQuaternion","from","to","reset","raycastClosest","hasHit","setHitData","hitNormalWorld","hitPointWorld","setHitDistance","DefaultPluginFactory"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Physics/Plugins/cannonJSPlugin.ts"],"sourcesContent":["import type { Nullable, FloatArray } from \"../../types\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { IPhysicsEnginePlugin, PhysicsImpostorJoint } from \"../../Physics/IPhysicsEngine\";\r\nimport type { IPhysicsEnabledObject } from \"../../Physics/physicsImpostor\";\r\nimport { PhysicsImpostor } from \"../../Physics/physicsImpostor\";\r\nimport type { IMotorEnabledJoint, DistanceJointData, SpringJointData } from \"../../Physics/physicsJoint\";\r\nimport { PhysicsJoint } from \"../../Physics/physicsJoint\";\r\nimport { PhysicsEngine } from \"../../Physics/physicsEngine\";\r\nimport { PhysicsRaycastResult } from \"../physicsRaycastResult\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\n\r\n//declare var require: any;\r\ndeclare let CANNON: any;\r\n\r\n/** @hidden */\r\nexport class CannonJSPlugin implements IPhysicsEnginePlugin {\r\n    public world: any;\r\n    public name: string = \"CannonJSPlugin\";\r\n    private _physicsMaterials = new Array();\r\n    private _fixedTimeStep: number = 1 / 60;\r\n    private _cannonRaycastResult: any;\r\n    private _raycastResult: PhysicsRaycastResult;\r\n    private _physicsBodysToRemoveAfterStep = new Array<any>();\r\n    private _firstFrame = true;\r\n    private _tmpQuaternion: Quaternion = new Quaternion();\r\n    //See https://github.com/schteppe/CANNON.js/blob/gh-pages/demos/collisionFilter.html\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public BJSCANNON: any;\r\n\r\n    public constructor(private _useDeltaForWorldStep: boolean = true, iterations: number = 10, cannonInjection = CANNON) {\r\n        this.BJSCANNON = cannonInjection;\r\n        if (!this.isSupported()) {\r\n            Logger.Error(\"CannonJS is not available. Please make sure you included the js file.\");\r\n            return;\r\n        }\r\n\r\n        this._extendNamespace();\r\n\r\n        this.world = new this.BJSCANNON.World();\r\n        this.world.broadphase = new this.BJSCANNON.NaiveBroadphase();\r\n        this.world.solver.iterations = iterations;\r\n        this._cannonRaycastResult = new this.BJSCANNON.RaycastResult();\r\n        this._raycastResult = new PhysicsRaycastResult();\r\n    }\r\n\r\n    public setGravity(gravity: Vector3): void {\r\n        const vec = gravity;\r\n        this.world.gravity.set(vec.x, vec.y, vec.z);\r\n    }\r\n\r\n    public setTimeStep(timeStep: number) {\r\n        this._fixedTimeStep = timeStep;\r\n    }\r\n\r\n    public getTimeStep(): number {\r\n        return this._fixedTimeStep;\r\n    }\r\n\r\n    public executeStep(delta: number, impostors: Array<PhysicsImpostor>): void {\r\n        // due to cannon's architecture, the first frame's before-step is skipped.\r\n        if (this._firstFrame) {\r\n            this._firstFrame = false;\r\n            for (const impostor of impostors) {\r\n                if (!(impostor.type == PhysicsImpostor.HeightmapImpostor || impostor.type === PhysicsImpostor.PlaneImpostor)) {\r\n                    impostor.beforeStep();\r\n                }\r\n            }\r\n        }\r\n        this.world.step(this._useDeltaForWorldStep ? delta : this._fixedTimeStep);\r\n        this._removeMarkedPhysicsBodiesFromWorld();\r\n    }\r\n\r\n    private _removeMarkedPhysicsBodiesFromWorld(): void {\r\n        if (this._physicsBodysToRemoveAfterStep.length > 0) {\r\n            this._physicsBodysToRemoveAfterStep.forEach((physicsBody) => {\r\n                if (typeof this.world.removeBody === \"function\") {\r\n                    this.world.removeBody(physicsBody);\r\n                } else {\r\n                    this.world.remove(physicsBody);\r\n                }\r\n            });\r\n            this._physicsBodysToRemoveAfterStep = [];\r\n        }\r\n    }\r\n\r\n    public applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        const worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\r\n        const impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);\r\n\r\n        impostor.physicsBody.applyImpulse(impulse, worldPoint);\r\n    }\r\n\r\n    public applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        const worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\r\n        const impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);\r\n\r\n        impostor.physicsBody.applyForce(impulse, worldPoint);\r\n    }\r\n\r\n    public generatePhysicsBody(impostor: PhysicsImpostor) {\r\n        // When calling forceUpdate generatePhysicsBody is called again, ensure that the updated body does not instantly collide with removed body\r\n        this._removeMarkedPhysicsBodiesFromWorld();\r\n\r\n        //parent-child relationship. Does this impostor has a parent impostor?\r\n        if (impostor.parent) {\r\n            if (impostor.physicsBody) {\r\n                this.removePhysicsBody(impostor);\r\n                //TODO is that needed?\r\n                impostor.forceUpdate();\r\n            }\r\n            return;\r\n        }\r\n\r\n        //should a new body be created for this impostor?\r\n        if (impostor.isBodyInitRequired()) {\r\n            const shape = this._createShape(impostor);\r\n            if (!shape) {\r\n                Logger.Warn(\"It was not possible to create a physics body for this object.\");\r\n                return;\r\n            }\r\n\r\n            //unregister events, if body is being changed\r\n            const oldBody = impostor.physicsBody;\r\n            if (oldBody) {\r\n                this.removePhysicsBody(impostor);\r\n            }\r\n\r\n            //create the body and material\r\n            const material = this._addMaterial(\"mat-\" + impostor.uniqueId, impostor.getParam(\"friction\"), impostor.getParam(\"restitution\"));\r\n\r\n            const bodyCreationObject = {\r\n                mass: impostor.getParam(\"mass\"),\r\n                material: material,\r\n            };\r\n            // A simple extend, in case native options were used.\r\n            const nativeOptions = impostor.getParam(\"nativeOptions\");\r\n            for (const key in nativeOptions) {\r\n                if (Object.prototype.hasOwnProperty.call(nativeOptions, key)) {\r\n                    (<any>bodyCreationObject)[key] = nativeOptions[key];\r\n                }\r\n            }\r\n            impostor.physicsBody = new this.BJSCANNON.Body(bodyCreationObject);\r\n            impostor.physicsBody.addEventListener(\"collide\", impostor.onCollide);\r\n            this.world.addEventListener(\"preStep\", impostor.beforeStep);\r\n            this.world.addEventListener(\"postStep\", impostor.afterStep);\r\n            impostor.physicsBody.addShape(shape);\r\n            if (typeof this.world.addBody === \"function\") {\r\n                this.world.addBody(impostor.physicsBody);\r\n            } else {\r\n                this.world.add(impostor.physicsBody);\r\n            }\r\n\r\n            //try to keep the body moving in the right direction by taking old properties.\r\n            //Should be tested!\r\n            if (oldBody) {\r\n                [\"force\", \"torque\", \"velocity\", \"angularVelocity\"].forEach(function (param) {\r\n                    const vec = oldBody[param];\r\n                    impostor.physicsBody[param].set(vec.x, vec.y, vec.z);\r\n                });\r\n            }\r\n            this._processChildMeshes(impostor);\r\n        }\r\n\r\n        //now update the body's transformation\r\n        this._updatePhysicsBodyTransformation(impostor);\r\n    }\r\n\r\n    private _processChildMeshes(mainImpostor: PhysicsImpostor) {\r\n        const meshChildren = mainImpostor.object.getChildMeshes ? mainImpostor.object.getChildMeshes(true) : [];\r\n        const mainRotation: Nullable<Quaternion> = mainImpostor.object.rotationQuaternion;\r\n        if (mainRotation) {\r\n            mainRotation.conjugateToRef(this._tmpQuaternion);\r\n        } else {\r\n            this._tmpQuaternion.set(0, 0, 0, 1);\r\n        }\r\n\r\n        if (meshChildren.length) {\r\n            const processMesh = (mesh: AbstractMesh) => {\r\n                if (!mesh.rotationQuaternion) {\r\n                    return;\r\n                }\r\n\r\n                const childImpostor = mesh.getPhysicsImpostor();\r\n                if (childImpostor) {\r\n                    const parent = childImpostor.parent;\r\n                    if (parent !== mainImpostor && mesh.parent) {\r\n                        const pPosition = mesh.getAbsolutePosition().subtract((mesh.parent as TransformNode).getAbsolutePosition());\r\n                        const q = mesh.rotationQuaternion.multiply(this._tmpQuaternion);\r\n\r\n                        if (childImpostor.physicsBody) {\r\n                            this.removePhysicsBody(childImpostor);\r\n                            childImpostor.physicsBody = null;\r\n                        }\r\n                        childImpostor.parent = mainImpostor;\r\n                        childImpostor.resetUpdateFlags();\r\n                        mainImpostor.physicsBody.addShape(\r\n                            this._createShape(childImpostor),\r\n                            new this.BJSCANNON.Vec3(pPosition.x, pPosition.y, pPosition.z),\r\n                            new this.BJSCANNON.Quaternion(q.x, q.y, q.z, q.w)\r\n                        );\r\n                        //Add the mass of the children.\r\n                        mainImpostor.physicsBody.mass += childImpostor.getParam(\"mass\");\r\n                    }\r\n                }\r\n                mesh.getChildMeshes(true)\r\n                    .filter((m) => !!m.physicsImpostor)\r\n                    .forEach(processMesh);\r\n            };\r\n            meshChildren.filter((m) => !!m.physicsImpostor).forEach(processMesh);\r\n        }\r\n    }\r\n\r\n    public removePhysicsBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.removeEventListener(\"collide\", impostor.onCollide);\r\n        this.world.removeEventListener(\"preStep\", impostor.beforeStep);\r\n        this.world.removeEventListener(\"postStep\", impostor.afterStep);\r\n\r\n        // Only remove the physics body after the physics step to avoid disrupting cannon's internal state\r\n        if (this._physicsBodysToRemoveAfterStep.indexOf(impostor.physicsBody) === -1) {\r\n            this._physicsBodysToRemoveAfterStep.push(impostor.physicsBody);\r\n        }\r\n    }\r\n\r\n    public generateJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        const mainBody = impostorJoint.mainImpostor.physicsBody;\r\n        const connectedBody = impostorJoint.connectedImpostor.physicsBody;\r\n        if (!mainBody || !connectedBody) {\r\n            return;\r\n        }\r\n        let constraint: any;\r\n        const jointData = impostorJoint.joint.jointData;\r\n        //TODO - https://github.com/schteppe/this.BJSCANNON.js/blob/gh-pages/demos/collisionFilter.html\r\n        const constraintData = {\r\n            pivotA: jointData.mainPivot ? new this.BJSCANNON.Vec3().set(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z) : null,\r\n            pivotB: jointData.connectedPivot ? new this.BJSCANNON.Vec3().set(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z) : null,\r\n            axisA: jointData.mainAxis ? new this.BJSCANNON.Vec3().set(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z) : null,\r\n            axisB: jointData.connectedAxis ? new this.BJSCANNON.Vec3().set(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z) : null,\r\n            maxForce: jointData.nativeParams.maxForce,\r\n            collideConnected: !!jointData.collision,\r\n        };\r\n        switch (impostorJoint.joint.type) {\r\n            case PhysicsJoint.HingeJoint:\r\n            case PhysicsJoint.Hinge2Joint:\r\n                constraint = new this.BJSCANNON.HingeConstraint(mainBody, connectedBody, constraintData);\r\n                break;\r\n            case PhysicsJoint.DistanceJoint:\r\n                constraint = new this.BJSCANNON.DistanceConstraint(mainBody, connectedBody, (<DistanceJointData>jointData).maxDistance || 2);\r\n                break;\r\n            case PhysicsJoint.SpringJoint: {\r\n                const springData = <SpringJointData>jointData;\r\n                constraint = new this.BJSCANNON.Spring(mainBody, connectedBody, {\r\n                    restLength: springData.length,\r\n                    stiffness: springData.stiffness,\r\n                    damping: springData.damping,\r\n                    localAnchorA: constraintData.pivotA,\r\n                    localAnchorB: constraintData.pivotB,\r\n                });\r\n                break;\r\n            }\r\n            case PhysicsJoint.LockJoint:\r\n                constraint = new this.BJSCANNON.LockConstraint(mainBody, connectedBody, constraintData);\r\n                break;\r\n            case PhysicsJoint.PointToPointJoint:\r\n            case PhysicsJoint.BallAndSocketJoint:\r\n            default:\r\n                constraint = new this.BJSCANNON.PointToPointConstraint(mainBody, constraintData.pivotA, connectedBody, constraintData.pivotB, constraintData.maxForce);\r\n                break;\r\n        }\r\n        //set the collideConnected flag after the creation, since DistanceJoint ignores it.\r\n        constraint.collideConnected = !!jointData.collision;\r\n        impostorJoint.joint.physicsJoint = constraint;\r\n        //don't add spring as constraint, as it is not one.\r\n        if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {\r\n            this.world.addConstraint(constraint);\r\n        } else {\r\n            (<SpringJointData>impostorJoint.joint.jointData).forceApplicationCallback =\r\n                (<SpringJointData>impostorJoint.joint.jointData).forceApplicationCallback ||\r\n                function () {\r\n                    constraint.applyForce();\r\n                };\r\n            impostorJoint.mainImpostor.registerAfterPhysicsStep((<SpringJointData>impostorJoint.joint.jointData).forceApplicationCallback);\r\n        }\r\n    }\r\n\r\n    public removeJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {\r\n            this.world.removeConstraint(impostorJoint.joint.physicsJoint);\r\n        } else {\r\n            impostorJoint.mainImpostor.unregisterAfterPhysicsStep((<SpringJointData>impostorJoint.joint.jointData).forceApplicationCallback);\r\n        }\r\n    }\r\n\r\n    private _addMaterial(name: string, friction: number, restitution: number) {\r\n        let index;\r\n        let mat;\r\n\r\n        for (index = 0; index < this._physicsMaterials.length; index++) {\r\n            mat = this._physicsMaterials[index];\r\n\r\n            if (mat.friction === friction && mat.restitution === restitution) {\r\n                return mat;\r\n            }\r\n        }\r\n\r\n        const currentMat = new this.BJSCANNON.Material(name);\r\n        currentMat.friction = friction;\r\n        currentMat.restitution = restitution;\r\n\r\n        this._physicsMaterials.push(currentMat);\r\n        return currentMat;\r\n    }\r\n\r\n    private _checkWithEpsilon(value: number): number {\r\n        return value < PhysicsEngine.Epsilon ? PhysicsEngine.Epsilon : value;\r\n    }\r\n\r\n    private _createShape(impostor: PhysicsImpostor) {\r\n        const object = impostor.object;\r\n\r\n        let returnValue;\r\n        const extendSize = impostor.getObjectExtendSize();\r\n        switch (impostor.type) {\r\n            case PhysicsImpostor.SphereImpostor: {\r\n                const radiusX = extendSize.x;\r\n                const radiusY = extendSize.y;\r\n                const radiusZ = extendSize.z;\r\n\r\n                returnValue = new this.BJSCANNON.Sphere(Math.max(this._checkWithEpsilon(radiusX), this._checkWithEpsilon(radiusY), this._checkWithEpsilon(radiusZ)) / 2);\r\n\r\n                break;\r\n            }\r\n            //TMP also for cylinder - TODO Cannon supports cylinder natively.\r\n            case PhysicsImpostor.CylinderImpostor: {\r\n                let nativeParams = impostor.getParam(\"nativeOptions\");\r\n                if (!nativeParams) {\r\n                    nativeParams = {};\r\n                }\r\n                const radiusTop = nativeParams.radiusTop !== undefined ? nativeParams.radiusTop : this._checkWithEpsilon(extendSize.x) / 2;\r\n                const radiusBottom = nativeParams.radiusBottom !== undefined ? nativeParams.radiusBottom : this._checkWithEpsilon(extendSize.x) / 2;\r\n                const height = nativeParams.height !== undefined ? nativeParams.height : this._checkWithEpsilon(extendSize.y);\r\n                const numSegments = nativeParams.numSegments !== undefined ? nativeParams.numSegments : 16;\r\n                returnValue = new this.BJSCANNON.Cylinder(radiusTop, radiusBottom, height, numSegments);\r\n\r\n                // Rotate 90 degrees as this shape is horizontal in cannon\r\n                const quat = new this.BJSCANNON.Quaternion();\r\n                quat.setFromAxisAngle(new this.BJSCANNON.Vec3(1, 0, 0), -Math.PI / 2);\r\n                const translation = new this.BJSCANNON.Vec3(0, 0, 0);\r\n                returnValue.transformAllPoints(translation, quat);\r\n                break;\r\n            }\r\n            case PhysicsImpostor.BoxImpostor: {\r\n                const box = extendSize.scale(0.5);\r\n                returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(this._checkWithEpsilon(box.x), this._checkWithEpsilon(box.y), this._checkWithEpsilon(box.z)));\r\n                break;\r\n            }\r\n            case PhysicsImpostor.PlaneImpostor:\r\n                Logger.Warn(\"Attention, PlaneImposter might not behave as you expect. Consider using BoxImposter instead\");\r\n                returnValue = new this.BJSCANNON.Plane();\r\n                break;\r\n            case PhysicsImpostor.MeshImpostor: {\r\n                // should transform the vertex data to world coordinates!!\r\n                const rawVerts = object.getVerticesData ? object.getVerticesData(VertexBuffer.PositionKind) : [];\r\n                const rawFaces = object.getIndices ? object.getIndices() : [];\r\n                if (!rawVerts) {\r\n                    Logger.Warn(\"Tried to create a MeshImpostor for an object without vertices. This will fail.\");\r\n                    return;\r\n                }\r\n                // get only scale! so the object could transform correctly.\r\n                const oldPosition = object.position.clone();\r\n                const oldRotation = object.rotation && object.rotation.clone();\r\n                const oldQuaternion = object.rotationQuaternion && object.rotationQuaternion.clone();\r\n                object.position.copyFromFloats(0, 0, 0);\r\n                object.rotation && object.rotation.copyFromFloats(0, 0, 0);\r\n                object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());\r\n\r\n                object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();\r\n\r\n                const transform = object.computeWorldMatrix(true);\r\n                // convert rawVerts to object space\r\n                const temp = new Array<number>();\r\n                let index: number;\r\n                for (index = 0; index < rawVerts.length; index += 3) {\r\n                    Vector3.TransformCoordinates(Vector3.FromArray(rawVerts, index), transform).toArray(temp, index);\r\n                }\r\n\r\n                Logger.Warn(\"MeshImpostor only collides against spheres.\");\r\n                returnValue = new this.BJSCANNON.Trimesh(temp, <number[]>rawFaces);\r\n                //now set back the transformation!\r\n                object.position.copyFrom(oldPosition);\r\n                oldRotation && object.rotation && object.rotation.copyFrom(oldRotation);\r\n                oldQuaternion && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion);\r\n                break;\r\n            }\r\n            case PhysicsImpostor.HeightmapImpostor: {\r\n                const oldPosition2 = object.position.clone();\r\n                const oldRotation2 = object.rotation && object.rotation.clone();\r\n                const oldQuaternion2 = object.rotationQuaternion && object.rotationQuaternion.clone();\r\n                object.position.copyFromFloats(0, 0, 0);\r\n                object.rotation && object.rotation.copyFromFloats(0, 0, 0);\r\n                object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());\r\n                object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();\r\n                object.rotationQuaternion && object.rotationQuaternion.multiplyInPlace(this._minus90X);\r\n\r\n                returnValue = this._createHeightmap(object);\r\n                object.position.copyFrom(oldPosition2);\r\n                oldRotation2 && object.rotation && object.rotation.copyFrom(oldRotation2);\r\n                oldQuaternion2 && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion2);\r\n                object.computeWorldMatrix(true);\r\n                break;\r\n            }\r\n            case PhysicsImpostor.ParticleImpostor:\r\n                returnValue = new this.BJSCANNON.Particle();\r\n                break;\r\n            case PhysicsImpostor.NoImpostor:\r\n                returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(0, 0, 0));\r\n                break;\r\n        }\r\n\r\n        return returnValue;\r\n    }\r\n\r\n    private _createHeightmap(object: IPhysicsEnabledObject, pointDepth?: number) {\r\n        let pos = <FloatArray>object.getVerticesData(VertexBuffer.PositionKind);\r\n        const transform = object.computeWorldMatrix(true);\r\n        // convert rawVerts to object space\r\n        const temp = new Array<number>();\r\n        let index: number;\r\n        for (index = 0; index < pos.length; index += 3) {\r\n            Vector3.TransformCoordinates(Vector3.FromArray(pos, index), transform).toArray(temp, index);\r\n        }\r\n        pos = temp;\r\n        const matrix = new Array<Array<any>>();\r\n\r\n        //For now pointDepth will not be used and will be automatically calculated.\r\n        //Future reference - try and find the best place to add a reference to the pointDepth variable.\r\n        const arraySize = pointDepth || ~~(Math.sqrt(pos.length / 3) - 1);\r\n        const boundingInfo = object.getBoundingInfo();\r\n        const dim = Math.min(boundingInfo.boundingBox.extendSizeWorld.x, boundingInfo.boundingBox.extendSizeWorld.y);\r\n        const minY = boundingInfo.boundingBox.extendSizeWorld.z;\r\n\r\n        const elementSize = (dim * 2) / arraySize;\r\n\r\n        for (let i = 0; i < pos.length; i = i + 3) {\r\n            const x = Math.round(pos[i + 0] / elementSize + arraySize / 2);\r\n            const z = Math.round((pos[i + 1] / elementSize - arraySize / 2) * -1);\r\n            const y = -pos[i + 2] + minY;\r\n            if (!matrix[x]) {\r\n                matrix[x] = [];\r\n            }\r\n            if (!matrix[x][z]) {\r\n                matrix[x][z] = y;\r\n            }\r\n            matrix[x][z] = Math.max(y, matrix[x][z]);\r\n        }\r\n\r\n        for (let x = 0; x <= arraySize; ++x) {\r\n            if (!matrix[x]) {\r\n                let loc = 1;\r\n                while (!matrix[(x + loc) % arraySize]) {\r\n                    loc++;\r\n                }\r\n                matrix[x] = matrix[(x + loc) % arraySize].slice();\r\n                //console.log(\"missing x\", x);\r\n            }\r\n            for (let z = 0; z <= arraySize; ++z) {\r\n                if (!matrix[x][z]) {\r\n                    let loc = 1;\r\n                    let newValue;\r\n                    while (newValue === undefined) {\r\n                        newValue = matrix[x][(z + loc++) % arraySize];\r\n                    }\r\n                    matrix[x][z] = newValue;\r\n                }\r\n            }\r\n        }\r\n\r\n        const shape = new this.BJSCANNON.Heightfield(matrix, {\r\n            elementSize: elementSize,\r\n        });\r\n\r\n        //For future reference, needed for body transformation\r\n        shape.minY = minY;\r\n\r\n        return shape;\r\n    }\r\n\r\n    private _minus90X = new Quaternion(-0.7071067811865475, 0, 0, 0.7071067811865475);\r\n    private _plus90X = new Quaternion(0.7071067811865475, 0, 0, 0.7071067811865475);\r\n    private _tmpPosition: Vector3 = Vector3.Zero();\r\n    private _tmpDeltaPosition: Vector3 = Vector3.Zero();\r\n    private _tmpUnityRotation: Quaternion = new Quaternion();\r\n\r\n    private _updatePhysicsBodyTransformation(impostor: PhysicsImpostor) {\r\n        const object = impostor.object;\r\n        //make sure it is updated...\r\n        object.computeWorldMatrix && object.computeWorldMatrix(true);\r\n        // The delta between the mesh position and the mesh bounding box center\r\n        if (!object.getBoundingInfo()) {\r\n            return;\r\n        }\r\n        const center = impostor.getObjectCenter();\r\n        //m.getAbsolutePosition().subtract(m.getBoundingInfo().boundingBox.centerWorld)\r\n        this._tmpDeltaPosition.copyFrom(object.getAbsolutePivotPoint().subtract(center));\r\n        this._tmpDeltaPosition.divideInPlace(impostor.object.scaling);\r\n        this._tmpPosition.copyFrom(center);\r\n        let quaternion = object.rotationQuaternion;\r\n\r\n        if (!quaternion) {\r\n            return;\r\n        }\r\n\r\n        //is shape is a plane or a heightmap, it must be rotated 90 degs in the X axis.\r\n        //ideally these would be rotated at time of creation like cylinder but they dont extend ConvexPolyhedron\r\n        if (impostor.type === PhysicsImpostor.PlaneImpostor || impostor.type === PhysicsImpostor.HeightmapImpostor) {\r\n            //-90 DEG in X, precalculated\r\n            quaternion = quaternion.multiply(this._minus90X);\r\n            //Invert! (Precalculated, 90 deg in X)\r\n            //No need to clone. this will never change.\r\n            impostor.setDeltaRotation(this._plus90X);\r\n        }\r\n\r\n        //If it is a heightfield, if should be centered.\r\n        if (impostor.type === PhysicsImpostor.HeightmapImpostor) {\r\n            const mesh = <AbstractMesh>(<any>object);\r\n            let boundingInfo = mesh.getBoundingInfo();\r\n            //calculate the correct body position:\r\n            const rotationQuaternion = mesh.rotationQuaternion;\r\n            mesh.rotationQuaternion = this._tmpUnityRotation;\r\n            mesh.computeWorldMatrix(true);\r\n\r\n            //get original center with no rotation\r\n            const c = center.clone();\r\n\r\n            let oldPivot = mesh.getPivotMatrix();\r\n            if (oldPivot) {\r\n                // create a copy the pivot Matrix as it is modified in place\r\n                oldPivot = oldPivot.clone();\r\n            } else {\r\n                oldPivot = Matrix.Identity();\r\n            }\r\n\r\n            //calculate the new center using a pivot (since this.BJSCANNON.js doesn't center height maps)\r\n            const p = Matrix.Translation(boundingInfo.boundingBox.extendSizeWorld.x, 0, -boundingInfo.boundingBox.extendSizeWorld.z);\r\n            mesh.setPreTransformMatrix(p);\r\n            mesh.computeWorldMatrix(true);\r\n            // force bounding box recomputation\r\n            boundingInfo = mesh.getBoundingInfo();\r\n\r\n            //calculate the translation\r\n            const translation = boundingInfo.boundingBox.centerWorld.subtract(center).subtract(mesh.position).negate();\r\n\r\n            this._tmpPosition.copyFromFloats(translation.x, translation.y - boundingInfo.boundingBox.extendSizeWorld.y, translation.z);\r\n            //add it inverted to the delta\r\n            this._tmpDeltaPosition.copyFrom(boundingInfo.boundingBox.centerWorld.subtract(c));\r\n            this._tmpDeltaPosition.y += boundingInfo.boundingBox.extendSizeWorld.y;\r\n            //rotation is back\r\n            mesh.rotationQuaternion = rotationQuaternion;\r\n\r\n            mesh.setPreTransformMatrix(oldPivot);\r\n            mesh.computeWorldMatrix(true);\r\n        } else if (impostor.type === PhysicsImpostor.MeshImpostor) {\r\n            this._tmpDeltaPosition.copyFromFloats(0, 0, 0);\r\n        }\r\n\r\n        impostor.setDeltaPosition(this._tmpDeltaPosition);\r\n        //Now update the impostor object\r\n        impostor.physicsBody.position.set(this._tmpPosition.x, this._tmpPosition.y, this._tmpPosition.z);\r\n        impostor.physicsBody.quaternion.set(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\r\n    }\r\n\r\n    public setTransformationFromPhysicsBody(impostor: PhysicsImpostor) {\r\n        impostor.object.position.set(impostor.physicsBody.position.x, impostor.physicsBody.position.y, impostor.physicsBody.position.z);\r\n        if (impostor.object.rotationQuaternion) {\r\n            const q = impostor.physicsBody.quaternion;\r\n            impostor.object.rotationQuaternion.set(q.x, q.y, q.z, q.w);\r\n        }\r\n    }\r\n\r\n    public setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion) {\r\n        impostor.physicsBody.position.set(newPosition.x, newPosition.y, newPosition.z);\r\n        impostor.physicsBody.quaternion.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\r\n    }\r\n\r\n    public isSupported(): boolean {\r\n        return this.BJSCANNON !== undefined;\r\n    }\r\n\r\n    public setLinearVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        impostor.physicsBody.velocity.set(velocity.x, velocity.y, velocity.z);\r\n    }\r\n\r\n    public setAngularVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);\r\n    }\r\n\r\n    public getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        const v = impostor.physicsBody.velocity;\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        return new Vector3(v.x, v.y, v.z);\r\n    }\r\n    public getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        const v = impostor.physicsBody.angularVelocity;\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        return new Vector3(v.x, v.y, v.z);\r\n    }\r\n\r\n    public setBodyMass(impostor: PhysicsImpostor, mass: number) {\r\n        impostor.physicsBody.mass = mass;\r\n        impostor.physicsBody.updateMassProperties();\r\n    }\r\n\r\n    public getBodyMass(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.mass;\r\n    }\r\n\r\n    public getBodyFriction(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.material.friction;\r\n    }\r\n\r\n    public setBodyFriction(impostor: PhysicsImpostor, friction: number) {\r\n        impostor.physicsBody.material.friction = friction;\r\n    }\r\n\r\n    public getBodyRestitution(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.material.restitution;\r\n    }\r\n\r\n    public setBodyRestitution(impostor: PhysicsImpostor, restitution: number) {\r\n        impostor.physicsBody.material.restitution = restitution;\r\n    }\r\n\r\n    public sleepBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.sleep();\r\n    }\r\n\r\n    public wakeUpBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.wakeUp();\r\n    }\r\n\r\n    public updateDistanceJoint(joint: PhysicsJoint, maxDistance: number) {\r\n        joint.physicsJoint.distance = maxDistance;\r\n    }\r\n\r\n    public setMotor(joint: IMotorEnabledJoint, speed?: number, maxForce?: number, motorIndex?: number) {\r\n        if (!motorIndex) {\r\n            joint.physicsJoint.enableMotor();\r\n            joint.physicsJoint.setMotorSpeed(speed);\r\n            if (maxForce) {\r\n                this.setLimit(joint, maxForce);\r\n            }\r\n        }\r\n    }\r\n\r\n    public setLimit(joint: IMotorEnabledJoint, upperLimit: number, lowerLimit?: number) {\r\n        joint.physicsJoint.motorEquation.maxForce = upperLimit;\r\n        joint.physicsJoint.motorEquation.minForce = lowerLimit === void 0 ? -upperLimit : lowerLimit;\r\n    }\r\n\r\n    public syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor) {\r\n        const body = impostor.physicsBody;\r\n\r\n        mesh.position.x = body.position.x;\r\n        mesh.position.y = body.position.y;\r\n        mesh.position.z = body.position.z;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            mesh.rotationQuaternion.x = body.quaternion.x;\r\n            mesh.rotationQuaternion.y = body.quaternion.y;\r\n            mesh.rotationQuaternion.z = body.quaternion.z;\r\n            mesh.rotationQuaternion.w = body.quaternion.w;\r\n        }\r\n    }\r\n\r\n    public getRadius(impostor: PhysicsImpostor): number {\r\n        const shape = impostor.physicsBody.shapes[0];\r\n        return shape.boundingSphereRadius;\r\n    }\r\n\r\n    public getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void {\r\n        const shape = impostor.physicsBody.shapes[0];\r\n        result.x = shape.halfExtents.x * 2;\r\n        result.y = shape.halfExtents.y * 2;\r\n        result.z = shape.halfExtents.z * 2;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    private _extendNamespace() {\r\n        //this will force cannon to execute at least one step when using interpolation\r\n        const step_tmp1 = new this.BJSCANNON.Vec3();\r\n        const engine = this.BJSCANNON;\r\n        this.BJSCANNON.World.prototype.step = function (dt: number, timeSinceLastCalled: number, maxSubSteps: number) {\r\n            maxSubSteps = maxSubSteps || 10;\r\n            timeSinceLastCalled = timeSinceLastCalled || 0;\r\n            if (timeSinceLastCalled === 0) {\r\n                this.internalStep(dt);\r\n                this.time += dt;\r\n            } else {\r\n                let internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);\r\n                internalSteps = Math.min(internalSteps, maxSubSteps) || 1;\r\n                const t0 = performance.now();\r\n                for (let i = 0; i !== internalSteps; i++) {\r\n                    this.internalStep(dt);\r\n                    if (performance.now() - t0 > dt * 1000) {\r\n                        break;\r\n                    }\r\n                }\r\n                this.time += timeSinceLastCalled;\r\n                const h = this.time % dt;\r\n                const h_div_dt = h / dt;\r\n                const interpvelo = step_tmp1;\r\n                const bodies = this.bodies;\r\n                for (let j = 0; j !== bodies.length; j++) {\r\n                    const b = bodies[j];\r\n                    if (b.type !== engine.Body.STATIC && b.sleepState !== engine.Body.SLEEPING) {\r\n                        b.position.vsub(b.previousPosition, interpvelo);\r\n                        interpvelo.scale(h_div_dt, interpvelo);\r\n                        b.position.vadd(interpvelo, b.interpolatedPosition);\r\n                    } else {\r\n                        b.interpolatedPosition.set(b.position.x, b.position.y, b.position.z);\r\n                        b.interpolatedQuaternion.set(b.quaternion.x, b.quaternion.y, b.quaternion.z, b.quaternion.w);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3): PhysicsRaycastResult {\r\n        this._cannonRaycastResult.reset();\r\n        this.world.raycastClosest(from, to, {}, this._cannonRaycastResult);\r\n\r\n        this._raycastResult.reset(from, to);\r\n        if (this._cannonRaycastResult.hasHit) {\r\n            // TODO: do we also want to get the body it hit?\r\n            this._raycastResult.setHitData(\r\n                {\r\n                    x: this._cannonRaycastResult.hitNormalWorld.x,\r\n                    y: this._cannonRaycastResult.hitNormalWorld.y,\r\n                    z: this._cannonRaycastResult.hitNormalWorld.z,\r\n                },\r\n                {\r\n                    x: this._cannonRaycastResult.hitPointWorld.x,\r\n                    y: this._cannonRaycastResult.hitPointWorld.y,\r\n                    z: this._cannonRaycastResult.hitPointWorld.z,\r\n                }\r\n            );\r\n            this._raycastResult.setHitDistance(this._cannonRaycastResult.distance);\r\n        }\r\n\r\n        return this._raycastResult;\r\n    }\r\n}\r\n\r\nPhysicsEngine.DefaultPluginFactory = () => {\r\n    return new CannonJSPlugin();\r\n};\r\n"]},"metadata":{},"sourceType":"module"}