{"ast":null,"code":"import \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.sticky.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array-buffer.is-view.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/web.url.js\";\nimport \"core-js/modules/web.url-search-params.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.string.substr.js\";\nimport \"core-js/modules/web.timers.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport { __assign, __extends } from \"tslib\";\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { WebRequest } from \"./webRequest.js\";\nimport { IsWindowObjectExist } from \"./domManagement.js\";\nimport { Observable } from \"./observable.js\";\nimport { FilesInputStore } from \"./filesInputStore.js\";\nimport { RetryStrategy } from \"./retryStrategy.js\";\nimport { BaseError, ErrorCodes, RuntimeError } from \"./error.js\";\nimport { DecodeBase64ToBinary, DecodeBase64ToString, EncodeArrayBufferToBase64 } from \"./stringTools.js\";\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor.js\";\nimport { ThinEngine } from \"../Engines/thinEngine.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Logger } from \"./logger.js\";\nimport { TimingTools } from \"./timingTools.js\";\nvar Base64DataUrlRegEx = new RegExp(/^data:([^,]+\\/[^,]+)?;base64,/i);\n/** @ignore */\n\nvar LoadFileError =\n/** @class */\nfunction (_super) {\n  __extends(LoadFileError, _super);\n  /**\n   * Creates a new LoadFileError\n   * @param message defines the message of the error\n   * @param object defines the optional web request\n   */\n\n\n  function LoadFileError(message, object) {\n    var _this = _super.call(this, message, ErrorCodes.LoadFileError) || this;\n\n    _this.name = \"LoadFileError\";\n\n    BaseError._setPrototypeOf(_this, LoadFileError.prototype);\n\n    if (object instanceof WebRequest) {\n      _this.request = object;\n    } else {\n      _this.file = object;\n    }\n\n    return _this;\n  }\n\n  return LoadFileError;\n}(RuntimeError);\n\nexport { LoadFileError };\n/** @ignore */\n\nvar RequestFileError =\n/** @class */\nfunction (_super) {\n  __extends(RequestFileError, _super);\n  /**\n   * Creates a new LoadFileError\n   * @param message defines the message of the error\n   * @param request defines the optional web request\n   */\n\n\n  function RequestFileError(message, request) {\n    var _this = _super.call(this, message, ErrorCodes.RequestFileError) || this;\n\n    _this.request = request;\n    _this.name = \"RequestFileError\";\n\n    BaseError._setPrototypeOf(_this, RequestFileError.prototype);\n\n    return _this;\n  }\n\n  return RequestFileError;\n}(RuntimeError);\n\nexport { RequestFileError };\n/** @ignore */\n\nvar ReadFileError =\n/** @class */\nfunction (_super) {\n  __extends(ReadFileError, _super);\n  /**\n   * Creates a new ReadFileError\n   * @param message defines the message of the error\n   * @param file defines the optional file\n   */\n\n\n  function ReadFileError(message, file) {\n    var _this = _super.call(this, message, ErrorCodes.ReadFileError) || this;\n\n    _this.file = file;\n    _this.name = \"ReadFileError\";\n\n    BaseError._setPrototypeOf(_this, ReadFileError.prototype);\n\n    return _this;\n  }\n\n  return ReadFileError;\n}(RuntimeError);\n\nexport { ReadFileError };\n/**\n * @hidden\n */\n\nexport var FileToolsOptions = {\n  /**\n   * Gets or sets the retry strategy to apply when an error happens while loading an asset.\n   * When defining this function, return the wait time before trying again or return -1 to\n   * stop retrying and error out.\n   */\n  DefaultRetryStrategy: RetryStrategy.ExponentialBackoff(),\n\n  /**\n   * Gets or sets the base URL to use to load assets\n   */\n  BaseUrl: \"\",\n\n  /**\n   * Default behaviour for cors in the application.\n   * It can be a string if the expected behavior is identical in the entire app.\n   * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)\n   */\n  CorsBehavior: \"anonymous\",\n\n  /**\n   * Gets or sets a function used to pre-process url before using them to load assets\n   * @param url\n   */\n  PreprocessUrl: function PreprocessUrl(url) {\n    return url;\n  }\n};\n/**\n * Removes unwanted characters from an url\n * @param url defines the url to clean\n * @returns the cleaned url\n */\n\nvar _CleanUrl = function _CleanUrl(url) {\n  url = url.replace(/#/gm, \"%23\");\n  return url;\n};\n/**\n * Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.\n * @param url define the url we are trying\n * @param element define the dom element where to configure the cors policy\n * @param element.crossOrigin\n * @hidden\n */\n\n\nexport var SetCorsBehavior = function SetCorsBehavior(url, element) {\n  if (url && url.indexOf(\"data:\") === 0) {\n    return;\n  }\n\n  if (FileToolsOptions.CorsBehavior) {\n    if (typeof FileToolsOptions.CorsBehavior === \"string\" || FileToolsOptions.CorsBehavior instanceof String) {\n      element.crossOrigin = FileToolsOptions.CorsBehavior;\n    } else {\n      var result = FileToolsOptions.CorsBehavior(url);\n\n      if (result) {\n        element.crossOrigin = result;\n      }\n    }\n  }\n};\n/**\n * Loads an image as an HTMLImageElement.\n * @param input url string, ArrayBuffer, or Blob to load\n * @param onLoad callback called when the image successfully loads\n * @param onError callback called when the image fails to load\n * @param offlineProvider offline provider for caching\n * @param mimeType optional mime type\n * @param imageBitmapOptions\n * @returns the HTMLImageElement of the loaded image\n * @hidden\n */\n\nexport var LoadImage = function LoadImage(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions) {\n  var _a;\n\n  if (mimeType === void 0) {\n    mimeType = \"\";\n  }\n\n  var url;\n  var usingObjectURL = false;\n\n  if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {\n    if (typeof Blob !== \"undefined\") {\n      url = URL.createObjectURL(new Blob([input], {\n        type: mimeType\n      }));\n      usingObjectURL = true;\n    } else {\n      url = \"data:\".concat(mimeType, \";base64,\") + EncodeArrayBufferToBase64(input);\n    }\n  } else if (input instanceof Blob) {\n    url = URL.createObjectURL(input);\n    usingObjectURL = true;\n  } else {\n    url = _CleanUrl(input);\n    url = FileToolsOptions.PreprocessUrl(input);\n  }\n\n  var engine = EngineStore.LastCreatedEngine;\n\n  var onErrorHandler = function onErrorHandler(exception) {\n    if (onError) {\n      var inputText = url || input.toString();\n      onError(\"Error while trying to load image: \".concat(inputText.indexOf(\"http\") === 0 || inputText.length <= 128 ? inputText : inputText.slice(0, 128) + \"...\"), exception);\n    }\n  };\n\n  if (typeof Image === \"undefined\" || ((_a = engine === null || engine === void 0 ? void 0 : engine._features.forceBitmapOverHTMLImageElement) !== null && _a !== void 0 ? _a : false)) {\n    LoadFile(url, function (data) {\n      engine.createImageBitmap(new Blob([data], {\n        type: mimeType\n      }), __assign({\n        premultiplyAlpha: \"none\"\n      }, imageBitmapOptions)).then(function (imgBmp) {\n        onLoad(imgBmp);\n\n        if (usingObjectURL) {\n          URL.revokeObjectURL(url);\n        }\n      })[\"catch\"](function (reason) {\n        if (onError) {\n          onError(\"Error while trying to load image: \" + input, reason);\n        }\n      });\n    }, undefined, offlineProvider || undefined, true, function (request, exception) {\n      onErrorHandler(exception);\n    });\n    return null;\n  }\n\n  var img = new Image();\n  SetCorsBehavior(url, img);\n\n  var loadHandler = function loadHandler() {\n    img.removeEventListener(\"load\", loadHandler);\n    img.removeEventListener(\"error\", errorHandler);\n    onLoad(img); // Must revoke the URL after calling onLoad to avoid security exceptions in\n    // certain scenarios (e.g. when hosted in vscode).\n\n    if (usingObjectURL && img.src) {\n      URL.revokeObjectURL(img.src);\n    }\n  };\n\n  var errorHandler = function errorHandler(err) {\n    img.removeEventListener(\"load\", loadHandler);\n    img.removeEventListener(\"error\", errorHandler);\n    onErrorHandler(err);\n\n    if (usingObjectURL && img.src) {\n      URL.revokeObjectURL(img.src);\n    }\n  };\n\n  img.addEventListener(\"load\", loadHandler);\n  img.addEventListener(\"error\", errorHandler);\n\n  var noOfflineSupport = function noOfflineSupport() {\n    img.src = url;\n  };\n\n  var loadFromOfflineSupport = function loadFromOfflineSupport() {\n    if (offlineProvider) {\n      offlineProvider.loadImage(url, img);\n    }\n  };\n\n  if (url.substr(0, 5) !== \"blob:\" && url.substr(0, 5) !== \"data:\" && offlineProvider && offlineProvider.enableTexturesOffline) {\n    offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);\n  } else {\n    if (url.indexOf(\"file:\") !== -1) {\n      var textureName = decodeURIComponent(url.substring(5).toLowerCase());\n\n      if (FilesInputStore.FilesToLoad[textureName]) {\n        try {\n          var blobURL = void 0;\n\n          try {\n            blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\n          } catch (ex) {\n            // Chrome doesn't support oneTimeOnly parameter\n            blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\n          }\n\n          img.src = blobURL;\n          usingObjectURL = true;\n        } catch (e) {\n          img.src = \"\";\n        }\n\n        return img;\n      }\n    }\n\n    noOfflineSupport();\n  }\n\n  return img;\n};\n/**\n * Reads a file from a File object\n * @param file defines the file to load\n * @param onSuccess defines the callback to call when data is loaded\n * @param onProgress defines the callback to call during loading process\n * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer\n * @param onError defines the callback to call when an error occurs\n * @returns a file request object\n * @hidden\n */\n\nexport var ReadFile = function ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError) {\n  var reader = new FileReader();\n  var fileRequest = {\n    onCompleteObservable: new Observable(),\n    abort: function abort() {\n      return reader.abort();\n    }\n  };\n\n  reader.onloadend = function () {\n    return fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n  };\n\n  if (onError) {\n    reader.onerror = function () {\n      onError(new ReadFileError(\"Unable to read \".concat(file.name), file));\n    };\n  }\n\n  reader.onload = function (e) {\n    //target doesn't have result from ts 1.3\n    onSuccess(e.target[\"result\"]);\n  };\n\n  if (onProgress) {\n    reader.onprogress = onProgress;\n  }\n\n  if (!useArrayBuffer) {\n    // Asynchronous read\n    reader.readAsText(file);\n  } else {\n    reader.readAsArrayBuffer(file);\n  }\n\n  return fileRequest;\n};\n/**\n * Loads a file from a url, a data url, or a file url\n * @param fileOrUrl file, url, data url, or file url to load\n * @param onSuccess callback called when the file successfully loads\n * @param onProgress callback called while file is loading (if the server supports this mode)\n * @param offlineProvider defines the offline provider for caching\n * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\n * @param onError callback called when the file fails to load\n * @param onOpened\n * @returns a file request object\n * @hidden\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\nexport var LoadFile = function LoadFile(fileOrUrl, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) {\n  if (fileOrUrl.name) {\n    return ReadFile(fileOrUrl, onSuccess, onProgress, useArrayBuffer, onError ? function (error) {\n      onError(undefined, error);\n    } : undefined);\n  }\n\n  var url = fileOrUrl; // If file and file input are set\n\n  if (url.indexOf(\"file:\") !== -1) {\n    var fileName = decodeURIComponent(url.substring(5).toLowerCase());\n\n    if (fileName.indexOf(\"./\") === 0) {\n      fileName = fileName.substring(2);\n    }\n\n    var file = FilesInputStore.FilesToLoad[fileName];\n\n    if (file) {\n      return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError ? function (error) {\n        return onError(undefined, new LoadFileError(error.message, error.file));\n      } : undefined);\n    }\n  } // For a Base64 Data URL\n\n\n  if (IsBase64DataUrl(url)) {\n    var fileRequest_1 = {\n      onCompleteObservable: new Observable(),\n      abort: function abort() {\n        return function () {};\n      }\n    };\n\n    try {\n      onSuccess(useArrayBuffer ? DecodeBase64UrlToBinary(url) : DecodeBase64UrlToString(url));\n    } catch (error) {\n      if (onError) {\n        onError(undefined, error);\n      } else {\n        Logger.Error(error.message || \"Failed to parse the Data URL\");\n      }\n    }\n\n    TimingTools.SetImmediate(function () {\n      fileRequest_1.onCompleteObservable.notifyObservers(fileRequest_1);\n    });\n    return fileRequest_1;\n  }\n\n  return RequestFile(url, function (data, request) {\n    onSuccess(data, request ? request.responseURL : undefined);\n  }, onProgress, offlineProvider, useArrayBuffer, onError ? function (error) {\n    onError(error.request, new LoadFileError(error.message, error.request));\n  } : undefined, onOpened);\n};\n/**\n * Loads a file from a url\n * @param url url to load\n * @param onSuccess callback called when the file successfully loads\n * @param onProgress callback called while file is loading (if the server supports this mode)\n * @param offlineProvider defines the offline provider for caching\n * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\n * @param onError callback called when the file fails to load\n * @param onOpened callback called when the web request is opened\n * @returns a file request object\n * @hidden\n */\n\nexport var RequestFile = function RequestFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) {\n  url = _CleanUrl(url);\n  url = FileToolsOptions.PreprocessUrl(url);\n  var loadUrl = FileToolsOptions.BaseUrl + url;\n  var aborted = false;\n  var fileRequest = {\n    onCompleteObservable: new Observable(),\n    abort: function abort() {\n      return aborted = true;\n    }\n  };\n\n  var requestFile = function requestFile() {\n    var request = new WebRequest();\n    var retryHandle = null;\n\n    var _onReadyStateChange;\n\n    var unbindEvents = function unbindEvents() {\n      if (!request) {\n        return;\n      }\n\n      if (onProgress) {\n        request.removeEventListener(\"progress\", onProgress);\n      }\n\n      if (_onReadyStateChange) {\n        request.removeEventListener(\"readystatechange\", _onReadyStateChange);\n      }\n\n      request.removeEventListener(\"loadend\", _onLoadEnd);\n    };\n\n    var _onLoadEnd = function onLoadEnd() {\n      unbindEvents();\n      fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n      fileRequest.onCompleteObservable.clear();\n      onProgress = undefined;\n      _onReadyStateChange = null;\n      _onLoadEnd = null;\n      onError = undefined;\n      onOpened = undefined;\n      onSuccess = undefined;\n    };\n\n    fileRequest.abort = function () {\n      aborted = true;\n\n      if (_onLoadEnd) {\n        _onLoadEnd();\n      }\n\n      if (request && request.readyState !== (XMLHttpRequest.DONE || 4)) {\n        request.abort();\n      }\n\n      if (retryHandle !== null) {\n        clearTimeout(retryHandle);\n        retryHandle = null;\n      }\n\n      request = null;\n    };\n\n    var handleError = function handleError(error) {\n      var message = error.message || \"Unknown error\";\n\n      if (onError && request) {\n        onError(new RequestFileError(message, request));\n      } else {\n        Logger.Error(message);\n      }\n    };\n\n    var retryLoop = function retryLoop(retryIndex) {\n      if (!request) {\n        return;\n      }\n\n      request.open(\"GET\", loadUrl);\n\n      if (onOpened) {\n        try {\n          onOpened(request);\n        } catch (e) {\n          handleError(e);\n          return;\n        }\n      }\n\n      if (useArrayBuffer) {\n        request.responseType = \"arraybuffer\";\n      }\n\n      if (onProgress) {\n        request.addEventListener(\"progress\", onProgress);\n      }\n\n      if (_onLoadEnd) {\n        request.addEventListener(\"loadend\", _onLoadEnd);\n      }\n\n      _onReadyStateChange = function onReadyStateChange() {\n        if (aborted || !request) {\n          return;\n        } // In case of undefined state in some browsers.\n\n\n        if (request.readyState === (XMLHttpRequest.DONE || 4)) {\n          // Some browsers have issues where onreadystatechange can be called multiple times with the same value.\n          if (_onReadyStateChange) {\n            request.removeEventListener(\"readystatechange\", _onReadyStateChange);\n          }\n\n          if (request.status >= 200 && request.status < 300 || request.status === 0 && (!IsWindowObjectExist() || IsFileURL())) {\n            try {\n              if (onSuccess) {\n                onSuccess(useArrayBuffer ? request.response : request.responseText, request);\n              }\n            } catch (e) {\n              handleError(e);\n            }\n\n            return;\n          }\n\n          var retryStrategy = FileToolsOptions.DefaultRetryStrategy;\n\n          if (retryStrategy) {\n            var waitTime = retryStrategy(loadUrl, request, retryIndex);\n\n            if (waitTime !== -1) {\n              // Prevent the request from completing for retry.\n              unbindEvents();\n              request = new WebRequest();\n              retryHandle = setTimeout(function () {\n                return retryLoop(retryIndex + 1);\n              }, waitTime);\n              return;\n            }\n          }\n\n          var error = new RequestFileError(\"Error status: \" + request.status + \" \" + request.statusText + \" - Unable to load \" + loadUrl, request);\n\n          if (onError) {\n            onError(error);\n          }\n        }\n      };\n\n      request.addEventListener(\"readystatechange\", _onReadyStateChange);\n      request.send();\n    };\n\n    retryLoop(0);\n  }; // Caching all files\n\n\n  if (offlineProvider && offlineProvider.enableSceneOffline) {\n    var noOfflineSupport_1 = function noOfflineSupport_1(request) {\n      if (request && request.status > 400) {\n        if (onError) {\n          onError(request);\n        }\n      } else {\n        requestFile();\n      }\n    };\n\n    var loadFromOfflineSupport = function loadFromOfflineSupport() {\n      // TODO: database needs to support aborting and should return a IFileRequest\n      if (offlineProvider) {\n        offlineProvider.loadFile(FileToolsOptions.BaseUrl + url, function (data) {\n          if (!aborted && onSuccess) {\n            onSuccess(data);\n          }\n\n          fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n        }, onProgress ? function (event) {\n          if (!aborted && onProgress) {\n            onProgress(event);\n          }\n        } : undefined, noOfflineSupport_1, useArrayBuffer);\n      }\n    };\n\n    offlineProvider.open(loadFromOfflineSupport, noOfflineSupport_1);\n  } else {\n    requestFile();\n  }\n\n  return fileRequest;\n};\n/**\n * Checks if the loaded document was accessed via `file:`-Protocol.\n * @returns boolean\n * @hidden\n */\n\nexport var IsFileURL = function IsFileURL() {\n  return typeof location !== \"undefined\" && location.protocol === \"file:\";\n};\n/**\n * Test if the given uri is a valid base64 data url\n * @param uri The uri to test\n * @return True if the uri is a base64 data url or false otherwise\n * @hidden\n */\n\nexport var IsBase64DataUrl = function IsBase64DataUrl(uri) {\n  return Base64DataUrlRegEx.test(uri);\n};\n/**\n * Decode the given base64 uri.\n * @param uri The uri to decode\n * @return The decoded base64 data.\n * @hidden\n */\n\nexport function DecodeBase64UrlToBinary(uri) {\n  return DecodeBase64ToBinary(uri.split(\",\")[1]);\n}\n/**\n * Decode the given base64 uri into a UTF-8 encoded string.\n * @param uri The uri to decode\n * @return The decoded base64 data.\n * @hidden\n */\n\nexport var DecodeBase64UrlToString = function DecodeBase64UrlToString(uri) {\n  return DecodeBase64ToString(uri.split(\",\")[1]);\n};\n/**\n * This will be executed automatically for UMD and es5.\n * If esm dev wants the side effects to execute they will have to run it manually\n * Once we build native modules those need to be exported.\n * @hidden\n */\n\nvar initSideEffects = function initSideEffects() {\n  ThinEngine._FileToolsLoadImage = LoadImage;\n  ThinEngine._FileToolsLoadFile = LoadFile;\n  ShaderProcessor._FileToolsLoadFile = LoadFile;\n};\n\ninitSideEffects();\n/**\n* FileTools defined as any.\n* This should not be imported or used in future releases or in any module in the framework\n* @hidden\n* @deprecated import the needed function from fileTools.ts\n*/\n\nexport var FileTools;\n/**\n * @param DecodeBase64UrlToBinary\n * @param DecodeBase64UrlToString\n * @param FileToolsOptions\n * @param FileToolsOptions.DefaultRetryStrategy\n * @param FileToolsOptions.BaseUrl\n * @param FileToolsOptions.CorsBehavior\n * @param FileToolsOptions.PreprocessUrl\n * @param IsBase64DataUrl\n * @param IsFileURL\n * @param LoadFile\n * @param LoadImage\n * @param ReadFile\n * @param RequestFile\n * @param SetCorsBehavior\n * @hidden\n */\n\nexport var _injectLTSFileTools = function _injectLTSFileTools(DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior) {\n  /**\n   * Backwards compatibility.\n   * @hidden\n   * @deprecated\n   */\n  FileTools = {\n    DecodeBase64UrlToBinary: DecodeBase64UrlToBinary,\n    DecodeBase64UrlToString: DecodeBase64UrlToString,\n    DefaultRetryStrategy: FileToolsOptions.DefaultRetryStrategy,\n    BaseUrl: FileToolsOptions.BaseUrl,\n    CorsBehavior: FileToolsOptions.CorsBehavior,\n    PreprocessUrl: FileToolsOptions.PreprocessUrl,\n    IsBase64DataUrl: IsBase64DataUrl,\n    IsFileURL: IsFileURL,\n    LoadFile: LoadFile,\n    LoadImage: LoadImage,\n    ReadFile: ReadFile,\n    RequestFile: RequestFile,\n    SetCorsBehavior: SetCorsBehavior\n  };\n  Object.defineProperty(FileTools, \"DefaultRetryStrategy\", {\n    get: function get() {\n      return FileToolsOptions.DefaultRetryStrategy;\n    },\n    set: function set(value) {\n      FileToolsOptions.DefaultRetryStrategy = value;\n    }\n  });\n  Object.defineProperty(FileTools, \"BaseUrl\", {\n    get: function get() {\n      return FileToolsOptions.BaseUrl;\n    },\n    set: function set(value) {\n      FileToolsOptions.BaseUrl = value;\n    }\n  });\n  Object.defineProperty(FileTools, \"PreprocessUrl\", {\n    get: function get() {\n      return FileToolsOptions.PreprocessUrl;\n    },\n    set: function set(value) {\n      FileToolsOptions.PreprocessUrl = value;\n    }\n  });\n  Object.defineProperty(FileTools, \"CorsBehavior\", {\n    get: function get() {\n      return FileToolsOptions.CorsBehavior;\n    },\n    set: function set(value) {\n      FileToolsOptions.CorsBehavior = value;\n    }\n  });\n};\n\n_injectLTSFileTools(DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior);","map":{"version":3,"mappings":"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","names":["WebRequest","IsWindowObjectExist","Observable","FilesInputStore","RetryStrategy","BaseError","ErrorCodes","RuntimeError","DecodeBase64ToBinary","DecodeBase64ToString","EncodeArrayBufferToBase64","ShaderProcessor","ThinEngine","EngineStore","Logger","TimingTools","Base64DataUrlRegEx","RegExp","__extends","message","object","_super","LoadFileError","_this","name","_setPrototypeOf","prototype","request","file","RequestFileError","ReadFileError","FileToolsOptions","DefaultRetryStrategy","ExponentialBackoff","BaseUrl","CorsBehavior","PreprocessUrl","url","_CleanUrl","replace","SetCorsBehavior","element","indexOf","String","crossOrigin","result","LoadImage","input","onLoad","onError","offlineProvider","mimeType","imageBitmapOptions","usingObjectURL","ArrayBuffer","isView","Blob","URL","createObjectURL","type","engine","LastCreatedEngine","onErrorHandler","exception","inputText","toString","length","slice","Image","_features","forceBitmapOverHTMLImageElement","_a","LoadFile","data","createImageBitmap","__assign","premultiplyAlpha","then","imgBmp","revokeObjectURL","reason","undefined","img","loadHandler","removeEventListener","errorHandler","src","err","addEventListener","noOfflineSupport","loadFromOfflineSupport","loadImage","substr","enableTexturesOffline","open","textureName","decodeURIComponent","substring","toLowerCase","FilesToLoad","blobURL","ex","e","ReadFile","onSuccess","onProgress","useArrayBuffer","reader","FileReader","fileRequest","onCompleteObservable","abort","onloadend","notifyObservers","onerror","onload","target","onprogress","readAsText","readAsArrayBuffer","fileOrUrl","onOpened","error","fileName","IsBase64DataUrl","fileRequest_1","DecodeBase64UrlToBinary","DecodeBase64UrlToString","Error","SetImmediate","RequestFile","responseURL","loadUrl","aborted","requestFile","retryHandle","onReadyStateChange","unbindEvents","onLoadEnd","clear","readyState","XMLHttpRequest","DONE","clearTimeout","handleError","retryLoop","retryIndex","responseType","status","IsFileURL","response","responseText","retryStrategy","waitTime","setTimeout","statusText","send","enableSceneOffline","noOfflineSupport_1","loadFile","event","location","protocol","uri","test","split","initSideEffects","_FileToolsLoadImage","_FileToolsLoadFile","FileTools","_injectLTSFileTools","Object","defineProperty","get","set","value"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/fileTools.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\nimport { WebRequest } from \"./webRequest\";\nimport { IsWindowObjectExist } from \"./domManagement\";\nimport type { Nullable } from \"../types\";\nimport type { IOfflineProvider } from \"../Offline/IOfflineProvider\";\nimport type { IFileRequest } from \"./fileRequest\";\nimport { Observable } from \"./observable\";\nimport { FilesInputStore } from \"./filesInputStore\";\nimport { RetryStrategy } from \"./retryStrategy\";\nimport { BaseError, ErrorCodes, RuntimeError } from \"./error\";\nimport { DecodeBase64ToBinary, DecodeBase64ToString, EncodeArrayBufferToBase64 } from \"./stringTools\";\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor\";\nimport { ThinEngine } from \"../Engines/thinEngine\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { Logger } from \"./logger\";\nimport { TimingTools } from \"./timingTools\";\nconst Base64DataUrlRegEx = new RegExp(/^data:([^,]+\\/[^,]+)?;base64,/i);\n/** @ignore */\nexport class LoadFileError extends RuntimeError {\n    public request?: WebRequest;\n    public file?: File;\n    /**\n     * Creates a new LoadFileError\n     * @param message defines the message of the error\n     * @param object defines the optional web request\n     */\n    constructor(message: string, object?: WebRequest | File) {\n        super(message, ErrorCodes.LoadFileError);\n        this.name = \"LoadFileError\";\n        BaseError._setPrototypeOf(this, LoadFileError.prototype);\n        if (object instanceof WebRequest) {\n            this.request = object;\n        }\n        else {\n            this.file = object;\n        }\n    }\n}\n/** @ignore */\nexport class RequestFileError extends RuntimeError {\n    /**\n     * Creates a new LoadFileError\n     * @param message defines the message of the error\n     * @param request defines the optional web request\n     */\n    constructor(message: string, public request: WebRequest) {\n        super(message, ErrorCodes.RequestFileError);\n        this.name = \"RequestFileError\";\n        BaseError._setPrototypeOf(this, RequestFileError.prototype);\n    }\n}\n/** @ignore */\nexport class ReadFileError extends RuntimeError {\n    /**\n     * Creates a new ReadFileError\n     * @param message defines the message of the error\n     * @param file defines the optional file\n     */\n    constructor(message: string, public file: File) {\n        super(message, ErrorCodes.ReadFileError);\n        this.name = \"ReadFileError\";\n        BaseError._setPrototypeOf(this, ReadFileError.prototype);\n    }\n}\n/**\n * @hidden\n */\nexport const FileToolsOptions: {\n    DefaultRetryStrategy: (url: string, request: WebRequest, retryIndex: number) => number;\n    BaseUrl: string;\n    CorsBehavior: string | ((url: string | string[]) => string);\n    PreprocessUrl: (url: string) => string;\n} = {\n    /**\n     * Gets or sets the retry strategy to apply when an error happens while loading an asset.\n     * When defining this function, return the wait time before trying again or return -1 to\n     * stop retrying and error out.\n     */\n    DefaultRetryStrategy: RetryStrategy.ExponentialBackoff(),\n    /**\n     * Gets or sets the base URL to use to load assets\n     */\n    BaseUrl: \"\",\n    /**\n     * Default behaviour for cors in the application.\n     * It can be a string if the expected behavior is identical in the entire app.\n     * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)\n     */\n    CorsBehavior: \"anonymous\",\n    /**\n     * Gets or sets a function used to pre-process url before using them to load assets\n     * @param url\n     */\n    PreprocessUrl: (url: string) => {\n        return url;\n    }\n};\n/**\n * Removes unwanted characters from an url\n * @param url defines the url to clean\n * @returns the cleaned url\n */\nconst _CleanUrl = (url: string): string => {\n    url = url.replace(/#/gm, \"%23\");\n    return url;\n};\n/**\n * Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.\n * @param url define the url we are trying\n * @param element define the dom element where to configure the cors policy\n * @param element.crossOrigin\n * @hidden\n */\nexport const SetCorsBehavior = (url: string | string[], element: {\n    crossOrigin: string | null;\n}): void => {\n    if (url && url.indexOf(\"data:\") === 0) {\n        return;\n    }\n    if (FileToolsOptions.CorsBehavior) {\n        if (typeof FileToolsOptions.CorsBehavior === \"string\" || FileToolsOptions.CorsBehavior instanceof String) {\n            element.crossOrigin = <string>FileToolsOptions.CorsBehavior;\n        }\n        else {\n            const result = FileToolsOptions.CorsBehavior(url);\n            if (result) {\n                element.crossOrigin = result;\n            }\n        }\n    }\n};\n/**\n * Loads an image as an HTMLImageElement.\n * @param input url string, ArrayBuffer, or Blob to load\n * @param onLoad callback called when the image successfully loads\n * @param onError callback called when the image fails to load\n * @param offlineProvider offline provider for caching\n * @param mimeType optional mime type\n * @param imageBitmapOptions\n * @returns the HTMLImageElement of the loaded image\n * @hidden\n */\nexport const LoadImage = (input: string | ArrayBuffer | ArrayBufferView | Blob, onLoad: (img: HTMLImageElement | ImageBitmap) => void, onError: (message?: string, exception?: any) => void, offlineProvider: Nullable<IOfflineProvider>, mimeType: string = \"\", imageBitmapOptions?: ImageBitmapOptions): Nullable<HTMLImageElement> => {\n    let url: string;\n    let usingObjectURL = false;\n    if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {\n        if (typeof Blob !== \"undefined\") {\n            url = URL.createObjectURL(new Blob([input], { type: mimeType }));\n            usingObjectURL = true;\n        }\n        else {\n            url = `data:${mimeType};base64,` + EncodeArrayBufferToBase64(input);\n        }\n    }\n    else if (input instanceof Blob) {\n        url = URL.createObjectURL(input);\n        usingObjectURL = true;\n    }\n    else {\n        url = _CleanUrl(input);\n        url = FileToolsOptions.PreprocessUrl(input);\n    }\n    const engine = EngineStore.LastCreatedEngine;\n    const onErrorHandler = (exception: any) => {\n        if (onError) {\n            const inputText = url || input.toString();\n            onError(`Error while trying to load image: ${inputText.indexOf(\"http\") === 0 || inputText.length <= 128 ? inputText : inputText.slice(0, 128) + \"...\"}`, exception);\n        }\n    };\n    if (typeof Image === \"undefined\" || (engine?._features.forceBitmapOverHTMLImageElement ?? false)) {\n        LoadFile(url, (data) => {\n            engine!\n                .createImageBitmap(new Blob([data], { type: mimeType }), { premultiplyAlpha: \"none\", ...imageBitmapOptions })\n                .then((imgBmp) => {\n                onLoad(imgBmp);\n                if (usingObjectURL) {\n                    URL.revokeObjectURL(url);\n                }\n            })\n                .catch((reason) => {\n                if (onError) {\n                    onError(\"Error while trying to load image: \" + input, reason);\n                }\n            });\n        }, undefined, offlineProvider || undefined, true, (request, exception) => {\n            onErrorHandler(exception);\n        });\n        return null;\n    }\n    const img = new Image();\n    SetCorsBehavior(url, img);\n    const loadHandler = () => {\n        img.removeEventListener(\"load\", loadHandler);\n        img.removeEventListener(\"error\", errorHandler);\n        onLoad(img);\n        // Must revoke the URL after calling onLoad to avoid security exceptions in\n        // certain scenarios (e.g. when hosted in vscode).\n        if (usingObjectURL && img.src) {\n            URL.revokeObjectURL(img.src);\n        }\n    };\n    const errorHandler = (err: any) => {\n        img.removeEventListener(\"load\", loadHandler);\n        img.removeEventListener(\"error\", errorHandler);\n        onErrorHandler(err);\n        if (usingObjectURL && img.src) {\n            URL.revokeObjectURL(img.src);\n        }\n    };\n    img.addEventListener(\"load\", loadHandler);\n    img.addEventListener(\"error\", errorHandler);\n    const noOfflineSupport = () => {\n        img.src = url;\n    };\n    const loadFromOfflineSupport = () => {\n        if (offlineProvider) {\n            offlineProvider.loadImage(url, img);\n        }\n    };\n    if (url.substr(0, 5) !== \"blob:\" && url.substr(0, 5) !== \"data:\" && offlineProvider && offlineProvider.enableTexturesOffline) {\n        offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);\n    }\n    else {\n        if (url.indexOf(\"file:\") !== -1) {\n            const textureName = decodeURIComponent(url.substring(5).toLowerCase());\n            if (FilesInputStore.FilesToLoad[textureName]) {\n                try {\n                    let blobURL;\n                    try {\n                        blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\n                    }\n                    catch (ex) {\n                        // Chrome doesn't support oneTimeOnly parameter\n                        blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\n                    }\n                    img.src = blobURL;\n                    usingObjectURL = true;\n                }\n                catch (e) {\n                    img.src = \"\";\n                }\n                return img;\n            }\n        }\n        noOfflineSupport();\n    }\n    return img;\n};\n/**\n * Reads a file from a File object\n * @param file defines the file to load\n * @param onSuccess defines the callback to call when data is loaded\n * @param onProgress defines the callback to call during loading process\n * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer\n * @param onError defines the callback to call when an error occurs\n * @returns a file request object\n * @hidden\n */\nexport const ReadFile = (file: File, onSuccess: (data: any) => void, onProgress?: (ev: ProgressEvent) => any, useArrayBuffer?: boolean, onError?: (error: ReadFileError) => void): IFileRequest => {\n    const reader = new FileReader();\n    const fileRequest: IFileRequest = {\n        onCompleteObservable: new Observable<IFileRequest>(),\n        abort: () => reader.abort()\n    };\n    reader.onloadend = () => fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n    if (onError) {\n        reader.onerror = () => {\n            onError(new ReadFileError(`Unable to read ${file.name}`, file));\n        };\n    }\n    reader.onload = (e) => {\n        //target doesn't have result from ts 1.3\n        onSuccess((<any>e.target)[\"result\"]);\n    };\n    if (onProgress) {\n        reader.onprogress = onProgress;\n    }\n    if (!useArrayBuffer) {\n        // Asynchronous read\n        reader.readAsText(file);\n    }\n    else {\n        reader.readAsArrayBuffer(file);\n    }\n    return fileRequest;\n};\n/**\n * Loads a file from a url, a data url, or a file url\n * @param fileOrUrl file, url, data url, or file url to load\n * @param onSuccess callback called when the file successfully loads\n * @param onProgress callback called while file is loading (if the server supports this mode)\n * @param offlineProvider defines the offline provider for caching\n * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\n * @param onError callback called when the file fails to load\n * @param onOpened\n * @returns a file request object\n * @hidden\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const LoadFile = (fileOrUrl: File | string, onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void, onProgress?: (ev: ProgressEvent) => void, offlineProvider?: IOfflineProvider, useArrayBuffer?: boolean, onError?: (request?: WebRequest, exception?: LoadFileError) => void, onOpened?: (request: WebRequest) => void): IFileRequest => {\n    if ((fileOrUrl as File).name) {\n        return ReadFile(fileOrUrl as File, onSuccess, onProgress, useArrayBuffer, onError\n            ? (error: ReadFileError) => {\n                onError(undefined, error);\n            }\n            : undefined);\n    }\n    const url = fileOrUrl as string;\n    // If file and file input are set\n    if (url.indexOf(\"file:\") !== -1) {\n        let fileName = decodeURIComponent(url.substring(5).toLowerCase());\n        if (fileName.indexOf(\"./\") === 0) {\n            fileName = fileName.substring(2);\n        }\n        const file = FilesInputStore.FilesToLoad[fileName];\n        if (file) {\n            return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError ? (error) => onError(undefined, new LoadFileError(error.message, error.file)) : undefined);\n        }\n    }\n    // For a Base64 Data URL\n    if (IsBase64DataUrl(url)) {\n        const fileRequest: IFileRequest = {\n            onCompleteObservable: new Observable<IFileRequest>(),\n            abort: () => () => { }\n        };\n        try {\n            onSuccess(useArrayBuffer ? DecodeBase64UrlToBinary(url) : DecodeBase64UrlToString(url));\n        }\n        catch (error) {\n            if (onError) {\n                onError(undefined, error);\n            }\n            else {\n                Logger.Error(error.message || \"Failed to parse the Data URL\");\n            }\n        }\n        TimingTools.SetImmediate(() => {\n            fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n        });\n        return fileRequest;\n    }\n    return RequestFile(url, (data, request) => {\n        onSuccess(data, request ? request.responseURL : undefined);\n    }, onProgress, offlineProvider, useArrayBuffer, onError\n        ? (error) => {\n            onError(error.request, new LoadFileError(error.message, error.request));\n        }\n        : undefined, onOpened);\n};\n/**\n * Loads a file from a url\n * @param url url to load\n * @param onSuccess callback called when the file successfully loads\n * @param onProgress callback called while file is loading (if the server supports this mode)\n * @param offlineProvider defines the offline provider for caching\n * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\n * @param onError callback called when the file fails to load\n * @param onOpened callback called when the web request is opened\n * @returns a file request object\n * @hidden\n */\nexport const RequestFile = (url: string, onSuccess?: (data: string | ArrayBuffer, request?: WebRequest) => void, onProgress?: (event: ProgressEvent) => void, offlineProvider?: IOfflineProvider, useArrayBuffer?: boolean, onError?: (error: RequestFileError) => void, onOpened?: (request: WebRequest) => void): IFileRequest => {\n    url = _CleanUrl(url);\n    url = FileToolsOptions.PreprocessUrl(url);\n    const loadUrl = FileToolsOptions.BaseUrl + url;\n    let aborted = false;\n    const fileRequest: IFileRequest = {\n        onCompleteObservable: new Observable<IFileRequest>(),\n        abort: () => (aborted = true)\n    };\n    const requestFile = () => {\n        let request: Nullable<WebRequest> = new WebRequest();\n        let retryHandle: Nullable<ReturnType<typeof setTimeout>> = null;\n        let onReadyStateChange: Nullable<() => void>;\n        const unbindEvents = () => {\n            if (!request) {\n                return;\n            }\n            if (onProgress) {\n                request.removeEventListener(\"progress\", onProgress);\n            }\n            if (onReadyStateChange) {\n                request.removeEventListener(\"readystatechange\", onReadyStateChange);\n            }\n            request.removeEventListener(\"loadend\", onLoadEnd!);\n        };\n        let onLoadEnd: Nullable<() => void> = () => {\n            unbindEvents();\n            fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n            fileRequest.onCompleteObservable.clear();\n            onProgress = undefined;\n            onReadyStateChange = null;\n            onLoadEnd = null;\n            onError = undefined;\n            onOpened = undefined;\n            onSuccess = undefined;\n        };\n        fileRequest.abort = () => {\n            aborted = true;\n            if (onLoadEnd) {\n                onLoadEnd();\n            }\n            if (request && request.readyState !== (XMLHttpRequest.DONE || 4)) {\n                request.abort();\n            }\n            if (retryHandle !== null) {\n                clearTimeout(retryHandle);\n                retryHandle = null;\n            }\n            request = null;\n        };\n        const handleError = (error: any) => {\n            const message = error.message || \"Unknown error\";\n            if (onError && request) {\n                onError(new RequestFileError(message, request));\n            }\n            else {\n                Logger.Error(message);\n            }\n        };\n        const retryLoop = (retryIndex: number) => {\n            if (!request) {\n                return;\n            }\n            request.open(\"GET\", loadUrl);\n            if (onOpened) {\n                try {\n                    onOpened(request);\n                }\n                catch (e) {\n                    handleError(e);\n                    return;\n                }\n            }\n            if (useArrayBuffer) {\n                request.responseType = \"arraybuffer\";\n            }\n            if (onProgress) {\n                request.addEventListener(\"progress\", onProgress);\n            }\n            if (onLoadEnd) {\n                request.addEventListener(\"loadend\", onLoadEnd);\n            }\n            onReadyStateChange = () => {\n                if (aborted || !request) {\n                    return;\n                }\n                // In case of undefined state in some browsers.\n                if (request.readyState === (XMLHttpRequest.DONE || 4)) {\n                    // Some browsers have issues where onreadystatechange can be called multiple times with the same value.\n                    if (onReadyStateChange) {\n                        request.removeEventListener(\"readystatechange\", onReadyStateChange);\n                    }\n                    if ((request.status >= 200 && request.status < 300) || (request.status === 0 && (!IsWindowObjectExist() || IsFileURL()))) {\n                        try {\n                            if (onSuccess) {\n                                onSuccess(useArrayBuffer ? request.response : request.responseText, request);\n                            }\n                        }\n                        catch (e) {\n                            handleError(e);\n                        }\n                        return;\n                    }\n                    const retryStrategy = FileToolsOptions.DefaultRetryStrategy;\n                    if (retryStrategy) {\n                        const waitTime = retryStrategy(loadUrl, request, retryIndex);\n                        if (waitTime !== -1) {\n                            // Prevent the request from completing for retry.\n                            unbindEvents();\n                            request = new WebRequest();\n                            retryHandle = setTimeout(() => retryLoop(retryIndex + 1), waitTime);\n                            return;\n                        }\n                    }\n                    const error = new RequestFileError(\"Error status: \" + request.status + \" \" + request.statusText + \" - Unable to load \" + loadUrl, request);\n                    if (onError) {\n                        onError(error);\n                    }\n                }\n            };\n            request.addEventListener(\"readystatechange\", onReadyStateChange);\n            request.send();\n        };\n        retryLoop(0);\n    };\n    // Caching all files\n    if (offlineProvider && offlineProvider.enableSceneOffline) {\n        const noOfflineSupport = (request?: any) => {\n            if (request && request.status > 400) {\n                if (onError) {\n                    onError(request);\n                }\n            }\n            else {\n                requestFile();\n            }\n        };\n        const loadFromOfflineSupport = () => {\n            // TODO: database needs to support aborting and should return a IFileRequest\n            if (offlineProvider) {\n                offlineProvider.loadFile(FileToolsOptions.BaseUrl + url, (data) => {\n                    if (!aborted && onSuccess) {\n                        onSuccess(data);\n                    }\n                    fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n                }, onProgress\n                    ? (event) => {\n                        if (!aborted && onProgress) {\n                            onProgress(event);\n                        }\n                    }\n                    : undefined, noOfflineSupport, useArrayBuffer);\n            }\n        };\n        offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);\n    }\n    else {\n        requestFile();\n    }\n    return fileRequest;\n};\n/**\n * Checks if the loaded document was accessed via `file:`-Protocol.\n * @returns boolean\n * @hidden\n */\nexport const IsFileURL = (): boolean => {\n    return typeof location !== \"undefined\" && location.protocol === \"file:\";\n};\n/**\n * Test if the given uri is a valid base64 data url\n * @param uri The uri to test\n * @return True if the uri is a base64 data url or false otherwise\n * @hidden\n */\nexport const IsBase64DataUrl = (uri: string): boolean => {\n    return Base64DataUrlRegEx.test(uri);\n};\n/**\n * Decode the given base64 uri.\n * @param uri The uri to decode\n * @return The decoded base64 data.\n * @hidden\n */\nexport function DecodeBase64UrlToBinary(uri: string): ArrayBuffer {\n    return DecodeBase64ToBinary(uri.split(\",\")[1]);\n}\n/**\n * Decode the given base64 uri into a UTF-8 encoded string.\n * @param uri The uri to decode\n * @return The decoded base64 data.\n * @hidden\n */\nexport const DecodeBase64UrlToString = (uri: string): string => {\n    return DecodeBase64ToString(uri.split(\",\")[1]);\n};\n/**\n * This will be executed automatically for UMD and es5.\n * If esm dev wants the side effects to execute they will have to run it manually\n * Once we build native modules those need to be exported.\n * @hidden\n */\nconst initSideEffects = () => {\n    ThinEngine._FileToolsLoadImage = LoadImage;\n    ThinEngine._FileToolsLoadFile = LoadFile;\n    ShaderProcessor._FileToolsLoadFile = LoadFile;\n};\ninitSideEffects();\n\n    /**\n * FileTools defined as any.\n * This should not be imported or used in future releases or in any module in the framework\n * @hidden\n * @deprecated import the needed function from fileTools.ts\n */\nexport let FileTools: {\n    DecodeBase64UrlToBinary: (uri: string) => ArrayBuffer;\n    DecodeBase64UrlToString: (uri: string) => string;\n    DefaultRetryStrategy: any;\n    BaseUrl: any;\n    CorsBehavior: any;\n    PreprocessUrl: any;\n    IsBase64DataUrl: (uri: string) => boolean;\n    IsFileURL: () => boolean;\n    LoadFile: (fileOrUrl: string | File, onSuccess: (data: string | ArrayBuffer, responseURL?: string | undefined) => void, onProgress?: ((ev: ProgressEvent<EventTarget>) => void) | undefined, offlineProvider?: IOfflineProvider | undefined, useArrayBuffer?: boolean | undefined, onError?: ((request?: WebRequest | undefined, exception?: LoadFileError | undefined) => void) | undefined, onOpened?: ((request: WebRequest) => void) | undefined) => IFileRequest;\n    LoadImage: (input: string | ArrayBuffer | Blob | ArrayBufferView, onLoad: (img: HTMLImageElement | ImageBitmap) => void, onError: (message?: string | undefined, exception?: any) => void, offlineProvider: Nullable<IOfflineProvider>, mimeType?: string | undefined, imageBitmapOptions?: ImageBitmapOptions | undefined) => Nullable<HTMLImageElement>;\n    ReadFile: (file: File, onSuccess: (data: any) => void, onProgress?: ((ev: ProgressEvent<EventTarget>) => any) | undefined, useArrayBuffer?: boolean | undefined, onError?: ((error: ReadFileError) => void) | undefined) => IFileRequest;\n    RequestFile: (url: string, onSuccess: (data: string | ArrayBuffer, request?: WebRequest | undefined) => void, onProgress?: ((event: ProgressEvent<EventTarget>) => void) | undefined, offlineProvider?: IOfflineProvider | undefined, useArrayBuffer?: boolean | undefined, onError?: ((error: RequestFileError) => void) | undefined, onOpened?: ((request: WebRequest) => void) | undefined) => IFileRequest;\n    SetCorsBehavior: (url: string | string[], element: {\n        crossOrigin: string | null;\n    }) => void;\n};\n/**\n * @param DecodeBase64UrlToBinary\n * @param DecodeBase64UrlToString\n * @param FileToolsOptions\n * @param FileToolsOptions.DefaultRetryStrategy\n * @param FileToolsOptions.BaseUrl\n * @param FileToolsOptions.CorsBehavior\n * @param FileToolsOptions.PreprocessUrl\n * @param IsBase64DataUrl\n * @param IsFileURL\n * @param LoadFile\n * @param LoadImage\n * @param ReadFile\n * @param RequestFile\n * @param SetCorsBehavior\n * @hidden\n */\nexport const _injectLTSFileTools = (DecodeBase64UrlToBinary: (uri: string) => ArrayBuffer, DecodeBase64UrlToString: (uri: string) => string, FileToolsOptions: {\n    DefaultRetryStrategy: any;\n    BaseUrl: any;\n    CorsBehavior: any;\n    PreprocessUrl: any;\n}, IsBase64DataUrl: (uri: string) => boolean, IsFileURL: () => boolean, LoadFile: (fileOrUrl: string | File, onSuccess: (data: string | ArrayBuffer, responseURL?: string | undefined) => void, onProgress?: ((ev: ProgressEvent<EventTarget>) => void) | undefined, offlineProvider?: IOfflineProvider | undefined, useArrayBuffer?: boolean | undefined, onError?: ((request?: WebRequest | undefined, exception?: LoadFileError | undefined) => void) | undefined, onOpened?: ((request: WebRequest) => void) | undefined) => IFileRequest, LoadImage: (input: string | ArrayBuffer | ArrayBufferView | Blob, onLoad: (img: HTMLImageElement | ImageBitmap) => void, onError: (message?: string | undefined, exception?: any) => void, offlineProvider: Nullable<IOfflineProvider>, mimeType?: string, imageBitmapOptions?: ImageBitmapOptions | undefined) => Nullable<HTMLImageElement>, ReadFile: (file: File, onSuccess: (data: any) => void, onProgress?: ((ev: ProgressEvent<EventTarget>) => any) | undefined, useArrayBuffer?: boolean | undefined, onError?: ((error: ReadFileError) => void) | undefined) => IFileRequest, RequestFile: (url: string, onSuccess: (data: string | ArrayBuffer, request?: WebRequest | undefined) => void, onProgress?: ((event: ProgressEvent<EventTarget>) => void) | undefined, offlineProvider?: IOfflineProvider | undefined, useArrayBuffer?: boolean | undefined, onError?: ((error: RequestFileError) => void) | undefined, onOpened?: ((request: WebRequest) => void) | undefined) => IFileRequest, SetCorsBehavior: (url: string | string[], element: {\n    crossOrigin: string | null;\n}) => void) => {\n    /**\n     * Backwards compatibility.\n     * @hidden\n     * @deprecated\n     */\n    FileTools = {\n        DecodeBase64UrlToBinary,\n        DecodeBase64UrlToString,\n        DefaultRetryStrategy: FileToolsOptions.DefaultRetryStrategy,\n        BaseUrl: FileToolsOptions.BaseUrl,\n        CorsBehavior: FileToolsOptions.CorsBehavior,\n        PreprocessUrl: FileToolsOptions.PreprocessUrl,\n        IsBase64DataUrl,\n        IsFileURL,\n        LoadFile,\n        LoadImage,\n        ReadFile,\n        RequestFile,\n        SetCorsBehavior\n    };\n    Object.defineProperty(FileTools, \"DefaultRetryStrategy\", {\n        get: function (this: null) {\n            return FileToolsOptions.DefaultRetryStrategy;\n        },\n        set: function (this: null, value: (url: string, request: WebRequest, retryIndex: number) => number) {\n            FileToolsOptions.DefaultRetryStrategy = value;\n        }\n    });\n    Object.defineProperty(FileTools, \"BaseUrl\", {\n        get: function (this: null) {\n            return FileToolsOptions.BaseUrl;\n        },\n        set: function (this: null, value: string) {\n            FileToolsOptions.BaseUrl = value;\n        }\n    });\n    Object.defineProperty(FileTools, \"PreprocessUrl\", {\n        get: function (this: null) {\n            return FileToolsOptions.PreprocessUrl;\n        },\n        set: function (this: null, value: (url: string) => string) {\n            FileToolsOptions.PreprocessUrl = value;\n        }\n    });\n    Object.defineProperty(FileTools, \"CorsBehavior\", {\n        get: function (this: null) {\n            return FileToolsOptions.CorsBehavior;\n        },\n        set: function (this: null, value: string | ((url: string | string[]) => string)) {\n            FileToolsOptions.CorsBehavior = value;\n        }\n    });\n};\n_injectLTSFileTools(DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior);\n"]},"metadata":{},"sourceType":"module"}