{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { BoundingBox } from \"./boundingBox.js\";\nimport { BoundingSphere } from \"./boundingSphere.js\";\nvar _result0 = {\n  min: 0,\n  max: 0\n};\nvar _result1 = {\n  min: 0,\n  max: 0\n};\n\nvar computeBoxExtents = function computeBoxExtents(axis, box, result) {\n  var p = Vector3.Dot(box.centerWorld, axis);\n  var r0 = Math.abs(Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;\n  var r1 = Math.abs(Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;\n  var r2 = Math.abs(Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;\n  var r = r0 + r1 + r2;\n  result.min = p - r;\n  result.max = p + r;\n};\n\nvar axisOverlap = function axisOverlap(axis, box0, box1) {\n  computeBoxExtents(axis, box0, _result0);\n  computeBoxExtents(axis, box1, _result1);\n  return !(_result0.min > _result1.max || _result1.min > _result0.max);\n};\n/**\n * Info for a bounding data of a mesh\n */\n\n\nvar BoundingInfo =\n/** @class */\nfunction () {\n  /**\n   * Constructs bounding info\n   * @param minimum min vector of the bounding box/sphere\n   * @param maximum max vector of the bounding box/sphere\n   * @param worldMatrix defines the new world matrix\n   */\n  function BoundingInfo(minimum, maximum, worldMatrix) {\n    this._isLocked = false;\n    this.boundingBox = new BoundingBox(minimum, maximum, worldMatrix);\n    this.boundingSphere = new BoundingSphere(minimum, maximum, worldMatrix);\n  }\n  /**\n   * Recreates the entire bounding info from scratch as if we call the constructor in place\n   * @param min defines the new minimum vector (in local space)\n   * @param max defines the new maximum vector (in local space)\n   * @param worldMatrix defines the new world matrix\n   */\n\n\n  BoundingInfo.prototype.reConstruct = function (min, max, worldMatrix) {\n    this.boundingBox.reConstruct(min, max, worldMatrix);\n    this.boundingSphere.reConstruct(min, max, worldMatrix);\n  };\n\n  Object.defineProperty(BoundingInfo.prototype, \"minimum\", {\n    /**\n     * min vector of the bounding box/sphere\n     */\n    get: function get() {\n      return this.boundingBox.minimum;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BoundingInfo.prototype, \"maximum\", {\n    /**\n     * max vector of the bounding box/sphere\n     */\n    get: function get() {\n      return this.boundingBox.maximum;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BoundingInfo.prototype, \"isLocked\", {\n    /**\n     * If the info is locked and won't be updated to avoid perf overhead\n     */\n    get: function get() {\n      return this._isLocked;\n    },\n    set: function set(value) {\n      this._isLocked = value;\n    },\n    enumerable: false,\n    configurable: true\n  }); // Methods\n\n  /**\n   * Updates the bounding sphere and box\n   * @param world world matrix to be used to update\n   */\n\n  BoundingInfo.prototype.update = function (world) {\n    if (this._isLocked) {\n      return;\n    }\n\n    this.boundingBox._update(world);\n\n    this.boundingSphere._update(world);\n  };\n  /**\n   * Recreate the bounding info to be centered around a specific point given a specific extend.\n   * @param center New center of the bounding info\n   * @param extend New extend of the bounding info\n   * @returns the current bounding info\n   */\n\n\n  BoundingInfo.prototype.centerOn = function (center, extend) {\n    var minimum = BoundingInfo._TmpVector3[0].copyFrom(center).subtractInPlace(extend);\n\n    var maximum = BoundingInfo._TmpVector3[1].copyFrom(center).addInPlace(extend);\n\n    this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\n    this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\n    return this;\n  };\n  /**\n   * Grows the bounding info to include the given point.\n   * @param point The point that will be included in the current bounding info\n   * @returns the current bounding info\n   */\n\n\n  BoundingInfo.prototype.encapsulate = function (point) {\n    var minimum = Vector3.Minimize(this.minimum, point);\n    var maximum = Vector3.Maximize(this.maximum, point);\n    this.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\n    return this;\n  };\n  /**\n   * Grows the bounding info to encapsulate the given bounding info.\n   * @param toEncapsulate The bounding info that will be encapsulated in the current bounding info\n   * @returns the current bounding info\n   */\n\n\n  BoundingInfo.prototype.encapsulateBoundingInfo = function (toEncapsulate) {\n    this.encapsulate(toEncapsulate.boundingBox.centerWorld.subtract(toEncapsulate.boundingBox.extendSizeWorld));\n    this.encapsulate(toEncapsulate.boundingBox.centerWorld.add(toEncapsulate.boundingBox.extendSizeWorld));\n    return this;\n  };\n  /**\n   * Scale the current bounding info by applying a scale factor\n   * @param factor defines the scale factor to apply\n   * @returns the current bounding info\n   */\n\n\n  BoundingInfo.prototype.scale = function (factor) {\n    this.boundingBox.scale(factor);\n    this.boundingSphere.scale(factor);\n    return this;\n  };\n  /**\n   * Returns `true` if the bounding info is within the frustum defined by the passed array of planes.\n   * @param frustumPlanes defines the frustum to test\n   * @param strategy defines the strategy to use for the culling (default is BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD)\n   * @returns true if the bounding info is in the frustum planes\n   */\n\n\n  BoundingInfo.prototype.isInFrustum = function (frustumPlanes, strategy) {\n    if (strategy === void 0) {\n      strategy = 0;\n    }\n\n    var inclusionTest = strategy === 2 || strategy === 3;\n\n    if (inclusionTest) {\n      if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {\n        return true;\n      }\n    }\n\n    if (!this.boundingSphere.isInFrustum(frustumPlanes)) {\n      return false;\n    }\n\n    var bSphereOnlyTest = strategy === 1 || strategy === 3;\n\n    if (bSphereOnlyTest) {\n      return true;\n    }\n\n    return this.boundingBox.isInFrustum(frustumPlanes);\n  };\n\n  Object.defineProperty(BoundingInfo.prototype, \"diagonalLength\", {\n    /**\n     * Gets the world distance between the min and max points of the bounding box\n     */\n    get: function get() {\n      var boundingBox = this.boundingBox;\n      var diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, BoundingInfo._TmpVector3[0]);\n      return diag.length();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Checks if a cullable object (mesh...) is in the camera frustum\n   * Unlike isInFrustum this checks the full bounding box\n   * @param frustumPlanes Camera near/planes\n   * @returns true if the object is in frustum otherwise false\n   */\n\n  BoundingInfo.prototype.isCompletelyInFrustum = function (frustumPlanes) {\n    return this.boundingBox.isCompletelyInFrustum(frustumPlanes);\n  };\n  /**\n   * @param collider\n   * @hidden\n   */\n\n\n  BoundingInfo.prototype._checkCollision = function (collider) {\n    return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);\n  };\n  /**\n   * Checks if a point is inside the bounding box and bounding sphere or the mesh\n   * @see https://doc.babylonjs.com/babylon101/intersect_collisions_-_mesh\n   * @param point the point to check intersection with\n   * @returns if the point intersects\n   */\n\n\n  BoundingInfo.prototype.intersectsPoint = function (point) {\n    if (!this.boundingSphere.centerWorld) {\n      return false;\n    }\n\n    if (!this.boundingSphere.intersectsPoint(point)) {\n      return false;\n    }\n\n    if (!this.boundingBox.intersectsPoint(point)) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Checks if another bounding info intersects the bounding box and bounding sphere or the mesh\n   * @see https://doc.babylonjs.com/babylon101/intersect_collisions_-_mesh\n   * @param boundingInfo the bounding info to check intersection with\n   * @param precise if the intersection should be done using OBB\n   * @returns if the bounding info intersects\n   */\n\n\n  BoundingInfo.prototype.intersects = function (boundingInfo, precise) {\n    if (!BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {\n      return false;\n    }\n\n    if (!BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {\n      return false;\n    }\n\n    if (!precise) {\n      return true;\n    }\n\n    var box0 = this.boundingBox;\n    var box1 = boundingInfo.boundingBox;\n\n    if (!axisOverlap(box0.directions[0], box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(box0.directions[1], box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(box0.directions[2], box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(box1.directions[0], box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(box1.directions[1], box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(box1.directions[2], box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  BoundingInfo._TmpVector3 = ArrayTools.BuildArray(2, Vector3.Zero);\n  return BoundingInfo;\n}();\n\nexport { BoundingInfo };","map":{"version":3,"mappings":";AACA,SAASA,UAAT,QAA2B,uBAA3B;AAEA,SAASC,OAAT,QAAwB,yBAAxB;AAEA,SAASC,WAAT,QAA4B,kBAA5B;AACA,SAASC,cAAT,QAA+B,qBAA/B;AAKA,IAAMC,QAAQ,GAAG;AAAEC,KAAG,EAAE,CAAP;AAAUC,KAAG,EAAE;AAAf,CAAjB;AACA,IAAMC,QAAQ,GAAG;AAAEF,KAAG,EAAE,CAAP;AAAUC,KAAG,EAAE;AAAf,CAAjB;;AACA,IAAME,iBAAiB,GAAG,SAApBA,iBAAoB,CAACC,IAAD,EAA+BC,GAA/B,EAAgEC,MAAhE,EAAoG;AAC1H,MAAMC,CAAC,GAAGX,OAAO,CAACY,GAAR,CAAYH,GAAG,CAACI,WAAhB,EAA6BL,IAA7B,CAAV;AAEA,MAAMM,EAAE,GAAGC,IAAI,CAACC,GAAL,CAAShB,OAAO,CAACY,GAAR,CAAYH,GAAG,CAACQ,UAAJ,CAAe,CAAf,CAAZ,EAA+BT,IAA/B,CAAT,IAAiDC,GAAG,CAACS,UAAJ,CAAeC,CAA3E;AACA,MAAMC,EAAE,GAAGL,IAAI,CAACC,GAAL,CAAShB,OAAO,CAACY,GAAR,CAAYH,GAAG,CAACQ,UAAJ,CAAe,CAAf,CAAZ,EAA+BT,IAA/B,CAAT,IAAiDC,GAAG,CAACS,UAAJ,CAAeG,CAA3E;AACA,MAAMC,EAAE,GAAGP,IAAI,CAACC,GAAL,CAAShB,OAAO,CAACY,GAAR,CAAYH,GAAG,CAACQ,UAAJ,CAAe,CAAf,CAAZ,EAA+BT,IAA/B,CAAT,IAAiDC,GAAG,CAACS,UAAJ,CAAeK,CAA3E;AAEA,MAAMC,CAAC,GAAGV,EAAE,GAAGM,EAAL,GAAUE,EAApB;AACAZ,QAAM,CAACN,GAAP,GAAaO,CAAC,GAAGa,CAAjB;AACAd,QAAM,CAACL,GAAP,GAAaM,CAAC,GAAGa,CAAjB;AACH,CAVD;;AAYA,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAACjB,IAAD,EAA+BkB,IAA/B,EAAiEC,IAAjE,EAAiG;AACjHpB,mBAAiB,CAACC,IAAD,EAAOkB,IAAP,EAAavB,QAAb,CAAjB;AACAI,mBAAiB,CAACC,IAAD,EAAOmB,IAAP,EAAarB,QAAb,CAAjB;AACA,SAAO,EAAEH,QAAQ,CAACC,GAAT,GAAeE,QAAQ,CAACD,GAAxB,IAA+BC,QAAQ,CAACF,GAAT,GAAeD,QAAQ,CAACE,GAAzD,CAAP;AACH,CAJD;AA0BA;;;;;AAGA;AAAA;AAAA;AAcI;;;;;;AAMA,wBAAYuB,OAAZ,EAA6CC,OAA7C,EAA8EC,WAA9E,EAAiH;AAVzG,qBAAY,KAAZ;AAWJ,SAAKC,WAAL,GAAmB,IAAI9B,WAAJ,CAAgB2B,OAAhB,EAAyBC,OAAzB,EAAkCC,WAAlC,CAAnB;AACA,SAAKE,cAAL,GAAsB,IAAI9B,cAAJ,CAAmB0B,OAAnB,EAA4BC,OAA5B,EAAqCC,WAArC,CAAtB;AACH;AAED;;;;;;;;AAMOG,uCAAP,UAAmB7B,GAAnB,EAAgDC,GAAhD,EAA6EyB,WAA7E,EAAgH;AAC5G,SAAKC,WAAL,CAAiBG,WAAjB,CAA6B9B,GAA7B,EAAkCC,GAAlC,EAAuCyB,WAAvC;AACA,SAAKE,cAAL,CAAoBE,WAApB,CAAgC9B,GAAhC,EAAqCC,GAArC,EAA0CyB,WAA1C;AACH,GAHM;;AAQPK,wBAAWF,sBAAX,EAAW,SAAX,EAAkB;AAHlB;;;SAGA;AACI,aAAO,KAAKF,WAAL,CAAiBH,OAAxB;AACH,KAFiB;qBAAA;;AAAA,GAAlB;AAOAO,wBAAWF,sBAAX,EAAW,SAAX,EAAkB;AAHlB;;;SAGA;AACI,aAAO,KAAKF,WAAL,CAAiBF,OAAxB;AACH,KAFiB;qBAAA;;AAAA,GAAlB;AAOAM,wBAAWF,sBAAX,EAAW,UAAX,EAAmB;AAHnB;;;SAGA;AACI,aAAO,KAAKG,SAAZ;AACH,KAFkB;SAInB,aAAoBC,KAApB,EAAkC;AAC9B,WAAKD,SAAL,GAAiBC,KAAjB;AACH,KANkB;qBAAA;;AAAA,GAAnB,EArDJ,CA6DI;;AACA;;;;;AAIOJ,kCAAP,UAAcK,KAAd,EAA0C;AACtC,QAAI,KAAKF,SAAT,EAAoB;AAChB;AACH;;AACD,SAAKL,WAAL,CAAiBQ,OAAjB,CAAyBD,KAAzB;;AACA,SAAKN,cAAL,CAAoBO,OAApB,CAA4BD,KAA5B;AACH,GANM;AAQP;;;;;;;;AAMOL,oCAAP,UAAgBO,MAAhB,EAAgDC,MAAhD,EAA8E;AAC1E,QAAMb,OAAO,GAAGK,YAAY,CAACS,WAAb,CAAyB,CAAzB,EAA4BC,QAA5B,CAAqCH,MAArC,EAA6CI,eAA7C,CAA6DH,MAA7D,CAAhB;;AACA,QAAMZ,OAAO,GAAGI,YAAY,CAACS,WAAb,CAAyB,CAAzB,EAA4BC,QAA5B,CAAqCH,MAArC,EAA6CK,UAA7C,CAAwDJ,MAAxD,CAAhB;;AAEA,SAAKV,WAAL,CAAiBG,WAAjB,CAA6BN,OAA7B,EAAsCC,OAAtC,EAA+C,KAAKE,WAAL,CAAiBe,cAAjB,EAA/C;AACA,SAAKd,cAAL,CAAoBE,WAApB,CAAgCN,OAAhC,EAAyCC,OAAzC,EAAkD,KAAKE,WAAL,CAAiBe,cAAjB,EAAlD;AAEA,WAAO,IAAP;AACH,GARM;AAUP;;;;;;;AAKOb,uCAAP,UAAmBc,KAAnB,EAAiC;AAC7B,QAAMnB,OAAO,GAAG5B,OAAO,CAACgD,QAAR,CAAiB,KAAKpB,OAAtB,EAA+BmB,KAA/B,CAAhB;AACA,QAAMlB,OAAO,GAAG7B,OAAO,CAACiD,QAAR,CAAiB,KAAKpB,OAAtB,EAA+BkB,KAA/B,CAAhB;AACA,SAAKb,WAAL,CAAiBN,OAAjB,EAA0BC,OAA1B,EAAmC,KAAKE,WAAL,CAAiBe,cAAjB,EAAnC;AAEA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;AAKOb,mDAAP,UAA+BiB,aAA/B,EAA0D;AACtD,SAAKC,WAAL,CAAiBD,aAAa,CAACnB,WAAd,CAA0BlB,WAA1B,CAAsCuC,QAAtC,CAA+CF,aAAa,CAACnB,WAAd,CAA0BsB,eAAzE,CAAjB;AACA,SAAKF,WAAL,CAAiBD,aAAa,CAACnB,WAAd,CAA0BlB,WAA1B,CAAsCyC,GAAtC,CAA0CJ,aAAa,CAACnB,WAAd,CAA0BsB,eAApE,CAAjB;AAEA,WAAO,IAAP;AACH,GALM;AAOP;;;;;;;AAKOpB,iCAAP,UAAasB,MAAb,EAA2B;AACvB,SAAKxB,WAAL,CAAiByB,KAAjB,CAAuBD,MAAvB;AACA,SAAKvB,cAAL,CAAoBwB,KAApB,CAA0BD,MAA1B;AAEA,WAAO,IAAP;AACH,GALM;AAOP;;;;;;;;AAMOtB,uCAAP,UAAmBwB,aAAnB,EAA+DC,QAA/D,EAA2H;AAA5D;AAAAA,iBAAmB,CAAnB;AAAmB;;AAC9E,QAAMC,aAAa,GACfD,QAAQ,KAAK,CAAb,IAAaA,QAAU,MAD3B;;AAEA,QAAIC,aAAJ,EAAmB;AACf,UAAI,KAAK3B,cAAL,CAAoB4B,iBAApB,CAAsCH,aAAtC,CAAJ,EAA0D;AACtD,eAAO,IAAP;AACH;AACJ;;AAED,QAAI,CAAC,KAAKzB,cAAL,CAAoB6B,WAApB,CAAgCJ,aAAhC,CAAL,EAAqD;AACjD,aAAO,KAAP;AACH;;AAED,QAAMK,eAAe,GACjBJ,QAAQ,KAAK,CAAb,IAAaA,QAAU,MAD3B;;AAEA,QAAII,eAAJ,EAAqB;AACjB,aAAO,IAAP;AACH;;AAED,WAAO,KAAK/B,WAAL,CAAiB8B,WAAjB,CAA6BJ,aAA7B,CAAP;AACH,GApBM;;AAyBPtB,wBAAWF,sBAAX,EAAW,gBAAX,EAAyB;AAHzB;;;SAGA;AACI,UAAMF,WAAW,GAAG,KAAKA,WAAzB;AACA,UAAMgC,IAAI,GAAGhC,WAAW,CAACiC,YAAZ,CAAyBC,aAAzB,CAAuClC,WAAW,CAACmC,YAAnD,EAAiEjC,YAAY,CAACS,WAAb,CAAyB,CAAzB,CAAjE,CAAb;AACA,aAAOqB,IAAI,CAACI,MAAL,EAAP;AACH,KAJwB;qBAAA;;AAAA,GAAzB;AAMA;;;;;;;AAMOlC,iDAAP,UAA6BwB,aAA7B,EAAuE;AACnE,WAAO,KAAK1B,WAAL,CAAiBqC,qBAAjB,CAAuCX,aAAvC,CAAP;AACH,GAFM;AAGP;;;;;;AAIOxB,2CAAP,UAAuBoC,QAAvB,EAAyC;AACrC,WAAOA,QAAQ,CAACC,eAAT,CAAyB,KAAKtC,cAAL,CAAoBnB,WAA7C,EAA0D,KAAKmB,cAAL,CAAoBuC,WAA9E,EAA2F,KAAKxC,WAAL,CAAiBmC,YAA5G,EAA0H,KAAKnC,WAAL,CAAiBiC,YAA3I,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMO/B,2CAAP,UAAuBc,KAAvB,EAAoD;AAChD,QAAI,CAAC,KAAKf,cAAL,CAAoBnB,WAAzB,EAAsC;AAClC,aAAO,KAAP;AACH;;AAED,QAAI,CAAC,KAAKmB,cAAL,CAAoBwC,eAApB,CAAoCzB,KAApC,CAAL,EAAiD;AAC7C,aAAO,KAAP;AACH;;AAED,QAAI,CAAC,KAAKhB,WAAL,CAAiByC,eAAjB,CAAiCzB,KAAjC,CAAL,EAA8C;AAC1C,aAAO,KAAP;AACH;;AAED,WAAO,IAAP;AACH,GAdM;AAgBP;;;;;;;;;AAOOd,sCAAP,UAAkBwC,YAAlB,EAA6DC,OAA7D,EAA6E;AACzE,QAAI,CAACxE,cAAc,CAACyE,UAAf,CAA0B,KAAK3C,cAA/B,EAA+CyC,YAAY,CAACzC,cAA5D,CAAL,EAAkF;AAC9E,aAAO,KAAP;AACH;;AAED,QAAI,CAAC/B,WAAW,CAAC0E,UAAZ,CAAuB,KAAK5C,WAA5B,EAAyC0C,YAAY,CAAC1C,WAAtD,CAAL,EAAyE;AACrE,aAAO,KAAP;AACH;;AAED,QAAI,CAAC2C,OAAL,EAAc;AACV,aAAO,IAAP;AACH;;AAED,QAAMhD,IAAI,GAAG,KAAKK,WAAlB;AACA,QAAMJ,IAAI,GAAG8C,YAAY,CAAC1C,WAA1B;;AAEA,QAAI,CAACN,WAAW,CAACC,IAAI,CAACT,UAAL,CAAgB,CAAhB,CAAD,EAAqBS,IAArB,EAA2BC,IAA3B,CAAhB,EAAkD;AAC9C,aAAO,KAAP;AACH;;AACD,QAAI,CAACF,WAAW,CAACC,IAAI,CAACT,UAAL,CAAgB,CAAhB,CAAD,EAAqBS,IAArB,EAA2BC,IAA3B,CAAhB,EAAkD;AAC9C,aAAO,KAAP;AACH;;AACD,QAAI,CAACF,WAAW,CAACC,IAAI,CAACT,UAAL,CAAgB,CAAhB,CAAD,EAAqBS,IAArB,EAA2BC,IAA3B,CAAhB,EAAkD;AAC9C,aAAO,KAAP;AACH;;AACD,QAAI,CAACF,WAAW,CAACE,IAAI,CAACV,UAAL,CAAgB,CAAhB,CAAD,EAAqBS,IAArB,EAA2BC,IAA3B,CAAhB,EAAkD;AAC9C,aAAO,KAAP;AACH;;AACD,QAAI,CAACF,WAAW,CAACE,IAAI,CAACV,UAAL,CAAgB,CAAhB,CAAD,EAAqBS,IAArB,EAA2BC,IAA3B,CAAhB,EAAkD;AAC9C,aAAO,KAAP;AACH;;AACD,QAAI,CAACF,WAAW,CAACE,IAAI,CAACV,UAAL,CAAgB,CAAhB,CAAD,EAAqBS,IAArB,EAA2BC,IAA3B,CAAhB,EAAkD;AAC9C,aAAO,KAAP;AACH;;AACD,QAAI,CAACF,WAAW,CAACzB,OAAO,CAAC4E,KAAR,CAAclD,IAAI,CAACT,UAAL,CAAgB,CAAhB,CAAd,EAAkCU,IAAI,CAACV,UAAL,CAAgB,CAAhB,CAAlC,CAAD,EAAwDS,IAAxD,EAA8DC,IAA9D,CAAhB,EAAqF;AACjF,aAAO,KAAP;AACH;;AACD,QAAI,CAACF,WAAW,CAACzB,OAAO,CAAC4E,KAAR,CAAclD,IAAI,CAACT,UAAL,CAAgB,CAAhB,CAAd,EAAkCU,IAAI,CAACV,UAAL,CAAgB,CAAhB,CAAlC,CAAD,EAAwDS,IAAxD,EAA8DC,IAA9D,CAAhB,EAAqF;AACjF,aAAO,KAAP;AACH;;AACD,QAAI,CAACF,WAAW,CAACzB,OAAO,CAAC4E,KAAR,CAAclD,IAAI,CAACT,UAAL,CAAgB,CAAhB,CAAd,EAAkCU,IAAI,CAACV,UAAL,CAAgB,CAAhB,CAAlC,CAAD,EAAwDS,IAAxD,EAA8DC,IAA9D,CAAhB,EAAqF;AACjF,aAAO,KAAP;AACH;;AACD,QAAI,CAACF,WAAW,CAACzB,OAAO,CAAC4E,KAAR,CAAclD,IAAI,CAACT,UAAL,CAAgB,CAAhB,CAAd,EAAkCU,IAAI,CAACV,UAAL,CAAgB,CAAhB,CAAlC,CAAD,EAAwDS,IAAxD,EAA8DC,IAA9D,CAAhB,EAAqF;AACjF,aAAO,KAAP;AACH;;AACD,QAAI,CAACF,WAAW,CAACzB,OAAO,CAAC4E,KAAR,CAAclD,IAAI,CAACT,UAAL,CAAgB,CAAhB,CAAd,EAAkCU,IAAI,CAACV,UAAL,CAAgB,CAAhB,CAAlC,CAAD,EAAwDS,IAAxD,EAA8DC,IAA9D,CAAhB,EAAqF;AACjF,aAAO,KAAP;AACH;;AACD,QAAI,CAACF,WAAW,CAACzB,OAAO,CAAC4E,KAAR,CAAclD,IAAI,CAACT,UAAL,CAAgB,CAAhB,CAAd,EAAkCU,IAAI,CAACV,UAAL,CAAgB,CAAhB,CAAlC,CAAD,EAAwDS,IAAxD,EAA8DC,IAA9D,CAAhB,EAAqF;AACjF,aAAO,KAAP;AACH;;AACD,QAAI,CAACF,WAAW,CAACzB,OAAO,CAAC4E,KAAR,CAAclD,IAAI,CAACT,UAAL,CAAgB,CAAhB,CAAd,EAAkCU,IAAI,CAACV,UAAL,CAAgB,CAAhB,CAAlC,CAAD,EAAwDS,IAAxD,EAA8DC,IAA9D,CAAhB,EAAqF;AACjF,aAAO,KAAP;AACH;;AACD,QAAI,CAACF,WAAW,CAACzB,OAAO,CAAC4E,KAAR,CAAclD,IAAI,CAACT,UAAL,CAAgB,CAAhB,CAAd,EAAkCU,IAAI,CAACV,UAAL,CAAgB,CAAhB,CAAlC,CAAD,EAAwDS,IAAxD,EAA8DC,IAA9D,CAAhB,EAAqF;AACjF,aAAO,KAAP;AACH;;AACD,QAAI,CAACF,WAAW,CAACzB,OAAO,CAAC4E,KAAR,CAAclD,IAAI,CAACT,UAAL,CAAgB,CAAhB,CAAd,EAAkCU,IAAI,CAACV,UAAL,CAAgB,CAAhB,CAAlC,CAAD,EAAwDS,IAAxD,EAA8DC,IAA9D,CAAhB,EAAqF;AACjF,aAAO,KAAP;AACH;;AAED,WAAO,IAAP;AACH,GA/DM;;AAtMiBM,6BAAclC,UAAU,CAAC8E,UAAX,CAAsB,CAAtB,EAAyB7E,OAAO,CAAC8E,IAAjC,CAAd;AAsQ5B;AAAC,CAlRD;;SAAa7C","names":["ArrayTools","Vector3","BoundingBox","BoundingSphere","_result0","min","max","_result1","computeBoxExtents","axis","box","result","p","Dot","centerWorld","r0","Math","abs","directions","extendSize","x","r1","y","r2","z","r","axisOverlap","box0","box1","minimum","maximum","worldMatrix","boundingBox","boundingSphere","BoundingInfo","reConstruct","Object","_isLocked","value","world","_update","center","extend","_TmpVector3","copyFrom","subtractInPlace","addInPlace","getWorldMatrix","point","Minimize","Maximize","toEncapsulate","encapsulate","subtract","extendSizeWorld","add","factor","scale","frustumPlanes","strategy","inclusionTest","isCenterInFrustum","isInFrustum","bSphereOnlyTest","diag","maximumWorld","subtractToRef","minimumWorld","length","isCompletelyInFrustum","collider","_canDoCollision","radiusWorld","intersectsPoint","boundingInfo","precise","Intersects","Cross","BuildArray","Zero"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Culling/boundingInfo.ts"],"sourcesContent":["import type { DeepImmutable } from \"../types\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { BoundingBox } from \"./boundingBox\";\r\nimport { BoundingSphere } from \"./boundingSphere\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\ndeclare type Collider = import(\"../Collisions/collider\").Collider;\r\n\r\nconst _result0 = { min: 0, max: 0 };\r\nconst _result1 = { min: 0, max: 0 };\r\nconst computeBoxExtents = (axis: DeepImmutable<Vector3>, box: DeepImmutable<BoundingBox>, result: { min: number; max: number }) => {\r\n    const p = Vector3.Dot(box.centerWorld, axis);\r\n\r\n    const r0 = Math.abs(Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;\r\n    const r1 = Math.abs(Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;\r\n    const r2 = Math.abs(Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;\r\n\r\n    const r = r0 + r1 + r2;\r\n    result.min = p - r;\r\n    result.max = p + r;\r\n};\r\n\r\nconst axisOverlap = (axis: DeepImmutable<Vector3>, box0: DeepImmutable<BoundingBox>, box1: DeepImmutable<BoundingBox>): boolean => {\r\n    computeBoxExtents(axis, box0, _result0);\r\n    computeBoxExtents(axis, box1, _result1);\r\n    return !(_result0.min > _result1.max || _result1.min > _result0.max);\r\n};\r\n\r\n/**\r\n * Interface for cullable objects\r\n * @see https://doc.babylonjs.com/babylon101/materials#back-face-culling\r\n */\r\nexport interface ICullable {\r\n    /**\r\n     * Checks if the object or part of the object is in the frustum\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    isInFrustum(frustumPlanes: Plane[]): boolean;\r\n    /**\r\n     * Checks if a cullable object (mesh...) is in the camera frustum\r\n     * Unlike isInFrustum this checks the full bounding box\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    isCompletelyInFrustum(frustumPlanes: Plane[]): boolean;\r\n}\r\n\r\n/**\r\n * Info for a bounding data of a mesh\r\n */\r\nexport class BoundingInfo implements ICullable {\r\n    /**\r\n     * Bounding box for the mesh\r\n     */\r\n    public readonly boundingBox: BoundingBox;\r\n    /**\r\n     * Bounding sphere for the mesh\r\n     */\r\n    public readonly boundingSphere: BoundingSphere;\r\n\r\n    private _isLocked = false;\r\n\r\n    private static readonly _TmpVector3 = ArrayTools.BuildArray(2, Vector3.Zero);\r\n\r\n    /**\r\n     * Constructs bounding info\r\n     * @param minimum min vector of the bounding box/sphere\r\n     * @param maximum max vector of the bounding box/sphere\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.boundingBox = new BoundingBox(minimum, maximum, worldMatrix);\r\n        this.boundingSphere = new BoundingSphere(minimum, maximum, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Recreates the entire bounding info from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.boundingBox.reConstruct(min, max, worldMatrix);\r\n        this.boundingSphere.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * min vector of the bounding box/sphere\r\n     */\r\n    public get minimum(): Vector3 {\r\n        return this.boundingBox.minimum;\r\n    }\r\n\r\n    /**\r\n     * max vector of the bounding box/sphere\r\n     */\r\n    public get maximum(): Vector3 {\r\n        return this.boundingBox.maximum;\r\n    }\r\n\r\n    /**\r\n     * If the info is locked and won't be updated to avoid perf overhead\r\n     */\r\n    public get isLocked(): boolean {\r\n        return this._isLocked;\r\n    }\r\n\r\n    public set isLocked(value: boolean) {\r\n        this._isLocked = value;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Updates the bounding sphere and box\r\n     * @param world world matrix to be used to update\r\n     */\r\n    public update(world: DeepImmutable<Matrix>) {\r\n        if (this._isLocked) {\r\n            return;\r\n        }\r\n        this.boundingBox._update(world);\r\n        this.boundingSphere._update(world);\r\n    }\r\n\r\n    /**\r\n     * Recreate the bounding info to be centered around a specific point given a specific extend.\r\n     * @param center New center of the bounding info\r\n     * @param extend New extend of the bounding info\r\n     * @returns the current bounding info\r\n     */\r\n    public centerOn(center: DeepImmutable<Vector3>, extend: DeepImmutable<Vector3>): BoundingInfo {\r\n        const minimum = BoundingInfo._TmpVector3[0].copyFrom(center).subtractInPlace(extend);\r\n        const maximum = BoundingInfo._TmpVector3[1].copyFrom(center).addInPlace(extend);\r\n\r\n        this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n        this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Grows the bounding info to include the given point.\r\n     * @param point The point that will be included in the current bounding info\r\n     * @returns the current bounding info\r\n     */\r\n    public encapsulate(point: Vector3): BoundingInfo {\r\n        const minimum = Vector3.Minimize(this.minimum, point);\r\n        const maximum = Vector3.Maximize(this.maximum, point);\r\n        this.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Grows the bounding info to encapsulate the given bounding info.\r\n     * @param toEncapsulate The bounding info that will be encapsulated in the current bounding info\r\n     * @returns the current bounding info\r\n     */\r\n    public encapsulateBoundingInfo(toEncapsulate: BoundingInfo): BoundingInfo {\r\n        this.encapsulate(toEncapsulate.boundingBox.centerWorld.subtract(toEncapsulate.boundingBox.extendSizeWorld));\r\n        this.encapsulate(toEncapsulate.boundingBox.centerWorld.add(toEncapsulate.boundingBox.extendSizeWorld));\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding info by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding info\r\n     */\r\n    public scale(factor: number): BoundingInfo {\r\n        this.boundingBox.scale(factor);\r\n        this.boundingSphere.scale(factor);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the bounding info is within the frustum defined by the passed array of planes.\r\n     * @param frustumPlanes defines the frustum to test\r\n     * @param strategy defines the strategy to use for the culling (default is BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD)\r\n     * @returns true if the bounding info is in the frustum planes\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>, strategy: number = Constants.MESHES_CULLINGSTRATEGY_STANDARD): boolean {\r\n        const inclusionTest =\r\n            strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION || strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY;\r\n        if (inclusionTest) {\r\n            if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!this.boundingSphere.isInFrustum(frustumPlanes)) {\r\n            return false;\r\n        }\r\n\r\n        const bSphereOnlyTest =\r\n            strategy === Constants.MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY || strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY;\r\n        if (bSphereOnlyTest) {\r\n            return true;\r\n        }\r\n\r\n        return this.boundingBox.isInFrustum(frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Gets the world distance between the min and max points of the bounding box\r\n     */\r\n    public get diagonalLength(): number {\r\n        const boundingBox = this.boundingBox;\r\n        const diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, BoundingInfo._TmpVector3[0]);\r\n        return diag.length();\r\n    }\r\n\r\n    /**\r\n     * Checks if a cullable object (mesh...) is in the camera frustum\r\n     * Unlike isInFrustum this checks the full bounding box\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return this.boundingBox.isCompletelyInFrustum(frustumPlanes);\r\n    }\r\n    /**\r\n     * @param collider\r\n     * @hidden\r\n     */\r\n    public _checkCollision(collider: Collider): boolean {\r\n        return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);\r\n    }\r\n\r\n    /**\r\n     * Checks if a point is inside the bounding box and bounding sphere or the mesh\r\n     * @see https://doc.babylonjs.com/babylon101/intersect_collisions_-_mesh\r\n     * @param point the point to check intersection with\r\n     * @returns if the point intersects\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        if (!this.boundingSphere.centerWorld) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.boundingSphere.intersectsPoint(point)) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.boundingBox.intersectsPoint(point)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks if another bounding info intersects the bounding box and bounding sphere or the mesh\r\n     * @see https://doc.babylonjs.com/babylon101/intersect_collisions_-_mesh\r\n     * @param boundingInfo the bounding info to check intersection with\r\n     * @param precise if the intersection should be done using OBB\r\n     * @returns if the bounding info intersects\r\n     */\r\n    public intersects(boundingInfo: DeepImmutable<BoundingInfo>, precise: boolean): boolean {\r\n        if (!BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {\r\n            return false;\r\n        }\r\n\r\n        if (!BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {\r\n            return false;\r\n        }\r\n\r\n        if (!precise) {\r\n            return true;\r\n        }\r\n\r\n        const box0 = this.boundingBox;\r\n        const box1 = boundingInfo.boundingBox;\r\n\r\n        if (!axisOverlap(box0.directions[0], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box0.directions[1], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box0.directions[2], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box1.directions[0], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box1.directions[1], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box1.directions[2], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}