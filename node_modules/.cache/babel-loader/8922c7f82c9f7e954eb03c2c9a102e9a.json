{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Camera } from \"../../Cameras/camera.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../../Meshes/mesh.js\";\nimport { Geometry } from \"../../Meshes/geometry.js\";\nimport { TransformNode } from \"../../Meshes/transformNode.js\";\nimport { Material } from \"../../Materials/material.js\";\nimport { MultiMaterial } from \"../../Materials/multiMaterial.js\";\nimport { CubeTexture } from \"../../Materials/Textures/cubeTexture.js\";\nimport { HDRCubeTexture } from \"../../Materials/Textures/hdrCubeTexture.js\";\nimport { AnimationGroup } from \"../../Animations/animationGroup.js\";\nimport { Light } from \"../../Lights/light.js\";\nimport { SceneComponentConstants } from \"../../sceneComponent.js\";\nimport { SceneLoader } from \"../../Loading/sceneLoader.js\";\nimport { AbstractScene } from \"../../abstractScene.js\";\nimport { AssetContainer } from \"../../assetContainer.js\";\nimport { ActionManager } from \"../../Actions/actionManager.js\";\nimport { Skeleton } from \"../../Bones/skeleton.js\";\nimport { MorphTargetManager } from \"../../Morph/morphTargetManager.js\";\nimport { CannonJSPlugin } from \"../../Physics/Plugins/cannonJSPlugin.js\";\nimport { OimoJSPlugin } from \"../../Physics/Plugins/oimoJSPlugin.js\";\nimport { AmmoJSPlugin } from \"../../Physics/Plugins/ammoJSPlugin.js\";\nimport { ReflectionProbe } from \"../../Probes/reflectionProbe.js\";\nimport { GetClass } from \"../../Misc/typeStore.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { PostProcess } from \"../../PostProcesses/postProcess.js\";\nimport { EndsWith } from \"../../Misc/stringTools.js\";\n/** @hidden */\n// eslint-disable-next-line @typescript-eslint/naming-convention, no-var\n\nexport var _BabylonLoaderRegistered = true;\n/**\n * Helps setting up some configuration for the babylon file loader.\n */\n\nvar BabylonFileLoaderConfiguration =\n/** @class */\nfunction () {\n  function BabylonFileLoaderConfiguration() {}\n  /**\n   * The loader does not allow injecting custom physics engine into the plugins.\n   * Unfortunately in ES6, we need to manually inject them into the plugin.\n   * So you could set this variable to your engine import to make it work.\n   */\n\n\n  BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine = undefined;\n  return BabylonFileLoaderConfiguration;\n}();\n\nexport { BabylonFileLoaderConfiguration };\nvar tempIndexContainer = {};\nvar tempMaterialIndexContainer = {};\n\nvar parseMaterialByPredicate = function parseMaterialByPredicate(predicate, parsedData, scene, rootUrl) {\n  if (!parsedData.materials) {\n    return null;\n  }\n\n  for (var index = 0, cache = parsedData.materials.length; index < cache; index++) {\n    var parsedMaterial = parsedData.materials[index];\n\n    if (predicate(parsedMaterial)) {\n      return {\n        parsedMaterial: parsedMaterial,\n        material: Material.Parse(parsedMaterial, scene, rootUrl)\n      };\n    }\n  }\n\n  return null;\n};\n\nvar isDescendantOf = function isDescendantOf(mesh, names, hierarchyIds) {\n  for (var i in names) {\n    if (mesh.name === names[i]) {\n      hierarchyIds.push(mesh.id);\n      return true;\n    }\n  }\n\n  if (mesh.parentId !== undefined && hierarchyIds.indexOf(mesh.parentId) !== -1) {\n    hierarchyIds.push(mesh.id);\n    return true;\n  }\n\n  return false;\n}; // eslint-disable-next-line @typescript-eslint/naming-convention\n\n\nvar logOperation = function logOperation(operation, producer) {\n  return operation + \" of \" + (producer ? producer.file + \" from \" + producer.name + \" version: \" + producer.version + \", exporter version: \" + producer.exporter_version : \"unknown\");\n};\n\nvar loadDetailLevels = function loadDetailLevels(scene, mesh) {\n  var mastermesh = mesh; // Every value specified in the ids array of the lod data points to another mesh which should be used as the lower LOD level.\n  // The distances (or coverages) array values specified are used along with the lod mesh ids as a hint to determine the switching threshold for the various LODs.\n\n  if (mesh._waitingData.lods) {\n    if (mesh._waitingData.lods.ids && mesh._waitingData.lods.ids.length > 0) {\n      var lodmeshes = mesh._waitingData.lods.ids;\n      var wasenabled = mastermesh.isEnabled(false);\n\n      if (mesh._waitingData.lods.distances) {\n        var distances = mesh._waitingData.lods.distances;\n\n        if (distances.length >= lodmeshes.length) {\n          var culling = distances.length > lodmeshes.length ? distances[distances.length - 1] : 0;\n          mastermesh.setEnabled(false);\n\n          for (var index = 0; index < lodmeshes.length; index++) {\n            var lodid = lodmeshes[index];\n            var lodmesh = scene.getMeshById(lodid);\n\n            if (lodmesh != null) {\n              mastermesh.addLODLevel(distances[index], lodmesh);\n            }\n          }\n\n          if (culling > 0) {\n            mastermesh.addLODLevel(culling, null);\n          }\n\n          if (wasenabled === true) {\n            mastermesh.setEnabled(true);\n          }\n        } else {\n          Tools.Warn(\"Invalid level of detail distances for \" + mesh.name);\n        }\n      }\n    }\n\n    mesh._waitingData.lods = null;\n  }\n};\n\nvar findParent = function findParent(parentId, scene) {\n  if (typeof parentId !== \"number\") {\n    return scene.getLastEntryById(parentId);\n  }\n\n  var parent = tempIndexContainer[parentId];\n  return parent;\n};\n\nvar findMaterial = function findMaterial(materialId, scene) {\n  if (typeof materialId !== \"number\") {\n    return scene.getLastMaterialById(materialId, true);\n  }\n\n  return tempMaterialIndexContainer[materialId];\n};\n\nvar _loadAssetContainer = function loadAssetContainer(scene, data, rootUrl, onError, addToScene) {\n  if (addToScene === void 0) {\n    addToScene = false;\n  }\n\n  var container = new AssetContainer(scene); // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\n  // when SceneLoader.debugLogging = true (default), or exception encountered.\n  // Everything stored in var log instead of writing separate lines to support only writing in exception,\n  // and avoid problems with multiple concurrent .babylon loads.\n\n  var log = \"importScene has failed JSON parse\";\n\n  try {\n    // eslint-disable-next-line no-var\n    var parsedData = JSON.parse(data);\n    log = \"\";\n    var fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;\n    var index = void 0;\n    var cache = void 0; // Environment texture\n\n    if (parsedData.environmentTexture !== undefined && parsedData.environmentTexture !== null) {\n      // PBR needed for both HDR texture (gamma space) & a sky box\n      var isPBR = parsedData.isPBR !== undefined ? parsedData.isPBR : true;\n\n      if (parsedData.environmentTextureType && parsedData.environmentTextureType === \"BABYLON.HDRCubeTexture\") {\n        var hdrSize = parsedData.environmentTextureSize ? parsedData.environmentTextureSize : 128;\n        var hdrTexture = new HDRCubeTexture((parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture, scene, hdrSize, true, !isPBR, undefined, parsedData.environmentTexturePrefilterOnLoad);\n\n        if (parsedData.environmentTextureRotationY) {\n          hdrTexture.rotationY = parsedData.environmentTextureRotationY;\n        }\n\n        scene.environmentTexture = hdrTexture;\n      } else {\n        if (EndsWith(parsedData.environmentTexture, \".env\")) {\n          var compressedTexture = new CubeTexture((parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture, scene, parsedData.environmentTextureForcedExtension);\n\n          if (parsedData.environmentTextureRotationY) {\n            compressedTexture.rotationY = parsedData.environmentTextureRotationY;\n          }\n\n          scene.environmentTexture = compressedTexture;\n        } else {\n          var cubeTexture = CubeTexture.CreateFromPrefilteredData((parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture, scene);\n\n          if (parsedData.environmentTextureRotationY) {\n            cubeTexture.rotationY = parsedData.environmentTextureRotationY;\n          }\n\n          scene.environmentTexture = cubeTexture;\n        }\n      }\n\n      if (parsedData.createDefaultSkybox === true) {\n        var skyboxScale = scene.activeCamera !== undefined && scene.activeCamera !== null ? (scene.activeCamera.maxZ - scene.activeCamera.minZ) / 2 : 1000;\n        var skyboxBlurLevel = parsedData.skyboxBlurLevel || 0;\n        scene.createDefaultSkybox(scene.environmentTexture, isPBR, skyboxScale, skyboxBlurLevel);\n      }\n\n      container.environmentTexture = scene.environmentTexture;\n    } // Environment Intensity\n\n\n    if (parsedData.environmentIntensity !== undefined && parsedData.environmentIntensity !== null) {\n      scene.environmentIntensity = parsedData.environmentIntensity;\n    } // Lights\n\n\n    if (parsedData.lights !== undefined && parsedData.lights !== null) {\n      for (index = 0, cache = parsedData.lights.length; index < cache; index++) {\n        var parsedLight = parsedData.lights[index];\n        var light = Light.Parse(parsedLight, scene);\n\n        if (light) {\n          tempIndexContainer[parsedLight.uniqueId] = light;\n          container.lights.push(light);\n          light._parentContainer = container;\n          log += index === 0 ? \"\\n\\tLights:\" : \"\";\n          log += \"\\n\\t\\t\" + light.toString(fullDetails);\n        }\n      }\n    } // Reflection probes\n\n\n    if (parsedData.reflectionProbes !== undefined && parsedData.reflectionProbes !== null) {\n      for (index = 0, cache = parsedData.reflectionProbes.length; index < cache; index++) {\n        var parsedReflectionProbe = parsedData.reflectionProbes[index];\n        var reflectionProbe = ReflectionProbe.Parse(parsedReflectionProbe, scene, rootUrl);\n\n        if (reflectionProbe) {\n          container.reflectionProbes.push(reflectionProbe);\n          reflectionProbe._parentContainer = container;\n          log += index === 0 ? \"\\n\\tReflection Probes:\" : \"\";\n          log += \"\\n\\t\\t\" + reflectionProbe.toString(fullDetails);\n        }\n      }\n    } // Animations\n\n\n    if (parsedData.animations !== undefined && parsedData.animations !== null) {\n      for (index = 0, cache = parsedData.animations.length; index < cache; index++) {\n        var parsedAnimation = parsedData.animations[index];\n        var internalClass = GetClass(\"BABYLON.Animation\");\n\n        if (internalClass) {\n          var animation = internalClass.Parse(parsedAnimation);\n          scene.animations.push(animation);\n          container.animations.push(animation);\n          log += index === 0 ? \"\\n\\tAnimations:\" : \"\";\n          log += \"\\n\\t\\t\" + animation.toString(fullDetails);\n        }\n      }\n    } // Materials\n\n\n    if (parsedData.materials !== undefined && parsedData.materials !== null) {\n      for (index = 0, cache = parsedData.materials.length; index < cache; index++) {\n        var parsedMaterial = parsedData.materials[index];\n        var mat = Material.Parse(parsedMaterial, scene, rootUrl);\n\n        if (mat) {\n          tempMaterialIndexContainer[parsedMaterial.uniqueId || parsedMaterial.id] = mat;\n          container.materials.push(mat);\n          mat._parentContainer = container;\n          log += index === 0 ? \"\\n\\tMaterials:\" : \"\";\n          log += \"\\n\\t\\t\" + mat.toString(fullDetails); // Textures\n\n          var textures = mat.getActiveTextures();\n          textures.forEach(function (t) {\n            if (container.textures.indexOf(t) == -1) {\n              container.textures.push(t);\n              t._parentContainer = container;\n            }\n          });\n        }\n      }\n    }\n\n    if (parsedData.multiMaterials !== undefined && parsedData.multiMaterials !== null) {\n      for (index = 0, cache = parsedData.multiMaterials.length; index < cache; index++) {\n        var parsedMultiMaterial = parsedData.multiMaterials[index];\n        var mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);\n        tempMaterialIndexContainer[parsedMultiMaterial.uniqueId || parsedMultiMaterial.id] = mmat;\n        container.multiMaterials.push(mmat);\n        mmat._parentContainer = container;\n        log += index === 0 ? \"\\n\\tMultiMaterials:\" : \"\";\n        log += \"\\n\\t\\t\" + mmat.toString(fullDetails); // Textures\n\n        var textures = mmat.getActiveTextures();\n        textures.forEach(function (t) {\n          if (container.textures.indexOf(t) == -1) {\n            container.textures.push(t);\n            t._parentContainer = container;\n          }\n        });\n      }\n    } // Morph targets\n\n\n    if (parsedData.morphTargetManagers !== undefined && parsedData.morphTargetManagers !== null) {\n      for (var _i = 0, _a = parsedData.morphTargetManagers; _i < _a.length; _i++) {\n        var managerData = _a[_i];\n        var manager = MorphTargetManager.Parse(managerData, scene);\n        container.morphTargetManagers.push(manager);\n        manager._parentContainer = container;\n      }\n    } // Skeletons\n\n\n    if (parsedData.skeletons !== undefined && parsedData.skeletons !== null) {\n      for (index = 0, cache = parsedData.skeletons.length; index < cache; index++) {\n        var parsedSkeleton = parsedData.skeletons[index];\n        var skeleton = Skeleton.Parse(parsedSkeleton, scene);\n        container.skeletons.push(skeleton);\n        skeleton._parentContainer = container;\n        log += index === 0 ? \"\\n\\tSkeletons:\" : \"\";\n        log += \"\\n\\t\\t\" + skeleton.toString(fullDetails);\n      }\n    } // Geometries\n\n\n    var geometries = parsedData.geometries;\n\n    if (geometries !== undefined && geometries !== null) {\n      var addedGeometry = new Array(); // VertexData\n\n      var vertexData = geometries.vertexData;\n\n      if (vertexData !== undefined && vertexData !== null) {\n        for (index = 0, cache = vertexData.length; index < cache; index++) {\n          var parsedVertexData = vertexData[index];\n          addedGeometry.push(Geometry.Parse(parsedVertexData, scene, rootUrl));\n        }\n      }\n\n      addedGeometry.forEach(function (g) {\n        if (g) {\n          container.geometries.push(g);\n          g._parentContainer = container;\n        }\n      });\n    } // Transform nodes\n\n\n    if (parsedData.transformNodes !== undefined && parsedData.transformNodes !== null) {\n      for (index = 0, cache = parsedData.transformNodes.length; index < cache; index++) {\n        var parsedTransformNode = parsedData.transformNodes[index];\n        var node = TransformNode.Parse(parsedTransformNode, scene, rootUrl);\n        tempIndexContainer[parsedTransformNode.uniqueId] = node;\n        container.transformNodes.push(node);\n        node._parentContainer = container;\n      }\n    } // Meshes\n\n\n    if (parsedData.meshes !== undefined && parsedData.meshes !== null) {\n      for (index = 0, cache = parsedData.meshes.length; index < cache; index++) {\n        var parsedMesh = parsedData.meshes[index];\n        var mesh = Mesh.Parse(parsedMesh, scene, rootUrl);\n        tempIndexContainer[parsedMesh.uniqueId] = mesh;\n        container.meshes.push(mesh);\n        mesh._parentContainer = container;\n\n        if (mesh.hasInstances) {\n          for (var _b = 0, _c = mesh.instances; _b < _c.length; _b++) {\n            var instance = _c[_b];\n            container.meshes.push(instance);\n            instance._parentContainer = container;\n          }\n        }\n\n        log += index === 0 ? \"\\n\\tMeshes:\" : \"\";\n        log += \"\\n\\t\\t\" + mesh.toString(fullDetails);\n      }\n    } // Cameras\n\n\n    if (parsedData.cameras !== undefined && parsedData.cameras !== null) {\n      for (index = 0, cache = parsedData.cameras.length; index < cache; index++) {\n        var parsedCamera = parsedData.cameras[index];\n        var camera = Camera.Parse(parsedCamera, scene);\n        tempIndexContainer[parsedCamera.uniqueId] = camera;\n        container.cameras.push(camera);\n        camera._parentContainer = container;\n        log += index === 0 ? \"\\n\\tCameras:\" : \"\";\n        log += \"\\n\\t\\t\" + camera.toString(fullDetails);\n      }\n    } // Postprocesses\n\n\n    if (parsedData.postProcesses !== undefined && parsedData.postProcesses !== null) {\n      for (index = 0, cache = parsedData.postProcesses.length; index < cache; index++) {\n        var parsedPostProcess = parsedData.postProcesses[index];\n        var postProcess = PostProcess.Parse(parsedPostProcess, scene, rootUrl);\n\n        if (postProcess) {\n          container.postProcesses.push(postProcess);\n          postProcess._parentContainer = container;\n          log += index === 0 ? \"\\nPostprocesses:\" : \"\";\n          log += \"\\n\\t\\t\" + postProcess.toString();\n        }\n      }\n    } // Animation Groups\n\n\n    if (parsedData.animationGroups !== undefined && parsedData.animationGroups !== null) {\n      for (index = 0, cache = parsedData.animationGroups.length; index < cache; index++) {\n        var parsedAnimationGroup = parsedData.animationGroups[index];\n        var animationGroup = AnimationGroup.Parse(parsedAnimationGroup, scene);\n        container.animationGroups.push(animationGroup);\n        animationGroup._parentContainer = container;\n        log += index === 0 ? \"\\n\\tAnimationGroups:\" : \"\";\n        log += \"\\n\\t\\t\" + animationGroup.toString(fullDetails);\n      }\n    } // Browsing all the graph to connect the dots\n\n\n    for (index = 0, cache = scene.cameras.length; index < cache; index++) {\n      var camera = scene.cameras[index];\n\n      if (camera._waitingParentId !== null) {\n        camera.parent = findParent(camera._waitingParentId, scene);\n        camera._waitingParentId = null;\n      }\n    }\n\n    for (index = 0, cache = scene.lights.length; index < cache; index++) {\n      var light = scene.lights[index];\n\n      if (light && light._waitingParentId !== null) {\n        light.parent = findParent(light._waitingParentId, scene);\n        light._waitingParentId = null;\n      }\n    } // Connect parents & children and parse actions and lods\n\n\n    for (index = 0, cache = scene.transformNodes.length; index < cache; index++) {\n      var transformNode = scene.transformNodes[index];\n\n      if (transformNode._waitingParentId !== null) {\n        transformNode.parent = findParent(transformNode._waitingParentId, scene);\n        transformNode._waitingParentId = null;\n      }\n    }\n\n    for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n      var mesh = scene.meshes[index];\n\n      if (mesh._waitingParentId !== null) {\n        mesh.parent = findParent(mesh._waitingParentId, scene);\n        mesh._waitingParentId = null;\n      }\n\n      if (mesh._waitingData.lods) {\n        loadDetailLevels(scene, mesh);\n      }\n    } // link multimats with materials\n\n\n    scene.multiMaterials.forEach(function (multimat) {\n      multimat._waitingSubMaterialsUniqueIds.forEach(function (subMaterial) {\n        multimat.subMaterials.push(findMaterial(subMaterial, scene));\n      });\n\n      multimat._waitingSubMaterialsUniqueIds = [];\n    }); // link meshes with materials\n\n    scene.meshes.forEach(function (mesh) {\n      if (mesh._waitingMaterialId !== null) {\n        mesh.material = findMaterial(mesh._waitingMaterialId, scene);\n        mesh._waitingMaterialId = null;\n      }\n    }); // link skeleton transform nodes\n\n    for (index = 0, cache = scene.skeletons.length; index < cache; index++) {\n      var skeleton = scene.skeletons[index];\n\n      if (skeleton._hasWaitingData) {\n        if (skeleton.bones != null) {\n          skeleton.bones.forEach(function (bone) {\n            if (bone._waitingTransformNodeId) {\n              var linkTransformNode = scene.getLastEntryById(bone._waitingTransformNodeId);\n\n              if (linkTransformNode) {\n                bone.linkTransformNode(linkTransformNode);\n              }\n\n              bone._waitingTransformNodeId = null;\n            }\n          });\n        }\n\n        skeleton._hasWaitingData = null;\n      }\n    } // freeze world matrix application\n\n\n    for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n      var currentMesh = scene.meshes[index];\n\n      if (currentMesh._waitingData.freezeWorldMatrix) {\n        currentMesh.freezeWorldMatrix();\n        currentMesh._waitingData.freezeWorldMatrix = null;\n      } else {\n        currentMesh.computeWorldMatrix(true);\n      }\n    } // Lights exclusions / inclusions\n\n\n    for (index = 0, cache = scene.lights.length; index < cache; index++) {\n      var light = scene.lights[index]; // Excluded check\n\n      if (light._excludedMeshesIds.length > 0) {\n        for (var excludedIndex = 0; excludedIndex < light._excludedMeshesIds.length; excludedIndex++) {\n          var excludedMesh = scene.getMeshById(light._excludedMeshesIds[excludedIndex]);\n\n          if (excludedMesh) {\n            light.excludedMeshes.push(excludedMesh);\n          }\n        }\n\n        light._excludedMeshesIds = [];\n      } // Included check\n\n\n      if (light._includedOnlyMeshesIds.length > 0) {\n        for (var includedOnlyIndex = 0; includedOnlyIndex < light._includedOnlyMeshesIds.length; includedOnlyIndex++) {\n          var includedOnlyMesh = scene.getMeshById(light._includedOnlyMeshesIds[includedOnlyIndex]);\n\n          if (includedOnlyMesh) {\n            light.includedOnlyMeshes.push(includedOnlyMesh);\n          }\n        }\n\n        light._includedOnlyMeshesIds = [];\n      }\n    }\n\n    AbstractScene.Parse(parsedData, scene, container, rootUrl); // Actions (scene) Done last as it can access other objects.\n\n    for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n      var mesh = scene.meshes[index];\n\n      if (mesh._waitingData.actions) {\n        ActionManager.Parse(mesh._waitingData.actions, mesh, scene);\n        mesh._waitingData.actions = null;\n      }\n    }\n\n    if (parsedData.actions !== undefined && parsedData.actions !== null) {\n      ActionManager.Parse(parsedData.actions, null, scene);\n    }\n  } catch (err) {\n    var msg = logOperation(\"loadAssets\", parsedData ? parsedData.producer : \"Unknown\") + log;\n\n    if (onError) {\n      onError(msg, err);\n    } else {\n      Logger.Log(msg);\n      throw err;\n    }\n  } finally {\n    tempIndexContainer = {};\n\n    if (!addToScene) {\n      container.removeAllFromScene();\n    }\n\n    if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\n      Logger.Log(logOperation(\"loadAssets\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\n    }\n  }\n\n  return container;\n};\n\nSceneLoader.RegisterPlugin({\n  name: \"babylon.js\",\n  extensions: \".babylon\",\n  canDirectLoad: function canDirectLoad(data) {\n    if (data.indexOf(\"babylon\") !== -1) {\n      // We consider that the producer string is filled\n      return true;\n    }\n\n    return false;\n  },\n  importMesh: function importMesh(meshesNames, scene, data, rootUrl, meshes, particleSystems, skeletons, onError) {\n    var _a; // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\n    // when SceneLoader.debugLogging = true (default), or exception encountered.\n    // Everything stored in var log instead of writing separate lines to support only writing in exception,\n    // and avoid problems with multiple concurrent .babylon loads.\n\n\n    var log = \"importMesh has failed JSON parse\";\n\n    try {\n      // eslint-disable-next-line no-var\n      var parsedData = JSON.parse(data);\n      log = \"\";\n      var fullDetails_1 = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;\n\n      if (!meshesNames) {\n        meshesNames = null;\n      } else if (!Array.isArray(meshesNames)) {\n        meshesNames = [meshesNames];\n      }\n\n      var hierarchyIds = new Array(); // Transform nodes (the overall idea is to load all of them as this is super fast and then get rid of the ones we don't need)\n\n      var loadedTransformNodes = [];\n\n      if (parsedData.transformNodes !== undefined && parsedData.transformNodes !== null) {\n        for (var index = 0, cache = parsedData.transformNodes.length; index < cache; index++) {\n          var parsedTransformNode = parsedData.transformNodes[index];\n          loadedTransformNodes.push(TransformNode.Parse(parsedTransformNode, scene, rootUrl));\n        }\n      }\n\n      if (parsedData.meshes !== undefined && parsedData.meshes !== null) {\n        var loadedSkeletonsIds = [];\n        var loadedMaterialsIds = [];\n        var loadedMaterialsUniqueIds = [];\n        var loadedMorphTargetsIds = [];\n\n        var _loop_1 = function _loop_1(index, cache) {\n          var parsedMesh = parsedData.meshes[index];\n\n          if (meshesNames === null || isDescendantOf(parsedMesh, meshesNames, hierarchyIds)) {\n            if (meshesNames !== null) {\n              // Remove found mesh name from list.\n              delete meshesNames[meshesNames.indexOf(parsedMesh.name)];\n            } //Geometry?\n\n\n            if (parsedMesh.geometryId !== undefined && parsedMesh.geometryId !== null) {\n              //does the file contain geometries?\n              if (parsedData.geometries !== undefined && parsedData.geometries !== null) {\n                //find the correct geometry and add it to the scene\n                var found_1 = false;\n                [\"boxes\", \"spheres\", \"cylinders\", \"toruses\", \"grounds\", \"planes\", \"torusKnots\", \"vertexData\"].forEach(function (geometryType) {\n                  if (found_1 === true || !parsedData.geometries[geometryType] || !Array.isArray(parsedData.geometries[geometryType])) {\n                    return;\n                  } else {\n                    parsedData.geometries[geometryType].forEach(function (parsedGeometryData) {\n                      if (parsedGeometryData.id === parsedMesh.geometryId) {\n                        switch (geometryType) {\n                          case \"vertexData\":\n                            Geometry.Parse(parsedGeometryData, scene, rootUrl);\n                            break;\n                        }\n\n                        found_1 = true;\n                      }\n                    });\n                  }\n                });\n\n                if (found_1 === false) {\n                  Logger.Warn(\"Geometry not found for mesh \" + parsedMesh.id);\n                }\n              }\n            } // Material ?\n\n\n            if (parsedMesh.materialUniqueId || parsedMesh.materialId) {\n              // if we have a unique ID, look up and store in loadedMaterialsUniqueIds, else use loadedMaterialsIds\n              var materialArray_1 = parsedMesh.materialUniqueId ? loadedMaterialsUniqueIds : loadedMaterialsIds;\n              var materialFound = materialArray_1.indexOf(parsedMesh.materialUniqueId || parsedMesh.materialId) !== -1;\n\n              if (materialFound === false && parsedData.multiMaterials !== undefined && parsedData.multiMaterials !== null) {\n                // Loads a submaterial of a multimaterial\n                var loadSubMaterial_1 = function loadSubMaterial_1(subMatId, predicate) {\n                  materialArray_1.push(subMatId);\n                  var mat = parseMaterialByPredicate(predicate, parsedData, scene, rootUrl);\n\n                  if (mat && mat.material) {\n                    tempMaterialIndexContainer[mat.parsedMaterial.uniqueId || mat.parsedMaterial.id] = mat.material;\n                    log += \"\\n\\tMaterial \" + mat.material.toString(fullDetails_1);\n                  }\n                };\n\n                for (var multimatIndex = 0, multimatCache = parsedData.multiMaterials.length; multimatIndex < multimatCache; multimatIndex++) {\n                  var parsedMultiMaterial = parsedData.multiMaterials[multimatIndex];\n\n                  if (parsedMesh.materialUniqueId && parsedMultiMaterial.uniqueId === parsedMesh.materialUniqueId || parsedMultiMaterial.id === parsedMesh.materialId) {\n                    if (parsedMultiMaterial.materialsUniqueIds) {\n                      // if the materials inside the multimat are stored by unique id\n                      parsedMultiMaterial.materialsUniqueIds.forEach(function (subMatId) {\n                        return loadSubMaterial_1(subMatId, function (parsedMaterial) {\n                          return parsedMaterial.uniqueId === subMatId;\n                        });\n                      });\n                    } else {\n                      // if the mats are stored by id instead\n                      parsedMultiMaterial.materials.forEach(function (subMatId) {\n                        return loadSubMaterial_1(subMatId, function (parsedMaterial) {\n                          return parsedMaterial.id === subMatId;\n                        });\n                      });\n                    }\n\n                    materialArray_1.push(parsedMultiMaterial.uniqueId || parsedMultiMaterial.id);\n                    var mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);\n                    tempMaterialIndexContainer[parsedMultiMaterial.uniqueId || parsedMultiMaterial.id] = mmat;\n\n                    if (mmat) {\n                      materialFound = true;\n                      log += \"\\n\\tMulti-Material \" + mmat.toString(fullDetails_1);\n                    }\n\n                    break;\n                  }\n                }\n              }\n\n              if (materialFound === false) {\n                materialArray_1.push(parsedMesh.materialUniqueId || parsedMesh.materialId);\n                var mat = parseMaterialByPredicate(function (parsedMaterial) {\n                  return parsedMesh.materialUniqueId && parsedMaterial.uniqueId === parsedMesh.materialUniqueId || parsedMaterial.id === parsedMesh.materialId;\n                }, parsedData, scene, rootUrl);\n\n                if (!mat || !mat.material) {\n                  Logger.Warn(\"Material not found for mesh \" + parsedMesh.id);\n                } else {\n                  tempMaterialIndexContainer[mat.parsedMaterial.uniqueId || mat.parsedMaterial.id] = mat.material;\n                  log += \"\\n\\tMaterial \" + mat.material.toString(fullDetails_1);\n                }\n              }\n            } // Skeleton ?\n\n\n            if (parsedMesh.skeletonId > -1 && parsedData.skeletons !== undefined && parsedData.skeletons !== null) {\n              var skeletonAlreadyLoaded = loadedSkeletonsIds.indexOf(parsedMesh.skeletonId) > -1;\n\n              if (!skeletonAlreadyLoaded) {\n                for (var skeletonIndex = 0, skeletonCache = parsedData.skeletons.length; skeletonIndex < skeletonCache; skeletonIndex++) {\n                  var parsedSkeleton = parsedData.skeletons[skeletonIndex];\n\n                  if (parsedSkeleton.id === parsedMesh.skeletonId) {\n                    var skeleton = Skeleton.Parse(parsedSkeleton, scene);\n                    skeletons.push(skeleton);\n                    loadedSkeletonsIds.push(parsedSkeleton.id);\n                    log += \"\\n\\tSkeleton \" + skeleton.toString(fullDetails_1);\n                  }\n                }\n              }\n            } // Morph targets ?\n\n\n            if (parsedMesh.morphTargetManagerId > -1 && parsedData.morphTargetManagers !== undefined && parsedData.morphTargetManagers !== null) {\n              var morphTargetAlreadyLoaded = loadedMorphTargetsIds.indexOf(parsedMesh.morphTargetManagerId) > -1;\n\n              if (!morphTargetAlreadyLoaded) {\n                for (var morphTargetIndex = 0, morphTargetCache = parsedData.morphTargetManagers.length; morphTargetIndex < morphTargetCache; morphTargetIndex++) {\n                  var parsedMorphTarget = parsedData.morphTargetManagers[morphTargetIndex];\n\n                  if (parsedMorphTarget.id === parsedMesh.morphTargetManagerId) {\n                    var morphTarget = MorphTargetManager.Parse(parsedMorphTarget, scene);\n                    loadedMorphTargetsIds.push(morphTarget.uniqueId);\n                    log += \"\\nMorph target \" + morphTarget.toString();\n                  }\n                }\n              }\n            }\n\n            var mesh = Mesh.Parse(parsedMesh, scene, rootUrl);\n            meshes.push(mesh);\n            log += \"\\n\\tMesh \" + mesh.toString(fullDetails_1);\n          }\n        };\n\n        for (var index = 0, cache = parsedData.meshes.length; index < cache; index++) {\n          _loop_1(index, cache);\n        } // link multimats with materials\n\n\n        scene.multiMaterials.forEach(function (multimat) {\n          multimat._waitingSubMaterialsUniqueIds.forEach(function (subMaterial) {\n            multimat.subMaterials.push(findMaterial(subMaterial, scene));\n          });\n\n          multimat._waitingSubMaterialsUniqueIds = [];\n        }); // link meshes with materials\n\n        scene.meshes.forEach(function (mesh) {\n          if (mesh._waitingMaterialId !== null) {\n            mesh.material = findMaterial(mesh._waitingMaterialId, scene);\n            mesh._waitingMaterialId = null;\n          }\n        }); // Connecting parents and lods\n\n        for (var index = 0, cache = scene.transformNodes.length; index < cache; index++) {\n          var transformNode = scene.transformNodes[index];\n\n          if (transformNode._waitingParentId !== null) {\n            transformNode.parent = scene.getLastEntryById(transformNode._waitingParentId);\n            transformNode._waitingParentId = null;\n          }\n        }\n\n        var currentMesh = void 0;\n\n        for (var index = 0, cache = scene.meshes.length; index < cache; index++) {\n          currentMesh = scene.meshes[index];\n\n          if (currentMesh._waitingParentId) {\n            currentMesh.parent = scene.getLastEntryById(currentMesh._waitingParentId);\n\n            if (((_a = currentMesh.parent) === null || _a === void 0 ? void 0 : _a.getClassName()) === \"TransformNode\") {\n              var loadedTransformNodeIndex = loadedTransformNodes.indexOf(currentMesh.parent);\n\n              if (loadedTransformNodeIndex > -1) {\n                loadedTransformNodes.splice(loadedTransformNodeIndex, 1);\n              }\n            }\n\n            currentMesh._waitingParentId = null;\n          }\n\n          if (currentMesh._waitingData.lods) {\n            loadDetailLevels(scene, currentMesh);\n          }\n        } // Remove unused transform nodes\n\n\n        for (var _i = 0, loadedTransformNodes_1 = loadedTransformNodes; _i < loadedTransformNodes_1.length; _i++) {\n          var transformNode = loadedTransformNodes_1[_i];\n          transformNode.dispose();\n        } // link skeleton transform nodes\n\n\n        for (var index = 0, cache = scene.skeletons.length; index < cache; index++) {\n          var skeleton = scene.skeletons[index];\n\n          if (skeleton._hasWaitingData) {\n            if (skeleton.bones != null) {\n              skeleton.bones.forEach(function (bone) {\n                if (bone._waitingTransformNodeId) {\n                  var linkTransformNode = scene.getLastEntryById(bone._waitingTransformNodeId);\n\n                  if (linkTransformNode) {\n                    bone.linkTransformNode(linkTransformNode);\n                  }\n\n                  bone._waitingTransformNodeId = null;\n                }\n              });\n            }\n\n            skeleton._hasWaitingData = null;\n          }\n        } // freeze and compute world matrix application\n\n\n        for (var index = 0, cache = scene.meshes.length; index < cache; index++) {\n          currentMesh = scene.meshes[index];\n\n          if (currentMesh._waitingData.freezeWorldMatrix) {\n            currentMesh.freezeWorldMatrix();\n            currentMesh._waitingData.freezeWorldMatrix = null;\n          } else {\n            currentMesh.computeWorldMatrix(true);\n          }\n        }\n      } // Particles\n\n\n      if (parsedData.particleSystems !== undefined && parsedData.particleSystems !== null) {\n        var parser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);\n\n        if (parser) {\n          for (var index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {\n            var parsedParticleSystem = parsedData.particleSystems[index];\n\n            if (hierarchyIds.indexOf(parsedParticleSystem.emitterId) !== -1) {\n              particleSystems.push(parser(parsedParticleSystem, scene, rootUrl));\n            }\n          }\n        }\n      }\n\n      return true;\n    } catch (err) {\n      var msg = logOperation(\"importMesh\", parsedData ? parsedData.producer : \"Unknown\") + log;\n\n      if (onError) {\n        onError(msg, err);\n      } else {\n        Logger.Log(msg);\n        throw err;\n      }\n    } finally {\n      if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\n        Logger.Log(logOperation(\"importMesh\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\n      }\n    }\n\n    return false;\n  },\n  load: function load(scene, data, rootUrl, onError) {\n    // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\n    // when SceneLoader.debugLogging = true (default), or exception encountered.\n    // Everything stored in var log instead of writing separate lines to support only writing in exception,\n    // and avoid problems with multiple concurrent .babylon loads.\n    var log = \"importScene has failed JSON parse\";\n\n    try {\n      // eslint-disable-next-line no-var\n      var parsedData = JSON.parse(data);\n      log = \"\"; // Scene\n\n      if (parsedData.useDelayedTextureLoading !== undefined && parsedData.useDelayedTextureLoading !== null) {\n        scene.useDelayedTextureLoading = parsedData.useDelayedTextureLoading && !SceneLoader.ForceFullSceneLoadingForIncremental;\n      }\n\n      if (parsedData.autoClear !== undefined && parsedData.autoClear !== null) {\n        scene.autoClear = parsedData.autoClear;\n      }\n\n      if (parsedData.clearColor !== undefined && parsedData.clearColor !== null) {\n        scene.clearColor = Color4.FromArray(parsedData.clearColor);\n      }\n\n      if (parsedData.ambientColor !== undefined && parsedData.ambientColor !== null) {\n        scene.ambientColor = Color3.FromArray(parsedData.ambientColor);\n      }\n\n      if (parsedData.gravity !== undefined && parsedData.gravity !== null) {\n        scene.gravity = Vector3.FromArray(parsedData.gravity);\n      }\n\n      if (parsedData.useRightHandedSystem !== undefined) {\n        scene.useRightHandedSystem = !!parsedData.useRightHandedSystem;\n      } // Fog\n\n\n      if (parsedData.fogMode && parsedData.fogMode !== 0) {\n        scene.fogMode = parsedData.fogMode;\n        scene.fogColor = Color3.FromArray(parsedData.fogColor);\n        scene.fogStart = parsedData.fogStart;\n        scene.fogEnd = parsedData.fogEnd;\n        scene.fogDensity = parsedData.fogDensity;\n        log += \"\\tFog mode for scene:  \";\n\n        switch (scene.fogMode) {\n          // getters not compiling, so using hardcoded\n          case 1:\n            log += \"exp\\n\";\n            break;\n\n          case 2:\n            log += \"exp2\\n\";\n            break;\n\n          case 3:\n            log += \"linear\\n\";\n            break;\n        }\n      } //Physics\n\n\n      if (parsedData.physicsEnabled) {\n        var physicsPlugin = void 0;\n\n        if (parsedData.physicsEngine === \"cannon\") {\n          physicsPlugin = new CannonJSPlugin(undefined, undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);\n        } else if (parsedData.physicsEngine === \"oimo\") {\n          physicsPlugin = new OimoJSPlugin(undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);\n        } else if (parsedData.physicsEngine === \"ammo\") {\n          physicsPlugin = new AmmoJSPlugin(undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine, undefined);\n        }\n\n        log = \"\\tPhysics engine \" + (parsedData.physicsEngine ? parsedData.physicsEngine : \"oimo\") + \" enabled\\n\"; //else - default engine, which is currently oimo\n\n        var physicsGravity = parsedData.physicsGravity ? Vector3.FromArray(parsedData.physicsGravity) : null;\n        scene.enablePhysics(physicsGravity, physicsPlugin);\n      } // Metadata\n\n\n      if (parsedData.metadata !== undefined && parsedData.metadata !== null) {\n        scene.metadata = parsedData.metadata;\n      } //collisions, if defined. otherwise, default is true\n\n\n      if (parsedData.collisionsEnabled !== undefined && parsedData.collisionsEnabled !== null) {\n        scene.collisionsEnabled = parsedData.collisionsEnabled;\n      }\n\n      var container = _loadAssetContainer(scene, data, rootUrl, onError, true);\n\n      if (!container) {\n        return false;\n      }\n\n      if (parsedData.autoAnimate) {\n        scene.beginAnimation(scene, parsedData.autoAnimateFrom, parsedData.autoAnimateTo, parsedData.autoAnimateLoop, parsedData.autoAnimateSpeed || 1.0);\n      }\n\n      if (parsedData.activeCameraID !== undefined && parsedData.activeCameraID !== null) {\n        scene.setActiveCameraById(parsedData.activeCameraID);\n      } // Finish\n\n\n      return true;\n    } catch (err) {\n      var msg = logOperation(\"importScene\", parsedData ? parsedData.producer : \"Unknown\") + log;\n\n      if (onError) {\n        onError(msg, err);\n      } else {\n        Logger.Log(msg);\n        throw err;\n      }\n    } finally {\n      if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\n        Logger.Log(logOperation(\"importScene\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\n      }\n    }\n\n    return false;\n  },\n  loadAssetContainer: function loadAssetContainer(scene, data, rootUrl, onError) {\n    var container = _loadAssetContainer(scene, data, rootUrl, onError);\n\n    return container;\n  }\n});","map":{"version":3,"mappings":"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","names":["Logger","Camera","Vector3","Color3","Color4","Mesh","Geometry","TransformNode","Material","MultiMaterial","CubeTexture","HDRCubeTexture","AnimationGroup","Light","SceneComponentConstants","SceneLoader","AbstractScene","AssetContainer","ActionManager","Skeleton","MorphTargetManager","CannonJSPlugin","OimoJSPlugin","AmmoJSPlugin","ReflectionProbe","GetClass","Tools","PostProcess","EndsWith","_BabylonLoaderRegistered","BabylonFileLoaderConfiguration","undefined","tempIndexContainer","tempMaterialIndexContainer","parseMaterialByPredicate","predicate","parsedData","scene","rootUrl","materials","index","cache","length","parsedMaterial","material","Parse","isDescendantOf","mesh","names","hierarchyIds","i","name","push","id","parentId","indexOf","logOperation","operation","producer","file","version","exporter_version","loadDetailLevels","mastermesh","_waitingData","lods","ids","lodmeshes","wasenabled","isEnabled","distances","culling","setEnabled","lodid","lodmesh","getMeshById","addLODLevel","Warn","findParent","getLastEntryById","parent","findMaterial","materialId","getLastMaterialById","loadAssetContainer","data","onError","addToScene","container","log","JSON","parse","fullDetails","loggingLevel","DETAILED_LOGGING","environmentTexture","isPBR","environmentTextureType","hdrSize","environmentTextureSize","hdrTexture","match","environmentTexturePrefilterOnLoad","environmentTextureRotationY","rotationY","compressedTexture","environmentTextureForcedExtension","cubeTexture","CreateFromPrefilteredData","createDefaultSkybox","skyboxScale","activeCamera","maxZ","minZ","skyboxBlurLevel","environmentIntensity","lights","parsedLight","light","uniqueId","_parentContainer","toString","reflectionProbes","parsedReflectionProbe","reflectionProbe","animations","parsedAnimation","internalClass","animation","mat","textures","getActiveTextures","forEach","t","multiMaterials","parsedMultiMaterial","mmat","ParseMultiMaterial","morphTargetManagers","_i","managerData","manager","skeletons","parsedSkeleton","skeleton","geometries","addedGeometry","Array","vertexData","parsedVertexData","g","transformNodes","parsedTransformNode","node","meshes","parsedMesh","hasInstances","instances","_b","instance","cameras","parsedCamera","camera","postProcesses","parsedPostProcess","postProcess","animationGroups","parsedAnimationGroup","animationGroup","_waitingParentId","transformNode","multimat","_waitingSubMaterialsUniqueIds","subMaterial","subMaterials","_waitingMaterialId","_hasWaitingData","bones","bone","_waitingTransformNodeId","linkTransformNode","currentMesh","freezeWorldMatrix","computeWorldMatrix","_excludedMeshesIds","excludedIndex","excludedMesh","excludedMeshes","_includedOnlyMeshesIds","includedOnlyIndex","includedOnlyMesh","includedOnlyMeshes","actions","err","msg","Log","removeAllFromScene","NO_LOGGING","MINIMAL_LOGGING","RegisterPlugin","extensions","canDirectLoad","importMesh","meshesNames","particleSystems","fullDetails_1","isArray","loadedTransformNodes","loadedSkeletonsIds","loadedMaterialsIds","loadedMaterialsUniqueIds","loadedMorphTargetsIds","geometryId","found_1","geometryType","parsedGeometryData","materialUniqueId","materialArray_1","materialFound","loadSubMaterial_1","subMatId","multimatIndex","multimatCache","materialsUniqueIds","skeletonId","skeletonAlreadyLoaded","skeletonIndex","skeletonCache","morphTargetManagerId","morphTargetAlreadyLoaded","morphTargetIndex","morphTargetCache","parsedMorphTarget","morphTarget","_a","getClassName","loadedTransformNodeIndex","splice","dispose","parser","GetIndividualParser","NAME_PARTICLESYSTEM","parsedParticleSystem","emitterId","load","useDelayedTextureLoading","ForceFullSceneLoadingForIncremental","autoClear","clearColor","FromArray","ambientColor","gravity","useRightHandedSystem","fogMode","fogColor","fogStart","fogEnd","fogDensity","physicsEnabled","physicsPlugin","physicsEngine","LoaderInjectedPhysicsEngine","physicsGravity","enablePhysics","metadata","collisionsEnabled","autoAnimate","beginAnimation","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","activeCameraID","setActiveCameraById"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Loading/Plugins/babylonFileLoader.ts"],"sourcesContent":["import { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Camera } from \"../../Cameras/camera\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Geometry } from \"../../Meshes/geometry\";\r\nimport type { Node } from \"../../node\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Material } from \"../../Materials/material\";\r\nimport { MultiMaterial } from \"../../Materials/multiMaterial\";\r\nimport { CubeTexture } from \"../../Materials/Textures/cubeTexture\";\r\nimport { HDRCubeTexture } from \"../../Materials/Textures/hdrCubeTexture\";\r\nimport { AnimationGroup } from \"../../Animations/animationGroup\";\r\nimport { Light } from \"../../Lights/light\";\r\nimport { SceneComponentConstants } from \"../../sceneComponent\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\nimport { AbstractScene } from \"../../abstractScene\";\r\nimport { AssetContainer } from \"../../assetContainer\";\r\nimport { ActionManager } from \"../../Actions/actionManager\";\r\nimport type { IParticleSystem } from \"../../Particles/IParticleSystem\";\r\nimport { Skeleton } from \"../../Bones/skeleton\";\r\nimport { MorphTargetManager } from \"../../Morph/morphTargetManager\";\r\nimport { CannonJSPlugin } from \"../../Physics/Plugins/cannonJSPlugin\";\r\nimport { OimoJSPlugin } from \"../../Physics/Plugins/oimoJSPlugin\";\r\nimport { AmmoJSPlugin } from \"../../Physics/Plugins/ammoJSPlugin\";\r\nimport { ReflectionProbe } from \"../../Probes/reflectionProbe\";\r\nimport { GetClass } from \"../../Misc/typeStore\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport { EndsWith } from \"../../Misc/stringTools\";\r\n\r\n/** @hidden */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention, no-var\r\nexport var _BabylonLoaderRegistered = true;\r\n\r\n/**\r\n * Helps setting up some configuration for the babylon file loader.\r\n */\r\nexport class BabylonFileLoaderConfiguration {\r\n    /**\r\n     * The loader does not allow injecting custom physics engine into the plugins.\r\n     * Unfortunately in ES6, we need to manually inject them into the plugin.\r\n     * So you could set this variable to your engine import to make it work.\r\n     */\r\n    public static LoaderInjectedPhysicsEngine: any = undefined;\r\n}\r\n\r\nlet tempIndexContainer: { [key: string]: Node } = {};\r\nconst tempMaterialIndexContainer: { [key: string]: Material } = {};\r\n\r\nconst parseMaterialByPredicate = (predicate: (parsedMaterial: any) => boolean, parsedData: any, scene: Scene, rootUrl: string) => {\r\n    if (!parsedData.materials) {\r\n        return null;\r\n    }\r\n\r\n    for (let index = 0, cache = parsedData.materials.length; index < cache; index++) {\r\n        const parsedMaterial = parsedData.materials[index];\r\n        if (predicate(parsedMaterial)) {\r\n            return { parsedMaterial, material: Material.Parse(parsedMaterial, scene, rootUrl) };\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nconst isDescendantOf = (mesh: any, names: Array<any>, hierarchyIds: Array<number>) => {\r\n    for (const i in names) {\r\n        if (mesh.name === names[i]) {\r\n            hierarchyIds.push(mesh.id);\r\n            return true;\r\n        }\r\n    }\r\n    if (mesh.parentId !== undefined && hierarchyIds.indexOf(mesh.parentId) !== -1) {\r\n        hierarchyIds.push(mesh.id);\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst logOperation = (operation: string, producer: { file: string; name: string; version: string; exporter_version: string }) => {\r\n    return (\r\n        operation +\r\n        \" of \" +\r\n        (producer ? producer.file + \" from \" + producer.name + \" version: \" + producer.version + \", exporter version: \" + producer.exporter_version : \"unknown\")\r\n    );\r\n};\r\n\r\nconst loadDetailLevels = (scene: Scene, mesh: AbstractMesh) => {\r\n    const mastermesh: Mesh = mesh as Mesh;\r\n\r\n    // Every value specified in the ids array of the lod data points to another mesh which should be used as the lower LOD level.\r\n    // The distances (or coverages) array values specified are used along with the lod mesh ids as a hint to determine the switching threshold for the various LODs.\r\n    if (mesh._waitingData.lods) {\r\n        if (mesh._waitingData.lods.ids && mesh._waitingData.lods.ids.length > 0) {\r\n            const lodmeshes: string[] = mesh._waitingData.lods.ids;\r\n            const wasenabled: boolean = mastermesh.isEnabled(false);\r\n            if (mesh._waitingData.lods.distances) {\r\n                const distances: number[] = mesh._waitingData.lods.distances;\r\n                if (distances.length >= lodmeshes.length) {\r\n                    const culling: number = distances.length > lodmeshes.length ? distances[distances.length - 1] : 0;\r\n                    mastermesh.setEnabled(false);\r\n                    for (let index = 0; index < lodmeshes.length; index++) {\r\n                        const lodid: string = lodmeshes[index];\r\n                        const lodmesh: Mesh = scene.getMeshById(lodid) as Mesh;\r\n                        if (lodmesh != null) {\r\n                            mastermesh.addLODLevel(distances[index], lodmesh);\r\n                        }\r\n                    }\r\n                    if (culling > 0) {\r\n                        mastermesh.addLODLevel(culling, null);\r\n                    }\r\n                    if (wasenabled === true) {\r\n                        mastermesh.setEnabled(true);\r\n                    }\r\n                } else {\r\n                    Tools.Warn(\"Invalid level of detail distances for \" + mesh.name);\r\n                }\r\n            }\r\n        }\r\n        mesh._waitingData.lods = null;\r\n    }\r\n};\r\n\r\nconst findParent = (parentId: any, scene: Scene) => {\r\n    if (typeof parentId !== \"number\") {\r\n        return scene.getLastEntryById(parentId);\r\n    }\r\n\r\n    const parent = tempIndexContainer[parentId];\r\n\r\n    return parent;\r\n};\r\n\r\nconst findMaterial = (materialId: any, scene: Scene) => {\r\n    if (typeof materialId !== \"number\") {\r\n        return scene.getLastMaterialById(materialId, true);\r\n    }\r\n\r\n    return tempMaterialIndexContainer[materialId];\r\n};\r\n\r\nconst loadAssetContainer = (scene: Scene, data: string, rootUrl: string, onError?: (message: string, exception?: any) => void, addToScene = false): AssetContainer => {\r\n    const container = new AssetContainer(scene);\r\n\r\n    // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\r\n    // when SceneLoader.debugLogging = true (default), or exception encountered.\r\n    // Everything stored in var log instead of writing separate lines to support only writing in exception,\r\n    // and avoid problems with multiple concurrent .babylon loads.\r\n    let log = \"importScene has failed JSON parse\";\r\n    try {\r\n        // eslint-disable-next-line no-var\r\n        var parsedData = JSON.parse(data);\r\n        log = \"\";\r\n        const fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;\r\n\r\n        let index: number;\r\n        let cache: number;\r\n\r\n        // Environment texture\r\n        if (parsedData.environmentTexture !== undefined && parsedData.environmentTexture !== null) {\r\n            // PBR needed for both HDR texture (gamma space) & a sky box\r\n            const isPBR = parsedData.isPBR !== undefined ? parsedData.isPBR : true;\r\n            if (parsedData.environmentTextureType && parsedData.environmentTextureType === \"BABYLON.HDRCubeTexture\") {\r\n                const hdrSize: number = parsedData.environmentTextureSize ? parsedData.environmentTextureSize : 128;\r\n                const hdrTexture = new HDRCubeTexture(\r\n                    (parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture,\r\n                    scene,\r\n                    hdrSize,\r\n                    true,\r\n                    !isPBR,\r\n                    undefined,\r\n                    parsedData.environmentTexturePrefilterOnLoad\r\n                );\r\n                if (parsedData.environmentTextureRotationY) {\r\n                    hdrTexture.rotationY = parsedData.environmentTextureRotationY;\r\n                }\r\n                scene.environmentTexture = hdrTexture;\r\n            } else {\r\n                if (EndsWith(parsedData.environmentTexture, \".env\")) {\r\n                    const compressedTexture = new CubeTexture(\r\n                        (parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture,\r\n                        scene,\r\n                        parsedData.environmentTextureForcedExtension\r\n                    );\r\n                    if (parsedData.environmentTextureRotationY) {\r\n                        compressedTexture.rotationY = parsedData.environmentTextureRotationY;\r\n                    }\r\n                    scene.environmentTexture = compressedTexture;\r\n                } else {\r\n                    const cubeTexture = CubeTexture.CreateFromPrefilteredData(\r\n                        (parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture,\r\n                        scene\r\n                    );\r\n                    if (parsedData.environmentTextureRotationY) {\r\n                        cubeTexture.rotationY = parsedData.environmentTextureRotationY;\r\n                    }\r\n                    scene.environmentTexture = cubeTexture;\r\n                }\r\n            }\r\n            if (parsedData.createDefaultSkybox === true) {\r\n                const skyboxScale = scene.activeCamera !== undefined && scene.activeCamera !== null ? (scene.activeCamera.maxZ - scene.activeCamera.minZ) / 2 : 1000;\r\n                const skyboxBlurLevel = parsedData.skyboxBlurLevel || 0;\r\n                scene.createDefaultSkybox(scene.environmentTexture, isPBR, skyboxScale, skyboxBlurLevel);\r\n            }\r\n            container.environmentTexture = scene.environmentTexture;\r\n        }\r\n\r\n        // Environment Intensity\r\n        if (parsedData.environmentIntensity !== undefined && parsedData.environmentIntensity !== null) {\r\n            scene.environmentIntensity = parsedData.environmentIntensity;\r\n        }\r\n\r\n        // Lights\r\n        if (parsedData.lights !== undefined && parsedData.lights !== null) {\r\n            for (index = 0, cache = parsedData.lights.length; index < cache; index++) {\r\n                const parsedLight = parsedData.lights[index];\r\n                const light = Light.Parse(parsedLight, scene);\r\n                if (light) {\r\n                    tempIndexContainer[parsedLight.uniqueId] = light;\r\n                    container.lights.push(light);\r\n                    light._parentContainer = container;\r\n                    log += index === 0 ? \"\\n\\tLights:\" : \"\";\r\n                    log += \"\\n\\t\\t\" + light.toString(fullDetails);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Reflection probes\r\n        if (parsedData.reflectionProbes !== undefined && parsedData.reflectionProbes !== null) {\r\n            for (index = 0, cache = parsedData.reflectionProbes.length; index < cache; index++) {\r\n                const parsedReflectionProbe = parsedData.reflectionProbes[index];\r\n                const reflectionProbe = ReflectionProbe.Parse(parsedReflectionProbe, scene, rootUrl);\r\n                if (reflectionProbe) {\r\n                    container.reflectionProbes.push(reflectionProbe);\r\n                    reflectionProbe._parentContainer = container;\r\n                    log += index === 0 ? \"\\n\\tReflection Probes:\" : \"\";\r\n                    log += \"\\n\\t\\t\" + reflectionProbe.toString(fullDetails);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Animations\r\n        if (parsedData.animations !== undefined && parsedData.animations !== null) {\r\n            for (index = 0, cache = parsedData.animations.length; index < cache; index++) {\r\n                const parsedAnimation = parsedData.animations[index];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    const animation = internalClass.Parse(parsedAnimation);\r\n                    scene.animations.push(animation);\r\n                    container.animations.push(animation);\r\n                    log += index === 0 ? \"\\n\\tAnimations:\" : \"\";\r\n                    log += \"\\n\\t\\t\" + animation.toString(fullDetails);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Materials\r\n        if (parsedData.materials !== undefined && parsedData.materials !== null) {\r\n            for (index = 0, cache = parsedData.materials.length; index < cache; index++) {\r\n                const parsedMaterial = parsedData.materials[index];\r\n                const mat = Material.Parse(parsedMaterial, scene, rootUrl);\r\n                if (mat) {\r\n                    tempMaterialIndexContainer[parsedMaterial.uniqueId || parsedMaterial.id] = mat;\r\n                    container.materials.push(mat);\r\n                    mat._parentContainer = container;\r\n                    log += index === 0 ? \"\\n\\tMaterials:\" : \"\";\r\n                    log += \"\\n\\t\\t\" + mat.toString(fullDetails);\r\n\r\n                    // Textures\r\n                    const textures = mat.getActiveTextures();\r\n                    textures.forEach((t) => {\r\n                        if (container.textures.indexOf(t) == -1) {\r\n                            container.textures.push(t);\r\n                            t._parentContainer = container;\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        if (parsedData.multiMaterials !== undefined && parsedData.multiMaterials !== null) {\r\n            for (index = 0, cache = parsedData.multiMaterials.length; index < cache; index++) {\r\n                const parsedMultiMaterial = parsedData.multiMaterials[index];\r\n                const mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);\r\n                tempMaterialIndexContainer[parsedMultiMaterial.uniqueId || parsedMultiMaterial.id] = mmat;\r\n                container.multiMaterials.push(mmat);\r\n                mmat._parentContainer = container;\r\n\r\n                log += index === 0 ? \"\\n\\tMultiMaterials:\" : \"\";\r\n                log += \"\\n\\t\\t\" + mmat.toString(fullDetails);\r\n\r\n                // Textures\r\n                const textures = mmat.getActiveTextures();\r\n                textures.forEach((t) => {\r\n                    if (container.textures.indexOf(t) == -1) {\r\n                        container.textures.push(t);\r\n                        t._parentContainer = container;\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        // Morph targets\r\n        if (parsedData.morphTargetManagers !== undefined && parsedData.morphTargetManagers !== null) {\r\n            for (const managerData of parsedData.morphTargetManagers) {\r\n                const manager = MorphTargetManager.Parse(managerData, scene);\r\n                container.morphTargetManagers.push(manager);\r\n                manager._parentContainer = container;\r\n            }\r\n        }\r\n\r\n        // Skeletons\r\n        if (parsedData.skeletons !== undefined && parsedData.skeletons !== null) {\r\n            for (index = 0, cache = parsedData.skeletons.length; index < cache; index++) {\r\n                const parsedSkeleton = parsedData.skeletons[index];\r\n                const skeleton = Skeleton.Parse(parsedSkeleton, scene);\r\n                container.skeletons.push(skeleton);\r\n                skeleton._parentContainer = container;\r\n                log += index === 0 ? \"\\n\\tSkeletons:\" : \"\";\r\n                log += \"\\n\\t\\t\" + skeleton.toString(fullDetails);\r\n            }\r\n        }\r\n\r\n        // Geometries\r\n        const geometries = parsedData.geometries;\r\n        if (geometries !== undefined && geometries !== null) {\r\n            const addedGeometry = new Array<Nullable<Geometry>>();\r\n\r\n            // VertexData\r\n            const vertexData = geometries.vertexData;\r\n            if (vertexData !== undefined && vertexData !== null) {\r\n                for (index = 0, cache = vertexData.length; index < cache; index++) {\r\n                    const parsedVertexData = vertexData[index];\r\n                    addedGeometry.push(Geometry.Parse(parsedVertexData, scene, rootUrl));\r\n                }\r\n            }\r\n\r\n            addedGeometry.forEach((g) => {\r\n                if (g) {\r\n                    container.geometries.push(g);\r\n                    g._parentContainer = container;\r\n                }\r\n            });\r\n        }\r\n\r\n        // Transform nodes\r\n        if (parsedData.transformNodes !== undefined && parsedData.transformNodes !== null) {\r\n            for (index = 0, cache = parsedData.transformNodes.length; index < cache; index++) {\r\n                const parsedTransformNode = parsedData.transformNodes[index];\r\n                const node = TransformNode.Parse(parsedTransformNode, scene, rootUrl);\r\n                tempIndexContainer[parsedTransformNode.uniqueId] = node;\r\n                container.transformNodes.push(node);\r\n                node._parentContainer = container;\r\n            }\r\n        }\r\n\r\n        // Meshes\r\n        if (parsedData.meshes !== undefined && parsedData.meshes !== null) {\r\n            for (index = 0, cache = parsedData.meshes.length; index < cache; index++) {\r\n                const parsedMesh = parsedData.meshes[index];\r\n                const mesh = <AbstractMesh>Mesh.Parse(parsedMesh, scene, rootUrl);\r\n                tempIndexContainer[parsedMesh.uniqueId] = mesh;\r\n                container.meshes.push(mesh);\r\n                mesh._parentContainer = container;\r\n                if (mesh.hasInstances) {\r\n                    for (const instance of (mesh as Mesh).instances) {\r\n                        container.meshes.push(instance);\r\n                        instance._parentContainer = container;\r\n                    }\r\n                }\r\n                log += index === 0 ? \"\\n\\tMeshes:\" : \"\";\r\n                log += \"\\n\\t\\t\" + mesh.toString(fullDetails);\r\n            }\r\n        }\r\n\r\n        // Cameras\r\n        if (parsedData.cameras !== undefined && parsedData.cameras !== null) {\r\n            for (index = 0, cache = parsedData.cameras.length; index < cache; index++) {\r\n                const parsedCamera = parsedData.cameras[index];\r\n                const camera = Camera.Parse(parsedCamera, scene);\r\n                tempIndexContainer[parsedCamera.uniqueId] = camera;\r\n                container.cameras.push(camera);\r\n                camera._parentContainer = container;\r\n                log += index === 0 ? \"\\n\\tCameras:\" : \"\";\r\n                log += \"\\n\\t\\t\" + camera.toString(fullDetails);\r\n            }\r\n        }\r\n\r\n        // Postprocesses\r\n        if (parsedData.postProcesses !== undefined && parsedData.postProcesses !== null) {\r\n            for (index = 0, cache = parsedData.postProcesses.length; index < cache; index++) {\r\n                const parsedPostProcess = parsedData.postProcesses[index];\r\n                const postProcess = PostProcess.Parse(parsedPostProcess, scene, rootUrl);\r\n                if (postProcess) {\r\n                    container.postProcesses.push(postProcess);\r\n                    postProcess._parentContainer = container;\r\n                    log += index === 0 ? \"\\nPostprocesses:\" : \"\";\r\n                    log += \"\\n\\t\\t\" + postProcess.toString();\r\n                }\r\n            }\r\n        }\r\n\r\n        // Animation Groups\r\n        if (parsedData.animationGroups !== undefined && parsedData.animationGroups !== null) {\r\n            for (index = 0, cache = parsedData.animationGroups.length; index < cache; index++) {\r\n                const parsedAnimationGroup = parsedData.animationGroups[index];\r\n                const animationGroup = AnimationGroup.Parse(parsedAnimationGroup, scene);\r\n                container.animationGroups.push(animationGroup);\r\n                animationGroup._parentContainer = container;\r\n                log += index === 0 ? \"\\n\\tAnimationGroups:\" : \"\";\r\n                log += \"\\n\\t\\t\" + animationGroup.toString(fullDetails);\r\n            }\r\n        }\r\n\r\n        // Browsing all the graph to connect the dots\r\n        for (index = 0, cache = scene.cameras.length; index < cache; index++) {\r\n            const camera = scene.cameras[index];\r\n            if (camera._waitingParentId !== null) {\r\n                camera.parent = findParent(camera._waitingParentId, scene);\r\n                camera._waitingParentId = null;\r\n            }\r\n        }\r\n\r\n        for (index = 0, cache = scene.lights.length; index < cache; index++) {\r\n            const light = scene.lights[index];\r\n            if (light && light._waitingParentId !== null) {\r\n                light.parent = findParent(light._waitingParentId, scene);\r\n                light._waitingParentId = null;\r\n            }\r\n        }\r\n\r\n        // Connect parents & children and parse actions and lods\r\n        for (index = 0, cache = scene.transformNodes.length; index < cache; index++) {\r\n            const transformNode = scene.transformNodes[index];\r\n            if (transformNode._waitingParentId !== null) {\r\n                transformNode.parent = findParent(transformNode._waitingParentId, scene);\r\n                transformNode._waitingParentId = null;\r\n            }\r\n        }\r\n        for (index = 0, cache = scene.meshes.length; index < cache; index++) {\r\n            const mesh = scene.meshes[index];\r\n            if (mesh._waitingParentId !== null) {\r\n                mesh.parent = findParent(mesh._waitingParentId, scene);\r\n                mesh._waitingParentId = null;\r\n            }\r\n            if (mesh._waitingData.lods) {\r\n                loadDetailLevels(scene, mesh);\r\n            }\r\n        }\r\n\r\n        // link multimats with materials\r\n        scene.multiMaterials.forEach((multimat) => {\r\n            multimat._waitingSubMaterialsUniqueIds.forEach((subMaterial) => {\r\n                multimat.subMaterials.push(findMaterial(subMaterial, scene));\r\n            });\r\n            multimat._waitingSubMaterialsUniqueIds = [];\r\n        });\r\n\r\n        // link meshes with materials\r\n        scene.meshes.forEach((mesh) => {\r\n            if (mesh._waitingMaterialId !== null) {\r\n                mesh.material = findMaterial(mesh._waitingMaterialId, scene);\r\n                mesh._waitingMaterialId = null;\r\n            }\r\n        });\r\n\r\n        // link skeleton transform nodes\r\n        for (index = 0, cache = scene.skeletons.length; index < cache; index++) {\r\n            const skeleton = scene.skeletons[index];\r\n            if (skeleton._hasWaitingData) {\r\n                if (skeleton.bones != null) {\r\n                    skeleton.bones.forEach((bone) => {\r\n                        if (bone._waitingTransformNodeId) {\r\n                            const linkTransformNode = scene.getLastEntryById(bone._waitingTransformNodeId) as TransformNode;\r\n                            if (linkTransformNode) {\r\n                                bone.linkTransformNode(linkTransformNode);\r\n                            }\r\n                            bone._waitingTransformNodeId = null;\r\n                        }\r\n                    });\r\n                }\r\n\r\n                skeleton._hasWaitingData = null;\r\n            }\r\n        }\r\n\r\n        // freeze world matrix application\r\n        for (index = 0, cache = scene.meshes.length; index < cache; index++) {\r\n            const currentMesh = scene.meshes[index];\r\n            if (currentMesh._waitingData.freezeWorldMatrix) {\r\n                currentMesh.freezeWorldMatrix();\r\n                currentMesh._waitingData.freezeWorldMatrix = null;\r\n            } else {\r\n                currentMesh.computeWorldMatrix(true);\r\n            }\r\n        }\r\n\r\n        // Lights exclusions / inclusions\r\n        for (index = 0, cache = scene.lights.length; index < cache; index++) {\r\n            const light = scene.lights[index];\r\n            // Excluded check\r\n            if (light._excludedMeshesIds.length > 0) {\r\n                for (let excludedIndex = 0; excludedIndex < light._excludedMeshesIds.length; excludedIndex++) {\r\n                    const excludedMesh = scene.getMeshById(light._excludedMeshesIds[excludedIndex]);\r\n\r\n                    if (excludedMesh) {\r\n                        light.excludedMeshes.push(excludedMesh);\r\n                    }\r\n                }\r\n\r\n                light._excludedMeshesIds = [];\r\n            }\r\n\r\n            // Included check\r\n            if (light._includedOnlyMeshesIds.length > 0) {\r\n                for (let includedOnlyIndex = 0; includedOnlyIndex < light._includedOnlyMeshesIds.length; includedOnlyIndex++) {\r\n                    const includedOnlyMesh = scene.getMeshById(light._includedOnlyMeshesIds[includedOnlyIndex]);\r\n\r\n                    if (includedOnlyMesh) {\r\n                        light.includedOnlyMeshes.push(includedOnlyMesh);\r\n                    }\r\n                }\r\n\r\n                light._includedOnlyMeshesIds = [];\r\n            }\r\n        }\r\n\r\n        AbstractScene.Parse(parsedData, scene, container, rootUrl);\r\n\r\n        // Actions (scene) Done last as it can access other objects.\r\n        for (index = 0, cache = scene.meshes.length; index < cache; index++) {\r\n            const mesh = scene.meshes[index];\r\n            if (mesh._waitingData.actions) {\r\n                ActionManager.Parse(mesh._waitingData.actions, mesh, scene);\r\n                mesh._waitingData.actions = null;\r\n            }\r\n        }\r\n        if (parsedData.actions !== undefined && parsedData.actions !== null) {\r\n            ActionManager.Parse(parsedData.actions, null, scene);\r\n        }\r\n    } catch (err) {\r\n        const msg = logOperation(\"loadAssets\", parsedData ? parsedData.producer : \"Unknown\") + log;\r\n        if (onError) {\r\n            onError(msg, err);\r\n        } else {\r\n            Logger.Log(msg);\r\n            throw err;\r\n        }\r\n    } finally {\r\n        tempIndexContainer = {};\r\n\r\n        if (!addToScene) {\r\n            container.removeAllFromScene();\r\n        }\r\n        if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\r\n            Logger.Log(logOperation(\"loadAssets\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\r\n        }\r\n    }\r\n\r\n    return container;\r\n};\r\n\r\nSceneLoader.RegisterPlugin({\r\n    name: \"babylon.js\",\r\n    extensions: \".babylon\",\r\n    canDirectLoad: (data: string) => {\r\n        if (data.indexOf(\"babylon\") !== -1) {\r\n            // We consider that the producer string is filled\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    },\r\n    importMesh: (\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        data: any,\r\n        rootUrl: string,\r\n        meshes: AbstractMesh[],\r\n        particleSystems: IParticleSystem[],\r\n        skeletons: Skeleton[],\r\n        onError?: (message: string, exception?: any) => void\r\n    ): boolean => {\r\n        // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\r\n        // when SceneLoader.debugLogging = true (default), or exception encountered.\r\n        // Everything stored in var log instead of writing separate lines to support only writing in exception,\r\n        // and avoid problems with multiple concurrent .babylon loads.\r\n        let log = \"importMesh has failed JSON parse\";\r\n        try {\r\n            // eslint-disable-next-line no-var\r\n            var parsedData = JSON.parse(data);\r\n            log = \"\";\r\n            const fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;\r\n            if (!meshesNames) {\r\n                meshesNames = null;\r\n            } else if (!Array.isArray(meshesNames)) {\r\n                meshesNames = [meshesNames];\r\n            }\r\n\r\n            const hierarchyIds = new Array<number>();\r\n\r\n            // Transform nodes (the overall idea is to load all of them as this is super fast and then get rid of the ones we don't need)\r\n            const loadedTransformNodes = [];\r\n            if (parsedData.transformNodes !== undefined && parsedData.transformNodes !== null) {\r\n                for (let index = 0, cache = parsedData.transformNodes.length; index < cache; index++) {\r\n                    const parsedTransformNode = parsedData.transformNodes[index];\r\n                    loadedTransformNodes.push(TransformNode.Parse(parsedTransformNode, scene, rootUrl));\r\n                }\r\n            }\r\n\r\n            if (parsedData.meshes !== undefined && parsedData.meshes !== null) {\r\n                const loadedSkeletonsIds = [];\r\n                const loadedMaterialsIds: string[] = [];\r\n                const loadedMaterialsUniqueIds: string[] = [];\r\n                const loadedMorphTargetsIds = [];\r\n                for (let index = 0, cache = parsedData.meshes.length; index < cache; index++) {\r\n                    const parsedMesh = parsedData.meshes[index];\r\n\r\n                    if (meshesNames === null || isDescendantOf(parsedMesh, meshesNames, hierarchyIds)) {\r\n                        if (meshesNames !== null) {\r\n                            // Remove found mesh name from list.\r\n                            delete meshesNames[meshesNames.indexOf(parsedMesh.name)];\r\n                        }\r\n\r\n                        //Geometry?\r\n                        if (parsedMesh.geometryId !== undefined && parsedMesh.geometryId !== null) {\r\n                            //does the file contain geometries?\r\n                            if (parsedData.geometries !== undefined && parsedData.geometries !== null) {\r\n                                //find the correct geometry and add it to the scene\r\n                                let found: boolean = false;\r\n                                [\"boxes\", \"spheres\", \"cylinders\", \"toruses\", \"grounds\", \"planes\", \"torusKnots\", \"vertexData\"].forEach((geometryType: string) => {\r\n                                    if (found === true || !parsedData.geometries[geometryType] || !Array.isArray(parsedData.geometries[geometryType])) {\r\n                                        return;\r\n                                    } else {\r\n                                        parsedData.geometries[geometryType].forEach((parsedGeometryData: any) => {\r\n                                            if (parsedGeometryData.id === parsedMesh.geometryId) {\r\n                                                switch (geometryType) {\r\n                                                    case \"vertexData\":\r\n                                                        Geometry.Parse(parsedGeometryData, scene, rootUrl);\r\n                                                        break;\r\n                                                }\r\n                                                found = true;\r\n                                            }\r\n                                        });\r\n                                    }\r\n                                });\r\n                                if (found === false) {\r\n                                    Logger.Warn(\"Geometry not found for mesh \" + parsedMesh.id);\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // Material ?\r\n                        if (parsedMesh.materialUniqueId || parsedMesh.materialId) {\r\n                            // if we have a unique ID, look up and store in loadedMaterialsUniqueIds, else use loadedMaterialsIds\r\n                            const materialArray = parsedMesh.materialUniqueId ? loadedMaterialsUniqueIds : loadedMaterialsIds;\r\n                            let materialFound = materialArray.indexOf(parsedMesh.materialUniqueId || parsedMesh.materialId) !== -1;\r\n                            if (materialFound === false && parsedData.multiMaterials !== undefined && parsedData.multiMaterials !== null) {\r\n                                // Loads a submaterial of a multimaterial\r\n                                const loadSubMaterial = (subMatId: string, predicate: (parsedMaterial: any) => boolean) => {\r\n                                    materialArray.push(subMatId);\r\n                                    const mat = parseMaterialByPredicate(predicate, parsedData, scene, rootUrl);\r\n                                    if (mat && mat.material) {\r\n                                        tempMaterialIndexContainer[mat.parsedMaterial.uniqueId || mat.parsedMaterial.id] = mat.material;\r\n                                        log += \"\\n\\tMaterial \" + mat.material.toString(fullDetails);\r\n                                    }\r\n                                };\r\n                                for (let multimatIndex = 0, multimatCache = parsedData.multiMaterials.length; multimatIndex < multimatCache; multimatIndex++) {\r\n                                    const parsedMultiMaterial = parsedData.multiMaterials[multimatIndex];\r\n                                    if (\r\n                                        (parsedMesh.materialUniqueId && parsedMultiMaterial.uniqueId === parsedMesh.materialUniqueId) ||\r\n                                        parsedMultiMaterial.id === parsedMesh.materialId\r\n                                    ) {\r\n                                        if (parsedMultiMaterial.materialsUniqueIds) {\r\n                                            // if the materials inside the multimat are stored by unique id\r\n                                            parsedMultiMaterial.materialsUniqueIds.forEach((subMatId: string) =>\r\n                                                loadSubMaterial(subMatId, (parsedMaterial) => parsedMaterial.uniqueId === subMatId)\r\n                                            );\r\n                                        } else {\r\n                                            // if the mats are stored by id instead\r\n                                            parsedMultiMaterial.materials.forEach((subMatId: string) =>\r\n                                                loadSubMaterial(subMatId, (parsedMaterial) => parsedMaterial.id === subMatId)\r\n                                            );\r\n                                        }\r\n                                        materialArray.push(parsedMultiMaterial.uniqueId || parsedMultiMaterial.id);\r\n                                        const mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);\r\n                                        tempMaterialIndexContainer[parsedMultiMaterial.uniqueId || parsedMultiMaterial.id] = mmat;\r\n                                        if (mmat) {\r\n                                            materialFound = true;\r\n                                            log += \"\\n\\tMulti-Material \" + mmat.toString(fullDetails);\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            if (materialFound === false) {\r\n                                materialArray.push(parsedMesh.materialUniqueId || parsedMesh.materialId);\r\n                                const mat = parseMaterialByPredicate(\r\n                                    (parsedMaterial) =>\r\n                                        (parsedMesh.materialUniqueId && parsedMaterial.uniqueId === parsedMesh.materialUniqueId) || parsedMaterial.id === parsedMesh.materialId,\r\n                                    parsedData,\r\n                                    scene,\r\n                                    rootUrl\r\n                                );\r\n                                if (!mat || !mat.material) {\r\n                                    Logger.Warn(\"Material not found for mesh \" + parsedMesh.id);\r\n                                } else {\r\n                                    tempMaterialIndexContainer[mat.parsedMaterial.uniqueId || mat.parsedMaterial.id] = mat.material;\r\n                                    log += \"\\n\\tMaterial \" + mat.material.toString(fullDetails);\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // Skeleton ?\r\n                        if (parsedMesh.skeletonId > -1 && parsedData.skeletons !== undefined && parsedData.skeletons !== null) {\r\n                            const skeletonAlreadyLoaded = loadedSkeletonsIds.indexOf(parsedMesh.skeletonId) > -1;\r\n                            if (!skeletonAlreadyLoaded) {\r\n                                for (let skeletonIndex = 0, skeletonCache = parsedData.skeletons.length; skeletonIndex < skeletonCache; skeletonIndex++) {\r\n                                    const parsedSkeleton = parsedData.skeletons[skeletonIndex];\r\n                                    if (parsedSkeleton.id === parsedMesh.skeletonId) {\r\n                                        const skeleton = Skeleton.Parse(parsedSkeleton, scene);\r\n                                        skeletons.push(skeleton);\r\n                                        loadedSkeletonsIds.push(parsedSkeleton.id);\r\n                                        log += \"\\n\\tSkeleton \" + skeleton.toString(fullDetails);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // Morph targets ?\r\n                        if (parsedMesh.morphTargetManagerId > -1 && parsedData.morphTargetManagers !== undefined && parsedData.morphTargetManagers !== null) {\r\n                            const morphTargetAlreadyLoaded = loadedMorphTargetsIds.indexOf(parsedMesh.morphTargetManagerId) > -1;\r\n                            if (!morphTargetAlreadyLoaded) {\r\n                                for (let morphTargetIndex = 0, morphTargetCache = parsedData.morphTargetManagers.length; morphTargetIndex < morphTargetCache; morphTargetIndex++) {\r\n                                    const parsedMorphTarget = parsedData.morphTargetManagers[morphTargetIndex];\r\n                                    if (parsedMorphTarget.id === parsedMesh.morphTargetManagerId) {\r\n                                        const morphTarget = MorphTargetManager.Parse(parsedMorphTarget, scene);\r\n                                        loadedMorphTargetsIds.push(morphTarget.uniqueId);\r\n                                        log += \"\\nMorph target \" + morphTarget.toString();\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        const mesh = Mesh.Parse(parsedMesh, scene, rootUrl);\r\n                        meshes.push(mesh);\r\n                        log += \"\\n\\tMesh \" + mesh.toString(fullDetails);\r\n                    }\r\n                }\r\n\r\n                // link multimats with materials\r\n                scene.multiMaterials.forEach((multimat) => {\r\n                    multimat._waitingSubMaterialsUniqueIds.forEach((subMaterial) => {\r\n                        multimat.subMaterials.push(findMaterial(subMaterial, scene));\r\n                    });\r\n                    multimat._waitingSubMaterialsUniqueIds = [];\r\n                });\r\n\r\n                // link meshes with materials\r\n                scene.meshes.forEach((mesh) => {\r\n                    if (mesh._waitingMaterialId !== null) {\r\n                        mesh.material = findMaterial(mesh._waitingMaterialId, scene);\r\n                        mesh._waitingMaterialId = null;\r\n                    }\r\n                });\r\n\r\n                // Connecting parents and lods\r\n                for (let index = 0, cache = scene.transformNodes.length; index < cache; index++) {\r\n                    const transformNode = scene.transformNodes[index];\r\n                    if (transformNode._waitingParentId !== null) {\r\n                        transformNode.parent = scene.getLastEntryById(transformNode._waitingParentId);\r\n                        transformNode._waitingParentId = null;\r\n                    }\r\n                }\r\n                let currentMesh: AbstractMesh;\r\n                for (let index = 0, cache = scene.meshes.length; index < cache; index++) {\r\n                    currentMesh = scene.meshes[index];\r\n                    if (currentMesh._waitingParentId) {\r\n                        currentMesh.parent = scene.getLastEntryById(currentMesh._waitingParentId);\r\n                        if (currentMesh.parent?.getClassName() === \"TransformNode\") {\r\n                            const loadedTransformNodeIndex = loadedTransformNodes.indexOf(currentMesh.parent as TransformNode);\r\n                            if (loadedTransformNodeIndex > -1) {\r\n                                loadedTransformNodes.splice(loadedTransformNodeIndex, 1);\r\n                            }\r\n                        }\r\n                        currentMesh._waitingParentId = null;\r\n                    }\r\n                    if (currentMesh._waitingData.lods) {\r\n                        loadDetailLevels(scene, currentMesh);\r\n                    }\r\n                }\r\n\r\n                // Remove unused transform nodes\r\n                for (const transformNode of loadedTransformNodes) {\r\n                    transformNode.dispose();\r\n                }\r\n\r\n                // link skeleton transform nodes\r\n                for (let index = 0, cache = scene.skeletons.length; index < cache; index++) {\r\n                    const skeleton = scene.skeletons[index];\r\n                    if (skeleton._hasWaitingData) {\r\n                        if (skeleton.bones != null) {\r\n                            skeleton.bones.forEach((bone) => {\r\n                                if (bone._waitingTransformNodeId) {\r\n                                    const linkTransformNode = scene.getLastEntryById(bone._waitingTransformNodeId) as TransformNode;\r\n                                    if (linkTransformNode) {\r\n                                        bone.linkTransformNode(linkTransformNode);\r\n                                    }\r\n                                    bone._waitingTransformNodeId = null;\r\n                                }\r\n                            });\r\n                        }\r\n\r\n                        skeleton._hasWaitingData = null;\r\n                    }\r\n                }\r\n\r\n                // freeze and compute world matrix application\r\n                for (let index = 0, cache = scene.meshes.length; index < cache; index++) {\r\n                    currentMesh = scene.meshes[index];\r\n                    if (currentMesh._waitingData.freezeWorldMatrix) {\r\n                        currentMesh.freezeWorldMatrix();\r\n                        currentMesh._waitingData.freezeWorldMatrix = null;\r\n                    } else {\r\n                        currentMesh.computeWorldMatrix(true);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Particles\r\n            if (parsedData.particleSystems !== undefined && parsedData.particleSystems !== null) {\r\n                const parser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);\r\n                if (parser) {\r\n                    for (let index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {\r\n                        const parsedParticleSystem = parsedData.particleSystems[index];\r\n                        if (hierarchyIds.indexOf(parsedParticleSystem.emitterId) !== -1) {\r\n                            particleSystems.push(parser(parsedParticleSystem, scene, rootUrl));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        } catch (err) {\r\n            const msg = logOperation(\"importMesh\", parsedData ? parsedData.producer : \"Unknown\") + log;\r\n            if (onError) {\r\n                onError(msg, err);\r\n            } else {\r\n                Logger.Log(msg);\r\n                throw err;\r\n            }\r\n        } finally {\r\n            if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\r\n                Logger.Log(logOperation(\"importMesh\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n    load: (scene: Scene, data: string, rootUrl: string, onError?: (message: string, exception?: any) => void): boolean => {\r\n        // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\r\n        // when SceneLoader.debugLogging = true (default), or exception encountered.\r\n        // Everything stored in var log instead of writing separate lines to support only writing in exception,\r\n        // and avoid problems with multiple concurrent .babylon loads.\r\n        let log = \"importScene has failed JSON parse\";\r\n        try {\r\n            // eslint-disable-next-line no-var\r\n            var parsedData = JSON.parse(data);\r\n            log = \"\";\r\n\r\n            // Scene\r\n            if (parsedData.useDelayedTextureLoading !== undefined && parsedData.useDelayedTextureLoading !== null) {\r\n                scene.useDelayedTextureLoading = parsedData.useDelayedTextureLoading && !SceneLoader.ForceFullSceneLoadingForIncremental;\r\n            }\r\n            if (parsedData.autoClear !== undefined && parsedData.autoClear !== null) {\r\n                scene.autoClear = parsedData.autoClear;\r\n            }\r\n            if (parsedData.clearColor !== undefined && parsedData.clearColor !== null) {\r\n                scene.clearColor = Color4.FromArray(parsedData.clearColor);\r\n            }\r\n            if (parsedData.ambientColor !== undefined && parsedData.ambientColor !== null) {\r\n                scene.ambientColor = Color3.FromArray(parsedData.ambientColor);\r\n            }\r\n            if (parsedData.gravity !== undefined && parsedData.gravity !== null) {\r\n                scene.gravity = Vector3.FromArray(parsedData.gravity);\r\n            }\r\n\r\n            if (parsedData.useRightHandedSystem !== undefined) {\r\n                scene.useRightHandedSystem = !!parsedData.useRightHandedSystem;\r\n            }\r\n\r\n            // Fog\r\n            if (parsedData.fogMode && parsedData.fogMode !== 0) {\r\n                scene.fogMode = parsedData.fogMode;\r\n                scene.fogColor = Color3.FromArray(parsedData.fogColor);\r\n                scene.fogStart = parsedData.fogStart;\r\n                scene.fogEnd = parsedData.fogEnd;\r\n                scene.fogDensity = parsedData.fogDensity;\r\n                log += \"\\tFog mode for scene:  \";\r\n                switch (scene.fogMode) {\r\n                    // getters not compiling, so using hardcoded\r\n                    case 1:\r\n                        log += \"exp\\n\";\r\n                        break;\r\n                    case 2:\r\n                        log += \"exp2\\n\";\r\n                        break;\r\n                    case 3:\r\n                        log += \"linear\\n\";\r\n                        break;\r\n                }\r\n            }\r\n\r\n            //Physics\r\n            if (parsedData.physicsEnabled) {\r\n                let physicsPlugin;\r\n                if (parsedData.physicsEngine === \"cannon\") {\r\n                    physicsPlugin = new CannonJSPlugin(undefined, undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);\r\n                } else if (parsedData.physicsEngine === \"oimo\") {\r\n                    physicsPlugin = new OimoJSPlugin(undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);\r\n                } else if (parsedData.physicsEngine === \"ammo\") {\r\n                    physicsPlugin = new AmmoJSPlugin(undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine, undefined);\r\n                }\r\n                log = \"\\tPhysics engine \" + (parsedData.physicsEngine ? parsedData.physicsEngine : \"oimo\") + \" enabled\\n\";\r\n                //else - default engine, which is currently oimo\r\n                const physicsGravity = parsedData.physicsGravity ? Vector3.FromArray(parsedData.physicsGravity) : null;\r\n                scene.enablePhysics(physicsGravity, physicsPlugin);\r\n            }\r\n\r\n            // Metadata\r\n            if (parsedData.metadata !== undefined && parsedData.metadata !== null) {\r\n                scene.metadata = parsedData.metadata;\r\n            }\r\n\r\n            //collisions, if defined. otherwise, default is true\r\n            if (parsedData.collisionsEnabled !== undefined && parsedData.collisionsEnabled !== null) {\r\n                scene.collisionsEnabled = parsedData.collisionsEnabled;\r\n            }\r\n\r\n            const container = loadAssetContainer(scene, data, rootUrl, onError, true);\r\n            if (!container) {\r\n                return false;\r\n            }\r\n\r\n            if (parsedData.autoAnimate) {\r\n                scene.beginAnimation(scene, parsedData.autoAnimateFrom, parsedData.autoAnimateTo, parsedData.autoAnimateLoop, parsedData.autoAnimateSpeed || 1.0);\r\n            }\r\n\r\n            if (parsedData.activeCameraID !== undefined && parsedData.activeCameraID !== null) {\r\n                scene.setActiveCameraById(parsedData.activeCameraID);\r\n            }\r\n\r\n            // Finish\r\n            return true;\r\n        } catch (err) {\r\n            const msg = logOperation(\"importScene\", parsedData ? parsedData.producer : \"Unknown\") + log;\r\n            if (onError) {\r\n                onError(msg, err);\r\n            } else {\r\n                Logger.Log(msg);\r\n                throw err;\r\n            }\r\n        } finally {\r\n            if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\r\n                Logger.Log(logOperation(\"importScene\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n    loadAssetContainer: (scene: Scene, data: string, rootUrl: string, onError?: (message: string, exception?: any) => void): AssetContainer => {\r\n        const container = loadAssetContainer(scene, data, rootUrl, onError);\r\n        return container;\r\n    },\r\n});\r\n"]},"metadata":{},"sourceType":"module"}