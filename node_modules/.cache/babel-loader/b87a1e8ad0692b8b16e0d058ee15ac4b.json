{"ast":null,"code":"import \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport { __extends } from \"tslib\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Quaternion, Matrix, Vector3, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { TransformNode } from \"../Meshes/transformNode.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { BoundingInfo } from \"../Culling/boundingInfo.js\";\nimport { UniformBuffer } from \"../Materials/uniformBuffer.js\";\nimport { _MeshCollisionData } from \"../Collisions/meshCollisionData.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { extractMinAndMax } from \"../Maths/math.functions.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\nimport { Axis } from \"../Maths/math.axis.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\n/** @hidden */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\nvar _FacetDataStorage =\n/** @class */\nfunction () {\n  function _FacetDataStorage() {\n    this.facetNb = 0; // facet number\n\n    this.partitioningSubdivisions = 10; // number of subdivisions per axis in the partitioning space\n\n    this.partitioningBBoxRatio = 1.01; // the partitioning array space is by default 1% bigger than the bounding box\n\n    this.facetDataEnabled = false; // is the facet data feature enabled on this mesh ?\n\n    this.facetParameters = {}; // keep a reference to the object parameters to avoid memory re-allocation\n\n    this.bbSize = Vector3.Zero(); // bbox size approximated for facet data\n\n    this.subDiv = {\n      // actual number of subdivisions per axis for ComputeNormals()\n      max: 1,\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      X: 1,\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      Y: 1,\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      Z: 1\n    };\n    this.facetDepthSort = false; // is the facet depth sort to be computed\n\n    this.facetDepthSortEnabled = false; // is the facet depth sort initialized\n  }\n\n  return _FacetDataStorage;\n}();\n/**\n * @hidden\n **/\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\n\nvar _InternalAbstractMeshDataInfo =\n/** @class */\nfunction () {\n  function _InternalAbstractMeshDataInfo() {\n    this._hasVertexAlpha = false;\n    this._useVertexColors = true;\n    this._numBoneInfluencers = 4;\n    this._applyFog = true;\n    this._receiveShadows = false;\n    this._facetData = new _FacetDataStorage();\n    this._visibility = 1.0;\n    this._skeleton = null;\n    this._layerMask = 0x0fffffff;\n    this._computeBonesUsingShaders = true;\n    this._isActive = false;\n    this._onlyForInstances = false;\n    this._isActiveIntermediate = false;\n    this._onlyForInstancesIntermediate = false;\n    this._actAsRegularMesh = false;\n    this._currentLOD = null;\n    this._currentLODIsUpToDate = false;\n    this._collisionRetryCount = 3;\n    this._morphTargetManager = null;\n    this._renderingGroupId = 0;\n    this._bakedVertexAnimationManager = null;\n    this._material = null;\n    this._positions = null; // Collisions\n\n    this._meshCollisionData = new _MeshCollisionData();\n    this._enableDistantPicking = false;\n  }\n\n  return _InternalAbstractMeshDataInfo;\n}();\n/**\n * Class used to store all common mesh properties\n */\n\n\nvar AbstractMesh =\n/** @class */\nfunction (_super) {\n  __extends(AbstractMesh, _super); // Constructor\n\n  /**\n   * Creates a new AbstractMesh\n   * @param name defines the name of the mesh\n   * @param scene defines the hosting scene\n   */\n\n\n  function AbstractMesh(name, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var _this = _super.call(this, name, scene, false) || this; // Internal data\n\n    /** @hidden */\n\n\n    _this._internalAbstractMeshDataInfo = new _InternalAbstractMeshDataInfo();\n    /** @hidden */\n\n    _this._waitingMaterialId = null;\n    /**\n     * The culling strategy to use to check whether the mesh must be rendered or not.\n     * This value can be changed at any time and will be used on the next render mesh selection.\n     * The possible values are :\n     * - AbstractMesh.CULLINGSTRATEGY_STANDARD\n     * - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\n     * Please read each static variable documentation to get details about the culling process.\n     * */\n\n    _this.cullingStrategy = AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY; // Events\n\n    /**\n     * An event triggered when this mesh collides with another one\n     */\n\n    _this.onCollideObservable = new Observable();\n    /**\n     * An event triggered when the collision's position changes\n     */\n\n    _this.onCollisionPositionChangeObservable = new Observable();\n    /**\n     * An event triggered when material is changed\n     */\n\n    _this.onMaterialChangedObservable = new Observable(); // Properties\n\n    /**\n     * Gets or sets the orientation for POV movement & rotation\n     */\n\n    _this.definedFacingForward = true;\n    /** @hidden */\n\n    _this._occlusionQuery = null;\n    /** @hidden */\n\n    _this._renderingGroup = null;\n    /** Gets or sets the alpha index used to sort transparent meshes\n     * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#alpha-index\n     */\n\n    _this.alphaIndex = Number.MAX_VALUE;\n    /**\n     * Gets or sets a boolean indicating if the mesh is visible (renderable). Default is true\n     */\n\n    _this.isVisible = true;\n    /**\n     * Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true\n     */\n\n    _this.isPickable = true;\n    /**\n     * Gets or sets a boolean indicating if the mesh can be near picked. Default is false\n     */\n\n    _this.isNearPickable = false;\n    /**\n     * Gets or sets a boolean indicating if the mesh can be near grabbed. Default is false\n     */\n\n    _this.isNearGrabbable = false;\n    /** Gets or sets a boolean indicating that bounding boxes of subMeshes must be rendered as well (false by default) */\n\n    _this.showSubMeshesBoundingBox = false;\n    /** Gets or sets a boolean indicating if the mesh must be considered as a ray blocker for lens flares (false by default)\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares\n     */\n\n    _this.isBlocker = false;\n    /**\n     * Gets or sets a boolean indicating that pointer move events must be supported on this mesh (false by default)\n     */\n\n    _this.enablePointerMoveEvents = false;\n    /** Defines color to use when rendering outline */\n\n    _this.outlineColor = Color3.Red();\n    /** Define width to use when rendering outline */\n\n    _this.outlineWidth = 0.02;\n    /** Defines color to use when rendering overlay */\n\n    _this.overlayColor = Color3.Red();\n    /** Defines alpha to use when rendering overlay */\n\n    _this.overlayAlpha = 0.5;\n    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes selection (true by default) */\n\n    _this.useOctreeForRenderingSelection = true;\n    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes picking (true by default) */\n\n    _this.useOctreeForPicking = true;\n    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes collision (true by default) */\n\n    _this.useOctreeForCollisions = true;\n    /**\n     * True if the mesh must be rendered in any case (this will shortcut the frustum clipping phase)\n     */\n\n    _this.alwaysSelectAsActiveMesh = false;\n    /**\n     * Gets or sets a boolean indicating that the bounding info does not need to be kept in sync (for performance reason)\n     */\n\n    _this.doNotSyncBoundingInfo = false;\n    /**\n     * Gets or sets the current action manager\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions\n     */\n\n    _this.actionManager = null;\n    /**\n     * Gets or sets the ellipsoid used to impersonate this mesh when using collision engine (default is (0.5, 1, 0.5))\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\n     */\n\n    _this.ellipsoid = new Vector3(0.5, 1, 0.5);\n    /**\n     * Gets or sets the ellipsoid offset used to impersonate this mesh when using collision engine (default is (0, 0, 0))\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\n     */\n\n    _this.ellipsoidOffset = new Vector3(0, 0, 0); // Edges\n\n    /**\n     * Defines edge width used when edgesRenderer is enabled\n     * @see https://www.babylonjs-playground.com/#10OJSG#13\n     */\n\n    _this.edgesWidth = 1;\n    /**\n     * Defines edge color used when edgesRenderer is enabled\n     * @see https://www.babylonjs-playground.com/#10OJSG#13\n     */\n\n    _this.edgesColor = new Color4(1, 0, 0, 1);\n    /** @hidden */\n\n    _this._edgesRenderer = null;\n    /** @hidden */\n\n    _this._masterMesh = null;\n    _this._boundingInfo = null;\n    _this._boundingInfoIsDirty = true;\n    /** @hidden */\n\n    _this._renderId = 0;\n    /** @hidden */\n\n    _this._intersectionsInProgress = new Array();\n    /** @hidden */\n\n    _this._unIndexed = false;\n    /** @hidden */\n\n    _this._lightSources = new Array(); // Loading properties\n\n    /** @hidden */\n\n    _this._waitingData = {\n      lods: null,\n      actions: null,\n      freezeWorldMatrix: null\n    };\n    /** @hidden */\n\n    _this._bonesTransformMatrices = null;\n    /** @hidden */\n\n    _this._transformMatrixTexture = null;\n    /**\n     * An event triggered when the mesh is rebuilt.\n     */\n\n    _this.onRebuildObservable = new Observable();\n\n    _this._onCollisionPositionChange = function (collisionId, newPosition, collidedMesh) {\n      if (collidedMesh === void 0) {\n        collidedMesh = null;\n      }\n\n      newPosition.subtractToRef(_this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, _this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions);\n\n      if (_this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length() > Engine.CollisionsEpsilon) {\n        _this.position.addInPlace(_this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions);\n      }\n\n      if (collidedMesh) {\n        _this.onCollideObservable.notifyObservers(collidedMesh);\n      }\n\n      _this.onCollisionPositionChangeObservable.notifyObservers(_this.position);\n    };\n\n    _this.getScene().addMesh(_this);\n\n    _this._resyncLightSources(); // Mesh Uniform Buffer.\n\n\n    _this._uniformBuffer = new UniformBuffer(_this.getScene().getEngine(), undefined, undefined, name, !_this.getScene().getEngine().isWebGPU);\n\n    _this._buildUniformLayout();\n\n    return _this;\n  }\n\n  Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_NONE\", {\n    /**\n     * No billboard\n     */\n    get: function get() {\n      return TransformNode.BILLBOARDMODE_NONE;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_X\", {\n    /** Billboard on X axis */\n    get: function get() {\n      return TransformNode.BILLBOARDMODE_X;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_Y\", {\n    /** Billboard on Y axis */\n    get: function get() {\n      return TransformNode.BILLBOARDMODE_Y;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_Z\", {\n    /** Billboard on Z axis */\n    get: function get() {\n      return TransformNode.BILLBOARDMODE_Z;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_ALL\", {\n    /** Billboard on all axes */\n    get: function get() {\n      return TransformNode.BILLBOARDMODE_ALL;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_USE_POSITION\", {\n    /** Billboard on using position instead of orientation */\n    get: function get() {\n      return TransformNode.BILLBOARDMODE_USE_POSITION;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"facetNb\", {\n    /**\n     * Gets the number of facets in the mesh\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#what-is-a-mesh-facet\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._facetData.facetNb;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"partitioningSubdivisions\", {\n    /**\n     * Gets or set the number (integer) of subdivisions per axis in the partitioning space\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#tweaking-the-partitioning\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions;\n    },\n    set: function set(nb) {\n      this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions = nb;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"partitioningBBoxRatio\", {\n    /**\n     * The ratio (float) to apply to the bounding box size to set to the partitioning space.\n     * Ex : 1.01 (default) the partitioning space is 1% bigger than the bounding box\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#tweaking-the-partitioning\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio;\n    },\n    set: function set(ratio) {\n      this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio = ratio;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"mustDepthSortFacets\", {\n    /**\n     * Gets or sets a boolean indicating that the facets must be depth sorted on next call to `updateFacetData()`.\n     * Works only for updatable meshes.\n     * Doesn't work with multi-materials\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#facet-depth-sort\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._facetData.facetDepthSort;\n    },\n    set: function set(sort) {\n      this._internalAbstractMeshDataInfo._facetData.facetDepthSort = sort;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"facetDepthSortFrom\", {\n    /**\n     * The location (Vector3) where the facet depth sort must be computed from.\n     * By default, the active camera position.\n     * Used only when facet depth sort is enabled\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#facet-depth-sort\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom;\n    },\n    set: function set(location) {\n      this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom = location;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"collisionRetryCount\", {\n    /** number of collision detection tries. Change this value if not all collisions are detected and handled properly */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._collisionRetryCount;\n    },\n    set: function set(retryCount) {\n      this._internalAbstractMeshDataInfo._collisionRetryCount = retryCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"isFacetDataEnabled\", {\n    /**\n     * gets a boolean indicating if facetData is enabled\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#what-is-a-mesh-facet\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"morphTargetManager\", {\n    /**\n     * Gets or sets the morph target manager\n     * @see https://doc.babylonjs.com/how_to/how_to_use_morphtargets\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._morphTargetManager;\n    },\n    set: function set(value) {\n      if (this._internalAbstractMeshDataInfo._morphTargetManager === value) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._morphTargetManager = value;\n\n      this._syncGeometryWithMorphTargetManager();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"bakedVertexAnimationManager\", {\n    /**\n     * Gets or sets the baked vertex animation manager\n     * @see https://doc.babylonjs.com/divingDeeper/animation/baked_texture_animations\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager;\n    },\n    set: function set(value) {\n      if (this._internalAbstractMeshDataInfo._bakedVertexAnimationManager === value) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._bakedVertexAnimationManager = value;\n\n      this._markSubMeshesAsAttributesDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  AbstractMesh.prototype._syncGeometryWithMorphTargetManager = function () {};\n  /**\n   * @param value\n   * @hidden\n   */\n\n\n  AbstractMesh.prototype._updateNonUniformScalingState = function (value) {\n    if (!_super.prototype._updateNonUniformScalingState.call(this, value)) {\n      return false;\n    }\n\n    this._markSubMeshesAsMiscDirty();\n\n    return true;\n  };\n\n  Object.defineProperty(AbstractMesh.prototype, \"onCollide\", {\n    /** Set a function to call when this mesh collides with another one */\n    set: function set(callback) {\n      if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver) {\n        this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver);\n      }\n\n      this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver = this.onCollideObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"onCollisionPositionChange\", {\n    /** Set a function to call when the collision's position changes */\n    set: function set(callback) {\n      if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver) {\n        this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver);\n      }\n\n      this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"visibility\", {\n    /**\n     * Gets or sets mesh visibility between 0 and 1 (default is 1)\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._visibility;\n    },\n\n    /**\n     * Gets or sets mesh visibility between 0 and 1 (default is 1)\n     */\n    set: function set(value) {\n      if (this._internalAbstractMeshDataInfo._visibility === value) {\n        return;\n      }\n\n      var oldValue = this._internalAbstractMeshDataInfo._visibility;\n      this._internalAbstractMeshDataInfo._visibility = value;\n\n      if (oldValue === 1 && value !== 1 || oldValue !== 1 && value === 1) {\n        this._markSubMeshesAsMiscDirty();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"renderingGroupId\", {\n    /**\n     * Specifies the rendering group id for this mesh (0 by default)\n     * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#rendering-groups\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._renderingGroupId;\n    },\n    set: function set(value) {\n      this._internalAbstractMeshDataInfo._renderingGroupId = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"material\", {\n    /** Gets or sets current material */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._material;\n    },\n    set: function set(value) {\n      if (this._internalAbstractMeshDataInfo._material === value) {\n        return;\n      } // remove from material mesh map id needed\n\n\n      if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {\n        this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = undefined;\n      }\n\n      this._internalAbstractMeshDataInfo._material = value;\n\n      if (value && value.meshMap) {\n        value.meshMap[this.uniqueId] = this;\n      }\n\n      if (this.onMaterialChangedObservable.hasObservers()) {\n        this.onMaterialChangedObservable.notifyObservers(this);\n      }\n\n      if (!this.subMeshes) {\n        return;\n      }\n\n      this.resetDrawCache();\n\n      this._unBindEffect();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets the material used to render the mesh in a specific render pass\n   * @param renderPassId render pass id\n   * @returns material used for the render pass. If no specific material is used for this render pass, undefined is returned (meaning mesh.material is used for this pass)\n   */\n\n  AbstractMesh.prototype.getMaterialForRenderPass = function (renderPassId) {\n    var _a;\n\n    return (_a = this._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[renderPassId];\n  };\n  /**\n   * Sets the material to be used to render the mesh in a specific render pass\n   * @param renderPassId render pass id\n   * @param material material to use for this render pass. If undefined is passed, no specific material will be used for this render pass but the regular material will be used instead (mesh.material)\n   */\n\n\n  AbstractMesh.prototype.setMaterialForRenderPass = function (renderPassId, material) {\n    if (!this._internalAbstractMeshDataInfo._materialForRenderPass) {\n      this._internalAbstractMeshDataInfo._materialForRenderPass = [];\n    }\n\n    this._internalAbstractMeshDataInfo._materialForRenderPass[renderPassId] = material;\n  };\n\n  Object.defineProperty(AbstractMesh.prototype, \"receiveShadows\", {\n    /**\n     * Gets or sets a boolean indicating that this mesh can receive realtime shadows\n     * @see https://doc.babylonjs.com/babylon101/shadows\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._receiveShadows;\n    },\n    set: function set(value) {\n      if (this._internalAbstractMeshDataInfo._receiveShadows === value) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._receiveShadows = value;\n\n      this._markSubMeshesAsLightDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"hasVertexAlpha\", {\n    /** Gets or sets a boolean indicating that this mesh contains vertex color data with alpha values */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._hasVertexAlpha;\n    },\n    set: function set(value) {\n      if (this._internalAbstractMeshDataInfo._hasVertexAlpha === value) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._hasVertexAlpha = value;\n\n      this._markSubMeshesAsAttributesDirty();\n\n      this._markSubMeshesAsMiscDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"useVertexColors\", {\n    /** Gets or sets a boolean indicating that this mesh needs to use vertex color data to render (if this kind of vertex data is available in the geometry) */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._useVertexColors;\n    },\n    set: function set(value) {\n      if (this._internalAbstractMeshDataInfo._useVertexColors === value) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._useVertexColors = value;\n\n      this._markSubMeshesAsAttributesDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"computeBonesUsingShaders\", {\n    /**\n     * Gets or sets a boolean indicating that bone animations must be computed by the CPU (false by default)\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;\n    },\n    set: function set(value) {\n      if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;\n\n      this._markSubMeshesAsAttributesDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"numBoneInfluencers\", {\n    /** Gets or sets the number of allowed bone influences per vertex (4 by default) */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._numBoneInfluencers;\n    },\n    set: function set(value) {\n      if (this._internalAbstractMeshDataInfo._numBoneInfluencers === value) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._numBoneInfluencers = value;\n\n      this._markSubMeshesAsAttributesDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"applyFog\", {\n    /** Gets or sets a boolean indicating that this mesh will allow fog to be rendered on it (true by default) */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._applyFog;\n    },\n    set: function set(value) {\n      if (this._internalAbstractMeshDataInfo._applyFog === value) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._applyFog = value;\n\n      this._markSubMeshesAsMiscDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"enableDistantPicking\", {\n    /** When enabled, decompose picking matrices for better precision with large values for mesh position and scling */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._enableDistantPicking;\n    },\n    set: function set(value) {\n      this._internalAbstractMeshDataInfo._enableDistantPicking = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"layerMask\", {\n    /**\n     * Gets or sets the current layer mask (default is 0x0FFFFFFF)\n     * @see https://doc.babylonjs.com/divingDeeper/cameras/layerMasksAndMultiCam\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._layerMask;\n    },\n    set: function set(value) {\n      if (value === this._internalAbstractMeshDataInfo._layerMask) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._layerMask = value;\n\n      this._resyncLightSources();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"collisionMask\", {\n    /**\n     * Gets or sets a collision mask used to mask collisions (default is -1).\n     * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask;\n    },\n    set: function set(mask) {\n      this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask = !isNaN(mask) ? mask : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"collisionResponse\", {\n    /**\n     * Gets or sets a collision response flag (default is true).\n     * when collisionResponse is false, events are still triggered but colliding entity has no response\n     * This helps creating trigger volume when user wants collision feedback events but not position/velocity\n     * to respond to the collision.\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse;\n    },\n    set: function set(response) {\n      this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse = response;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"collisionGroup\", {\n    /**\n     * Gets or sets the current collision group mask (-1 by default).\n     * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup;\n    },\n    set: function set(mask) {\n      this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup = !isNaN(mask) ? mask : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"surroundingMeshes\", {\n    /**\n     * Gets or sets current surrounding meshes (null by default).\n     *\n     * By default collision detection is tested against every mesh in the scene.\n     * It is possible to set surroundingMeshes to a defined list of meshes and then only these specified\n     * meshes will be tested for the collision.\n     *\n     * Note: if set to an empty array no collision will happen when this mesh is moved.\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes;\n    },\n    set: function set(meshes) {\n      this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes = meshes;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"lightSources\", {\n    /** Gets the list of lights affecting that mesh */\n    get: function get() {\n      return this._lightSources;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"_positions\", {\n    /** @hidden */\n    get: function get() {\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"skeleton\", {\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._skeleton;\n    },\n\n    /**\n     * Gets or sets a skeleton to apply skinning transformations\n     * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons\n     */\n    set: function set(value) {\n      var skeleton = this._internalAbstractMeshDataInfo._skeleton;\n\n      if (skeleton && skeleton.needInitialSkinMatrix) {\n        skeleton._unregisterMeshWithPoseMatrix(this);\n      }\n\n      if (value && value.needInitialSkinMatrix) {\n        value._registerMeshWithPoseMatrix(this);\n      }\n\n      this._internalAbstractMeshDataInfo._skeleton = value;\n\n      if (!this._internalAbstractMeshDataInfo._skeleton) {\n        this._bonesTransformMatrices = null;\n      }\n\n      this._markSubMeshesAsAttributesDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AbstractMesh.prototype._buildUniformLayout = function () {\n    this._uniformBuffer.addUniform(\"world\", 16);\n\n    this._uniformBuffer.addUniform(\"visibility\", 1);\n\n    this._uniformBuffer.create();\n  };\n  /**\n   * Transfer the mesh values to its UBO.\n   * @param world The world matrix associated with the mesh\n   */\n\n\n  AbstractMesh.prototype.transferToEffect = function (world) {\n    var ubo = this._uniformBuffer;\n    ubo.updateMatrix(\"world\", world);\n    ubo.updateFloat(\"visibility\", this._internalAbstractMeshDataInfo._visibility);\n    ubo.update();\n  };\n  /**\n   * Gets the mesh uniform buffer.\n   * @return the uniform buffer of the mesh.\n   */\n\n\n  AbstractMesh.prototype.getMeshUniformBuffer = function () {\n    return this._uniformBuffer;\n  };\n  /**\n   * Returns the string \"AbstractMesh\"\n   * @returns \"AbstractMesh\"\n   */\n\n\n  AbstractMesh.prototype.getClassName = function () {\n    return \"AbstractMesh\";\n  };\n  /**\n   * Gets a string representation of the current mesh\n   * @param fullDetails defines a boolean indicating if full details must be included\n   * @returns a string representation of the current mesh\n   */\n\n\n  AbstractMesh.prototype.toString = function (fullDetails) {\n    var ret = \"Name: \" + this.name + \", isInstance: \" + (this.getClassName() !== \"InstancedMesh\" ? \"YES\" : \"NO\");\n    ret += \", # of submeshes: \" + (this.subMeshes ? this.subMeshes.length : 0);\n    var skeleton = this._internalAbstractMeshDataInfo._skeleton;\n\n    if (skeleton) {\n      ret += \", skeleton: \" + skeleton.name;\n    }\n\n    if (fullDetails) {\n      ret += \", billboard mode: \" + [\"NONE\", \"X\", \"Y\", null, \"Z\", null, null, \"ALL\"][this.billboardMode];\n      ret += \", freeze wrld mat: \" + (this._isWorldMatrixFrozen || this._waitingData.freezeWorldMatrix ? \"YES\" : \"NO\");\n    }\n\n    return ret;\n  };\n  /**\n   * @hidden\n   */\n\n\n  AbstractMesh.prototype._getEffectiveParent = function () {\n    if (this._masterMesh && this.billboardMode !== TransformNode.BILLBOARDMODE_NONE) {\n      return this._masterMesh;\n    }\n\n    return _super.prototype._getEffectiveParent.call(this);\n  };\n  /**\n   * @param trigger\n   * @param initialCall\n   * @hidden\n   */\n\n\n  AbstractMesh.prototype._getActionManagerForTrigger = function (trigger, initialCall) {\n    if (initialCall === void 0) {\n      initialCall = true;\n    }\n\n    if (this.actionManager && (initialCall || this.actionManager.isRecursive)) {\n      if (trigger) {\n        if (this.actionManager.hasSpecificTrigger(trigger)) {\n          return this.actionManager;\n        }\n      } else {\n        return this.actionManager;\n      }\n    }\n\n    if (!this.parent) {\n      return null;\n    }\n\n    return this.parent._getActionManagerForTrigger(trigger, false);\n  };\n  /**\n   * @param dispose\n   * @hidden\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  AbstractMesh.prototype._rebuild = function (dispose) {\n    if (dispose === void 0) {\n      dispose = false;\n    }\n\n    this.onRebuildObservable.notifyObservers(this);\n\n    if (this._occlusionQuery !== null) {\n      this._occlusionQuery = null;\n    }\n\n    if (!this.subMeshes) {\n      return;\n    }\n\n    for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {\n      var subMesh = _a[_i];\n\n      subMesh._rebuild();\n    }\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._resyncLightSources = function () {\n    this._lightSources.length = 0;\n\n    for (var _i = 0, _a = this.getScene().lights; _i < _a.length; _i++) {\n      var light = _a[_i];\n\n      if (!light.isEnabled()) {\n        continue;\n      }\n\n      if (light.canAffectMesh(this)) {\n        this._lightSources.push(light);\n      }\n    }\n\n    this._markSubMeshesAsLightDirty();\n  };\n  /**\n   * @param light\n   * @hidden\n   */\n\n\n  AbstractMesh.prototype._resyncLightSource = function (light) {\n    var isIn = light.isEnabled() && light.canAffectMesh(this);\n\n    var index = this._lightSources.indexOf(light);\n\n    var removed = false;\n\n    if (index === -1) {\n      if (!isIn) {\n        return;\n      }\n\n      this._lightSources.push(light);\n    } else {\n      if (isIn) {\n        return;\n      }\n\n      removed = true;\n\n      this._lightSources.splice(index, 1);\n    }\n\n    this._markSubMeshesAsLightDirty(removed);\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._unBindEffect = function () {\n    for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {\n      var subMesh = _a[_i];\n      subMesh.setEffect(null);\n    }\n  };\n  /**\n   * @param light\n   * @param dispose\n   * @hidden\n   */\n\n\n  AbstractMesh.prototype._removeLightSource = function (light, dispose) {\n    var index = this._lightSources.indexOf(light);\n\n    if (index === -1) {\n      return;\n    }\n\n    this._lightSources.splice(index, 1);\n\n    this._markSubMeshesAsLightDirty(dispose);\n  };\n\n  AbstractMesh.prototype._markSubMeshesAsDirty = function (func) {\n    if (!this.subMeshes) {\n      return;\n    }\n\n    for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {\n      var subMesh = _a[_i];\n\n      for (var i = 0; i < subMesh._drawWrappers.length; ++i) {\n        var drawWrapper = subMesh._drawWrappers[i];\n\n        if (!drawWrapper || !drawWrapper.defines || !drawWrapper.defines.markAllAsDirty) {\n          continue;\n        }\n\n        func(drawWrapper.defines);\n      }\n    }\n  };\n  /**\n   * @param dispose\n   * @hidden\n   */\n\n\n  AbstractMesh.prototype._markSubMeshesAsLightDirty = function (dispose) {\n    if (dispose === void 0) {\n      dispose = false;\n    }\n\n    this._markSubMeshesAsDirty(function (defines) {\n      return defines.markAsLightDirty(dispose);\n    });\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._markSubMeshesAsAttributesDirty = function () {\n    this._markSubMeshesAsDirty(function (defines) {\n      return defines.markAsAttributesDirty();\n    });\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._markSubMeshesAsMiscDirty = function () {\n    this._markSubMeshesAsDirty(function (defines) {\n      return defines.markAsMiscDirty();\n    });\n  };\n  /**\n   * Flag the AbstractMesh as dirty (Forcing it to update everything)\n   * @param property if set to \"rotation\" the objects rotationQuaternion will be set to null\n   * @returns this AbstractMesh\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  AbstractMesh.prototype.markAsDirty = function (property) {\n    this._currentRenderId = Number.MAX_VALUE;\n    this._isDirty = true;\n    return this;\n  };\n  /**\n   * Resets the draw wrappers cache for all submeshes of this abstract mesh\n   * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\n   */\n\n\n  AbstractMesh.prototype.resetDrawCache = function (passId) {\n    if (!this.subMeshes) {\n      return;\n    }\n\n    for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {\n      var subMesh = _a[_i];\n      subMesh.resetDrawCache(passId);\n    }\n  };\n\n  Object.defineProperty(AbstractMesh.prototype, \"scaling\", {\n    /**\n     * Gets or sets a Vector3 depicting the mesh scaling along each local axis X, Y, Z.  Default is (1.0, 1.0, 1.0)\n     */\n    get: function get() {\n      return this._scaling;\n    },\n    set: function set(newScaling) {\n      this._scaling = newScaling;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"isBlocked\", {\n    // Methods\n\n    /**\n     * Returns true if the mesh is blocked. Implemented by child classes\n     */\n    get: function get() {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Returns the mesh itself by default. Implemented by child classes\n   * @param camera defines the camera to use to pick the right LOD level\n   * @returns the currentAbstractMesh\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  AbstractMesh.prototype.getLOD = function (camera) {\n    return this;\n  };\n  /**\n   * Returns 0 by default. Implemented by child classes\n   * @returns an integer\n   */\n\n\n  AbstractMesh.prototype.getTotalVertices = function () {\n    return 0;\n  };\n  /**\n   * Returns a positive integer : the total number of indices in this mesh geometry.\n   * @returns the number of indices or zero if the mesh has no geometry.\n   */\n\n\n  AbstractMesh.prototype.getTotalIndices = function () {\n    return 0;\n  };\n  /**\n   * Returns null by default. Implemented by child classes\n   * @returns null\n   */\n\n\n  AbstractMesh.prototype.getIndices = function () {\n    return null;\n  };\n  /**\n   * Returns the array of the requested vertex data kind. Implemented by child classes\n   * @param kind defines the vertex data kind to use\n   * @returns null\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  AbstractMesh.prototype.getVerticesData = function (kind) {\n    return null;\n  };\n  /**\n   * Sets the vertex data of the mesh geometry for the requested `kind`.\n   * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\n   * Note that a new underlying VertexBuffer object is created each call.\n   * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\n   * @param kind defines vertex data kind:\n   * * VertexBuffer.PositionKind\n   * * VertexBuffer.UVKind\n   * * VertexBuffer.UV2Kind\n   * * VertexBuffer.UV3Kind\n   * * VertexBuffer.UV4Kind\n   * * VertexBuffer.UV5Kind\n   * * VertexBuffer.UV6Kind\n   * * VertexBuffer.ColorKind\n   * * VertexBuffer.MatricesIndicesKind\n   * * VertexBuffer.MatricesIndicesExtraKind\n   * * VertexBuffer.MatricesWeightsKind\n   * * VertexBuffer.MatricesWeightsExtraKind\n   * @param data defines the data source\n   * @param updatable defines if the data must be flagged as updatable (or static)\n   * @param stride defines the vertex stride (size of an entire vertex). Can be null and in this case will be deduced from vertex data kind\n   * @returns the current mesh\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  AbstractMesh.prototype.setVerticesData = function (kind, data, updatable, stride) {\n    return this;\n  };\n  /**\n   * Updates the existing vertex data of the mesh geometry for the requested `kind`.\n   * If the mesh has no geometry, it is simply returned as it is.\n   * @param kind defines vertex data kind:\n   * * VertexBuffer.PositionKind\n   * * VertexBuffer.UVKind\n   * * VertexBuffer.UV2Kind\n   * * VertexBuffer.UV3Kind\n   * * VertexBuffer.UV4Kind\n   * * VertexBuffer.UV5Kind\n   * * VertexBuffer.UV6Kind\n   * * VertexBuffer.ColorKind\n   * * VertexBuffer.MatricesIndicesKind\n   * * VertexBuffer.MatricesIndicesExtraKind\n   * * VertexBuffer.MatricesWeightsKind\n   * * VertexBuffer.MatricesWeightsExtraKind\n   * @param data defines the data source\n   * @param updateExtends If `kind` is `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed\n   * @param makeItUnique If true, a new global geometry is created from this data and is set to the mesh\n   * @returns the current mesh\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  AbstractMesh.prototype.updateVerticesData = function (kind, data, updateExtends, makeItUnique) {\n    return this;\n  };\n  /**\n   * Sets the mesh indices,\n   * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\n   * @param indices Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array)\n   * @param totalVertices Defines the total number of vertices\n   * @returns the current mesh\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  AbstractMesh.prototype.setIndices = function (indices, totalVertices) {\n    return this;\n  };\n  /**\n   * Gets a boolean indicating if specific vertex data is present\n   * @param kind defines the vertex data kind to use\n   * @returns true is data kind is present\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  AbstractMesh.prototype.isVerticesDataPresent = function (kind) {\n    return false;\n  };\n  /**\n   * Returns the mesh BoundingInfo object or creates a new one and returns if it was undefined.\n   * Note that it returns a shallow bounding of the mesh (i.e. it does not include children).\n   * To get the full bounding of all children, call `getHierarchyBoundingVectors` instead.\n   * @returns a BoundingInfo\n   */\n\n\n  AbstractMesh.prototype.getBoundingInfo = function () {\n    if (this._masterMesh) {\n      return this._masterMesh.getBoundingInfo();\n    }\n\n    if (this._boundingInfoIsDirty) {\n      this._boundingInfoIsDirty = false; // this._boundingInfo is being created if undefined\n\n      this._updateBoundingInfo();\n    } // cannot be null.\n\n\n    return this._boundingInfo;\n  };\n  /**\n   * Overwrite the current bounding info\n   * @param boundingInfo defines the new bounding info\n   * @returns the current mesh\n   */\n\n\n  AbstractMesh.prototype.setBoundingInfo = function (boundingInfo) {\n    this._boundingInfo = boundingInfo;\n    return this;\n  };\n\n  Object.defineProperty(AbstractMesh.prototype, \"hasBoundingInfo\", {\n    /**\n     * Returns true if there is already a bounding info\n     */\n    get: function get() {\n      return this._boundingInfo !== null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Creates a new bounding info for the mesh\n   * @param minimum min vector of the bounding box/sphere\n   * @param maximum max vector of the bounding box/sphere\n   * @param worldMatrix defines the new world matrix\n   * @returns the new bounding info\n   */\n\n  AbstractMesh.prototype.buildBoundingInfo = function (minimum, maximum, worldMatrix) {\n    this._boundingInfo = new BoundingInfo(minimum, maximum, worldMatrix);\n    return this._boundingInfo;\n  };\n  /**\n   * Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)\n   * @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false\n   * @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false\n   * @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling\n   * @returns the current mesh\n   */\n\n\n  AbstractMesh.prototype.normalizeToUnitCube = function (includeDescendants, ignoreRotation, predicate) {\n    if (includeDescendants === void 0) {\n      includeDescendants = true;\n    }\n\n    if (ignoreRotation === void 0) {\n      ignoreRotation = false;\n    }\n\n    return _super.prototype.normalizeToUnitCube.call(this, includeDescendants, ignoreRotation, predicate);\n  };\n\n  Object.defineProperty(AbstractMesh.prototype, \"useBones\", {\n    /** Gets a boolean indicating if this mesh has skinning data and an attached skeleton */\n    get: function get() {\n      return this.skeleton && this.getScene().skeletonsEnabled && this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind) && this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  AbstractMesh.prototype._preActivate = function () {};\n  /**\n   * @param renderId\n   * @hidden\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  AbstractMesh.prototype._preActivateForIntermediateRendering = function (renderId) {};\n  /**\n   * @param renderId\n   * @param intermediateRendering\n   * @hidden\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  AbstractMesh.prototype._activate = function (renderId, intermediateRendering) {\n    this._renderId = renderId;\n    return true;\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._postActivate = function () {// Do nothing\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._freeze = function () {// Do nothing\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._unFreeze = function () {// Do nothing\n  };\n  /**\n   * Gets the current world matrix\n   * @returns a Matrix\n   */\n\n\n  AbstractMesh.prototype.getWorldMatrix = function () {\n    if (this._masterMesh && this.billboardMode === TransformNode.BILLBOARDMODE_NONE) {\n      return this._masterMesh.getWorldMatrix();\n    }\n\n    return _super.prototype.getWorldMatrix.call(this);\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._getWorldMatrixDeterminant = function () {\n    if (this._masterMesh) {\n      return this._masterMesh._getWorldMatrixDeterminant();\n    }\n\n    return _super.prototype._getWorldMatrixDeterminant.call(this);\n  };\n\n  Object.defineProperty(AbstractMesh.prototype, \"isAnInstance\", {\n    /**\n     * Gets a boolean indicating if this mesh is an instance or a regular mesh\n     */\n    get: function get() {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"hasInstances\", {\n    /**\n     * Gets a boolean indicating if this mesh has instances\n     */\n    get: function get() {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"hasThinInstances\", {\n    /**\n     * Gets a boolean indicating if this mesh has thin instances\n     */\n    get: function get() {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  }); // ================================== Point of View Movement =================================\n\n  /**\n   * Perform relative position change from the point of view of behind the front of the mesh.\n   * This is performed taking into account the meshes current rotation, so you do not have to care.\n   * Supports definition of mesh facing forward or backward\n   * @param amountRight defines the distance on the right axis\n   * @param amountUp defines the distance on the up axis\n   * @param amountForward defines the distance on the forward axis\n   * @returns the current mesh\n   */\n\n  AbstractMesh.prototype.movePOV = function (amountRight, amountUp, amountForward) {\n    this.position.addInPlace(this.calcMovePOV(amountRight, amountUp, amountForward));\n    return this;\n  };\n  /**\n   * Calculate relative position change from the point of view of behind the front of the mesh.\n   * This is performed taking into account the meshes current rotation, so you do not have to care.\n   * Supports definition of mesh facing forward or backward\n   * @param amountRight defines the distance on the right axis\n   * @param amountUp defines the distance on the up axis\n   * @param amountForward defines the distance on the forward axis\n   * @returns the new displacement vector\n   */\n\n\n  AbstractMesh.prototype.calcMovePOV = function (amountRight, amountUp, amountForward) {\n    var rotMatrix = new Matrix();\n    var rotQuaternion = this.rotationQuaternion ? this.rotationQuaternion : Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);\n    rotQuaternion.toRotationMatrix(rotMatrix);\n    var translationDelta = Vector3.Zero();\n    var defForwardMult = this.definedFacingForward ? -1 : 1;\n    Vector3.TransformCoordinatesFromFloatsToRef(amountRight * defForwardMult, amountUp, amountForward * defForwardMult, rotMatrix, translationDelta);\n    return translationDelta;\n  }; // ================================== Point of View Rotation =================================\n\n  /**\n   * Perform relative rotation change from the point of view of behind the front of the mesh.\n   * Supports definition of mesh facing forward or backward\n   * @param flipBack defines the flip\n   * @param twirlClockwise defines the twirl\n   * @param tiltRight defines the tilt\n   * @returns the current mesh\n   */\n\n\n  AbstractMesh.prototype.rotatePOV = function (flipBack, twirlClockwise, tiltRight) {\n    this.rotation.addInPlace(this.calcRotatePOV(flipBack, twirlClockwise, tiltRight));\n    return this;\n  };\n  /**\n   * Calculate relative rotation change from the point of view of behind the front of the mesh.\n   * Supports definition of mesh facing forward or backward.\n   * @param flipBack defines the flip\n   * @param twirlClockwise defines the twirl\n   * @param tiltRight defines the tilt\n   * @returns the new rotation vector\n   */\n\n\n  AbstractMesh.prototype.calcRotatePOV = function (flipBack, twirlClockwise, tiltRight) {\n    var defForwardMult = this.definedFacingForward ? 1 : -1;\n    return new Vector3(flipBack * defForwardMult, twirlClockwise, tiltRight * defForwardMult);\n  };\n  /**\n   * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\n   * This means the mesh underlying bounding box and sphere are recomputed.\n   * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\n   * @param applyMorph  defines whether to apply the morph target before computing the bounding info\n   * @returns the current mesh\n   */\n\n\n  AbstractMesh.prototype.refreshBoundingInfo = function (applySkeleton, applyMorph) {\n    if (applySkeleton === void 0) {\n      applySkeleton = false;\n    }\n\n    if (applyMorph === void 0) {\n      applyMorph = false;\n    }\n\n    if (this._boundingInfo && this._boundingInfo.isLocked) {\n      return this;\n    }\n\n    this._refreshBoundingInfo(this._getPositionData(applySkeleton, applyMorph), null);\n\n    return this;\n  };\n  /**\n   * @param data\n   * @param bias\n   * @hidden\n   */\n\n\n  AbstractMesh.prototype._refreshBoundingInfo = function (data, bias) {\n    if (data) {\n      var extend = extractMinAndMax(data, 0, this.getTotalVertices(), bias);\n\n      if (this._boundingInfo) {\n        this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\n      } else {\n        this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\n      }\n    }\n\n    if (this.subMeshes) {\n      for (var index = 0; index < this.subMeshes.length; index++) {\n        this.subMeshes[index].refreshBoundingInfo(data);\n      }\n    }\n\n    this._updateBoundingInfo();\n  };\n  /**\n   * Get the position vertex data and optionally apply skeleton and morphing.\n   * @param applySkeleton defines whether to apply the skeleton\n   * @param applyMorph  defines whether to apply the morph target\n   * @param data defines the position data to apply the skeleton and morph to\n   * @returns the position data\n   */\n\n\n  AbstractMesh.prototype.getPositionData = function (applySkeleton, applyMorph, data) {\n    if (applySkeleton === void 0) {\n      applySkeleton = false;\n    }\n\n    if (applyMorph === void 0) {\n      applyMorph = false;\n    }\n\n    data = data !== null && data !== void 0 ? data : Tools.Slice(this.getVerticesData(VertexBuffer.PositionKind));\n\n    if (data && applyMorph && this.morphTargetManager) {\n      var faceIndexCount = 0;\n      var positionIndex = 0;\n\n      for (var vertexCount = 0; vertexCount < data.length; vertexCount++) {\n        for (var targetCount = 0; targetCount < this.morphTargetManager.numTargets; targetCount++) {\n          var targetMorph = this.morphTargetManager.getTarget(targetCount);\n          var influence = targetMorph.influence;\n\n          if (influence > 0.0) {\n            var morphTargetPositions = targetMorph.getPositions();\n\n            if (morphTargetPositions) {\n              data[vertexCount] += (morphTargetPositions[vertexCount] - data[vertexCount]) * influence;\n            }\n          }\n        }\n\n        faceIndexCount++;\n\n        if (this._positions && faceIndexCount === 3) {\n          // We want to merge into positions every 3 indices starting (but not 0)\n          faceIndexCount = 0;\n          var index = positionIndex * 3;\n\n          this._positions[positionIndex++].copyFromFloats(data[index], data[index + 1], data[index + 2]);\n        }\n      }\n    }\n\n    if (data && applySkeleton && this.skeleton) {\n      var matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);\n      var matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n\n      if (matricesWeightsData && matricesIndicesData) {\n        var needExtras = this.numBoneInfluencers > 4;\n        var matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\n        var matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\n        var skeletonMatrices = this.skeleton.getTransformMatrices(this);\n        var tempVector = TmpVectors.Vector3[0];\n        var finalMatrix = TmpVectors.Matrix[0];\n        var tempMatrix = TmpVectors.Matrix[1];\n        var matWeightIdx = 0;\n\n        for (var index = 0; index < data.length; index += 3, matWeightIdx += 4) {\n          finalMatrix.reset();\n          var inf = void 0;\n          var weight = void 0;\n\n          for (inf = 0; inf < 4; inf++) {\n            weight = matricesWeightsData[matWeightIdx + inf];\n\n            if (weight > 0) {\n              Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);\n              finalMatrix.addToSelf(tempMatrix);\n            }\n          }\n\n          if (needExtras) {\n            for (inf = 0; inf < 4; inf++) {\n              weight = matricesWeightsExtraData[matWeightIdx + inf];\n\n              if (weight > 0) {\n                Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);\n                finalMatrix.addToSelf(tempMatrix);\n              }\n            }\n          }\n\n          Vector3.TransformCoordinatesFromFloatsToRef(data[index], data[index + 1], data[index + 2], finalMatrix, tempVector);\n          tempVector.toArray(data, index);\n\n          if (this._positions) {\n            this._positions[index / 3].copyFrom(tempVector);\n          }\n        }\n      }\n    }\n\n    return data;\n  };\n  /**\n   * @param applySkeleton\n   * @param applyMorph\n   * @hidden\n   */\n\n\n  AbstractMesh.prototype._getPositionData = function (applySkeleton, applyMorph) {\n    var _a;\n\n    var data = this.getVerticesData(VertexBuffer.PositionKind);\n\n    if (this._internalAbstractMeshDataInfo._positions) {\n      this._internalAbstractMeshDataInfo._positions = null;\n    }\n\n    if (data && (applySkeleton && this.skeleton || applyMorph && this.morphTargetManager)) {\n      data = Tools.Slice(data);\n\n      this._generatePointsArray();\n\n      if (this._positions) {\n        var pos = this._positions;\n        this._internalAbstractMeshDataInfo._positions = new Array(pos.length);\n\n        for (var i = 0; i < pos.length; i++) {\n          this._internalAbstractMeshDataInfo._positions[i] = ((_a = pos[i]) === null || _a === void 0 ? void 0 : _a.clone()) || new Vector3();\n        }\n      }\n\n      return this.getPositionData(applySkeleton, applyMorph, data);\n    }\n\n    return data;\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._updateBoundingInfo = function () {\n    if (this._boundingInfo) {\n      this._boundingInfo.update(this.worldMatrixFromCache);\n    } else {\n      this._boundingInfo = new BoundingInfo(Vector3.Zero(), Vector3.Zero(), this.worldMatrixFromCache);\n    }\n\n    this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\n\n    return this;\n  };\n  /**\n   * @param matrix\n   * @hidden\n   */\n\n\n  AbstractMesh.prototype._updateSubMeshesBoundingInfo = function (matrix) {\n    if (!this.subMeshes) {\n      return this;\n    }\n\n    var count = this.subMeshes.length;\n\n    for (var subIndex = 0; subIndex < count; subIndex++) {\n      var subMesh = this.subMeshes[subIndex];\n\n      if (count > 1 || !subMesh.IsGlobal) {\n        subMesh.updateBoundingInfo(matrix);\n      }\n    }\n\n    return this;\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._afterComputeWorldMatrix = function () {\n    if (this.doNotSyncBoundingInfo) {\n      return;\n    } // Bounding info\n\n\n    this._boundingInfoIsDirty = true;\n  };\n  /**\n   * Returns `true` if the mesh is within the frustum defined by the passed array of planes.\n   * A mesh is in the frustum if its bounding box intersects the frustum\n   * @param frustumPlanes defines the frustum to test\n   * @returns true if the mesh is in the frustum planes\n   */\n\n\n  AbstractMesh.prototype.isInFrustum = function (frustumPlanes) {\n    return this.getBoundingInfo().isInFrustum(frustumPlanes, this.cullingStrategy);\n  };\n  /**\n   * Returns `true` if the mesh is completely in the frustum defined be the passed array of planes.\n   * A mesh is completely in the frustum if its bounding box it completely inside the frustum.\n   * @param frustumPlanes defines the frustum to test\n   * @returns true if the mesh is completely in the frustum planes\n   */\n\n\n  AbstractMesh.prototype.isCompletelyInFrustum = function (frustumPlanes) {\n    return this.getBoundingInfo().isCompletelyInFrustum(frustumPlanes);\n  };\n  /**\n   * True if the mesh intersects another mesh or a SolidParticle object\n   * @param mesh defines a target mesh or SolidParticle to test\n   * @param precise Unless the parameter `precise` is set to `true` the intersection is computed according to Axis Aligned Bounding Boxes (AABB), else according to OBB (Oriented BBoxes)\n   * @param includeDescendants Can be set to true to test if the mesh defined in parameters intersects with the current mesh or any child meshes\n   * @returns true if there is an intersection\n   */\n\n\n  AbstractMesh.prototype.intersectsMesh = function (mesh, precise, includeDescendants) {\n    if (precise === void 0) {\n      precise = false;\n    }\n\n    var boundingInfo = this.getBoundingInfo();\n    var otherBoundingInfo = mesh.getBoundingInfo();\n\n    if (boundingInfo.intersects(otherBoundingInfo, precise)) {\n      return true;\n    }\n\n    if (includeDescendants) {\n      for (var _i = 0, _a = this.getChildMeshes(); _i < _a.length; _i++) {\n        var child = _a[_i];\n\n        if (child.intersectsMesh(mesh, precise, true)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Returns true if the passed point (Vector3) is inside the mesh bounding box\n   * @param point defines the point to test\n   * @returns true if there is an intersection\n   */\n\n\n  AbstractMesh.prototype.intersectsPoint = function (point) {\n    return this.getBoundingInfo().intersectsPoint(point);\n  };\n\n  Object.defineProperty(AbstractMesh.prototype, \"checkCollisions\", {\n    // Collisions\n\n    /**\n     * Gets or sets a boolean indicating that this mesh can be used in the collision engine\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions;\n    },\n    set: function set(collisionEnabled) {\n      this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions = collisionEnabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"collider\", {\n    /**\n     * Gets Collider object used to compute collisions (not physics)\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._meshCollisionData._collider;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Move the mesh using collision engine\n   * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\n   * @param displacement defines the requested displacement vector\n   * @returns the current mesh\n   */\n\n  AbstractMesh.prototype.moveWithCollisions = function (displacement) {\n    var globalPosition = this.getAbsolutePosition();\n    globalPosition.addToRef(this.ellipsoidOffset, this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions);\n    var coordinator = this.getScene().collisionCoordinator;\n\n    if (!this._internalAbstractMeshDataInfo._meshCollisionData._collider) {\n      this._internalAbstractMeshDataInfo._meshCollisionData._collider = coordinator.createCollider();\n    }\n\n    this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius = this.ellipsoid;\n    coordinator.getNewPosition(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, displacement, this._internalAbstractMeshDataInfo._meshCollisionData._collider, this.collisionRetryCount, this, this._onCollisionPositionChange, this.uniqueId);\n    return this;\n  }; // Collisions\n\n  /**\n   * @param subMesh\n   * @param transformMatrix\n   * @param collider\n   * @hidden\n   */\n\n\n  AbstractMesh.prototype._collideForSubMesh = function (subMesh, transformMatrix, collider) {\n    var _a;\n\n    this._generatePointsArray();\n\n    if (!this._positions) {\n      return this;\n    } // Transformation\n\n\n    if (!subMesh._lastColliderWorldVertices || !subMesh._lastColliderTransformMatrix.equals(transformMatrix)) {\n      subMesh._lastColliderTransformMatrix = transformMatrix.clone();\n      subMesh._lastColliderWorldVertices = [];\n      subMesh._trianglePlanes = [];\n      var start = subMesh.verticesStart;\n      var end = subMesh.verticesStart + subMesh.verticesCount;\n\n      for (var i = start; i < end; i++) {\n        subMesh._lastColliderWorldVertices.push(Vector3.TransformCoordinates(this._positions[i], transformMatrix));\n      }\n    } // Collide\n\n\n    collider._collide(subMesh._trianglePlanes, subMesh._lastColliderWorldVertices, this.getIndices(), subMesh.indexStart, subMesh.indexStart + subMesh.indexCount, subMesh.verticesStart, !!subMesh.getMaterial(), this, this._shouldConvertRHS(), ((_a = subMesh.getMaterial()) === null || _a === void 0 ? void 0 : _a.fillMode) === 7);\n\n    return this;\n  };\n  /**\n   * @param collider\n   * @param transformMatrix\n   * @hidden\n   */\n\n\n  AbstractMesh.prototype._processCollisionsForSubMeshes = function (collider, transformMatrix) {\n    var subMeshes = this._scene.getCollidingSubMeshCandidates(this, collider);\n\n    var len = subMeshes.length;\n\n    for (var index = 0; index < len; index++) {\n      var subMesh = subMeshes.data[index]; // Bounding test\n\n      if (len > 1 && !subMesh._checkCollision(collider)) {\n        continue;\n      }\n\n      this._collideForSubMesh(subMesh, transformMatrix, collider);\n    }\n\n    return this;\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._shouldConvertRHS = function () {\n    return false;\n  };\n  /**\n   * @param collider\n   * @hidden\n   */\n\n\n  AbstractMesh.prototype._checkCollision = function (collider) {\n    // Bounding box test\n    if (!this.getBoundingInfo()._checkCollision(collider)) {\n      return this;\n    } // Transformation matrix\n\n\n    var collisionsScalingMatrix = TmpVectors.Matrix[0];\n    var collisionsTransformMatrix = TmpVectors.Matrix[1];\n    Matrix.ScalingToRef(1.0 / collider._radius.x, 1.0 / collider._radius.y, 1.0 / collider._radius.z, collisionsScalingMatrix);\n    this.worldMatrixFromCache.multiplyToRef(collisionsScalingMatrix, collisionsTransformMatrix);\n\n    this._processCollisionsForSubMeshes(collider, collisionsTransformMatrix);\n\n    return this;\n  }; // Picking\n\n  /** @hidden */\n\n\n  AbstractMesh.prototype._generatePointsArray = function () {\n    return false;\n  };\n  /**\n   * Checks if the passed Ray intersects with the mesh\n   * @param ray defines the ray to use\n   * @param fastCheck defines if fast mode (but less precise) must be used (false by default)\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n   * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\n   * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point\n   * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\n   * @returns the picking info\n   * @see https://doc.babylonjs.com/babylon101/intersect_collisions_-_mesh\n   */\n\n\n  AbstractMesh.prototype.intersects = function (ray, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo) {\n    if (onlyBoundingInfo === void 0) {\n      onlyBoundingInfo = false;\n    }\n\n    if (skipBoundingInfo === void 0) {\n      skipBoundingInfo = false;\n    }\n\n    var pickingInfo = new PickingInfo();\n    var intersectionThreshold = this.getClassName() === \"InstancedLinesMesh\" || this.getClassName() === \"LinesMesh\" ? this.intersectionThreshold : 0;\n    var boundingInfo = this.getBoundingInfo();\n\n    if (!this.subMeshes) {\n      return pickingInfo;\n    }\n\n    if (!skipBoundingInfo && (!ray.intersectsSphere(boundingInfo.boundingSphere, intersectionThreshold) || !ray.intersectsBox(boundingInfo.boundingBox, intersectionThreshold))) {\n      return pickingInfo;\n    }\n\n    if (onlyBoundingInfo) {\n      pickingInfo.hit = skipBoundingInfo ? false : true;\n      pickingInfo.pickedMesh = skipBoundingInfo ? null : this;\n      pickingInfo.distance = skipBoundingInfo ? 0 : Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);\n      pickingInfo.subMeshId = 0;\n      return pickingInfo;\n    }\n\n    if (!this._generatePointsArray()) {\n      return pickingInfo;\n    }\n\n    var intersectInfo = null;\n\n    var subMeshes = this._scene.getIntersectingSubMeshCandidates(this, ray);\n\n    var len = subMeshes.length; // Check if all submeshes are using a material that don't allow picking (point/lines rendering)\n    // if no submesh can be picked that way, then fallback to BBox picking\n\n    var anySubmeshSupportIntersect = false;\n\n    for (var index = 0; index < len; index++) {\n      var subMesh = subMeshes.data[index];\n      var material = subMesh.getMaterial();\n\n      if (!material) {\n        continue;\n      }\n\n      if (material.fillMode == 7 || material.fillMode == 0 || material.fillMode == 1 || material.fillMode == 2 || material.fillMode == 4) {\n        anySubmeshSupportIntersect = true;\n        break;\n      }\n    } // no sub mesh support intersection, fallback to BBox that has already be done\n\n\n    if (!anySubmeshSupportIntersect) {\n      pickingInfo.hit = true;\n      pickingInfo.pickedMesh = this;\n      pickingInfo.distance = Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);\n      pickingInfo.subMeshId = -1;\n      return pickingInfo;\n    } // at least 1 submesh supports intersection, keep going\n\n\n    for (var index = 0; index < len; index++) {\n      var subMesh = subMeshes.data[index]; // Bounding test\n\n      if (len > 1 && !subMesh.canIntersects(ray)) {\n        continue;\n      }\n\n      var currentIntersectInfo = subMesh.intersects(ray, this._positions, this.getIndices(), fastCheck, trianglePredicate);\n\n      if (currentIntersectInfo) {\n        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\n          intersectInfo = currentIntersectInfo;\n          intersectInfo.subMeshId = index;\n\n          if (fastCheck) {\n            break;\n          }\n        }\n      }\n    }\n\n    if (intersectInfo) {\n      // Get picked point\n      var world = worldToUse !== null && worldToUse !== void 0 ? worldToUse : this.getWorldMatrix();\n      var worldOrigin = TmpVectors.Vector3[0];\n      var direction = TmpVectors.Vector3[1];\n      Vector3.TransformCoordinatesToRef(ray.origin, world, worldOrigin);\n      ray.direction.scaleToRef(intersectInfo.distance, direction);\n      var worldDirection = Vector3.TransformNormal(direction, world);\n      var pickedPoint = worldDirection.addInPlace(worldOrigin); // Return result\n\n      pickingInfo.hit = true;\n      pickingInfo.distance = Vector3.Distance(worldOrigin, pickedPoint);\n      pickingInfo.pickedPoint = pickedPoint;\n      pickingInfo.pickedMesh = this;\n      pickingInfo.bu = intersectInfo.bu || 0;\n      pickingInfo.bv = intersectInfo.bv || 0;\n      pickingInfo.subMeshFaceId = intersectInfo.faceId;\n      pickingInfo.faceId = intersectInfo.faceId + subMeshes.data[intersectInfo.subMeshId].indexStart / (this.getClassName().indexOf(\"LinesMesh\") !== -1 ? 2 : 3);\n      pickingInfo.subMeshId = intersectInfo.subMeshId;\n      return pickingInfo;\n    }\n\n    return pickingInfo;\n  };\n  /**\n   * Clones the current mesh\n   * @param name defines the mesh name\n   * @param newParent defines the new mesh parent\n   * @param doNotCloneChildren defines a boolean indicating that children must not be cloned (false by default)\n   * @returns the new mesh\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  AbstractMesh.prototype.clone = function (name, newParent, doNotCloneChildren) {\n    return null;\n  };\n  /**\n   * Disposes all the submeshes of the current meshnp\n   * @returns the current mesh\n   */\n\n\n  AbstractMesh.prototype.releaseSubMeshes = function () {\n    if (this.subMeshes) {\n      while (this.subMeshes.length) {\n        this.subMeshes[0].dispose();\n      }\n    } else {\n      this.subMeshes = new Array();\n    }\n\n    return this;\n  };\n  /**\n   * Releases resources associated with this abstract mesh.\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n   */\n\n\n  AbstractMesh.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {\n    var _this = this;\n\n    if (disposeMaterialAndTextures === void 0) {\n      disposeMaterialAndTextures = false;\n    }\n\n    var index; // mesh map release.\n\n    if (this._scene.useMaterialMeshMap) {\n      // remove from material mesh map id needed\n      if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {\n        this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = undefined;\n      }\n    } // Smart Array Retainers.\n\n\n    this.getScene().freeActiveMeshes();\n    this.getScene().freeRenderingGroups(); // Action manager\n\n    if (this.actionManager !== undefined && this.actionManager !== null) {\n      this.actionManager.dispose();\n      this.actionManager = null;\n    } // Skeleton\n\n\n    this._internalAbstractMeshDataInfo._skeleton = null;\n\n    if (this._transformMatrixTexture) {\n      this._transformMatrixTexture.dispose();\n\n      this._transformMatrixTexture = null;\n    } // Intersections in progress\n\n\n    for (index = 0; index < this._intersectionsInProgress.length; index++) {\n      var other = this._intersectionsInProgress[index];\n\n      var pos = other._intersectionsInProgress.indexOf(this);\n\n      other._intersectionsInProgress.splice(pos, 1);\n    }\n\n    this._intersectionsInProgress = []; // Lights\n\n    var lights = this.getScene().lights;\n    lights.forEach(function (light) {\n      var meshIndex = light.includedOnlyMeshes.indexOf(_this);\n\n      if (meshIndex !== -1) {\n        light.includedOnlyMeshes.splice(meshIndex, 1);\n      }\n\n      meshIndex = light.excludedMeshes.indexOf(_this);\n\n      if (meshIndex !== -1) {\n        light.excludedMeshes.splice(meshIndex, 1);\n      } // Shadow generators\n\n\n      var generator = light.getShadowGenerator();\n\n      if (generator) {\n        var shadowMap = generator.getShadowMap();\n\n        if (shadowMap && shadowMap.renderList) {\n          meshIndex = shadowMap.renderList.indexOf(_this);\n\n          if (meshIndex !== -1) {\n            shadowMap.renderList.splice(meshIndex, 1);\n          }\n        }\n      }\n    }); // SubMeshes\n\n    if (this.getClassName() !== \"InstancedMesh\" || this.getClassName() !== \"InstancedLinesMesh\") {\n      this.releaseSubMeshes();\n    } // Query\n\n\n    var engine = this.getScene().getEngine();\n\n    if (this._occlusionQuery !== null) {\n      this.isOcclusionQueryInProgress = false;\n      engine.deleteQuery(this._occlusionQuery);\n      this._occlusionQuery = null;\n    } // Engine\n\n\n    engine.wipeCaches(); // Remove from scene\n\n    this.getScene().removeMesh(this);\n\n    if (this._parentContainer) {\n      var index_1 = this._parentContainer.meshes.indexOf(this);\n\n      if (index_1 > -1) {\n        this._parentContainer.meshes.splice(index_1, 1);\n      }\n\n      this._parentContainer = null;\n    }\n\n    if (disposeMaterialAndTextures) {\n      if (this.material) {\n        if (this.material.getClassName() === \"MultiMaterial\") {\n          this.material.dispose(false, true, true);\n        } else {\n          this.material.dispose(false, true);\n        }\n      }\n    }\n\n    if (!doNotRecurse) {\n      // Particles\n      for (index = 0; index < this.getScene().particleSystems.length; index++) {\n        if (this.getScene().particleSystems[index].emitter === this) {\n          this.getScene().particleSystems[index].dispose();\n          index--;\n        }\n      }\n    } // facet data\n\n\n    if (this._internalAbstractMeshDataInfo._facetData.facetDataEnabled) {\n      this.disableFacetData();\n    }\n\n    this._uniformBuffer.dispose();\n\n    this.onAfterWorldMatrixUpdateObservable.clear();\n    this.onCollideObservable.clear();\n    this.onCollisionPositionChangeObservable.clear();\n    this.onRebuildObservable.clear();\n\n    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);\n  };\n  /**\n   * Adds the passed mesh as a child to the current mesh\n   * @param mesh defines the child mesh\n   * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.\n   * @returns the current mesh\n   */\n\n\n  AbstractMesh.prototype.addChild = function (mesh, preserveScalingSign) {\n    if (preserveScalingSign === void 0) {\n      preserveScalingSign = false;\n    }\n\n    mesh.setParent(this, preserveScalingSign);\n    return this;\n  };\n  /**\n   * Removes the passed mesh from the current mesh children list\n   * @param mesh defines the child mesh\n   * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.\n   * @returns the current mesh\n   */\n\n\n  AbstractMesh.prototype.removeChild = function (mesh, preserveScalingSign) {\n    if (preserveScalingSign === void 0) {\n      preserveScalingSign = false;\n    }\n\n    mesh.setParent(null, preserveScalingSign);\n    return this;\n  }; // Facet data\n\n  /** @hidden */\n\n\n  AbstractMesh.prototype._initFacetData = function () {\n    var data = this._internalAbstractMeshDataInfo._facetData;\n\n    if (!data.facetNormals) {\n      data.facetNormals = new Array();\n    }\n\n    if (!data.facetPositions) {\n      data.facetPositions = new Array();\n    }\n\n    if (!data.facetPartitioning) {\n      data.facetPartitioning = new Array();\n    }\n\n    data.facetNb = this.getIndices().length / 3 | 0;\n    data.partitioningSubdivisions = data.partitioningSubdivisions ? data.partitioningSubdivisions : 10; // default nb of partitioning subdivisions = 10\n\n    data.partitioningBBoxRatio = data.partitioningBBoxRatio ? data.partitioningBBoxRatio : 1.01; // default ratio 1.01 = the partitioning is 1% bigger than the bounding box\n\n    for (var f = 0; f < data.facetNb; f++) {\n      data.facetNormals[f] = Vector3.Zero();\n      data.facetPositions[f] = Vector3.Zero();\n    }\n\n    data.facetDataEnabled = true;\n    return this;\n  };\n  /**\n   * Updates the mesh facetData arrays and the internal partitioning when the mesh is morphed or updated.\n   * This method can be called within the render loop.\n   * You don't need to call this method by yourself in the render loop when you update/morph a mesh with the methods CreateXXX() as they automatically manage this computation\n   * @returns the current mesh\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n   */\n\n\n  AbstractMesh.prototype.updateFacetData = function () {\n    var data = this._internalAbstractMeshDataInfo._facetData;\n\n    if (!data.facetDataEnabled) {\n      this._initFacetData();\n    }\n\n    var positions = this.getVerticesData(VertexBuffer.PositionKind);\n    var indices = this.getIndices();\n    var normals = this.getVerticesData(VertexBuffer.NormalKind);\n    var bInfo = this.getBoundingInfo();\n\n    if (data.facetDepthSort && !data.facetDepthSortEnabled) {\n      // init arrays, matrix and sort function on first call\n      data.facetDepthSortEnabled = true;\n\n      if (indices instanceof Uint16Array) {\n        data.depthSortedIndices = new Uint16Array(indices);\n      } else if (indices instanceof Uint32Array) {\n        data.depthSortedIndices = new Uint32Array(indices);\n      } else {\n        var needs32bits = false;\n\n        for (var i = 0; i < indices.length; i++) {\n          if (indices[i] > 65535) {\n            needs32bits = true;\n            break;\n          }\n        }\n\n        if (needs32bits) {\n          data.depthSortedIndices = new Uint32Array(indices);\n        } else {\n          data.depthSortedIndices = new Uint16Array(indices);\n        }\n      }\n\n      data.facetDepthSortFunction = function (f1, f2) {\n        return f2.sqDistance - f1.sqDistance;\n      };\n\n      if (!data.facetDepthSortFrom) {\n        var camera = this.getScene().activeCamera;\n        data.facetDepthSortFrom = camera ? camera.position : Vector3.Zero();\n      }\n\n      data.depthSortedFacets = [];\n\n      for (var f = 0; f < data.facetNb; f++) {\n        var depthSortedFacet = {\n          ind: f * 3,\n          sqDistance: 0.0\n        };\n        data.depthSortedFacets.push(depthSortedFacet);\n      }\n\n      data.invertedMatrix = Matrix.Identity();\n      data.facetDepthSortOrigin = Vector3.Zero();\n    }\n\n    data.bbSize.x = bInfo.maximum.x - bInfo.minimum.x > Epsilon ? bInfo.maximum.x - bInfo.minimum.x : Epsilon;\n    data.bbSize.y = bInfo.maximum.y - bInfo.minimum.y > Epsilon ? bInfo.maximum.y - bInfo.minimum.y : Epsilon;\n    data.bbSize.z = bInfo.maximum.z - bInfo.minimum.z > Epsilon ? bInfo.maximum.z - bInfo.minimum.z : Epsilon;\n    var bbSizeMax = data.bbSize.x > data.bbSize.y ? data.bbSize.x : data.bbSize.y;\n    bbSizeMax = bbSizeMax > data.bbSize.z ? bbSizeMax : data.bbSize.z;\n    data.subDiv.max = data.partitioningSubdivisions;\n    data.subDiv.X = Math.floor(data.subDiv.max * data.bbSize.x / bbSizeMax); // adjust the number of subdivisions per axis\n\n    data.subDiv.Y = Math.floor(data.subDiv.max * data.bbSize.y / bbSizeMax); // according to each bbox size per axis\n\n    data.subDiv.Z = Math.floor(data.subDiv.max * data.bbSize.z / bbSizeMax);\n    data.subDiv.X = data.subDiv.X < 1 ? 1 : data.subDiv.X; // at least one subdivision\n\n    data.subDiv.Y = data.subDiv.Y < 1 ? 1 : data.subDiv.Y;\n    data.subDiv.Z = data.subDiv.Z < 1 ? 1 : data.subDiv.Z; // set the parameters for ComputeNormals()\n\n    data.facetParameters.facetNormals = this.getFacetLocalNormals();\n    data.facetParameters.facetPositions = this.getFacetLocalPositions();\n    data.facetParameters.facetPartitioning = this.getFacetLocalPartitioning();\n    data.facetParameters.bInfo = bInfo;\n    data.facetParameters.bbSize = data.bbSize;\n    data.facetParameters.subDiv = data.subDiv;\n    data.facetParameters.ratio = this.partitioningBBoxRatio;\n    data.facetParameters.depthSort = data.facetDepthSort;\n\n    if (data.facetDepthSort && data.facetDepthSortEnabled) {\n      this.computeWorldMatrix(true);\n\n      this._worldMatrix.invertToRef(data.invertedMatrix);\n\n      Vector3.TransformCoordinatesToRef(data.facetDepthSortFrom, data.invertedMatrix, data.facetDepthSortOrigin);\n      data.facetParameters.distanceTo = data.facetDepthSortOrigin;\n    }\n\n    data.facetParameters.depthSortedFacets = data.depthSortedFacets;\n\n    if (normals) {\n      VertexData.ComputeNormals(positions, indices, normals, data.facetParameters);\n    }\n\n    if (data.facetDepthSort && data.facetDepthSortEnabled) {\n      data.depthSortedFacets.sort(data.facetDepthSortFunction);\n      var l = data.depthSortedIndices.length / 3 | 0;\n\n      for (var f = 0; f < l; f++) {\n        var sind = data.depthSortedFacets[f].ind;\n        data.depthSortedIndices[f * 3] = indices[sind];\n        data.depthSortedIndices[f * 3 + 1] = indices[sind + 1];\n        data.depthSortedIndices[f * 3 + 2] = indices[sind + 2];\n      }\n\n      this.updateIndices(data.depthSortedIndices, undefined, true);\n    }\n\n    return this;\n  };\n  /**\n   * Returns the facetLocalNormals array.\n   * The normals are expressed in the mesh local spac\n   * @returns an array of Vector3\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n   */\n\n\n  AbstractMesh.prototype.getFacetLocalNormals = function () {\n    var facetData = this._internalAbstractMeshDataInfo._facetData;\n\n    if (!facetData.facetNormals) {\n      this.updateFacetData();\n    }\n\n    return facetData.facetNormals;\n  };\n  /**\n   * Returns the facetLocalPositions array.\n   * The facet positions are expressed in the mesh local space\n   * @returns an array of Vector3\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n   */\n\n\n  AbstractMesh.prototype.getFacetLocalPositions = function () {\n    var facetData = this._internalAbstractMeshDataInfo._facetData;\n\n    if (!facetData.facetPositions) {\n      this.updateFacetData();\n    }\n\n    return facetData.facetPositions;\n  };\n  /**\n   * Returns the facetLocalPartitioning array\n   * @returns an array of array of numbers\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n   */\n\n\n  AbstractMesh.prototype.getFacetLocalPartitioning = function () {\n    var facetData = this._internalAbstractMeshDataInfo._facetData;\n\n    if (!facetData.facetPartitioning) {\n      this.updateFacetData();\n    }\n\n    return facetData.facetPartitioning;\n  };\n  /**\n   * Returns the i-th facet position in the world system.\n   * This method allocates a new Vector3 per call\n   * @param i defines the facet index\n   * @returns a new Vector3\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n   */\n\n\n  AbstractMesh.prototype.getFacetPosition = function (i) {\n    var pos = Vector3.Zero();\n    this.getFacetPositionToRef(i, pos);\n    return pos;\n  };\n  /**\n   * Sets the reference Vector3 with the i-th facet position in the world system\n   * @param i defines the facet index\n   * @param ref defines the target vector\n   * @returns the current mesh\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n   */\n\n\n  AbstractMesh.prototype.getFacetPositionToRef = function (i, ref) {\n    var localPos = this.getFacetLocalPositions()[i];\n    var world = this.getWorldMatrix();\n    Vector3.TransformCoordinatesToRef(localPos, world, ref);\n    return this;\n  };\n  /**\n   * Returns the i-th facet normal in the world system.\n   * This method allocates a new Vector3 per call\n   * @param i defines the facet index\n   * @returns a new Vector3\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n   */\n\n\n  AbstractMesh.prototype.getFacetNormal = function (i) {\n    var norm = Vector3.Zero();\n    this.getFacetNormalToRef(i, norm);\n    return norm;\n  };\n  /**\n   * Sets the reference Vector3 with the i-th facet normal in the world system\n   * @param i defines the facet index\n   * @param ref defines the target vector\n   * @returns the current mesh\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n   */\n\n\n  AbstractMesh.prototype.getFacetNormalToRef = function (i, ref) {\n    var localNorm = this.getFacetLocalNormals()[i];\n    Vector3.TransformNormalToRef(localNorm, this.getWorldMatrix(), ref);\n    return this;\n  };\n  /**\n   * Returns the facets (in an array) in the same partitioning block than the one the passed coordinates are located (expressed in the mesh local system)\n   * @param x defines x coordinate\n   * @param y defines y coordinate\n   * @param z defines z coordinate\n   * @returns the array of facet indexes\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n   */\n\n\n  AbstractMesh.prototype.getFacetsAtLocalCoordinates = function (x, y, z) {\n    var bInfo = this.getBoundingInfo();\n    var data = this._internalAbstractMeshDataInfo._facetData;\n    var ox = Math.floor((x - bInfo.minimum.x * data.partitioningBBoxRatio) * data.subDiv.X * data.partitioningBBoxRatio / data.bbSize.x);\n    var oy = Math.floor((y - bInfo.minimum.y * data.partitioningBBoxRatio) * data.subDiv.Y * data.partitioningBBoxRatio / data.bbSize.y);\n    var oz = Math.floor((z - bInfo.minimum.z * data.partitioningBBoxRatio) * data.subDiv.Z * data.partitioningBBoxRatio / data.bbSize.z);\n\n    if (ox < 0 || ox > data.subDiv.max || oy < 0 || oy > data.subDiv.max || oz < 0 || oz > data.subDiv.max) {\n      return null;\n    }\n\n    return data.facetPartitioning[ox + data.subDiv.max * oy + data.subDiv.max * data.subDiv.max * oz];\n  };\n  /**\n   * Returns the closest mesh facet index at (x,y,z) World coordinates, null if not found\n   * @param x defines x coordinate\n   * @param y defines y coordinate\n   * @param z defines z coordinate\n   * @param projected sets as the (x,y,z) world projection on the facet\n   * @param checkFace if true (default false), only the facet \"facing\" to (x,y,z) or only the ones \"turning their backs\", according to the parameter \"facing\" are returned\n   * @param facing if facing and checkFace are true, only the facet \"facing\" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet \"turning their backs\" to (x, y, z) are returned : negative dot (x, y, z) * facet position\n   * @returns the face index if found (or null instead)\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n   */\n\n\n  AbstractMesh.prototype.getClosestFacetAtCoordinates = function (x, y, z, projected, checkFace, facing) {\n    if (checkFace === void 0) {\n      checkFace = false;\n    }\n\n    if (facing === void 0) {\n      facing = true;\n    }\n\n    var world = this.getWorldMatrix();\n    var invMat = TmpVectors.Matrix[5];\n    world.invertToRef(invMat);\n    var invVect = TmpVectors.Vector3[8];\n    Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, invMat, invVect); // transform (x,y,z) to coordinates in the mesh local space\n\n    var closest = this.getClosestFacetAtLocalCoordinates(invVect.x, invVect.y, invVect.z, projected, checkFace, facing);\n\n    if (projected) {\n      // transform the local computed projected vector to world coordinates\n      Vector3.TransformCoordinatesFromFloatsToRef(projected.x, projected.y, projected.z, world, projected);\n    }\n\n    return closest;\n  };\n  /**\n   * Returns the closest mesh facet index at (x,y,z) local coordinates, null if not found\n   * @param x defines x coordinate\n   * @param y defines y coordinate\n   * @param z defines z coordinate\n   * @param projected sets as the (x,y,z) local projection on the facet\n   * @param checkFace if true (default false), only the facet \"facing\" to (x,y,z) or only the ones \"turning their backs\", according to the parameter \"facing\" are returned\n   * @param facing if facing and checkFace are true, only the facet \"facing\" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet \"turning their backs\" to (x, y, z) are returned : negative dot (x, y, z) * facet position\n   * @returns the face index if found (or null instead)\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n   */\n\n\n  AbstractMesh.prototype.getClosestFacetAtLocalCoordinates = function (x, y, z, projected, checkFace, facing) {\n    if (checkFace === void 0) {\n      checkFace = false;\n    }\n\n    if (facing === void 0) {\n      facing = true;\n    }\n\n    var closest = null;\n    var tmpx = 0.0;\n    var tmpy = 0.0;\n    var tmpz = 0.0;\n    var d = 0.0; // tmp dot facet normal * facet position\n\n    var t0 = 0.0;\n    var projx = 0.0;\n    var projy = 0.0;\n    var projz = 0.0; // Get all the facets in the same partitioning block than (x, y, z)\n\n    var facetPositions = this.getFacetLocalPositions();\n    var facetNormals = this.getFacetLocalNormals();\n    var facetsInBlock = this.getFacetsAtLocalCoordinates(x, y, z);\n\n    if (!facetsInBlock) {\n      return null;\n    } // Get the closest facet to (x, y, z)\n\n\n    var shortest = Number.MAX_VALUE; // init distance vars\n\n    var tmpDistance = shortest;\n    var fib; // current facet in the block\n\n    var norm; // current facet normal\n\n    var p0; // current facet barycenter position\n    // loop on all the facets in the current partitioning block\n\n    for (var idx = 0; idx < facetsInBlock.length; idx++) {\n      fib = facetsInBlock[idx];\n      norm = facetNormals[fib];\n      p0 = facetPositions[fib];\n      d = (x - p0.x) * norm.x + (y - p0.y) * norm.y + (z - p0.z) * norm.z;\n\n      if (!checkFace || checkFace && facing && d >= 0.0 || checkFace && !facing && d <= 0.0) {\n        // compute (x,y,z) projection on the facet = (projx, projy, projz)\n        d = norm.x * p0.x + norm.y * p0.y + norm.z * p0.z;\n        t0 = -(norm.x * x + norm.y * y + norm.z * z - d) / (norm.x * norm.x + norm.y * norm.y + norm.z * norm.z);\n        projx = x + norm.x * t0;\n        projy = y + norm.y * t0;\n        projz = z + norm.z * t0;\n        tmpx = projx - x;\n        tmpy = projy - y;\n        tmpz = projz - z;\n        tmpDistance = tmpx * tmpx + tmpy * tmpy + tmpz * tmpz; // compute length between (x, y, z) and its projection on the facet\n\n        if (tmpDistance < shortest) {\n          // just keep the closest facet to (x, y, z)\n          shortest = tmpDistance;\n          closest = fib;\n\n          if (projected) {\n            projected.x = projx;\n            projected.y = projy;\n            projected.z = projz;\n          }\n        }\n      }\n    }\n\n    return closest;\n  };\n  /**\n   * Returns the object \"parameter\" set with all the expected parameters for facetData computation by ComputeNormals()\n   * @returns the parameters\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n   */\n\n\n  AbstractMesh.prototype.getFacetDataParameters = function () {\n    return this._internalAbstractMeshDataInfo._facetData.facetParameters;\n  };\n  /**\n   * Disables the feature FacetData and frees the related memory\n   * @returns the current mesh\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n   */\n\n\n  AbstractMesh.prototype.disableFacetData = function () {\n    var facetData = this._internalAbstractMeshDataInfo._facetData;\n\n    if (facetData.facetDataEnabled) {\n      facetData.facetDataEnabled = false;\n      facetData.facetPositions = new Array();\n      facetData.facetNormals = new Array();\n      facetData.facetPartitioning = new Array();\n      facetData.facetParameters = null;\n      facetData.depthSortedIndices = new Uint32Array(0);\n    }\n\n    return this;\n  };\n  /**\n   * Updates the AbstractMesh indices array\n   * @param indices defines the data source\n   * @param offset defines the offset in the index buffer where to store the new data (can be null)\n   * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\n   * @returns the current mesh\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  AbstractMesh.prototype.updateIndices = function (indices, offset, gpuMemoryOnly) {\n    if (gpuMemoryOnly === void 0) {\n      gpuMemoryOnly = false;\n    }\n\n    return this;\n  };\n  /**\n   * Creates new normals data for the mesh\n   * @param updatable defines if the normal vertex buffer must be flagged as updatable\n   * @returns the current mesh\n   */\n\n\n  AbstractMesh.prototype.createNormals = function (updatable) {\n    var positions = this.getVerticesData(VertexBuffer.PositionKind);\n    var indices = this.getIndices();\n    var normals;\n\n    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      normals = this.getVerticesData(VertexBuffer.NormalKind);\n    } else {\n      normals = [];\n    }\n\n    VertexData.ComputeNormals(positions, indices, normals, {\n      useRightHandedSystem: this.getScene().useRightHandedSystem\n    });\n    this.setVerticesData(VertexBuffer.NormalKind, normals, updatable);\n    return this;\n  };\n  /**\n   * Align the mesh with a normal\n   * @param normal defines the normal to use\n   * @param upDirection can be used to redefined the up vector to use (will use the (0, 1, 0) by default)\n   * @returns the current mesh\n   */\n\n\n  AbstractMesh.prototype.alignWithNormal = function (normal, upDirection) {\n    if (!upDirection) {\n      upDirection = Axis.Y;\n    }\n\n    var axisX = TmpVectors.Vector3[0];\n    var axisZ = TmpVectors.Vector3[1];\n    Vector3.CrossToRef(upDirection, normal, axisZ);\n    Vector3.CrossToRef(normal, axisZ, axisX);\n\n    if (this.rotationQuaternion) {\n      Quaternion.RotationQuaternionFromAxisToRef(axisX, normal, axisZ, this.rotationQuaternion);\n    } else {\n      Vector3.RotationFromAxisToRef(axisX, normal, axisZ, this.rotation);\n    }\n\n    return this;\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._checkOcclusionQuery = function () {\n    // Will be replaced by correct code if Occlusion queries are referenced\n    return false;\n  };\n  /**\n   * Disables the mesh edge rendering mode\n   * @returns the currentAbstractMesh\n   */\n\n\n  AbstractMesh.prototype.disableEdgesRendering = function () {\n    throw _WarnImport(\"EdgesRenderer\");\n  };\n  /**\n   * Enables the edge rendering mode on the mesh.\n   * This mode makes the mesh edges visible\n   * @param epsilon defines the maximal distance between two angles to detect a face\n   * @param checkVerticesInsteadOfIndices indicates that we should check vertex list directly instead of faces\n   * @param options options to the edge renderer\n   * @returns the currentAbstractMesh\n   * @see https://www.babylonjs-playground.com/#19O9TU#0\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  AbstractMesh.prototype.enableEdgesRendering = function (epsilon, checkVerticesInsteadOfIndices, options) {\n    throw _WarnImport(\"EdgesRenderer\");\n  };\n  /**\n   * This function returns all of the particle systems in the scene that use the mesh as an emitter.\n   * @returns an array of particle systems in the scene that use the mesh as an emitter\n   */\n\n\n  AbstractMesh.prototype.getConnectedParticleSystems = function () {\n    var _this = this;\n\n    return this._scene.particleSystems.filter(function (particleSystem) {\n      return particleSystem.emitter === _this;\n    });\n  };\n  /** No occlusion */\n\n\n  AbstractMesh.OCCLUSION_TYPE_NONE = 0;\n  /** Occlusion set to optimistic */\n\n  AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC = 1;\n  /** Occlusion set to strict */\n\n  AbstractMesh.OCCLUSION_TYPE_STRICT = 2;\n  /** Use an accurate occlusion algorithm */\n\n  AbstractMesh.OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0;\n  /** Use a conservative occlusion algorithm */\n\n  AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1;\n  /** Default culling strategy : this is an exclusion test and it's the more accurate.\n   *  Test order :\n   *  Is the bounding sphere outside the frustum ?\n   *  If not, are the bounding box vertices outside the frustum ?\n   *  It not, then the cullable object is in the frustum.\n   */\n\n  AbstractMesh.CULLINGSTRATEGY_STANDARD = 0;\n  /** Culling strategy : Bounding Sphere Only.\n   *  This is an exclusion test. It's faster than the standard strategy because the bounding box is not tested.\n   *  It's also less accurate than the standard because some not visible objects can still be selected.\n   *  Test : is the bounding sphere outside the frustum ?\n   *  If not, then the cullable object is in the frustum.\n   */\n\n  AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1;\n  /** Culling strategy : Optimistic Inclusion.\n   *  This in an inclusion test first, then the standard exclusion test.\n   *  This can be faster when a cullable object is expected to be almost always in the camera frustum.\n   *  This could also be a little slower than the standard test when the tested object center is not the frustum but one of its bounding box vertex is still inside.\n   *  Anyway, it's as accurate as the standard strategy.\n   *  Test :\n   *  Is the cullable object bounding sphere center in the frustum ?\n   *  If not, apply the default culling strategy.\n   */\n\n  AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2;\n  /** Culling strategy : Optimistic Inclusion then Bounding Sphere Only.\n   *  This in an inclusion test first, then the bounding sphere only exclusion test.\n   *  This can be the fastest test when a cullable object is expected to be almost always in the camera frustum.\n   *  This could also be a little slower than the BoundingSphereOnly strategy when the tested object center is not in the frustum but its bounding sphere still intersects it.\n   *  It's less accurate than the standard strategy and as accurate as the BoundingSphereOnly strategy.\n   *  Test :\n   *  Is the cullable object bounding sphere center in the frustum ?\n   *  If not, apply the Bounding Sphere Only strategy. No Bounding Box is tested here.\n   */\n\n  AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3;\n  return AbstractMesh;\n}(TransformNode);\n\nexport { AbstractMesh };\nRegisterClass(\"BABYLON.AbstractMesh\", AbstractMesh);","map":{"version":3,"mappings":"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","names":["Tools","Observable","Quaternion","Matrix","Vector3","TmpVectors","Engine","VertexBuffer","VertexData","TransformNode","PickingInfo","BoundingInfo","UniformBuffer","_MeshCollisionData","_WarnImport","extractMinAndMax","Color3","Color4","Epsilon","Axis","RegisterClass","Zero","max","X","Y","Z","_FacetDataStorage","__extends","name","scene","_super","_this","_InternalAbstractMeshDataInfo","AbstractMesh","CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY","Number","MAX_VALUE","Red","Array","lods","actions","freezeWorldMatrix","collisionId","newPosition","collidedMesh","subtractToRef","_internalAbstractMeshDataInfo","_meshCollisionData","_oldPositionForCollisions","_diffPositionForCollisions","length","CollisionsEpsilon","position","addInPlace","onCollideObservable","notifyObservers","onCollisionPositionChangeObservable","getScene","addMesh","_resyncLightSources","_uniformBuffer","getEngine","undefined","isWebGPU","_buildUniformLayout","Object","BILLBOARDMODE_NONE","BILLBOARDMODE_X","BILLBOARDMODE_Y","BILLBOARDMODE_Z","BILLBOARDMODE_ALL","BILLBOARDMODE_USE_POSITION","_facetData","facetNb","partitioningSubdivisions","nb","partitioningBBoxRatio","ratio","facetDepthSort","sort","facetDepthSortFrom","location","_collisionRetryCount","retryCount","facetDataEnabled","_morphTargetManager","value","_syncGeometryWithMorphTargetManager","_bakedVertexAnimationManager","_markSubMeshesAsAttributesDirty","_updateNonUniformScalingState","call","_markSubMeshesAsMiscDirty","callback","_onCollideObserver","remove","add","_onCollisionPositionChangeObserver","_visibility","oldValue","_renderingGroupId","_material","meshMap","uniqueId","onMaterialChangedObservable","hasObservers","subMeshes","resetDrawCache","_unBindEffect","renderPassId","_materialForRenderPass","_a","material","_receiveShadows","_markSubMeshesAsLightDirty","_hasVertexAlpha","_useVertexColors","_computeBonesUsingShaders","_numBoneInfluencers","_applyFog","_enableDistantPicking","_layerMask","_collisionMask","mask","isNaN","_collisionResponse","response","_collisionGroup","_surroundingMeshes","meshes","_lightSources","_skeleton","skeleton","needInitialSkinMatrix","_unregisterMeshWithPoseMatrix","_registerMeshWithPoseMatrix","_bonesTransformMatrices","addUniform","create","world","ubo","updateMatrix","updateFloat","update","fullDetails","ret","getClassName","billboardMode","_isWorldMatrixFrozen","_waitingData","_masterMesh","_getEffectiveParent","trigger","initialCall","actionManager","isRecursive","hasSpecificTrigger","parent","_getActionManagerForTrigger","dispose","onRebuildObservable","_occlusionQuery","_i","subMesh","_rebuild","lights","light","isEnabled","canAffectMesh","push","isIn","index","indexOf","removed","splice","setEffect","func","i","_drawWrappers","drawWrapper","defines","markAllAsDirty","_markSubMeshesAsDirty","markAsLightDirty","markAsAttributesDirty","markAsMiscDirty","property","_currentRenderId","_isDirty","passId","_scaling","newScaling","camera","kind","data","updatable","stride","updateExtends","makeItUnique","indices","totalVertices","getBoundingInfo","_boundingInfoIsDirty","_updateBoundingInfo","_boundingInfo","boundingInfo","minimum","maximum","worldMatrix","includeDescendants","ignoreRotation","predicate","normalizeToUnitCube","skeletonsEnabled","isVerticesDataPresent","MatricesIndicesKind","MatricesWeightsKind","renderId","intermediateRendering","_renderId","getWorldMatrix","_getWorldMatrixDeterminant","amountRight","amountUp","amountForward","calcMovePOV","rotMatrix","rotQuaternion","rotationQuaternion","RotationYawPitchRoll","rotation","y","x","z","toRotationMatrix","translationDelta","defForwardMult","definedFacingForward","TransformCoordinatesFromFloatsToRef","flipBack","twirlClockwise","tiltRight","calcRotatePOV","applySkeleton","applyMorph","isLocked","_refreshBoundingInfo","_getPositionData","bias","extend","getTotalVertices","reConstruct","refreshBoundingInfo","Slice","getVerticesData","PositionKind","morphTargetManager","faceIndexCount","positionIndex","vertexCount","targetCount","numTargets","targetMorph","getTarget","influence","morphTargetPositions","getPositions","_positions","copyFromFloats","matricesIndicesData","matricesWeightsData","needExtras","numBoneInfluencers","matricesIndicesExtraData","MatricesIndicesExtraKind","matricesWeightsExtraData","MatricesWeightsExtraKind","skeletonMatrices","getTransformMatrices","tempVector","finalMatrix","tempMatrix","matWeightIdx","reset","inf","weight","FromFloat32ArrayToRefScaled","Math","floor","addToSelf","toArray","copyFrom","_generatePointsArray","pos","clone","getPositionData","worldMatrixFromCache","_updateSubMeshesBoundingInfo","matrix","count","subIndex","IsGlobal","updateBoundingInfo","doNotSyncBoundingInfo","frustumPlanes","isInFrustum","cullingStrategy","isCompletelyInFrustum","mesh","precise","otherBoundingInfo","intersects","getChildMeshes","child","intersectsMesh","point","intersectsPoint","_checkCollisions","collisionEnabled","_collider","displacement","globalPosition","getAbsolutePosition","addToRef","ellipsoidOffset","coordinator","collisionCoordinator","createCollider","_radius","ellipsoid","getNewPosition","collisionRetryCount","_onCollisionPositionChange","transformMatrix","collider","_lastColliderWorldVertices","_lastColliderTransformMatrix","equals","_trianglePlanes","start","verticesStart","end","verticesCount","TransformCoordinates","_collide","getIndices","indexStart","indexCount","getMaterial","_shouldConvertRHS","fillMode","_scene","getCollidingSubMeshCandidates","len","_checkCollision","_collideForSubMesh","collisionsScalingMatrix","collisionsTransformMatrix","ScalingToRef","multiplyToRef","_processCollisionsForSubMeshes","ray","fastCheck","trianglePredicate","onlyBoundingInfo","worldToUse","skipBoundingInfo","pickingInfo","intersectionThreshold","intersectsSphere","boundingSphere","intersectsBox","boundingBox","hit","pickedMesh","distance","Distance","origin","center","subMeshId","intersectInfo","getIntersectingSubMeshCandidates","anySubmeshSupportIntersect","canIntersects","currentIntersectInfo","worldOrigin","direction","TransformCoordinatesToRef","scaleToRef","worldDirection","TransformNormal","pickedPoint","bu","bv","subMeshFaceId","faceId","newParent","doNotCloneChildren","doNotRecurse","disposeMaterialAndTextures","useMaterialMeshMap","freeActiveMeshes","freeRenderingGroups","_transformMatrixTexture","_intersectionsInProgress","other","forEach","meshIndex","includedOnlyMeshes","excludedMeshes","generator","getShadowGenerator","shadowMap","getShadowMap","renderList","releaseSubMeshes","engine","isOcclusionQueryInProgress","deleteQuery","wipeCaches","removeMesh","_parentContainer","index_1","particleSystems","emitter","disableFacetData","onAfterWorldMatrixUpdateObservable","clear","preserveScalingSign","setParent","facetNormals","facetPositions","facetPartitioning","f","_initFacetData","positions","normals","NormalKind","bInfo","facetDepthSortEnabled","Uint16Array","depthSortedIndices","Uint32Array","needs32bits","facetDepthSortFunction","f1","f2","sqDistance","activeCamera","depthSortedFacets","depthSortedFacet","ind","invertedMatrix","Identity","facetDepthSortOrigin","bbSize","bbSizeMax","subDiv","facetParameters","getFacetLocalNormals","getFacetLocalPositions","getFacetLocalPartitioning","depthSort","computeWorldMatrix","_worldMatrix","invertToRef","distanceTo","ComputeNormals","l","sind","updateIndices","facetData","updateFacetData","getFacetPositionToRef","ref","localPos","norm","getFacetNormalToRef","localNorm","TransformNormalToRef","ox","oy","oz","projected","checkFace","facing","invMat","invVect","closest","getClosestFacetAtLocalCoordinates","tmpx","tmpy","tmpz","d","t0","projx","projy","projz","facetsInBlock","getFacetsAtLocalCoordinates","shortest","tmpDistance","fib","p0","idx","offset","gpuMemoryOnly","useRightHandedSystem","setVerticesData","normal","upDirection","axisX","axisZ","CrossToRef","RotationQuaternionFromAxisToRef","RotationFromAxisToRef","epsilon","checkVerticesInsteadOfIndices","options","filter","particleSystem"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/abstractMesh.ts"],"sourcesContent":["import { Tools } from \"../Misc/tools\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable, FloatArray, IndicesArray, DeepImmutable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport type { Vector2 } from \"../Maths/math.vector\";\r\nimport { Quaternion, Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport type { Node } from \"../node\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { IGetSetVerticesData } from \"../Meshes/mesh.vertexData\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport type { ICullable } from \"../Culling/boundingInfo\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { MaterialDefines } from \"../Materials/materialDefines\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport type { MorphTargetManager } from \"../Morph/morphTargetManager\";\r\nimport type { IBakedVertexAnimationManager } from \"../BakedVertexAnimation/bakedVertexAnimationManager\";\r\nimport type { IEdgesRenderer } from \"../Rendering/edgesRenderer\";\r\nimport type { SolidParticle } from \"../Particles/solidParticle\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { AbstractActionManager } from \"../Actions/abstractActionManager\";\r\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport { _MeshCollisionData } from \"../Collisions/meshCollisionData\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport { extractMinAndMax } from \"../Maths/math.functions\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\nimport type { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\ndeclare type Ray = import(\"../Culling/ray\").Ray;\r\ndeclare type Collider = import(\"../Collisions/collider\").Collider;\r\ndeclare type TrianglePickingPredicate = import(\"../Culling/ray\").TrianglePickingPredicate;\r\ndeclare type RenderingGroup = import(\"../Rendering/renderingGroup\").RenderingGroup;\r\ndeclare type IEdgesRendererOptions = import(\"../Rendering/edgesRenderer\").IEdgesRendererOptions;\r\n\r\n/** @hidden */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nclass _FacetDataStorage {\r\n    // facetData private properties\r\n    public facetPositions: Vector3[]; // facet local positions\r\n    public facetNormals: Vector3[]; // facet local normals\r\n    public facetPartitioning: number[][]; // partitioning array of facet index arrays\r\n    public facetNb: number = 0; // facet number\r\n    public partitioningSubdivisions: number = 10; // number of subdivisions per axis in the partitioning space\r\n    public partitioningBBoxRatio: number = 1.01; // the partitioning array space is by default 1% bigger than the bounding box\r\n    public facetDataEnabled: boolean = false; // is the facet data feature enabled on this mesh ?\r\n    public facetParameters: any = {}; // keep a reference to the object parameters to avoid memory re-allocation\r\n    public bbSize: Vector3 = Vector3.Zero(); // bbox size approximated for facet data\r\n    public subDiv = {\r\n        // actual number of subdivisions per axis for ComputeNormals()\r\n        max: 1,\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        X: 1,\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        Y: 1,\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        Z: 1,\r\n    };\r\n\r\n    public facetDepthSort: boolean = false; // is the facet depth sort to be computed\r\n    public facetDepthSortEnabled: boolean = false; // is the facet depth sort initialized\r\n    public depthSortedIndices: IndicesArray; // copy of the indices array to store them once sorted\r\n    public depthSortedFacets: { ind: number; sqDistance: number }[]; // array of depth sorted facets\r\n    public facetDepthSortFunction: (f1: { ind: number; sqDistance: number }, f2: { ind: number; sqDistance: number }) => number; // facet depth sort function\r\n    public facetDepthSortFrom: Vector3; // location where to depth sort from\r\n    public facetDepthSortOrigin: Vector3; // same as facetDepthSortFrom but expressed in the mesh local space\r\n\r\n    public invertedMatrix: Matrix; // Inverted world matrix.\r\n}\r\n\r\n/**\r\n * @hidden\r\n **/\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nclass _InternalAbstractMeshDataInfo {\r\n    public _hasVertexAlpha = false;\r\n    public _useVertexColors = true;\r\n    public _numBoneInfluencers = 4;\r\n    public _applyFog = true;\r\n    public _receiveShadows = false;\r\n    public _facetData = new _FacetDataStorage();\r\n    public _visibility = 1.0;\r\n    public _skeleton: Nullable<Skeleton> = null;\r\n    public _layerMask: number = 0x0fffffff;\r\n    public _computeBonesUsingShaders = true;\r\n    public _isActive = false;\r\n    public _onlyForInstances = false;\r\n    public _isActiveIntermediate = false;\r\n    public _onlyForInstancesIntermediate = false;\r\n    public _actAsRegularMesh = false;\r\n    public _currentLOD: Nullable<AbstractMesh> = null;\r\n    public _currentLODIsUpToDate: boolean = false;\r\n    public _collisionRetryCount: number = 3;\r\n    public _morphTargetManager: Nullable<MorphTargetManager> = null;\r\n    public _renderingGroupId = 0;\r\n    public _bakedVertexAnimationManager: Nullable<IBakedVertexAnimationManager> = null;\r\n    public _material: Nullable<Material> = null;\r\n    public _materialForRenderPass: Array<Material | undefined>; // map a render pass id (index in the array) to a Material\r\n    public _positions: Nullable<Vector3[]> = null;\r\n    // Collisions\r\n    public _meshCollisionData = new _MeshCollisionData();\r\n    public _enableDistantPicking = false;\r\n}\r\n\r\n/**\r\n * Class used to store all common mesh properties\r\n */\r\nexport class AbstractMesh extends TransformNode implements IDisposable, ICullable, IGetSetVerticesData {\r\n    /** No occlusion */\r\n    public static OCCLUSION_TYPE_NONE = 0;\r\n    /** Occlusion set to optimistic */\r\n    public static OCCLUSION_TYPE_OPTIMISTIC = 1;\r\n    /** Occlusion set to strict */\r\n    public static OCCLUSION_TYPE_STRICT = 2;\r\n    /** Use an accurate occlusion algorithm */\r\n    public static OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0;\r\n    /** Use a conservative occlusion algorithm */\r\n    public static OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1;\r\n\r\n    /** Default culling strategy : this is an exclusion test and it's the more accurate.\r\n     *  Test order :\r\n     *  Is the bounding sphere outside the frustum ?\r\n     *  If not, are the bounding box vertices outside the frustum ?\r\n     *  It not, then the cullable object is in the frustum.\r\n     */\r\n    public static readonly CULLINGSTRATEGY_STANDARD = Constants.MESHES_CULLINGSTRATEGY_STANDARD;\r\n    /** Culling strategy : Bounding Sphere Only.\r\n     *  This is an exclusion test. It's faster than the standard strategy because the bounding box is not tested.\r\n     *  It's also less accurate than the standard because some not visible objects can still be selected.\r\n     *  Test : is the bounding sphere outside the frustum ?\r\n     *  If not, then the cullable object is in the frustum.\r\n     */\r\n    public static readonly CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = Constants.MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;\r\n    /** Culling strategy : Optimistic Inclusion.\r\n     *  This in an inclusion test first, then the standard exclusion test.\r\n     *  This can be faster when a cullable object is expected to be almost always in the camera frustum.\r\n     *  This could also be a little slower than the standard test when the tested object center is not the frustum but one of its bounding box vertex is still inside.\r\n     *  Anyway, it's as accurate as the standard strategy.\r\n     *  Test :\r\n     *  Is the cullable object bounding sphere center in the frustum ?\r\n     *  If not, apply the default culling strategy.\r\n     */\r\n    public static readonly CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION;\r\n    /** Culling strategy : Optimistic Inclusion then Bounding Sphere Only.\r\n     *  This in an inclusion test first, then the bounding sphere only exclusion test.\r\n     *  This can be the fastest test when a cullable object is expected to be almost always in the camera frustum.\r\n     *  This could also be a little slower than the BoundingSphereOnly strategy when the tested object center is not in the frustum but its bounding sphere still intersects it.\r\n     *  It's less accurate than the standard strategy and as accurate as the BoundingSphereOnly strategy.\r\n     *  Test :\r\n     *  Is the cullable object bounding sphere center in the frustum ?\r\n     *  If not, apply the Bounding Sphere Only strategy. No Bounding Box is tested here.\r\n     */\r\n    public static readonly CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY;\r\n\r\n    /**\r\n     * No billboard\r\n     */\r\n    public static get BILLBOARDMODE_NONE(): number {\r\n        return TransformNode.BILLBOARDMODE_NONE;\r\n    }\r\n\r\n    /** Billboard on X axis */\r\n    public static get BILLBOARDMODE_X(): number {\r\n        return TransformNode.BILLBOARDMODE_X;\r\n    }\r\n\r\n    /** Billboard on Y axis */\r\n    public static get BILLBOARDMODE_Y(): number {\r\n        return TransformNode.BILLBOARDMODE_Y;\r\n    }\r\n\r\n    /** Billboard on Z axis */\r\n    public static get BILLBOARDMODE_Z(): number {\r\n        return TransformNode.BILLBOARDMODE_Z;\r\n    }\r\n\r\n    /** Billboard on all axes */\r\n    public static get BILLBOARDMODE_ALL(): number {\r\n        return TransformNode.BILLBOARDMODE_ALL;\r\n    }\r\n\r\n    /** Billboard on using position instead of orientation */\r\n    public static get BILLBOARDMODE_USE_POSITION(): number {\r\n        return TransformNode.BILLBOARDMODE_USE_POSITION;\r\n    }\r\n\r\n    // Internal data\r\n    /** @hidden */\r\n    public _internalAbstractMeshDataInfo = new _InternalAbstractMeshDataInfo();\r\n\r\n    /** @hidden */\r\n    public _waitingMaterialId: Nullable<string> = null;\r\n\r\n    /**\r\n     * The culling strategy to use to check whether the mesh must be rendered or not.\r\n     * This value can be changed at any time and will be used on the next render mesh selection.\r\n     * The possible values are :\r\n     * - AbstractMesh.CULLINGSTRATEGY_STANDARD\r\n     * - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\r\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\r\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\r\n     * Please read each static variable documentation to get details about the culling process.\r\n     * */\r\n    public cullingStrategy = AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;\r\n\r\n    /**\r\n     * Gets the number of facets in the mesh\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#what-is-a-mesh-facet\r\n     */\r\n    public get facetNb(): number {\r\n        return this._internalAbstractMeshDataInfo._facetData.facetNb;\r\n    }\r\n    /**\r\n     * Gets or set the number (integer) of subdivisions per axis in the partitioning space\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#tweaking-the-partitioning\r\n     */\r\n    public get partitioningSubdivisions(): number {\r\n        return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions;\r\n    }\r\n    public set partitioningSubdivisions(nb: number) {\r\n        this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions = nb;\r\n    }\r\n    /**\r\n     * The ratio (float) to apply to the bounding box size to set to the partitioning space.\r\n     * Ex : 1.01 (default) the partitioning space is 1% bigger than the bounding box\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#tweaking-the-partitioning\r\n     */\r\n    public get partitioningBBoxRatio(): number {\r\n        return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio;\r\n    }\r\n    public set partitioningBBoxRatio(ratio: number) {\r\n        this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio = ratio;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the facets must be depth sorted on next call to `updateFacetData()`.\r\n     * Works only for updatable meshes.\r\n     * Doesn't work with multi-materials\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#facet-depth-sort\r\n     */\r\n    public get mustDepthSortFacets(): boolean {\r\n        return this._internalAbstractMeshDataInfo._facetData.facetDepthSort;\r\n    }\r\n    public set mustDepthSortFacets(sort: boolean) {\r\n        this._internalAbstractMeshDataInfo._facetData.facetDepthSort = sort;\r\n    }\r\n\r\n    /**\r\n     * The location (Vector3) where the facet depth sort must be computed from.\r\n     * By default, the active camera position.\r\n     * Used only when facet depth sort is enabled\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#facet-depth-sort\r\n     */\r\n    public get facetDepthSortFrom(): Vector3 {\r\n        return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom;\r\n    }\r\n    public set facetDepthSortFrom(location: Vector3) {\r\n        this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom = location;\r\n    }\r\n\r\n    /** number of collision detection tries. Change this value if not all collisions are detected and handled properly */\r\n    public get collisionRetryCount(): number {\r\n        return this._internalAbstractMeshDataInfo._collisionRetryCount;\r\n    }\r\n    public set collisionRetryCount(retryCount: number) {\r\n        this._internalAbstractMeshDataInfo._collisionRetryCount = retryCount;\r\n    }\r\n    /**\r\n     * gets a boolean indicating if facetData is enabled\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#what-is-a-mesh-facet\r\n     */\r\n    public get isFacetDataEnabled(): boolean {\r\n        return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the morph target manager\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_morphtargets\r\n     */\r\n    public get morphTargetManager(): Nullable<MorphTargetManager> {\r\n        return this._internalAbstractMeshDataInfo._morphTargetManager;\r\n    }\r\n\r\n    public set morphTargetManager(value: Nullable<MorphTargetManager>) {\r\n        if (this._internalAbstractMeshDataInfo._morphTargetManager === value) {\r\n            return;\r\n        }\r\n        this._internalAbstractMeshDataInfo._morphTargetManager = value;\r\n        this._syncGeometryWithMorphTargetManager();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the baked vertex animation manager\r\n     * @see https://doc.babylonjs.com/divingDeeper/animation/baked_texture_animations\r\n     */\r\n    public get bakedVertexAnimationManager(): Nullable<IBakedVertexAnimationManager> {\r\n        return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager;\r\n    }\r\n\r\n    public set bakedVertexAnimationManager(value: Nullable<IBakedVertexAnimationManager>) {\r\n        if (this._internalAbstractMeshDataInfo._bakedVertexAnimationManager === value) {\r\n            return;\r\n        }\r\n        this._internalAbstractMeshDataInfo._bakedVertexAnimationManager = value;\r\n        this._markSubMeshesAsAttributesDirty();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _syncGeometryWithMorphTargetManager(): void {}\r\n\r\n    /**\r\n     * @param value\r\n     * @hidden\r\n     */\r\n    public _updateNonUniformScalingState(value: boolean): boolean {\r\n        if (!super._updateNonUniformScalingState(value)) {\r\n            return false;\r\n        }\r\n        this._markSubMeshesAsMiscDirty();\r\n        return true;\r\n    }\r\n\r\n    // Events\r\n\r\n    /**\r\n     * An event triggered when this mesh collides with another one\r\n     */\r\n    public onCollideObservable = new Observable<AbstractMesh>();\r\n\r\n    /** Set a function to call when this mesh collides with another one */\r\n    public set onCollide(callback: (collidedMesh?: AbstractMesh) => void) {\r\n        if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver) {\r\n            this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver);\r\n        }\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver = this.onCollideObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the collision's position changes\r\n     */\r\n    public onCollisionPositionChangeObservable = new Observable<Vector3>();\r\n\r\n    /** Set a function to call when the collision's position changes */\r\n    public set onCollisionPositionChange(callback: () => void) {\r\n        if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver) {\r\n            this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver);\r\n        }\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when material is changed\r\n     */\r\n    public onMaterialChangedObservable = new Observable<AbstractMesh>();\r\n\r\n    // Properties\r\n\r\n    /**\r\n     * Gets or sets the orientation for POV movement & rotation\r\n     */\r\n    public definedFacingForward = true;\r\n\r\n    /** @hidden */\r\n    public _occlusionQuery: Nullable<WebGLQuery | number> = null;\r\n\r\n    /** @hidden */\r\n    public _renderingGroup: Nullable<RenderingGroup> = null;\r\n\r\n    /**\r\n     * Gets or sets mesh visibility between 0 and 1 (default is 1)\r\n     */\r\n    public get visibility(): number {\r\n        return this._internalAbstractMeshDataInfo._visibility;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets mesh visibility between 0 and 1 (default is 1)\r\n     */\r\n    public set visibility(value: number) {\r\n        if (this._internalAbstractMeshDataInfo._visibility === value) {\r\n            return;\r\n        }\r\n\r\n        const oldValue = this._internalAbstractMeshDataInfo._visibility;\r\n\r\n        this._internalAbstractMeshDataInfo._visibility = value;\r\n\r\n        if ((oldValue === 1 && value !== 1) || (oldValue !== 1 && value === 1)) {\r\n            this._markSubMeshesAsMiscDirty();\r\n        }\r\n    }\r\n\r\n    /** Gets or sets the alpha index used to sort transparent meshes\r\n     * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#alpha-index\r\n     */\r\n    public alphaIndex = Number.MAX_VALUE;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the mesh is visible (renderable). Default is true\r\n     */\r\n    public isVisible = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true\r\n     */\r\n    public isPickable = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the mesh can be near picked. Default is false\r\n     */\r\n    public isNearPickable = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the mesh can be near grabbed. Default is false\r\n     */\r\n    public isNearGrabbable = false;\r\n\r\n    /** Gets or sets a boolean indicating that bounding boxes of subMeshes must be rendered as well (false by default) */\r\n    public showSubMeshesBoundingBox = false;\r\n\r\n    /** Gets or sets a boolean indicating if the mesh must be considered as a ray blocker for lens flares (false by default)\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares\r\n     */\r\n    public isBlocker = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that pointer move events must be supported on this mesh (false by default)\r\n     */\r\n    public enablePointerMoveEvents = false;\r\n\r\n    /**\r\n     * Specifies the rendering group id for this mesh (0 by default)\r\n     * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#rendering-groups\r\n     */\r\n    public get renderingGroupId() {\r\n        return this._internalAbstractMeshDataInfo._renderingGroupId;\r\n    }\r\n\r\n    public set renderingGroupId(value: number) {\r\n        this._internalAbstractMeshDataInfo._renderingGroupId = value;\r\n    }\r\n\r\n    /** Gets or sets current material */\r\n    public get material(): Nullable<Material> {\r\n        return this._internalAbstractMeshDataInfo._material;\r\n    }\r\n    public set material(value: Nullable<Material>) {\r\n        if (this._internalAbstractMeshDataInfo._material === value) {\r\n            return;\r\n        }\r\n\r\n        // remove from material mesh map id needed\r\n        if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {\r\n            this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = undefined;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._material = value;\r\n\r\n        if (value && value.meshMap) {\r\n            value.meshMap[this.uniqueId] = this;\r\n        }\r\n\r\n        if (this.onMaterialChangedObservable.hasObservers()) {\r\n            this.onMaterialChangedObservable.notifyObservers(this);\r\n        }\r\n\r\n        if (!this.subMeshes) {\r\n            return;\r\n        }\r\n\r\n        this.resetDrawCache();\r\n        this._unBindEffect();\r\n    }\r\n\r\n    /**\r\n     * Gets the material used to render the mesh in a specific render pass\r\n     * @param renderPassId render pass id\r\n     * @returns material used for the render pass. If no specific material is used for this render pass, undefined is returned (meaning mesh.material is used for this pass)\r\n     */\r\n    public getMaterialForRenderPass(renderPassId: number): Material | undefined {\r\n        return this._internalAbstractMeshDataInfo._materialForRenderPass?.[renderPassId];\r\n    }\r\n\r\n    /**\r\n     * Sets the material to be used to render the mesh in a specific render pass\r\n     * @param renderPassId render pass id\r\n     * @param material material to use for this render pass. If undefined is passed, no specific material will be used for this render pass but the regular material will be used instead (mesh.material)\r\n     */\r\n    public setMaterialForRenderPass(renderPassId: number, material?: Material): void {\r\n        if (!this._internalAbstractMeshDataInfo._materialForRenderPass) {\r\n            this._internalAbstractMeshDataInfo._materialForRenderPass = [];\r\n        }\r\n        this._internalAbstractMeshDataInfo._materialForRenderPass[renderPassId] = material;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this mesh can receive realtime shadows\r\n     * @see https://doc.babylonjs.com/babylon101/shadows\r\n     */\r\n    public get receiveShadows(): boolean {\r\n        return this._internalAbstractMeshDataInfo._receiveShadows;\r\n    }\r\n    public set receiveShadows(value: boolean) {\r\n        if (this._internalAbstractMeshDataInfo._receiveShadows === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._receiveShadows = value;\r\n        this._markSubMeshesAsLightDirty();\r\n    }\r\n\r\n    /** Defines color to use when rendering outline */\r\n    public outlineColor = Color3.Red();\r\n    /** Define width to use when rendering outline */\r\n    public outlineWidth = 0.02;\r\n\r\n    /** Defines color to use when rendering overlay */\r\n    public overlayColor = Color3.Red();\r\n    /** Defines alpha to use when rendering overlay */\r\n    public overlayAlpha = 0.5;\r\n\r\n    /** Gets or sets a boolean indicating that this mesh contains vertex color data with alpha values */\r\n    public get hasVertexAlpha(): boolean {\r\n        return this._internalAbstractMeshDataInfo._hasVertexAlpha;\r\n    }\r\n    public set hasVertexAlpha(value: boolean) {\r\n        if (this._internalAbstractMeshDataInfo._hasVertexAlpha === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._hasVertexAlpha = value;\r\n        this._markSubMeshesAsAttributesDirty();\r\n        this._markSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating that this mesh needs to use vertex color data to render (if this kind of vertex data is available in the geometry) */\r\n    public get useVertexColors(): boolean {\r\n        return this._internalAbstractMeshDataInfo._useVertexColors;\r\n    }\r\n    public set useVertexColors(value: boolean) {\r\n        if (this._internalAbstractMeshDataInfo._useVertexColors === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._useVertexColors = value;\r\n        this._markSubMeshesAsAttributesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that bone animations must be computed by the CPU (false by default)\r\n     */\r\n    public get computeBonesUsingShaders(): boolean {\r\n        return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;\r\n    }\r\n    public set computeBonesUsingShaders(value: boolean) {\r\n        if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;\r\n        this._markSubMeshesAsAttributesDirty();\r\n    }\r\n\r\n    /** Gets or sets the number of allowed bone influences per vertex (4 by default) */\r\n    public get numBoneInfluencers(): number {\r\n        return this._internalAbstractMeshDataInfo._numBoneInfluencers;\r\n    }\r\n    public set numBoneInfluencers(value: number) {\r\n        if (this._internalAbstractMeshDataInfo._numBoneInfluencers === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._numBoneInfluencers = value;\r\n        this._markSubMeshesAsAttributesDirty();\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating that this mesh will allow fog to be rendered on it (true by default) */\r\n    public get applyFog(): boolean {\r\n        return this._internalAbstractMeshDataInfo._applyFog;\r\n    }\r\n    public set applyFog(value: boolean) {\r\n        if (this._internalAbstractMeshDataInfo._applyFog === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._applyFog = value;\r\n        this._markSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    /** When enabled, decompose picking matrices for better precision with large values for mesh position and scling */\r\n    public get enableDistantPicking(): boolean {\r\n        return this._internalAbstractMeshDataInfo._enableDistantPicking;\r\n    }\r\n    public set enableDistantPicking(value: boolean) {\r\n        this._internalAbstractMeshDataInfo._enableDistantPicking = value;\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes selection (true by default) */\r\n    public useOctreeForRenderingSelection = true;\r\n    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes picking (true by default) */\r\n    public useOctreeForPicking = true;\r\n    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes collision (true by default) */\r\n    public useOctreeForCollisions = true;\r\n    /**\r\n     * Gets or sets the current layer mask (default is 0x0FFFFFFF)\r\n     * @see https://doc.babylonjs.com/divingDeeper/cameras/layerMasksAndMultiCam\r\n     */\r\n    public get layerMask(): number {\r\n        return this._internalAbstractMeshDataInfo._layerMask;\r\n    }\r\n\r\n    public set layerMask(value: number) {\r\n        if (value === this._internalAbstractMeshDataInfo._layerMask) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._layerMask = value;\r\n        this._resyncLightSources();\r\n    }\r\n\r\n    /**\r\n     * True if the mesh must be rendered in any case (this will shortcut the frustum clipping phase)\r\n     */\r\n    public alwaysSelectAsActiveMesh = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the bounding info does not need to be kept in sync (for performance reason)\r\n     */\r\n    public doNotSyncBoundingInfo = false;\r\n\r\n    /**\r\n     * Gets or sets the current action manager\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions\r\n     */\r\n    public actionManager: Nullable<AbstractActionManager> = null;\r\n\r\n    /**\r\n     * Gets or sets the ellipsoid used to impersonate this mesh when using collision engine (default is (0.5, 1, 0.5))\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n     */\r\n    public ellipsoid = new Vector3(0.5, 1, 0.5);\r\n    /**\r\n     * Gets or sets the ellipsoid offset used to impersonate this mesh when using collision engine (default is (0, 0, 0))\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n     */\r\n    public ellipsoidOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Gets or sets a collision mask used to mask collisions (default is -1).\r\n     * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0\r\n     */\r\n    public get collisionMask(): number {\r\n        return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask;\r\n    }\r\n\r\n    public set collisionMask(mask: number) {\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a collision response flag (default is true).\r\n     * when collisionResponse is false, events are still triggered but colliding entity has no response\r\n     * This helps creating trigger volume when user wants collision feedback events but not position/velocity\r\n     * to respond to the collision.\r\n     */\r\n    public get collisionResponse(): boolean {\r\n        return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse;\r\n    }\r\n\r\n    public set collisionResponse(response: boolean) {\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse = response;\r\n    }\r\n    /**\r\n     * Gets or sets the current collision group mask (-1 by default).\r\n     * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0\r\n     */\r\n    public get collisionGroup(): number {\r\n        return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup;\r\n    }\r\n\r\n    public set collisionGroup(mask: number) {\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets current surrounding meshes (null by default).\r\n     *\r\n     * By default collision detection is tested against every mesh in the scene.\r\n     * It is possible to set surroundingMeshes to a defined list of meshes and then only these specified\r\n     * meshes will be tested for the collision.\r\n     *\r\n     * Note: if set to an empty array no collision will happen when this mesh is moved.\r\n     */\r\n    public get surroundingMeshes(): Nullable<AbstractMesh[]> {\r\n        return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes;\r\n    }\r\n\r\n    public set surroundingMeshes(meshes: Nullable<AbstractMesh[]>) {\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes = meshes;\r\n    }\r\n\r\n    // Edges\r\n    /**\r\n     * Defines edge width used when edgesRenderer is enabled\r\n     * @see https://www.babylonjs-playground.com/#10OJSG#13\r\n     */\r\n    public edgesWidth = 1;\r\n    /**\r\n     * Defines edge color used when edgesRenderer is enabled\r\n     * @see https://www.babylonjs-playground.com/#10OJSG#13\r\n     */\r\n    public edgesColor = new Color4(1, 0, 0, 1);\r\n    /** @hidden */\r\n    public _edgesRenderer: Nullable<IEdgesRenderer> = null;\r\n\r\n    /** @hidden */\r\n    public _masterMesh: Nullable<AbstractMesh> = null;\r\n    private _boundingInfo: Nullable<BoundingInfo> = null;\r\n    private _boundingInfoIsDirty = true;\r\n    /** @hidden */\r\n    public _renderId = 0;\r\n\r\n    /**\r\n     * Gets or sets the list of subMeshes\r\n     * @see https://doc.babylonjs.com/how_to/multi_materials\r\n     */\r\n    public subMeshes: SubMesh[];\r\n\r\n    /** @hidden */\r\n    public _intersectionsInProgress = new Array<AbstractMesh>();\r\n\r\n    /** @hidden */\r\n    public _unIndexed = false;\r\n\r\n    /** @hidden */\r\n    public _lightSources = new Array<Light>();\r\n\r\n    /** Gets the list of lights affecting that mesh */\r\n    public get lightSources(): Light[] {\r\n        return this._lightSources;\r\n    }\r\n\r\n    /** @hidden */\r\n    public get _positions(): Nullable<Vector3[]> {\r\n        return null;\r\n    }\r\n\r\n    // Loading properties\r\n    /** @hidden */\r\n    public _waitingData: {\r\n        lods: Nullable<any>;\r\n        actions: Nullable<any>;\r\n        freezeWorldMatrix: Nullable<boolean>;\r\n    } = {\r\n        lods: null,\r\n        actions: null,\r\n        freezeWorldMatrix: null,\r\n    };\r\n\r\n    /** @hidden */\r\n    public _bonesTransformMatrices: Nullable<Float32Array> = null;\r\n\r\n    /** @hidden */\r\n    public _transformMatrixTexture: Nullable<RawTexture> = null;\r\n\r\n    /**\r\n     * Gets or sets a skeleton to apply skinning transformations\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons\r\n     */\r\n    public set skeleton(value: Nullable<Skeleton>) {\r\n        const skeleton = this._internalAbstractMeshDataInfo._skeleton;\r\n        if (skeleton && skeleton.needInitialSkinMatrix) {\r\n            skeleton._unregisterMeshWithPoseMatrix(this);\r\n        }\r\n\r\n        if (value && value.needInitialSkinMatrix) {\r\n            value._registerMeshWithPoseMatrix(this);\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._skeleton = value;\r\n\r\n        if (!this._internalAbstractMeshDataInfo._skeleton) {\r\n            this._bonesTransformMatrices = null;\r\n        }\r\n\r\n        this._markSubMeshesAsAttributesDirty();\r\n    }\r\n\r\n    public get skeleton(): Nullable<Skeleton> {\r\n        return this._internalAbstractMeshDataInfo._skeleton;\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the mesh is rebuilt.\r\n     */\r\n    public onRebuildObservable = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * The current mesh uniform buffer.\r\n     * @hidden Internal use only.\r\n     */\r\n    public _uniformBuffer: UniformBuffer;\r\n\r\n    // Constructor\r\n\r\n    /**\r\n     * Creates a new AbstractMesh\r\n     * @param name defines the name of the mesh\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(name: string, scene: Nullable<Scene> = null) {\r\n        super(name, scene, false);\r\n\r\n        this.getScene().addMesh(this);\r\n\r\n        this._resyncLightSources();\r\n\r\n        // Mesh Uniform Buffer.\r\n        this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), undefined, undefined, name, !this.getScene().getEngine().isWebGPU);\r\n        this._buildUniformLayout();\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"world\", 16);\r\n        this._uniformBuffer.addUniform(\"visibility\", 1);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Transfer the mesh values to its UBO.\r\n     * @param world The world matrix associated with the mesh\r\n     */\r\n    public transferToEffect(world: Matrix): void {\r\n        const ubo = this._uniformBuffer;\r\n\r\n        ubo.updateMatrix(\"world\", world);\r\n        ubo.updateFloat(\"visibility\", this._internalAbstractMeshDataInfo._visibility);\r\n\r\n        ubo.update();\r\n    }\r\n\r\n    /**\r\n     * Gets the mesh uniform buffer.\r\n     * @return the uniform buffer of the mesh.\r\n     */\r\n    public getMeshUniformBuffer(): UniformBuffer {\r\n        return this._uniformBuffer;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"AbstractMesh\"\r\n     * @returns \"AbstractMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"AbstractMesh\";\r\n    }\r\n\r\n    /**\r\n     * Gets a string representation of the current mesh\r\n     * @param fullDetails defines a boolean indicating if full details must be included\r\n     * @returns a string representation of the current mesh\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name + \", isInstance: \" + (this.getClassName() !== \"InstancedMesh\" ? \"YES\" : \"NO\");\r\n        ret += \", # of submeshes: \" + (this.subMeshes ? this.subMeshes.length : 0);\r\n\r\n        const skeleton = this._internalAbstractMeshDataInfo._skeleton;\r\n        if (skeleton) {\r\n            ret += \", skeleton: \" + skeleton.name;\r\n        }\r\n        if (fullDetails) {\r\n            ret += \", billboard mode: \" + [\"NONE\", \"X\", \"Y\", null, \"Z\", null, null, \"ALL\"][this.billboardMode];\r\n            ret += \", freeze wrld mat: \" + (this._isWorldMatrixFrozen || this._waitingData.freezeWorldMatrix ? \"YES\" : \"NO\");\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    protected _getEffectiveParent(): Nullable<Node> {\r\n        if (this._masterMesh && this.billboardMode !== TransformNode.BILLBOARDMODE_NONE) {\r\n            return this._masterMesh;\r\n        }\r\n\r\n        return super._getEffectiveParent();\r\n    }\r\n\r\n    /**\r\n     * @param trigger\r\n     * @param initialCall\r\n     * @hidden\r\n     */\r\n    public _getActionManagerForTrigger(trigger?: number, initialCall = true): Nullable<AbstractActionManager> {\r\n        if (this.actionManager && (initialCall || this.actionManager.isRecursive)) {\r\n            if (trigger) {\r\n                if (this.actionManager.hasSpecificTrigger(trigger)) {\r\n                    return this.actionManager;\r\n                }\r\n            } else {\r\n                return this.actionManager;\r\n            }\r\n        }\r\n\r\n        if (!this.parent) {\r\n            return null;\r\n        }\r\n\r\n        return this.parent._getActionManagerForTrigger(trigger, false);\r\n    }\r\n\r\n    /**\r\n     * @param dispose\r\n     * @hidden\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public _rebuild(dispose = false): void {\r\n        this.onRebuildObservable.notifyObservers(this);\r\n\r\n        if (this._occlusionQuery !== null) {\r\n            this._occlusionQuery = null;\r\n        }\r\n\r\n        if (!this.subMeshes) {\r\n            return;\r\n        }\r\n\r\n        for (const subMesh of this.subMeshes) {\r\n            subMesh._rebuild();\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _resyncLightSources(): void {\r\n        this._lightSources.length = 0;\r\n\r\n        for (const light of this.getScene().lights) {\r\n            if (!light.isEnabled()) {\r\n                continue;\r\n            }\r\n\r\n            if (light.canAffectMesh(this)) {\r\n                this._lightSources.push(light);\r\n            }\r\n        }\r\n\r\n        this._markSubMeshesAsLightDirty();\r\n    }\r\n\r\n    /**\r\n     * @param light\r\n     * @hidden\r\n     */\r\n    public _resyncLightSource(light: Light): void {\r\n        const isIn = light.isEnabled() && light.canAffectMesh(this);\r\n\r\n        const index = this._lightSources.indexOf(light);\r\n        let removed = false;\r\n        if (index === -1) {\r\n            if (!isIn) {\r\n                return;\r\n            }\r\n            this._lightSources.push(light);\r\n        } else {\r\n            if (isIn) {\r\n                return;\r\n            }\r\n            removed = true;\r\n            this._lightSources.splice(index, 1);\r\n        }\r\n\r\n        this._markSubMeshesAsLightDirty(removed);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _unBindEffect() {\r\n        for (const subMesh of this.subMeshes) {\r\n            subMesh.setEffect(null);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param light\r\n     * @param dispose\r\n     * @hidden\r\n     */\r\n    public _removeLightSource(light: Light, dispose: boolean): void {\r\n        const index = this._lightSources.indexOf(light);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n        this._lightSources.splice(index, 1);\r\n\r\n        this._markSubMeshesAsLightDirty(dispose);\r\n    }\r\n\r\n    private _markSubMeshesAsDirty(func: (defines: MaterialDefines) => void) {\r\n        if (!this.subMeshes) {\r\n            return;\r\n        }\r\n\r\n        for (const subMesh of this.subMeshes) {\r\n            for (let i = 0; i < subMesh._drawWrappers.length; ++i) {\r\n                const drawWrapper = subMesh._drawWrappers[i];\r\n                if (!drawWrapper || !drawWrapper.defines || !(drawWrapper.defines as MaterialDefines).markAllAsDirty) {\r\n                    continue;\r\n                }\r\n                func(drawWrapper.defines as MaterialDefines);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param dispose\r\n     * @hidden\r\n     */\r\n    public _markSubMeshesAsLightDirty(dispose: boolean = false) {\r\n        this._markSubMeshesAsDirty((defines) => defines.markAsLightDirty(dispose));\r\n    }\r\n\r\n    /** @hidden */\r\n    public _markSubMeshesAsAttributesDirty() {\r\n        this._markSubMeshesAsDirty((defines) => defines.markAsAttributesDirty());\r\n    }\r\n\r\n    /** @hidden */\r\n    public _markSubMeshesAsMiscDirty() {\r\n        this._markSubMeshesAsDirty((defines) => defines.markAsMiscDirty());\r\n    }\r\n\r\n    /**\r\n     * Flag the AbstractMesh as dirty (Forcing it to update everything)\r\n     * @param property if set to \"rotation\" the objects rotationQuaternion will be set to null\r\n     * @returns this AbstractMesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public markAsDirty(property?: string): AbstractMesh {\r\n        this._currentRenderId = Number.MAX_VALUE;\r\n        this._isDirty = true;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache for all submeshes of this abstract mesh\r\n     * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\r\n     */\r\n    public resetDrawCache(passId?: number): void {\r\n        if (!this.subMeshes) {\r\n            return;\r\n        }\r\n\r\n        for (const subMesh of this.subMeshes) {\r\n            subMesh.resetDrawCache(passId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a Vector3 depicting the mesh scaling along each local axis X, Y, Z.  Default is (1.0, 1.0, 1.0)\r\n     */\r\n    public get scaling(): Vector3 {\r\n        return this._scaling;\r\n    }\r\n\r\n    public set scaling(newScaling: Vector3) {\r\n        this._scaling = newScaling;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Returns true if the mesh is blocked. Implemented by child classes\r\n     */\r\n    public get isBlocked(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh itself by default. Implemented by child classes\r\n     * @param camera defines the camera to use to pick the right LOD level\r\n     * @returns the currentAbstractMesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getLOD(camera: Camera): Nullable<AbstractMesh> {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns 0 by default. Implemented by child classes\r\n     * @returns an integer\r\n     */\r\n    public getTotalVertices(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns a positive integer : the total number of indices in this mesh geometry.\r\n     * @returns the number of indices or zero if the mesh has no geometry.\r\n     */\r\n    public getTotalIndices(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns null by default. Implemented by child classes\r\n     * @returns null\r\n     */\r\n    public getIndices(): Nullable<IndicesArray> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the array of the requested vertex data kind. Implemented by child classes\r\n     * @param kind defines the vertex data kind to use\r\n     * @returns null\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getVerticesData(kind: string): Nullable<FloatArray> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n     * Note that a new underlying VertexBuffer object is created each call.\r\n     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     * @param kind defines vertex data kind:\r\n     * * VertexBuffer.PositionKind\r\n     * * VertexBuffer.UVKind\r\n     * * VertexBuffer.UV2Kind\r\n     * * VertexBuffer.UV3Kind\r\n     * * VertexBuffer.UV4Kind\r\n     * * VertexBuffer.UV5Kind\r\n     * * VertexBuffer.UV6Kind\r\n     * * VertexBuffer.ColorKind\r\n     * * VertexBuffer.MatricesIndicesKind\r\n     * * VertexBuffer.MatricesIndicesExtraKind\r\n     * * VertexBuffer.MatricesWeightsKind\r\n     * * VertexBuffer.MatricesWeightsExtraKind\r\n     * @param data defines the data source\r\n     * @param updatable defines if the data must be flagged as updatable (or static)\r\n     * @param stride defines the vertex stride (size of an entire vertex). Can be null and in this case will be deduced from vertex data kind\r\n     * @returns the current mesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): AbstractMesh {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, it is simply returned as it is.\r\n     * @param kind defines vertex data kind:\r\n     * * VertexBuffer.PositionKind\r\n     * * VertexBuffer.UVKind\r\n     * * VertexBuffer.UV2Kind\r\n     * * VertexBuffer.UV3Kind\r\n     * * VertexBuffer.UV4Kind\r\n     * * VertexBuffer.UV5Kind\r\n     * * VertexBuffer.UV6Kind\r\n     * * VertexBuffer.ColorKind\r\n     * * VertexBuffer.MatricesIndicesKind\r\n     * * VertexBuffer.MatricesIndicesExtraKind\r\n     * * VertexBuffer.MatricesWeightsKind\r\n     * * VertexBuffer.MatricesWeightsExtraKind\r\n     * @param data defines the data source\r\n     * @param updateExtends If `kind` is `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed\r\n     * @param makeItUnique If true, a new global geometry is created from this data and is set to the mesh\r\n     * @returns the current mesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): AbstractMesh {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh indices,\r\n     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n     * @param indices Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array)\r\n     * @param totalVertices Defines the total number of vertices\r\n     * @returns the current mesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public setIndices(indices: IndicesArray, totalVertices: Nullable<number>): AbstractMesh {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if specific vertex data is present\r\n     * @param kind defines the vertex data kind to use\r\n     * @returns true is data kind is present\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isVerticesDataPresent(kind: string): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh BoundingInfo object or creates a new one and returns if it was undefined.\r\n     * Note that it returns a shallow bounding of the mesh (i.e. it does not include children).\r\n     * To get the full bounding of all children, call `getHierarchyBoundingVectors` instead.\r\n     * @returns a BoundingInfo\r\n     */\r\n    public getBoundingInfo(): BoundingInfo {\r\n        if (this._masterMesh) {\r\n            return this._masterMesh.getBoundingInfo();\r\n        }\r\n\r\n        if (this._boundingInfoIsDirty) {\r\n            this._boundingInfoIsDirty = false;\r\n            // this._boundingInfo is being created if undefined\r\n            this._updateBoundingInfo();\r\n        }\r\n        // cannot be null.\r\n        return this._boundingInfo!;\r\n    }\r\n\r\n    /**\r\n     * Overwrite the current bounding info\r\n     * @param boundingInfo defines the new bounding info\r\n     * @returns the current mesh\r\n     */\r\n    public setBoundingInfo(boundingInfo: BoundingInfo): AbstractMesh {\r\n        this._boundingInfo = boundingInfo;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns true if there is already a bounding info\r\n     */\r\n    public get hasBoundingInfo(): boolean {\r\n        return this._boundingInfo !== null;\r\n    }\r\n\r\n    /**\r\n     * Creates a new bounding info for the mesh\r\n     * @param minimum min vector of the bounding box/sphere\r\n     * @param maximum max vector of the bounding box/sphere\r\n     * @param worldMatrix defines the new world matrix\r\n     * @returns the new bounding info\r\n     */\r\n    public buildBoundingInfo(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this._boundingInfo = new BoundingInfo(minimum, maximum, worldMatrix);\r\n        return this._boundingInfo;\r\n    }\r\n\r\n    /**\r\n     * Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)\r\n     * @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false\r\n     * @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false\r\n     * @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling\r\n     * @returns the current mesh\r\n     */\r\n    public normalizeToUnitCube(includeDescendants = true, ignoreRotation = false, predicate?: Nullable<(node: AbstractMesh) => boolean>): AbstractMesh {\r\n        return <AbstractMesh>super.normalizeToUnitCube(includeDescendants, ignoreRotation, predicate);\r\n    }\r\n\r\n    /** Gets a boolean indicating if this mesh has skinning data and an attached skeleton */\r\n    public get useBones(): boolean {\r\n        return <boolean>(\r\n            (this.skeleton &&\r\n                this.getScene().skeletonsEnabled &&\r\n                this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind) &&\r\n                this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind))\r\n        );\r\n    }\r\n\r\n    /** @hidden */\r\n    public _preActivate(): void {}\r\n\r\n    /**\r\n     * @param renderId\r\n     * @hidden\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public _preActivateForIntermediateRendering(renderId: number): void {}\r\n\r\n    /**\r\n     * @param renderId\r\n     * @param intermediateRendering\r\n     * @hidden\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public _activate(renderId: number, intermediateRendering: boolean): boolean {\r\n        this._renderId = renderId;\r\n        return true;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _postActivate(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /** @hidden */\r\n    public _freeze() {\r\n        // Do nothing\r\n    }\r\n\r\n    /** @hidden */\r\n    public _unFreeze() {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Gets the current world matrix\r\n     * @returns a Matrix\r\n     */\r\n    public getWorldMatrix(): Matrix {\r\n        if (this._masterMesh && this.billboardMode === TransformNode.BILLBOARDMODE_NONE) {\r\n            return this._masterMesh.getWorldMatrix();\r\n        }\r\n\r\n        return super.getWorldMatrix();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _getWorldMatrixDeterminant(): number {\r\n        if (this._masterMesh) {\r\n            return this._masterMesh._getWorldMatrixDeterminant();\r\n        }\r\n\r\n        return super._getWorldMatrixDeterminant();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this mesh is an instance or a regular mesh\r\n     */\r\n    public get isAnInstance(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this mesh has instances\r\n     */\r\n    public get hasInstances(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this mesh has thin instances\r\n     */\r\n    public get hasThinInstances(): boolean {\r\n        return false;\r\n    }\r\n\r\n    // ================================== Point of View Movement =================================\r\n\r\n    /**\r\n     * Perform relative position change from the point of view of behind the front of the mesh.\r\n     * This is performed taking into account the meshes current rotation, so you do not have to care.\r\n     * Supports definition of mesh facing forward or backward\r\n     * @param amountRight defines the distance on the right axis\r\n     * @param amountUp defines the distance on the up axis\r\n     * @param amountForward defines the distance on the forward axis\r\n     * @returns the current mesh\r\n     */\r\n    public movePOV(amountRight: number, amountUp: number, amountForward: number): AbstractMesh {\r\n        this.position.addInPlace(this.calcMovePOV(amountRight, amountUp, amountForward));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Calculate relative position change from the point of view of behind the front of the mesh.\r\n     * This is performed taking into account the meshes current rotation, so you do not have to care.\r\n     * Supports definition of mesh facing forward or backward\r\n     * @param amountRight defines the distance on the right axis\r\n     * @param amountUp defines the distance on the up axis\r\n     * @param amountForward defines the distance on the forward axis\r\n     * @returns the new displacement vector\r\n     */\r\n    public calcMovePOV(amountRight: number, amountUp: number, amountForward: number): Vector3 {\r\n        const rotMatrix = new Matrix();\r\n        const rotQuaternion = this.rotationQuaternion ? this.rotationQuaternion : Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);\r\n        rotQuaternion.toRotationMatrix(rotMatrix);\r\n\r\n        const translationDelta = Vector3.Zero();\r\n        const defForwardMult = this.definedFacingForward ? -1 : 1;\r\n        Vector3.TransformCoordinatesFromFloatsToRef(amountRight * defForwardMult, amountUp, amountForward * defForwardMult, rotMatrix, translationDelta);\r\n        return translationDelta;\r\n    }\r\n    // ================================== Point of View Rotation =================================\r\n    /**\r\n     * Perform relative rotation change from the point of view of behind the front of the mesh.\r\n     * Supports definition of mesh facing forward or backward\r\n     * @param flipBack defines the flip\r\n     * @param twirlClockwise defines the twirl\r\n     * @param tiltRight defines the tilt\r\n     * @returns the current mesh\r\n     */\r\n    public rotatePOV(flipBack: number, twirlClockwise: number, tiltRight: number): AbstractMesh {\r\n        this.rotation.addInPlace(this.calcRotatePOV(flipBack, twirlClockwise, tiltRight));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Calculate relative rotation change from the point of view of behind the front of the mesh.\r\n     * Supports definition of mesh facing forward or backward.\r\n     * @param flipBack defines the flip\r\n     * @param twirlClockwise defines the twirl\r\n     * @param tiltRight defines the tilt\r\n     * @returns the new rotation vector\r\n     */\r\n    public calcRotatePOV(flipBack: number, twirlClockwise: number, tiltRight: number): Vector3 {\r\n        const defForwardMult = this.definedFacingForward ? 1 : -1;\r\n        return new Vector3(flipBack * defForwardMult, twirlClockwise, tiltRight * defForwardMult);\r\n    }\r\n\r\n    /**\r\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n     * This means the mesh underlying bounding box and sphere are recomputed.\r\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n     * @param applyMorph  defines whether to apply the morph target before computing the bounding info\r\n     * @returns the current mesh\r\n     */\r\n    public refreshBoundingInfo(applySkeleton: boolean = false, applyMorph: boolean = false): AbstractMesh {\r\n        if (this._boundingInfo && this._boundingInfo.isLocked) {\r\n            return this;\r\n        }\r\n\r\n        this._refreshBoundingInfo(this._getPositionData(applySkeleton, applyMorph), null);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param data\r\n     * @param bias\r\n     * @hidden\r\n     */\r\n    public _refreshBoundingInfo(data: Nullable<FloatArray>, bias: Nullable<Vector2>): void {\r\n        if (data) {\r\n            const extend = extractMinAndMax(data, 0, this.getTotalVertices(), bias);\r\n            if (this._boundingInfo) {\r\n                this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\r\n            } else {\r\n                this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\r\n            }\r\n        }\r\n\r\n        if (this.subMeshes) {\r\n            for (let index = 0; index < this.subMeshes.length; index++) {\r\n                this.subMeshes[index].refreshBoundingInfo(data);\r\n            }\r\n        }\r\n\r\n        this._updateBoundingInfo();\r\n    }\r\n\r\n    /**\r\n     * Get the position vertex data and optionally apply skeleton and morphing.\r\n     * @param applySkeleton defines whether to apply the skeleton\r\n     * @param applyMorph  defines whether to apply the morph target\r\n     * @param data defines the position data to apply the skeleton and morph to\r\n     * @returns the position data\r\n     */\r\n    public getPositionData(applySkeleton: boolean = false, applyMorph: boolean = false, data?: Nullable<FloatArray>): Nullable<FloatArray> {\r\n        data = data ?? Tools.Slice(this.getVerticesData(VertexBuffer.PositionKind));\r\n\r\n        if (data && applyMorph && this.morphTargetManager) {\r\n            let faceIndexCount = 0;\r\n            let positionIndex = 0;\r\n            for (let vertexCount = 0; vertexCount < data.length; vertexCount++) {\r\n                for (let targetCount = 0; targetCount < this.morphTargetManager.numTargets; targetCount++) {\r\n                    const targetMorph = this.morphTargetManager.getTarget(targetCount);\r\n                    const influence = targetMorph.influence;\r\n                    if (influence > 0.0) {\r\n                        const morphTargetPositions = targetMorph.getPositions();\r\n                        if (morphTargetPositions) {\r\n                            data[vertexCount] += (morphTargetPositions[vertexCount] - data[vertexCount]) * influence;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                faceIndexCount++;\r\n\r\n                if (this._positions && faceIndexCount === 3) {\r\n                    // We want to merge into positions every 3 indices starting (but not 0)\r\n                    faceIndexCount = 0;\r\n                    const index = positionIndex * 3;\r\n                    this._positions[positionIndex++].copyFromFloats(data[index], data[index + 1], data[index + 2]);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (data && applySkeleton && this.skeleton) {\r\n            const matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);\r\n            const matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\r\n            if (matricesWeightsData && matricesIndicesData) {\r\n                const needExtras = this.numBoneInfluencers > 4;\r\n                const matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\r\n                const matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\r\n\r\n                const skeletonMatrices = this.skeleton.getTransformMatrices(this);\r\n\r\n                const tempVector = TmpVectors.Vector3[0];\r\n                const finalMatrix = TmpVectors.Matrix[0];\r\n                const tempMatrix = TmpVectors.Matrix[1];\r\n\r\n                let matWeightIdx = 0;\r\n                for (let index = 0; index < data.length; index += 3, matWeightIdx += 4) {\r\n                    finalMatrix.reset();\r\n\r\n                    let inf: number;\r\n                    let weight: number;\r\n                    for (inf = 0; inf < 4; inf++) {\r\n                        weight = matricesWeightsData[matWeightIdx + inf];\r\n                        if (weight > 0) {\r\n                            Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);\r\n                            finalMatrix.addToSelf(tempMatrix);\r\n                        }\r\n                    }\r\n                    if (needExtras) {\r\n                        for (inf = 0; inf < 4; inf++) {\r\n                            weight = matricesWeightsExtraData![matWeightIdx + inf];\r\n                            if (weight > 0) {\r\n                                Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData![matWeightIdx + inf] * 16), weight, tempMatrix);\r\n                                finalMatrix.addToSelf(tempMatrix);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    Vector3.TransformCoordinatesFromFloatsToRef(data[index], data[index + 1], data[index + 2], finalMatrix, tempVector);\r\n                    tempVector.toArray(data, index);\r\n\r\n                    if (this._positions) {\r\n                        this._positions[index / 3].copyFrom(tempVector);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * @param applySkeleton\r\n     * @param applyMorph\r\n     * @hidden\r\n     */\r\n    public _getPositionData(applySkeleton: boolean, applyMorph: boolean): Nullable<FloatArray> {\r\n        let data = this.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n        if (this._internalAbstractMeshDataInfo._positions) {\r\n            this._internalAbstractMeshDataInfo._positions = null;\r\n        }\r\n\r\n        if (data && ((applySkeleton && this.skeleton) || (applyMorph && this.morphTargetManager))) {\r\n            data = Tools.Slice(data);\r\n            this._generatePointsArray();\r\n            if (this._positions) {\r\n                const pos = this._positions;\r\n                this._internalAbstractMeshDataInfo._positions = new Array<Vector3>(pos.length);\r\n                for (let i = 0; i < pos.length; i++) {\r\n                    this._internalAbstractMeshDataInfo._positions[i] = pos[i]?.clone() || new Vector3();\r\n                }\r\n            }\r\n            return this.getPositionData(applySkeleton, applyMorph, data);\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _updateBoundingInfo(): AbstractMesh {\r\n        if (this._boundingInfo) {\r\n            this._boundingInfo.update(this.worldMatrixFromCache);\r\n        } else {\r\n            this._boundingInfo = new BoundingInfo(Vector3.Zero(), Vector3.Zero(), this.worldMatrixFromCache);\r\n        }\r\n        this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param matrix\r\n     * @hidden\r\n     */\r\n    public _updateSubMeshesBoundingInfo(matrix: DeepImmutable<Matrix>): AbstractMesh {\r\n        if (!this.subMeshes) {\r\n            return this;\r\n        }\r\n        const count = this.subMeshes.length;\r\n        for (let subIndex = 0; subIndex < count; subIndex++) {\r\n            const subMesh = this.subMeshes[subIndex];\r\n            if (count > 1 || !subMesh.IsGlobal) {\r\n                subMesh.updateBoundingInfo(matrix);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    protected _afterComputeWorldMatrix(): void {\r\n        if (this.doNotSyncBoundingInfo) {\r\n            return;\r\n        }\r\n        // Bounding info\r\n        this._boundingInfoIsDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the mesh is within the frustum defined by the passed array of planes.\r\n     * A mesh is in the frustum if its bounding box intersects the frustum\r\n     * @param frustumPlanes defines the frustum to test\r\n     * @returns true if the mesh is in the frustum planes\r\n     */\r\n    public isInFrustum(frustumPlanes: Plane[]): boolean {\r\n        return this.getBoundingInfo().isInFrustum(frustumPlanes, this.cullingStrategy);\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the mesh is completely in the frustum defined be the passed array of planes.\r\n     * A mesh is completely in the frustum if its bounding box it completely inside the frustum.\r\n     * @param frustumPlanes defines the frustum to test\r\n     * @returns true if the mesh is completely in the frustum planes\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Plane[]): boolean {\r\n        return this.getBoundingInfo().isCompletelyInFrustum(frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * True if the mesh intersects another mesh or a SolidParticle object\r\n     * @param mesh defines a target mesh or SolidParticle to test\r\n     * @param precise Unless the parameter `precise` is set to `true` the intersection is computed according to Axis Aligned Bounding Boxes (AABB), else according to OBB (Oriented BBoxes)\r\n     * @param includeDescendants Can be set to true to test if the mesh defined in parameters intersects with the current mesh or any child meshes\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsMesh(mesh: AbstractMesh | SolidParticle, precise: boolean = false, includeDescendants?: boolean): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n        const otherBoundingInfo = mesh.getBoundingInfo();\r\n\r\n        if (boundingInfo.intersects(otherBoundingInfo, precise)) {\r\n            return true;\r\n        }\r\n\r\n        if (includeDescendants) {\r\n            for (const child of this.getChildMeshes()) {\r\n                if (child.intersectsMesh(mesh, precise, true)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the passed point (Vector3) is inside the mesh bounding box\r\n     * @param point defines the point to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsPoint(point: Vector3): boolean {\r\n        return this.getBoundingInfo().intersectsPoint(point);\r\n    }\r\n\r\n    // Collisions\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this mesh can be used in the collision engine\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n     */\r\n    public get checkCollisions(): boolean {\r\n        return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions;\r\n    }\r\n\r\n    public set checkCollisions(collisionEnabled: boolean) {\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions = collisionEnabled;\r\n    }\r\n\r\n    /**\r\n     * Gets Collider object used to compute collisions (not physics)\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n     */\r\n    public get collider(): Nullable<Collider> {\r\n        return this._internalAbstractMeshDataInfo._meshCollisionData._collider;\r\n    }\r\n\r\n    /**\r\n     * Move the mesh using collision engine\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n     * @param displacement defines the requested displacement vector\r\n     * @returns the current mesh\r\n     */\r\n    public moveWithCollisions(displacement: Vector3): AbstractMesh {\r\n        const globalPosition = this.getAbsolutePosition();\r\n\r\n        globalPosition.addToRef(this.ellipsoidOffset, this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions);\r\n        const coordinator = this.getScene().collisionCoordinator;\r\n\r\n        if (!this._internalAbstractMeshDataInfo._meshCollisionData._collider) {\r\n            this._internalAbstractMeshDataInfo._meshCollisionData._collider = coordinator.createCollider();\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius = this.ellipsoid;\r\n\r\n        coordinator.getNewPosition(\r\n            this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions,\r\n            displacement,\r\n            this._internalAbstractMeshDataInfo._meshCollisionData._collider,\r\n            this.collisionRetryCount,\r\n            this,\r\n            this._onCollisionPositionChange,\r\n            this.uniqueId\r\n        );\r\n        return this;\r\n    }\r\n\r\n    private _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n        newPosition.subtractToRef(\r\n            this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions,\r\n            this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions\r\n        );\r\n\r\n        if (this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length() > Engine.CollisionsEpsilon) {\r\n            this.position.addInPlace(this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions);\r\n        }\r\n\r\n        if (collidedMesh) {\r\n            this.onCollideObservable.notifyObservers(collidedMesh);\r\n        }\r\n\r\n        this.onCollisionPositionChangeObservable.notifyObservers(this.position);\r\n    };\r\n\r\n    // Collisions\r\n    /**\r\n     * @param subMesh\r\n     * @param transformMatrix\r\n     * @param collider\r\n     * @hidden\r\n     */\r\n    public _collideForSubMesh(subMesh: SubMesh, transformMatrix: Matrix, collider: Collider): AbstractMesh {\r\n        this._generatePointsArray();\r\n\r\n        if (!this._positions) {\r\n            return this;\r\n        }\r\n\r\n        // Transformation\r\n        if (!subMesh._lastColliderWorldVertices || !subMesh._lastColliderTransformMatrix!.equals(transformMatrix)) {\r\n            subMesh._lastColliderTransformMatrix = transformMatrix.clone();\r\n            subMesh._lastColliderWorldVertices = [];\r\n            subMesh._trianglePlanes = [];\r\n            const start = subMesh.verticesStart;\r\n            const end = subMesh.verticesStart + subMesh.verticesCount;\r\n            for (let i = start; i < end; i++) {\r\n                subMesh._lastColliderWorldVertices.push(Vector3.TransformCoordinates(this._positions[i], transformMatrix));\r\n            }\r\n        }\r\n\r\n        // Collide\r\n        collider._collide(\r\n            subMesh._trianglePlanes,\r\n            subMesh._lastColliderWorldVertices,\r\n            <IndicesArray>this.getIndices(),\r\n            subMesh.indexStart,\r\n            subMesh.indexStart + subMesh.indexCount,\r\n            subMesh.verticesStart,\r\n            !!subMesh.getMaterial(),\r\n            this,\r\n            this._shouldConvertRHS(),\r\n            subMesh.getMaterial()?.fillMode === Constants.MATERIAL_TriangleStripDrawMode\r\n        );\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param collider\r\n     * @param transformMatrix\r\n     * @hidden\r\n     */\r\n    public _processCollisionsForSubMeshes(collider: Collider, transformMatrix: Matrix): AbstractMesh {\r\n        const subMeshes = this._scene.getCollidingSubMeshCandidates(this, collider);\r\n        const len = subMeshes.length;\r\n\r\n        for (let index = 0; index < len; index++) {\r\n            const subMesh = subMeshes.data[index];\r\n\r\n            // Bounding test\r\n            if (len > 1 && !subMesh._checkCollision(collider)) {\r\n                continue;\r\n            }\r\n\r\n            this._collideForSubMesh(subMesh, transformMatrix, collider);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _shouldConvertRHS() {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @param collider\r\n     * @hidden\r\n     */\r\n    public _checkCollision(collider: Collider): AbstractMesh {\r\n        // Bounding box test\r\n        if (!this.getBoundingInfo()._checkCollision(collider)) {\r\n            return this;\r\n        }\r\n\r\n        // Transformation matrix\r\n        const collisionsScalingMatrix = TmpVectors.Matrix[0];\r\n        const collisionsTransformMatrix = TmpVectors.Matrix[1];\r\n        Matrix.ScalingToRef(1.0 / collider._radius.x, 1.0 / collider._radius.y, 1.0 / collider._radius.z, collisionsScalingMatrix);\r\n        this.worldMatrixFromCache.multiplyToRef(collisionsScalingMatrix, collisionsTransformMatrix);\r\n        this._processCollisionsForSubMeshes(collider, collisionsTransformMatrix);\r\n        return this;\r\n    }\r\n\r\n    // Picking\r\n    /** @hidden */\r\n    public _generatePointsArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the passed Ray intersects with the mesh\r\n     * @param ray defines the ray to use\r\n     * @param fastCheck defines if fast mode (but less precise) must be used (false by default)\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\r\n     * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point\r\n     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\r\n     * @returns the picking info\r\n     * @see https://doc.babylonjs.com/babylon101/intersect_collisions_-_mesh\r\n     */\r\n    public intersects(\r\n        ray: Ray,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate,\r\n        onlyBoundingInfo = false,\r\n        worldToUse?: Matrix,\r\n        skipBoundingInfo = false\r\n    ): PickingInfo {\r\n        const pickingInfo = new PickingInfo();\r\n        const intersectionThreshold = this.getClassName() === \"InstancedLinesMesh\" || this.getClassName() === \"LinesMesh\" ? (this as any).intersectionThreshold : 0;\r\n        const boundingInfo = this.getBoundingInfo();\r\n        if (!this.subMeshes) {\r\n            return pickingInfo;\r\n        }\r\n        if (\r\n            !skipBoundingInfo &&\r\n            (!ray.intersectsSphere(boundingInfo.boundingSphere, intersectionThreshold) || !ray.intersectsBox(boundingInfo.boundingBox, intersectionThreshold))\r\n        ) {\r\n            return pickingInfo;\r\n        }\r\n\r\n        if (onlyBoundingInfo) {\r\n            pickingInfo.hit = skipBoundingInfo ? false : true;\r\n            pickingInfo.pickedMesh = skipBoundingInfo ? null : this;\r\n            pickingInfo.distance = skipBoundingInfo ? 0 : Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);\r\n            pickingInfo.subMeshId = 0;\r\n            return pickingInfo;\r\n        }\r\n\r\n        if (!this._generatePointsArray()) {\r\n            return pickingInfo;\r\n        }\r\n\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        const subMeshes = this._scene.getIntersectingSubMeshCandidates(this, ray);\r\n        const len: number = subMeshes.length;\r\n\r\n        // Check if all submeshes are using a material that don't allow picking (point/lines rendering)\r\n        // if no submesh can be picked that way, then fallback to BBox picking\r\n        let anySubmeshSupportIntersect = false;\r\n        for (let index = 0; index < len; index++) {\r\n            const subMesh = subMeshes.data[index];\r\n            const material = subMesh.getMaterial();\r\n            if (!material) {\r\n                continue;\r\n            }\r\n            if (\r\n                material.fillMode == Constants.MATERIAL_TriangleStripDrawMode ||\r\n                material.fillMode == Constants.MATERIAL_TriangleFillMode ||\r\n                material.fillMode == Constants.MATERIAL_WireFrameFillMode ||\r\n                material.fillMode == Constants.MATERIAL_PointFillMode ||\r\n                material.fillMode == Constants.MATERIAL_LineListDrawMode\r\n            ) {\r\n                anySubmeshSupportIntersect = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // no sub mesh support intersection, fallback to BBox that has already be done\r\n        if (!anySubmeshSupportIntersect) {\r\n            pickingInfo.hit = true;\r\n            pickingInfo.pickedMesh = this;\r\n            pickingInfo.distance = Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);\r\n            pickingInfo.subMeshId = -1;\r\n            return pickingInfo;\r\n        }\r\n\r\n        // at least 1 submesh supports intersection, keep going\r\n        for (let index = 0; index < len; index++) {\r\n            const subMesh = subMeshes.data[index];\r\n\r\n            // Bounding test\r\n            if (len > 1 && !subMesh.canIntersects(ray)) {\r\n                continue;\r\n            }\r\n\r\n            const currentIntersectInfo = subMesh.intersects(ray, <Vector3[]>this._positions, <IndicesArray>this.getIndices(), fastCheck, trianglePredicate);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.subMeshId = index;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (intersectInfo) {\r\n            // Get picked point\r\n            const world = worldToUse ?? this.getWorldMatrix();\r\n            const worldOrigin = TmpVectors.Vector3[0];\r\n            const direction = TmpVectors.Vector3[1];\r\n            Vector3.TransformCoordinatesToRef(ray.origin, world, worldOrigin);\r\n            ray.direction.scaleToRef(intersectInfo.distance, direction);\r\n            const worldDirection = Vector3.TransformNormal(direction, world);\r\n            const pickedPoint = worldDirection.addInPlace(worldOrigin);\r\n\r\n            // Return result\r\n            pickingInfo.hit = true;\r\n            pickingInfo.distance = Vector3.Distance(worldOrigin, pickedPoint);\r\n            pickingInfo.pickedPoint = pickedPoint;\r\n            pickingInfo.pickedMesh = this;\r\n            pickingInfo.bu = intersectInfo.bu || 0;\r\n            pickingInfo.bv = intersectInfo.bv || 0;\r\n            pickingInfo.subMeshFaceId = intersectInfo.faceId;\r\n            pickingInfo.faceId = intersectInfo.faceId + subMeshes.data[intersectInfo.subMeshId].indexStart / (this.getClassName().indexOf(\"LinesMesh\") !== -1 ? 2 : 3);\r\n            pickingInfo.subMeshId = intersectInfo.subMeshId;\r\n            return pickingInfo;\r\n        }\r\n\r\n        return pickingInfo;\r\n    }\r\n\r\n    /**\r\n     * Clones the current mesh\r\n     * @param name defines the mesh name\r\n     * @param newParent defines the new mesh parent\r\n     * @param doNotCloneChildren defines a boolean indicating that children must not be cloned (false by default)\r\n     * @returns the new mesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public clone(name: string, newParent: Nullable<Node>, doNotCloneChildren?: boolean): Nullable<AbstractMesh> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Disposes all the submeshes of the current meshnp\r\n     * @returns the current mesh\r\n     */\r\n    public releaseSubMeshes(): AbstractMesh {\r\n        if (this.subMeshes) {\r\n            while (this.subMeshes.length) {\r\n                this.subMeshes[0].dispose();\r\n            }\r\n        } else {\r\n            this.subMeshes = new Array<SubMesh>();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this abstract mesh.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        let index: number;\r\n\r\n        // mesh map release.\r\n        if (this._scene.useMaterialMeshMap) {\r\n            // remove from material mesh map id needed\r\n            if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {\r\n                this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = undefined;\r\n            }\r\n        }\r\n\r\n        // Smart Array Retainers.\r\n        this.getScene().freeActiveMeshes();\r\n        this.getScene().freeRenderingGroups();\r\n\r\n        // Action manager\r\n        if (this.actionManager !== undefined && this.actionManager !== null) {\r\n            this.actionManager.dispose();\r\n            this.actionManager = null;\r\n        }\r\n\r\n        // Skeleton\r\n        this._internalAbstractMeshDataInfo._skeleton = null;\r\n\r\n        if (this._transformMatrixTexture) {\r\n            this._transformMatrixTexture.dispose();\r\n            this._transformMatrixTexture = null;\r\n        }\r\n\r\n        // Intersections in progress\r\n        for (index = 0; index < this._intersectionsInProgress.length; index++) {\r\n            const other = this._intersectionsInProgress[index];\r\n\r\n            const pos = other._intersectionsInProgress.indexOf(this);\r\n            other._intersectionsInProgress.splice(pos, 1);\r\n        }\r\n\r\n        this._intersectionsInProgress = [];\r\n\r\n        // Lights\r\n        const lights = this.getScene().lights;\r\n\r\n        lights.forEach((light: Light) => {\r\n            let meshIndex = light.includedOnlyMeshes.indexOf(this);\r\n\r\n            if (meshIndex !== -1) {\r\n                light.includedOnlyMeshes.splice(meshIndex, 1);\r\n            }\r\n\r\n            meshIndex = light.excludedMeshes.indexOf(this);\r\n\r\n            if (meshIndex !== -1) {\r\n                light.excludedMeshes.splice(meshIndex, 1);\r\n            }\r\n\r\n            // Shadow generators\r\n            const generator = light.getShadowGenerator();\r\n            if (generator) {\r\n                const shadowMap = generator.getShadowMap();\r\n\r\n                if (shadowMap && shadowMap.renderList) {\r\n                    meshIndex = shadowMap.renderList.indexOf(this);\r\n\r\n                    if (meshIndex !== -1) {\r\n                        shadowMap.renderList.splice(meshIndex, 1);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        // SubMeshes\r\n        if (this.getClassName() !== \"InstancedMesh\" || this.getClassName() !== \"InstancedLinesMesh\") {\r\n            this.releaseSubMeshes();\r\n        }\r\n\r\n        // Query\r\n        const engine = this.getScene().getEngine();\r\n        if (this._occlusionQuery !== null) {\r\n            this.isOcclusionQueryInProgress = false;\r\n            engine.deleteQuery(this._occlusionQuery);\r\n            this._occlusionQuery = null;\r\n        }\r\n\r\n        // Engine\r\n        engine.wipeCaches();\r\n\r\n        // Remove from scene\r\n        this.getScene().removeMesh(this);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.meshes.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.meshes.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        if (disposeMaterialAndTextures) {\r\n            if (this.material) {\r\n                if (this.material.getClassName() === \"MultiMaterial\") {\r\n                    this.material.dispose(false, true, true);\r\n                } else {\r\n                    this.material.dispose(false, true);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!doNotRecurse) {\r\n            // Particles\r\n            for (index = 0; index < this.getScene().particleSystems.length; index++) {\r\n                if (this.getScene().particleSystems[index].emitter === this) {\r\n                    this.getScene().particleSystems[index].dispose();\r\n                    index--;\r\n                }\r\n            }\r\n        }\r\n\r\n        // facet data\r\n        if (this._internalAbstractMeshDataInfo._facetData.facetDataEnabled) {\r\n            this.disableFacetData();\r\n        }\r\n\r\n        this._uniformBuffer.dispose();\r\n\r\n        this.onAfterWorldMatrixUpdateObservable.clear();\r\n        this.onCollideObservable.clear();\r\n        this.onCollisionPositionChangeObservable.clear();\r\n        this.onRebuildObservable.clear();\r\n\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * Adds the passed mesh as a child to the current mesh\r\n     * @param mesh defines the child mesh\r\n     * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.\r\n     * @returns the current mesh\r\n     */\r\n    public addChild(mesh: AbstractMesh, preserveScalingSign: boolean = false): AbstractMesh {\r\n        mesh.setParent(this, preserveScalingSign);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the passed mesh from the current mesh children list\r\n     * @param mesh defines the child mesh\r\n     * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.\r\n     * @returns the current mesh\r\n     */\r\n    public removeChild(mesh: AbstractMesh, preserveScalingSign: boolean = false): AbstractMesh {\r\n        mesh.setParent(null, preserveScalingSign);\r\n        return this;\r\n    }\r\n\r\n    // Facet data\r\n    /** @hidden */\r\n    private _initFacetData(): AbstractMesh {\r\n        const data = this._internalAbstractMeshDataInfo._facetData;\r\n        if (!data.facetNormals) {\r\n            data.facetNormals = new Array<Vector3>();\r\n        }\r\n        if (!data.facetPositions) {\r\n            data.facetPositions = new Array<Vector3>();\r\n        }\r\n        if (!data.facetPartitioning) {\r\n            data.facetPartitioning = new Array<number[]>();\r\n        }\r\n        data.facetNb = ((<IndicesArray>this.getIndices()).length / 3) | 0;\r\n        data.partitioningSubdivisions = data.partitioningSubdivisions ? data.partitioningSubdivisions : 10; // default nb of partitioning subdivisions = 10\r\n        data.partitioningBBoxRatio = data.partitioningBBoxRatio ? data.partitioningBBoxRatio : 1.01; // default ratio 1.01 = the partitioning is 1% bigger than the bounding box\r\n        for (let f = 0; f < data.facetNb; f++) {\r\n            data.facetNormals[f] = Vector3.Zero();\r\n            data.facetPositions[f] = Vector3.Zero();\r\n        }\r\n        data.facetDataEnabled = true;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the mesh facetData arrays and the internal partitioning when the mesh is morphed or updated.\r\n     * This method can be called within the render loop.\r\n     * You don't need to call this method by yourself in the render loop when you update/morph a mesh with the methods CreateXXX() as they automatically manage this computation\r\n     * @returns the current mesh\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public updateFacetData(): AbstractMesh {\r\n        const data = this._internalAbstractMeshDataInfo._facetData;\r\n        if (!data.facetDataEnabled) {\r\n            this._initFacetData();\r\n        }\r\n        const positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n        const indices = this.getIndices();\r\n        const normals = this.getVerticesData(VertexBuffer.NormalKind);\r\n        const bInfo = this.getBoundingInfo();\r\n\r\n        if (data.facetDepthSort && !data.facetDepthSortEnabled) {\r\n            // init arrays, matrix and sort function on first call\r\n            data.facetDepthSortEnabled = true;\r\n            if (indices instanceof Uint16Array) {\r\n                data.depthSortedIndices = new Uint16Array(indices!);\r\n            } else if (indices instanceof Uint32Array) {\r\n                data.depthSortedIndices = new Uint32Array(indices!);\r\n            } else {\r\n                let needs32bits = false;\r\n                for (let i = 0; i < indices!.length; i++) {\r\n                    if (indices![i] > 65535) {\r\n                        needs32bits = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (needs32bits) {\r\n                    data.depthSortedIndices = new Uint32Array(indices!);\r\n                } else {\r\n                    data.depthSortedIndices = new Uint16Array(indices!);\r\n                }\r\n            }\r\n            data.facetDepthSortFunction = function (f1, f2) {\r\n                return f2.sqDistance - f1.sqDistance;\r\n            };\r\n            if (!data.facetDepthSortFrom) {\r\n                const camera = this.getScene().activeCamera;\r\n                data.facetDepthSortFrom = camera ? camera.position : Vector3.Zero();\r\n            }\r\n            data.depthSortedFacets = [];\r\n            for (let f = 0; f < data.facetNb; f++) {\r\n                const depthSortedFacet = { ind: f * 3, sqDistance: 0.0 };\r\n                data.depthSortedFacets.push(depthSortedFacet);\r\n            }\r\n            data.invertedMatrix = Matrix.Identity();\r\n            data.facetDepthSortOrigin = Vector3.Zero();\r\n        }\r\n\r\n        data.bbSize.x = bInfo.maximum.x - bInfo.minimum.x > Epsilon ? bInfo.maximum.x - bInfo.minimum.x : Epsilon;\r\n        data.bbSize.y = bInfo.maximum.y - bInfo.minimum.y > Epsilon ? bInfo.maximum.y - bInfo.minimum.y : Epsilon;\r\n        data.bbSize.z = bInfo.maximum.z - bInfo.minimum.z > Epsilon ? bInfo.maximum.z - bInfo.minimum.z : Epsilon;\r\n        let bbSizeMax = data.bbSize.x > data.bbSize.y ? data.bbSize.x : data.bbSize.y;\r\n        bbSizeMax = bbSizeMax > data.bbSize.z ? bbSizeMax : data.bbSize.z;\r\n        data.subDiv.max = data.partitioningSubdivisions;\r\n        data.subDiv.X = Math.floor((data.subDiv.max * data.bbSize.x) / bbSizeMax); // adjust the number of subdivisions per axis\r\n        data.subDiv.Y = Math.floor((data.subDiv.max * data.bbSize.y) / bbSizeMax); // according to each bbox size per axis\r\n        data.subDiv.Z = Math.floor((data.subDiv.max * data.bbSize.z) / bbSizeMax);\r\n        data.subDiv.X = data.subDiv.X < 1 ? 1 : data.subDiv.X; // at least one subdivision\r\n        data.subDiv.Y = data.subDiv.Y < 1 ? 1 : data.subDiv.Y;\r\n        data.subDiv.Z = data.subDiv.Z < 1 ? 1 : data.subDiv.Z;\r\n        // set the parameters for ComputeNormals()\r\n        data.facetParameters.facetNormals = this.getFacetLocalNormals();\r\n        data.facetParameters.facetPositions = this.getFacetLocalPositions();\r\n        data.facetParameters.facetPartitioning = this.getFacetLocalPartitioning();\r\n        data.facetParameters.bInfo = bInfo;\r\n        data.facetParameters.bbSize = data.bbSize;\r\n        data.facetParameters.subDiv = data.subDiv;\r\n        data.facetParameters.ratio = this.partitioningBBoxRatio;\r\n        data.facetParameters.depthSort = data.facetDepthSort;\r\n        if (data.facetDepthSort && data.facetDepthSortEnabled) {\r\n            this.computeWorldMatrix(true);\r\n            this._worldMatrix.invertToRef(data.invertedMatrix);\r\n            Vector3.TransformCoordinatesToRef(data.facetDepthSortFrom, data.invertedMatrix, data.facetDepthSortOrigin);\r\n            data.facetParameters.distanceTo = data.facetDepthSortOrigin;\r\n        }\r\n        data.facetParameters.depthSortedFacets = data.depthSortedFacets;\r\n        if (normals) {\r\n            VertexData.ComputeNormals(positions, indices, normals, data.facetParameters);\r\n        }\r\n\r\n        if (data.facetDepthSort && data.facetDepthSortEnabled) {\r\n            data.depthSortedFacets.sort(data.facetDepthSortFunction);\r\n            const l = (data.depthSortedIndices.length / 3) | 0;\r\n            for (let f = 0; f < l; f++) {\r\n                const sind = data.depthSortedFacets[f].ind;\r\n                data.depthSortedIndices[f * 3] = indices![sind];\r\n                data.depthSortedIndices[f * 3 + 1] = indices![sind + 1];\r\n                data.depthSortedIndices[f * 3 + 2] = indices![sind + 2];\r\n            }\r\n            this.updateIndices(data.depthSortedIndices, undefined, true);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the facetLocalNormals array.\r\n     * The normals are expressed in the mesh local spac\r\n     * @returns an array of Vector3\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public getFacetLocalNormals(): Vector3[] {\r\n        const facetData = this._internalAbstractMeshDataInfo._facetData;\r\n        if (!facetData.facetNormals) {\r\n            this.updateFacetData();\r\n        }\r\n        return facetData.facetNormals;\r\n    }\r\n\r\n    /**\r\n     * Returns the facetLocalPositions array.\r\n     * The facet positions are expressed in the mesh local space\r\n     * @returns an array of Vector3\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public getFacetLocalPositions(): Vector3[] {\r\n        const facetData = this._internalAbstractMeshDataInfo._facetData;\r\n        if (!facetData.facetPositions) {\r\n            this.updateFacetData();\r\n        }\r\n        return facetData.facetPositions;\r\n    }\r\n\r\n    /**\r\n     * Returns the facetLocalPartitioning array\r\n     * @returns an array of array of numbers\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public getFacetLocalPartitioning(): number[][] {\r\n        const facetData = this._internalAbstractMeshDataInfo._facetData;\r\n\r\n        if (!facetData.facetPartitioning) {\r\n            this.updateFacetData();\r\n        }\r\n        return facetData.facetPartitioning;\r\n    }\r\n\r\n    /**\r\n     * Returns the i-th facet position in the world system.\r\n     * This method allocates a new Vector3 per call\r\n     * @param i defines the facet index\r\n     * @returns a new Vector3\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public getFacetPosition(i: number): Vector3 {\r\n        const pos = Vector3.Zero();\r\n        this.getFacetPositionToRef(i, pos);\r\n        return pos;\r\n    }\r\n\r\n    /**\r\n     * Sets the reference Vector3 with the i-th facet position in the world system\r\n     * @param i defines the facet index\r\n     * @param ref defines the target vector\r\n     * @returns the current mesh\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public getFacetPositionToRef(i: number, ref: Vector3): AbstractMesh {\r\n        const localPos = this.getFacetLocalPositions()[i];\r\n        const world = this.getWorldMatrix();\r\n        Vector3.TransformCoordinatesToRef(localPos, world, ref);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the i-th facet normal in the world system.\r\n     * This method allocates a new Vector3 per call\r\n     * @param i defines the facet index\r\n     * @returns a new Vector3\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public getFacetNormal(i: number): Vector3 {\r\n        const norm = Vector3.Zero();\r\n        this.getFacetNormalToRef(i, norm);\r\n        return norm;\r\n    }\r\n\r\n    /**\r\n     * Sets the reference Vector3 with the i-th facet normal in the world system\r\n     * @param i defines the facet index\r\n     * @param ref defines the target vector\r\n     * @returns the current mesh\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public getFacetNormalToRef(i: number, ref: Vector3) {\r\n        const localNorm = this.getFacetLocalNormals()[i];\r\n        Vector3.TransformNormalToRef(localNorm, this.getWorldMatrix(), ref);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the facets (in an array) in the same partitioning block than the one the passed coordinates are located (expressed in the mesh local system)\r\n     * @param x defines x coordinate\r\n     * @param y defines y coordinate\r\n     * @param z defines z coordinate\r\n     * @returns the array of facet indexes\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public getFacetsAtLocalCoordinates(x: number, y: number, z: number): Nullable<number[]> {\r\n        const bInfo = this.getBoundingInfo();\r\n        const data = this._internalAbstractMeshDataInfo._facetData;\r\n\r\n        const ox = Math.floor(((x - bInfo.minimum.x * data.partitioningBBoxRatio) * data.subDiv.X * data.partitioningBBoxRatio) / data.bbSize.x);\r\n        const oy = Math.floor(((y - bInfo.minimum.y * data.partitioningBBoxRatio) * data.subDiv.Y * data.partitioningBBoxRatio) / data.bbSize.y);\r\n        const oz = Math.floor(((z - bInfo.minimum.z * data.partitioningBBoxRatio) * data.subDiv.Z * data.partitioningBBoxRatio) / data.bbSize.z);\r\n        if (ox < 0 || ox > data.subDiv.max || oy < 0 || oy > data.subDiv.max || oz < 0 || oz > data.subDiv.max) {\r\n            return null;\r\n        }\r\n        return data.facetPartitioning[ox + data.subDiv.max * oy + data.subDiv.max * data.subDiv.max * oz];\r\n    }\r\n\r\n    /**\r\n     * Returns the closest mesh facet index at (x,y,z) World coordinates, null if not found\r\n     * @param x defines x coordinate\r\n     * @param y defines y coordinate\r\n     * @param z defines z coordinate\r\n     * @param projected sets as the (x,y,z) world projection on the facet\r\n     * @param checkFace if true (default false), only the facet \"facing\" to (x,y,z) or only the ones \"turning their backs\", according to the parameter \"facing\" are returned\r\n     * @param facing if facing and checkFace are true, only the facet \"facing\" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet \"turning their backs\" to (x, y, z) are returned : negative dot (x, y, z) * facet position\r\n     * @returns the face index if found (or null instead)\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public getClosestFacetAtCoordinates(x: number, y: number, z: number, projected?: Vector3, checkFace: boolean = false, facing: boolean = true): Nullable<number> {\r\n        const world = this.getWorldMatrix();\r\n        const invMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(invMat);\r\n        const invVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, invMat, invVect); // transform (x,y,z) to coordinates in the mesh local space\r\n        const closest = this.getClosestFacetAtLocalCoordinates(invVect.x, invVect.y, invVect.z, projected, checkFace, facing);\r\n        if (projected) {\r\n            // transform the local computed projected vector to world coordinates\r\n            Vector3.TransformCoordinatesFromFloatsToRef(projected.x, projected.y, projected.z, world, projected);\r\n        }\r\n        return closest;\r\n    }\r\n\r\n    /**\r\n     * Returns the closest mesh facet index at (x,y,z) local coordinates, null if not found\r\n     * @param x defines x coordinate\r\n     * @param y defines y coordinate\r\n     * @param z defines z coordinate\r\n     * @param projected sets as the (x,y,z) local projection on the facet\r\n     * @param checkFace if true (default false), only the facet \"facing\" to (x,y,z) or only the ones \"turning their backs\", according to the parameter \"facing\" are returned\r\n     * @param facing if facing and checkFace are true, only the facet \"facing\" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet \"turning their backs\" to (x, y, z) are returned : negative dot (x, y, z) * facet position\r\n     * @returns the face index if found (or null instead)\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public getClosestFacetAtLocalCoordinates(x: number, y: number, z: number, projected?: Vector3, checkFace: boolean = false, facing: boolean = true): Nullable<number> {\r\n        let closest = null;\r\n        let tmpx = 0.0;\r\n        let tmpy = 0.0;\r\n        let tmpz = 0.0;\r\n        let d = 0.0; // tmp dot facet normal * facet position\r\n        let t0 = 0.0;\r\n        let projx = 0.0;\r\n        let projy = 0.0;\r\n        let projz = 0.0;\r\n        // Get all the facets in the same partitioning block than (x, y, z)\r\n        const facetPositions = this.getFacetLocalPositions();\r\n        const facetNormals = this.getFacetLocalNormals();\r\n        const facetsInBlock = this.getFacetsAtLocalCoordinates(x, y, z);\r\n        if (!facetsInBlock) {\r\n            return null;\r\n        }\r\n        // Get the closest facet to (x, y, z)\r\n        let shortest = Number.MAX_VALUE; // init distance vars\r\n        let tmpDistance = shortest;\r\n        let fib; // current facet in the block\r\n        let norm; // current facet normal\r\n        let p0; // current facet barycenter position\r\n        // loop on all the facets in the current partitioning block\r\n        for (let idx = 0; idx < facetsInBlock.length; idx++) {\r\n            fib = facetsInBlock[idx];\r\n            norm = facetNormals[fib];\r\n            p0 = facetPositions[fib];\r\n\r\n            d = (x - p0.x) * norm.x + (y - p0.y) * norm.y + (z - p0.z) * norm.z;\r\n            if (!checkFace || (checkFace && facing && d >= 0.0) || (checkFace && !facing && d <= 0.0)) {\r\n                // compute (x,y,z) projection on the facet = (projx, projy, projz)\r\n                d = norm.x * p0.x + norm.y * p0.y + norm.z * p0.z;\r\n                t0 = -(norm.x * x + norm.y * y + norm.z * z - d) / (norm.x * norm.x + norm.y * norm.y + norm.z * norm.z);\r\n                projx = x + norm.x * t0;\r\n                projy = y + norm.y * t0;\r\n                projz = z + norm.z * t0;\r\n\r\n                tmpx = projx - x;\r\n                tmpy = projy - y;\r\n                tmpz = projz - z;\r\n                tmpDistance = tmpx * tmpx + tmpy * tmpy + tmpz * tmpz; // compute length between (x, y, z) and its projection on the facet\r\n                if (tmpDistance < shortest) {\r\n                    // just keep the closest facet to (x, y, z)\r\n                    shortest = tmpDistance;\r\n                    closest = fib;\r\n                    if (projected) {\r\n                        projected.x = projx;\r\n                        projected.y = projy;\r\n                        projected.z = projz;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return closest;\r\n    }\r\n\r\n    /**\r\n     * Returns the object \"parameter\" set with all the expected parameters for facetData computation by ComputeNormals()\r\n     * @returns the parameters\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public getFacetDataParameters(): any {\r\n        return this._internalAbstractMeshDataInfo._facetData.facetParameters;\r\n    }\r\n\r\n    /**\r\n     * Disables the feature FacetData and frees the related memory\r\n     * @returns the current mesh\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public disableFacetData(): AbstractMesh {\r\n        const facetData = this._internalAbstractMeshDataInfo._facetData;\r\n        if (facetData.facetDataEnabled) {\r\n            facetData.facetDataEnabled = false;\r\n            facetData.facetPositions = new Array<Vector3>();\r\n            facetData.facetNormals = new Array<Vector3>();\r\n            facetData.facetPartitioning = new Array<number[]>();\r\n            facetData.facetParameters = null;\r\n            facetData.depthSortedIndices = new Uint32Array(0);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the AbstractMesh indices array\r\n     * @param indices defines the data source\r\n     * @param offset defines the offset in the index buffer where to store the new data (can be null)\r\n     * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\r\n     * @returns the current mesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public updateIndices(indices: IndicesArray, offset?: number, gpuMemoryOnly = false): AbstractMesh {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates new normals data for the mesh\r\n     * @param updatable defines if the normal vertex buffer must be flagged as updatable\r\n     * @returns the current mesh\r\n     */\r\n    public createNormals(updatable: boolean): AbstractMesh {\r\n        const positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n        const indices = this.getIndices();\r\n        let normals: FloatArray;\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            normals = <FloatArray>this.getVerticesData(VertexBuffer.NormalKind);\r\n        } else {\r\n            normals = [];\r\n        }\r\n\r\n        VertexData.ComputeNormals(positions, indices, normals, { useRightHandedSystem: this.getScene().useRightHandedSystem });\r\n        this.setVerticesData(VertexBuffer.NormalKind, normals, updatable);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Align the mesh with a normal\r\n     * @param normal defines the normal to use\r\n     * @param upDirection can be used to redefined the up vector to use (will use the (0, 1, 0) by default)\r\n     * @returns the current mesh\r\n     */\r\n    public alignWithNormal(normal: Vector3, upDirection?: Vector3): AbstractMesh {\r\n        if (!upDirection) {\r\n            upDirection = Axis.Y;\r\n        }\r\n\r\n        const axisX = TmpVectors.Vector3[0];\r\n        const axisZ = TmpVectors.Vector3[1];\r\n        Vector3.CrossToRef(upDirection, normal, axisZ);\r\n        Vector3.CrossToRef(normal, axisZ, axisX);\r\n\r\n        if (this.rotationQuaternion) {\r\n            Quaternion.RotationQuaternionFromAxisToRef(axisX, normal, axisZ, this.rotationQuaternion);\r\n        } else {\r\n            Vector3.RotationFromAxisToRef(axisX, normal, axisZ, this.rotation);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _checkOcclusionQuery(): boolean {\r\n        // Will be replaced by correct code if Occlusion queries are referenced\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disables the mesh edge rendering mode\r\n     * @returns the currentAbstractMesh\r\n     */\r\n    disableEdgesRendering(): AbstractMesh {\r\n        throw _WarnImport(\"EdgesRenderer\");\r\n    }\r\n\r\n    /**\r\n     * Enables the edge rendering mode on the mesh.\r\n     * This mode makes the mesh edges visible\r\n     * @param epsilon defines the maximal distance between two angles to detect a face\r\n     * @param checkVerticesInsteadOfIndices indicates that we should check vertex list directly instead of faces\r\n     * @param options options to the edge renderer\r\n     * @returns the currentAbstractMesh\r\n     * @see https://www.babylonjs-playground.com/#19O9TU#0\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    enableEdgesRendering(epsilon?: number, checkVerticesInsteadOfIndices?: boolean, options?: IEdgesRendererOptions): AbstractMesh {\r\n        throw _WarnImport(\"EdgesRenderer\");\r\n    }\r\n\r\n    /**\r\n     * This function returns all of the particle systems in the scene that use the mesh as an emitter.\r\n     * @returns an array of particle systems in the scene that use the mesh as an emitter\r\n     */\r\n    public getConnectedParticleSystems(): IParticleSystem[] {\r\n        return this._scene.particleSystems.filter((particleSystem) => particleSystem.emitter === this);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.AbstractMesh\", AbstractMesh);\r\n"]},"metadata":{},"sourceType":"module"}