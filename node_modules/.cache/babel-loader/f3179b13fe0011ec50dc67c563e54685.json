{"ast":null,"code":"import \"core-js/modules/es.object.to-string.js\";\nimport { Vector3, Matrix, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { PositionNormalTextureVertex } from \"../../Maths/math.vertexFormat.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates a decal mesh.\n * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal\n * * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates\n * * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates\n * * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling\n * * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal\n * * The parameter `captureUVS` defines if we need to capture the uvs or compute them\n * @param name defines the name of the mesh\n * @param sourceMesh defines the mesh where the decal must be applied\n * @param options defines the options used to create the mesh\n * @param options.position\n * @param options.normal\n * @param options.size\n * @param options.angle\n * @param options.captureUVS\n * @returns the decal mesh\n * @see https://doc.babylonjs.com/how_to/decals\n */\n\nexport function CreateDecal(name, sourceMesh, options) {\n  var indices = sourceMesh.getIndices();\n  var positions = sourceMesh.getVerticesData(VertexBuffer.PositionKind);\n  var normals = sourceMesh.getVerticesData(VertexBuffer.NormalKind);\n  var uvs = sourceMesh.getVerticesData(VertexBuffer.UVKind);\n  var position = options.position || Vector3.Zero();\n  var normal = options.normal || Vector3.Up();\n  var size = options.size || Vector3.One();\n  var angle = options.angle || 0; // Getting correct rotation\n\n  if (!normal) {\n    var target = new Vector3(0, 0, 1);\n    var camera = sourceMesh.getScene().activeCamera;\n    var cameraWorldTarget = Vector3.TransformCoordinates(target, camera.getWorldMatrix());\n    normal = camera.globalPosition.subtract(cameraWorldTarget);\n  }\n\n  var yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;\n  var len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);\n  var pitch = Math.atan2(normal.y, len); // Matrix\n\n  var decalWorldMatrix = Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(Matrix.Translation(position.x, position.y, position.z));\n  var inverseDecalWorldMatrix = Matrix.Invert(decalWorldMatrix);\n  var meshWorldMatrix = sourceMesh.getWorldMatrix();\n  var transformMatrix = meshWorldMatrix.multiply(inverseDecalWorldMatrix);\n  var vertexData = new VertexData();\n  vertexData.indices = [];\n  vertexData.positions = [];\n  vertexData.normals = [];\n  vertexData.uvs = [];\n  var currentVertexDataIndex = 0;\n\n  var extractDecalVector3 = function extractDecalVector3(indexId) {\n    var result = new PositionNormalTextureVertex();\n\n    if (!indices || !positions || !normals) {\n      return result;\n    }\n\n    var vertexId = indices[indexId];\n    result.position = new Vector3(positions[vertexId * 3], positions[vertexId * 3 + 1], positions[vertexId * 3 + 2]); // Send vector to decal local world\n\n    result.position = Vector3.TransformCoordinates(result.position, transformMatrix); // Get normal\n\n    result.normal = new Vector3(normals[vertexId * 3], normals[vertexId * 3 + 1], normals[vertexId * 3 + 2]);\n    result.normal = Vector3.TransformNormal(result.normal, transformMatrix);\n\n    if (options.captureUVS && uvs) {\n      var v = uvs[vertexId * 2 + 1];\n      result.uv = new Vector2(uvs[vertexId * 2], CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n    }\n\n    return result;\n  }; // Inspired by https://github.com/mrdoob/three.js/blob/eee231960882f6f3b6113405f524956145148146/examples/js/geometries/DecalGeometry.js\n\n\n  var clip = function clip(vertices, axis) {\n    if (vertices.length === 0) {\n      return vertices;\n    }\n\n    var clipSize = 0.5 * Math.abs(Vector3.Dot(size, axis));\n\n    var clipVertices = function clipVertices(v0, v1) {\n      var clipFactor = Vector3.GetClipFactor(v0.position, v1.position, axis, clipSize);\n      return new PositionNormalTextureVertex(Vector3.Lerp(v0.position, v1.position, clipFactor), Vector3.Lerp(v0.normal, v1.normal, clipFactor));\n    };\n\n    var result = new Array();\n\n    for (var index = 0; index < vertices.length; index += 3) {\n      var total = 0;\n      var nV1 = null;\n      var nV2 = null;\n      var nV3 = null;\n      var nV4 = null;\n      var d1 = Vector3.Dot(vertices[index].position, axis) - clipSize;\n      var d2 = Vector3.Dot(vertices[index + 1].position, axis) - clipSize;\n      var d3 = Vector3.Dot(vertices[index + 2].position, axis) - clipSize;\n      var v1Out = d1 > 0;\n      var v2Out = d2 > 0;\n      var v3Out = d3 > 0;\n      total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\n\n      switch (total) {\n        case 0:\n          result.push(vertices[index]);\n          result.push(vertices[index + 1]);\n          result.push(vertices[index + 2]);\n          break;\n\n        case 1:\n          if (v1Out) {\n            nV1 = vertices[index + 1];\n            nV2 = vertices[index + 2];\n            nV3 = clipVertices(vertices[index], nV1);\n            nV4 = clipVertices(vertices[index], nV2);\n          }\n\n          if (v2Out) {\n            nV1 = vertices[index];\n            nV2 = vertices[index + 2];\n            nV3 = clipVertices(vertices[index + 1], nV1);\n            nV4 = clipVertices(vertices[index + 1], nV2);\n            result.push(nV3);\n            result.push(nV2.clone());\n            result.push(nV1.clone());\n            result.push(nV2.clone());\n            result.push(nV3.clone());\n            result.push(nV4);\n            break;\n          }\n\n          if (v3Out) {\n            nV1 = vertices[index];\n            nV2 = vertices[index + 1];\n            nV3 = clipVertices(vertices[index + 2], nV1);\n            nV4 = clipVertices(vertices[index + 2], nV2);\n          }\n\n          if (nV1 && nV2 && nV3 && nV4) {\n            result.push(nV1.clone());\n            result.push(nV2.clone());\n            result.push(nV3);\n            result.push(nV4);\n            result.push(nV3.clone());\n            result.push(nV2.clone());\n          }\n\n          break;\n\n        case 2:\n          if (!v1Out) {\n            nV1 = vertices[index].clone();\n            nV2 = clipVertices(nV1, vertices[index + 1]);\n            nV3 = clipVertices(nV1, vertices[index + 2]);\n            result.push(nV1);\n            result.push(nV2);\n            result.push(nV3);\n          }\n\n          if (!v2Out) {\n            nV1 = vertices[index + 1].clone();\n            nV2 = clipVertices(nV1, vertices[index + 2]);\n            nV3 = clipVertices(nV1, vertices[index]);\n            result.push(nV1);\n            result.push(nV2);\n            result.push(nV3);\n          }\n\n          if (!v3Out) {\n            nV1 = vertices[index + 2].clone();\n            nV2 = clipVertices(nV1, vertices[index]);\n            nV3 = clipVertices(nV1, vertices[index + 1]);\n            result.push(nV1);\n            result.push(nV2);\n            result.push(nV3);\n          }\n\n          break;\n\n        case 3:\n          break;\n      }\n    }\n\n    return result;\n  };\n\n  for (var index = 0; index < indices.length; index += 3) {\n    var faceVertices = new Array();\n    faceVertices.push(extractDecalVector3(index));\n    faceVertices.push(extractDecalVector3(index + 1));\n    faceVertices.push(extractDecalVector3(index + 2)); // Clip\n\n    faceVertices = clip(faceVertices, new Vector3(1, 0, 0));\n    faceVertices = clip(faceVertices, new Vector3(-1, 0, 0));\n    faceVertices = clip(faceVertices, new Vector3(0, 1, 0));\n    faceVertices = clip(faceVertices, new Vector3(0, -1, 0));\n    faceVertices = clip(faceVertices, new Vector3(0, 0, 1));\n    faceVertices = clip(faceVertices, new Vector3(0, 0, -1));\n\n    if (faceVertices.length === 0) {\n      continue;\n    } // Add UVs and get back to world\n\n\n    for (var vIndex = 0; vIndex < faceVertices.length; vIndex++) {\n      var vertex = faceVertices[vIndex]; //TODO check for Int32Array | Uint32Array | Uint16Array\n\n      vertexData.indices.push(currentVertexDataIndex);\n      vertex.position.toArray(vertexData.positions, currentVertexDataIndex * 3);\n      vertex.normal.toArray(vertexData.normals, currentVertexDataIndex * 3);\n\n      if (!options.captureUVS) {\n        vertexData.uvs.push(0.5 + vertex.position.x / size.x);\n        var v = 0.5 + vertex.position.y / size.y;\n        vertexData.uvs.push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n      } else {\n        vertex.uv.toArray(vertexData.uvs, currentVertexDataIndex * 2);\n      }\n\n      currentVertexDataIndex++;\n    }\n  } // Return mesh\n\n\n  var decal = new Mesh(name, sourceMesh.getScene());\n  vertexData.applyToMesh(decal);\n  decal.position = position.clone();\n  decal.rotation = new Vector3(pitch, yaw, angle);\n  return decal;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the function directly from the module\n */\n\nexport var DecalBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateDecal: CreateDecal\n};\n\nMesh.CreateDecal = function (name, sourceMesh, position, normal, size, angle) {\n  var options = {\n    position: position,\n    normal: normal,\n    size: size,\n    angle: angle\n  };\n  return CreateDecal(name, sourceMesh, options);\n};","map":{"version":3,"mappings":"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","names":["Vector3","Matrix","Vector2","Mesh","VertexBuffer","VertexData","PositionNormalTextureVertex","CompatibilityOptions","CreateDecal","name","sourceMesh","options","indices","getIndices","positions","getVerticesData","PositionKind","normals","NormalKind","uvs","UVKind","position","Zero","normal","Up","size","One","angle","target","camera","getScene","activeCamera","cameraWorldTarget","TransformCoordinates","getWorldMatrix","globalPosition","subtract","yaw","Math","atan2","z","x","PI","len","sqrt","pitch","y","decalWorldMatrix","RotationYawPitchRoll","multiply","Translation","inverseDecalWorldMatrix","Invert","meshWorldMatrix","transformMatrix","vertexData","currentVertexDataIndex","extractDecalVector3","indexId","result","vertexId","TransformNormal","captureUVS","v","uv","UseOpenGLOrientationForUV","clip","vertices","axis","length","clipSize","abs","Dot","clipVertices","v0","v1","clipFactor","GetClipFactor","Lerp","Array","index","total","nV1","nV2","nV3","nV4","d1","d2","d3","v1Out","v2Out","v3Out","push","clone","faceVertices","vIndex","vertex","toArray","decal","applyToMesh","rotation","DecalBuilder"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Meshes/Builders/decalBuilder.ts"],"sourcesContent":["import type { Nullable, IndicesArray } from \"../../types\";\r\nimport { Vector3, Matrix, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { AbstractMesh } from \"../abstractMesh\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport { PositionNormalTextureVertex } from \"../../Maths/math.vertexFormat\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates a decal mesh.\r\n * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal\r\n * * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates\r\n * * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates\r\n * * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling\r\n * * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal\r\n * * The parameter `captureUVS` defines if we need to capture the uvs or compute them\r\n * @param name defines the name of the mesh\r\n * @param sourceMesh defines the mesh where the decal must be applied\r\n * @param options defines the options used to create the mesh\r\n * @param options.position\r\n * @param options.normal\r\n * @param options.size\r\n * @param options.angle\r\n * @param options.captureUVS\r\n * @returns the decal mesh\r\n * @see https://doc.babylonjs.com/how_to/decals\r\n */\r\nexport function CreateDecal(name: string, sourceMesh: AbstractMesh, options: { position?: Vector3; normal?: Vector3; size?: Vector3; angle?: number; captureUVS?: boolean }): Mesh {\r\n    const indices = <IndicesArray>sourceMesh.getIndices();\r\n    const positions = sourceMesh.getVerticesData(VertexBuffer.PositionKind);\r\n    const normals = sourceMesh.getVerticesData(VertexBuffer.NormalKind);\r\n    const uvs = sourceMesh.getVerticesData(VertexBuffer.UVKind);\r\n    const position = options.position || Vector3.Zero();\r\n    let normal = options.normal || Vector3.Up();\r\n    const size = options.size || Vector3.One();\r\n    const angle = options.angle || 0;\r\n\r\n    // Getting correct rotation\r\n    if (!normal) {\r\n        const target = new Vector3(0, 0, 1);\r\n        const camera = <Camera>sourceMesh.getScene().activeCamera;\r\n        const cameraWorldTarget = Vector3.TransformCoordinates(target, camera.getWorldMatrix());\r\n\r\n        normal = camera.globalPosition.subtract(cameraWorldTarget);\r\n    }\r\n\r\n    const yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;\r\n    const len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);\r\n    const pitch = Math.atan2(normal.y, len);\r\n\r\n    // Matrix\r\n    const decalWorldMatrix = Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(Matrix.Translation(position.x, position.y, position.z));\r\n    const inverseDecalWorldMatrix = Matrix.Invert(decalWorldMatrix);\r\n    const meshWorldMatrix = sourceMesh.getWorldMatrix();\r\n    const transformMatrix = meshWorldMatrix.multiply(inverseDecalWorldMatrix);\r\n\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = [];\r\n    vertexData.positions = [];\r\n    vertexData.normals = [];\r\n    vertexData.uvs = [];\r\n\r\n    let currentVertexDataIndex = 0;\r\n\r\n    const extractDecalVector3 = (indexId: number): PositionNormalTextureVertex => {\r\n        const result = new PositionNormalTextureVertex();\r\n        if (!indices || !positions || !normals) {\r\n            return result;\r\n        }\r\n\r\n        const vertexId = indices[indexId];\r\n        result.position = new Vector3(positions[vertexId * 3], positions[vertexId * 3 + 1], positions[vertexId * 3 + 2]);\r\n\r\n        // Send vector to decal local world\r\n        result.position = Vector3.TransformCoordinates(result.position, transformMatrix);\r\n\r\n        // Get normal\r\n        result.normal = new Vector3(normals[vertexId * 3], normals[vertexId * 3 + 1], normals[vertexId * 3 + 2]);\r\n        result.normal = Vector3.TransformNormal(result.normal, transformMatrix);\r\n\r\n        if (options.captureUVS && uvs) {\r\n            const v = uvs[vertexId * 2 + 1];\r\n            result.uv = new Vector2(uvs[vertexId * 2], CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n        }\r\n\r\n        return result;\r\n    }; // Inspired by https://github.com/mrdoob/three.js/blob/eee231960882f6f3b6113405f524956145148146/examples/js/geometries/DecalGeometry.js\r\n    const clip = (vertices: PositionNormalTextureVertex[], axis: Vector3): PositionNormalTextureVertex[] => {\r\n        if (vertices.length === 0) {\r\n            return vertices;\r\n        }\r\n\r\n        const clipSize = 0.5 * Math.abs(Vector3.Dot(size, axis));\r\n\r\n        const clipVertices = (v0: PositionNormalTextureVertex, v1: PositionNormalTextureVertex): PositionNormalTextureVertex => {\r\n            const clipFactor = Vector3.GetClipFactor(v0.position, v1.position, axis, clipSize);\r\n\r\n            return new PositionNormalTextureVertex(Vector3.Lerp(v0.position, v1.position, clipFactor), Vector3.Lerp(v0.normal, v1.normal, clipFactor));\r\n        };\r\n        const result = new Array<PositionNormalTextureVertex>();\r\n\r\n        for (let index = 0; index < vertices.length; index += 3) {\r\n            let total = 0;\r\n            let nV1: Nullable<PositionNormalTextureVertex> = null;\r\n            let nV2: Nullable<PositionNormalTextureVertex> = null;\r\n            let nV3: Nullable<PositionNormalTextureVertex> = null;\r\n            let nV4: Nullable<PositionNormalTextureVertex> = null;\r\n\r\n            const d1 = Vector3.Dot(vertices[index].position, axis) - clipSize;\r\n            const d2 = Vector3.Dot(vertices[index + 1].position, axis) - clipSize;\r\n            const d3 = Vector3.Dot(vertices[index + 2].position, axis) - clipSize;\r\n\r\n            const v1Out = d1 > 0;\r\n            const v2Out = d2 > 0;\r\n            const v3Out = d3 > 0;\r\n\r\n            total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\r\n\r\n            switch (total) {\r\n                case 0:\r\n                    result.push(vertices[index]);\r\n                    result.push(vertices[index + 1]);\r\n                    result.push(vertices[index + 2]);\r\n                    break;\r\n                case 1:\r\n                    if (v1Out) {\r\n                        nV1 = vertices[index + 1];\r\n                        nV2 = vertices[index + 2];\r\n                        nV3 = clipVertices(vertices[index], nV1);\r\n                        nV4 = clipVertices(vertices[index], nV2);\r\n                    }\r\n\r\n                    if (v2Out) {\r\n                        nV1 = vertices[index];\r\n                        nV2 = vertices[index + 2];\r\n                        nV3 = clipVertices(vertices[index + 1], nV1);\r\n                        nV4 = clipVertices(vertices[index + 1], nV2);\r\n\r\n                        result.push(nV3);\r\n                        result.push(nV2.clone());\r\n                        result.push(nV1.clone());\r\n\r\n                        result.push(nV2.clone());\r\n                        result.push(nV3.clone());\r\n                        result.push(nV4);\r\n                        break;\r\n                    }\r\n                    if (v3Out) {\r\n                        nV1 = vertices[index];\r\n                        nV2 = vertices[index + 1];\r\n                        nV3 = clipVertices(vertices[index + 2], nV1);\r\n                        nV4 = clipVertices(vertices[index + 2], nV2);\r\n                    }\r\n\r\n                    if (nV1 && nV2 && nV3 && nV4) {\r\n                        result.push(nV1.clone());\r\n                        result.push(nV2.clone());\r\n                        result.push(nV3);\r\n\r\n                        result.push(nV4);\r\n                        result.push(nV3.clone());\r\n                        result.push(nV2.clone());\r\n                    }\r\n                    break;\r\n                case 2:\r\n                    if (!v1Out) {\r\n                        nV1 = vertices[index].clone();\r\n                        nV2 = clipVertices(nV1, vertices[index + 1]);\r\n                        nV3 = clipVertices(nV1, vertices[index + 2]);\r\n                        result.push(nV1);\r\n                        result.push(nV2);\r\n                        result.push(nV3);\r\n                    }\r\n                    if (!v2Out) {\r\n                        nV1 = vertices[index + 1].clone();\r\n                        nV2 = clipVertices(nV1, vertices[index + 2]);\r\n                        nV3 = clipVertices(nV1, vertices[index]);\r\n                        result.push(nV1);\r\n                        result.push(nV2);\r\n                        result.push(nV3);\r\n                    }\r\n                    if (!v3Out) {\r\n                        nV1 = vertices[index + 2].clone();\r\n                        nV2 = clipVertices(nV1, vertices[index]);\r\n                        nV3 = clipVertices(nV1, vertices[index + 1]);\r\n                        result.push(nV1);\r\n                        result.push(nV2);\r\n                        result.push(nV3);\r\n                    }\r\n                    break;\r\n                case 3:\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n    for (let index = 0; index < indices.length; index += 3) {\r\n        let faceVertices = new Array<PositionNormalTextureVertex>();\r\n\r\n        faceVertices.push(extractDecalVector3(index));\r\n        faceVertices.push(extractDecalVector3(index + 1));\r\n        faceVertices.push(extractDecalVector3(index + 2));\r\n\r\n        // Clip\r\n        faceVertices = clip(faceVertices, new Vector3(1, 0, 0));\r\n        faceVertices = clip(faceVertices, new Vector3(-1, 0, 0));\r\n        faceVertices = clip(faceVertices, new Vector3(0, 1, 0));\r\n        faceVertices = clip(faceVertices, new Vector3(0, -1, 0));\r\n        faceVertices = clip(faceVertices, new Vector3(0, 0, 1));\r\n        faceVertices = clip(faceVertices, new Vector3(0, 0, -1));\r\n\r\n        if (faceVertices.length === 0) {\r\n            continue;\r\n        }\r\n\r\n        // Add UVs and get back to world\r\n        for (let vIndex = 0; vIndex < faceVertices.length; vIndex++) {\r\n            const vertex = faceVertices[vIndex];\r\n\r\n            //TODO check for Int32Array | Uint32Array | Uint16Array\r\n            (<number[]>vertexData.indices).push(currentVertexDataIndex);\r\n            vertex.position.toArray(vertexData.positions, currentVertexDataIndex * 3);\r\n            vertex.normal.toArray(vertexData.normals, currentVertexDataIndex * 3);\r\n\r\n            if (!options.captureUVS) {\r\n                (<number[]>vertexData.uvs).push(0.5 + vertex.position.x / size.x);\r\n                const v = 0.5 + vertex.position.y / size.y;\r\n                (<number[]>vertexData.uvs).push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n            } else {\r\n                vertex.uv.toArray(vertexData.uvs, currentVertexDataIndex * 2);\r\n            }\r\n            currentVertexDataIndex++;\r\n        }\r\n    }\r\n\r\n    // Return mesh\r\n    const decal = new Mesh(name, sourceMesh.getScene());\r\n    vertexData.applyToMesh(decal);\r\n\r\n    decal.position = position.clone();\r\n    decal.rotation = new Vector3(pitch, yaw, angle);\r\n\r\n    return decal;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function directly from the module\r\n */\r\nexport const DecalBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateDecal,\r\n};\r\n\r\n(Mesh as any).CreateDecal = (name: string, sourceMesh: AbstractMesh, position: Vector3, normal: Vector3, size: Vector3, angle: number): Mesh => {\r\n    const options = {\r\n        position,\r\n        normal,\r\n        size,\r\n        angle,\r\n    };\r\n\r\n    return CreateDecal(name, sourceMesh, options);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}