{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport { __decorate, __extends } from \"tslib\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator.js\";\nimport \"../../../../Shaders/ShadersInclude/helperFunctions.js\";\nimport \"../../../../Shaders/ShadersInclude/imageProcessingDeclaration.js\";\nimport \"../../../../Shaders/ShadersInclude/imageProcessingFunctions.js\";\n/**\n * Block used to add image processing support to fragment shader\n */\n\nvar ImageProcessingBlock =\n/** @class */\nfunction (_super) {\n  __extends(ImageProcessingBlock, _super);\n  /**\n   * Create a new ImageProcessingBlock\n   * @param name defines the block name\n   */\n\n\n  function ImageProcessingBlock(name) {\n    var _this = _super.call(this, name, NodeMaterialBlockTargets.Fragment) || this;\n    /**\n     * Defines if the input should be converted to linear space (default: true)\n     */\n\n\n    _this.convertInputToLinearSpace = true;\n\n    _this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.Color4);\n\n    _this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Color4);\n\n    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Color3);\n\n    return _this;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n\n\n  ImageProcessingBlock.prototype.getClassName = function () {\n    return \"ImageProcessingBlock\";\n  };\n\n  Object.defineProperty(ImageProcessingBlock.prototype, \"color\", {\n    /**\n     * Gets the color input component\n     */\n    get: function get() {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ImageProcessingBlock.prototype, \"output\", {\n    /**\n     * Gets the output component\n     */\n    get: function get() {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n\n  ImageProcessingBlock.prototype.initialize = function (state) {\n    state._excludeVariableName(\"exposureLinear\");\n\n    state._excludeVariableName(\"contrast\");\n\n    state._excludeVariableName(\"vInverseScreenSize\");\n\n    state._excludeVariableName(\"vignetteSettings1\");\n\n    state._excludeVariableName(\"vignetteSettings2\");\n\n    state._excludeVariableName(\"vCameraColorCurveNegative\");\n\n    state._excludeVariableName(\"vCameraColorCurveNeutral\");\n\n    state._excludeVariableName(\"vCameraColorCurvePositive\");\n\n    state._excludeVariableName(\"txColorTransform\");\n\n    state._excludeVariableName(\"colorTransformSettings\");\n  };\n\n  ImageProcessingBlock.prototype.isReady = function (mesh, nodeMaterial, defines) {\n    if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {\n      if (!nodeMaterial.imageProcessingConfiguration.isReady()) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  ImageProcessingBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {\n      nodeMaterial.imageProcessingConfiguration.prepareDefines(defines);\n    }\n  };\n\n  ImageProcessingBlock.prototype.bind = function (effect, nodeMaterial, mesh) {\n    if (!mesh) {\n      return;\n    }\n\n    if (!nodeMaterial.imageProcessingConfiguration) {\n      return;\n    }\n\n    nodeMaterial.imageProcessingConfiguration.bind(effect);\n  };\n\n  ImageProcessingBlock.prototype._buildBlock = function (state) {\n    _super.prototype._buildBlock.call(this, state); // Register for defines\n\n\n    state.sharedData.blocksWithDefines.push(this); // Register for blocking\n\n    state.sharedData.blockingBlocks.push(this); // Register for binding\n\n    state.sharedData.bindableBlocks.push(this); // Uniforms\n\n    state.uniforms.push(\"exposureLinear\");\n    state.uniforms.push(\"contrast\");\n    state.uniforms.push(\"vInverseScreenSize\");\n    state.uniforms.push(\"vignetteSettings1\");\n    state.uniforms.push(\"vignetteSettings2\");\n    state.uniforms.push(\"vCameraColorCurveNegative\");\n    state.uniforms.push(\"vCameraColorCurveNeutral\");\n    state.uniforms.push(\"vCameraColorCurvePositive\");\n    state.uniforms.push(\"txColorTransform\");\n    state.uniforms.push(\"colorTransformSettings\"); // Emit code\n\n    var color = this.color;\n    var output = this._outputs[0];\n    var comments = \"//\".concat(this.name);\n\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n\n    state._emitFunctionFromInclude(\"imageProcessingDeclaration\", comments);\n\n    state._emitFunctionFromInclude(\"imageProcessingFunctions\", comments);\n\n    if (color.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Color4 || color.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector4) {\n      state.compilationString += \"\".concat(this._declareOutput(output, state), \" = \").concat(color.associatedVariableName, \";\\r\\n\");\n    } else {\n      state.compilationString += \"\".concat(this._declareOutput(output, state), \" = vec4(\").concat(color.associatedVariableName, \", 1.0);\\r\\n\");\n    }\n\n    state.compilationString += \"#ifdef IMAGEPROCESSINGPOSTPROCESS\\r\\n\";\n\n    if (this.convertInputToLinearSpace) {\n      state.compilationString += \"\".concat(output.associatedVariableName, \".rgb = toLinearSpace(\").concat(color.associatedVariableName, \".rgb);\\r\\n\");\n    }\n\n    state.compilationString += \"#else\\r\\n\";\n    state.compilationString += \"#ifdef IMAGEPROCESSING\\r\\n\";\n\n    if (this.convertInputToLinearSpace) {\n      state.compilationString += \"\".concat(output.associatedVariableName, \".rgb = toLinearSpace(\").concat(color.associatedVariableName, \".rgb);\\r\\n\");\n    }\n\n    state.compilationString += \"\".concat(output.associatedVariableName, \" = applyImageProcessing(\").concat(output.associatedVariableName, \");\\r\\n\");\n    state.compilationString += \"#endif\\r\\n\";\n    state.compilationString += \"#endif\\r\\n\";\n    return this;\n  };\n\n  ImageProcessingBlock.prototype._dumpPropertiesCode = function () {\n    var codeString = _super.prototype._dumpPropertiesCode.call(this);\n\n    codeString += \"\".concat(this._codeVariableName, \".convertInputToLinearSpace = \").concat(this.convertInputToLinearSpace, \";\\r\\n\");\n    return codeString;\n  };\n\n  ImageProcessingBlock.prototype.serialize = function () {\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    serializationObject.convertInputToLinearSpace = this.convertInputToLinearSpace;\n    return serializationObject;\n  };\n\n  ImageProcessingBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {\n    var _a;\n\n    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);\n\n    this.convertInputToLinearSpace = (_a = serializationObject.convertInputToLinearSpace) !== null && _a !== void 0 ? _a : true;\n  };\n\n  __decorate([editableInPropertyPage(\"Convert input to linear space\", PropertyTypeForEdition.Boolean, \"ADVANCED\")], ImageProcessingBlock.prototype, \"convertInputToLinearSpace\", void 0);\n\n  return ImageProcessingBlock;\n}(NodeMaterialBlock);\n\nexport { ImageProcessingBlock };\nRegisterClass(\"BABYLON.ImageProcessingBlock\", ImageProcessingBlock);","map":{"version":3,"mappings":"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","names":["NodeMaterialBlock","NodeMaterialBlockConnectionPointTypes","NodeMaterialBlockTargets","RegisterClass","editableInPropertyPage","PropertyTypeForEdition","__extends","name","_super","Fragment","_this","registerInput","Color4","registerOutput","_inputs","acceptedConnectionPointTypes","push","Color3","ImageProcessingBlock","Object","_outputs","state","_excludeVariableName","mesh","nodeMaterial","defines","_areImageProcessingDirty","imageProcessingConfiguration","isReady","prepareDefines","effect","bind","_buildBlock","call","sharedData","blocksWithDefines","blockingBlocks","bindableBlocks","uniforms","color","output","comments","_emitFunctionFromInclude","connectedPoint","type","Vector4","compilationString","_declareOutput","concat","associatedVariableName","convertInputToLinearSpace","codeString","_dumpPropertiesCode","_codeVariableName","serializationObject","serialize","scene","rootUrl","_deserialize","_a","__decorate","Boolean"],"sourceRoot":"","sources":["../../../../../../../../lts/core/generated/Materials/Node/Blocks/Fragment/imageProcessingBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator\";\r\n\r\nimport \"../../../../Shaders/ShadersInclude/helperFunctions\";\r\nimport \"../../../../Shaders/ShadersInclude/imageProcessingDeclaration\";\r\nimport \"../../../../Shaders/ShadersInclude/imageProcessingFunctions\";\r\n\r\n/**\r\n * Block used to add image processing support to fragment shader\r\n */\r\nexport class ImageProcessingBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new ImageProcessingBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.Color4);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Color4);\r\n\r\n        this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Color3);\r\n    }\r\n\r\n    /**\r\n     * Defines if the input should be converted to linear space (default: true)\r\n     */\r\n    @editableInPropertyPage(\"Convert input to linear space\", PropertyTypeForEdition.Boolean, \"ADVANCED\")\r\n    public convertInputToLinearSpace: boolean = true;\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ImageProcessingBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the color input component\r\n     */\r\n    public get color(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"exposureLinear\");\r\n        state._excludeVariableName(\"contrast\");\r\n        state._excludeVariableName(\"vInverseScreenSize\");\r\n        state._excludeVariableName(\"vignetteSettings1\");\r\n        state._excludeVariableName(\"vignetteSettings2\");\r\n        state._excludeVariableName(\"vCameraColorCurveNegative\");\r\n        state._excludeVariableName(\"vCameraColorCurveNeutral\");\r\n        state._excludeVariableName(\"vCameraColorCurvePositive\");\r\n        state._excludeVariableName(\"txColorTransform\");\r\n        state._excludeVariableName(\"colorTransformSettings\");\r\n    }\r\n\r\n    public isReady(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {\r\n            if (!nodeMaterial.imageProcessingConfiguration.isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {\r\n            nodeMaterial.imageProcessingConfiguration.prepareDefines(defines);\r\n        }\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        if (!nodeMaterial.imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n\r\n        nodeMaterial.imageProcessingConfiguration.bind(effect);\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        // Register for defines\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        // Register for blocking\r\n        state.sharedData.blockingBlocks.push(this);\r\n\r\n        // Register for binding\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        // Uniforms\r\n        state.uniforms.push(\"exposureLinear\");\r\n        state.uniforms.push(\"contrast\");\r\n        state.uniforms.push(\"vInverseScreenSize\");\r\n        state.uniforms.push(\"vignetteSettings1\");\r\n        state.uniforms.push(\"vignetteSettings2\");\r\n        state.uniforms.push(\"vCameraColorCurveNegative\");\r\n        state.uniforms.push(\"vCameraColorCurveNeutral\");\r\n        state.uniforms.push(\"vCameraColorCurvePositive\");\r\n        state.uniforms.push(\"txColorTransform\");\r\n        state.uniforms.push(\"colorTransformSettings\");\r\n\r\n        // Emit code\r\n        const color = this.color;\r\n        const output = this._outputs[0];\r\n        const comments = `//${this.name}`;\r\n\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n        state._emitFunctionFromInclude(\"imageProcessingDeclaration\", comments);\r\n        state._emitFunctionFromInclude(\"imageProcessingFunctions\", comments);\r\n\r\n        if (color.connectedPoint!.type === NodeMaterialBlockConnectionPointTypes.Color4 || color.connectedPoint!.type === NodeMaterialBlockConnectionPointTypes.Vector4) {\r\n            state.compilationString += `${this._declareOutput(output, state)} = ${color.associatedVariableName};\\r\\n`;\r\n        } else {\r\n            state.compilationString += `${this._declareOutput(output, state)} = vec4(${color.associatedVariableName}, 1.0);\\r\\n`;\r\n        }\r\n        state.compilationString += `#ifdef IMAGEPROCESSINGPOSTPROCESS\\r\\n`;\r\n        if (this.convertInputToLinearSpace) {\r\n            state.compilationString += `${output.associatedVariableName}.rgb = toLinearSpace(${color.associatedVariableName}.rgb);\\r\\n`;\r\n        }\r\n        state.compilationString += `#else\\r\\n`;\r\n        state.compilationString += `#ifdef IMAGEPROCESSING\\r\\n`;\r\n        if (this.convertInputToLinearSpace) {\r\n            state.compilationString += `${output.associatedVariableName}.rgb = toLinearSpace(${color.associatedVariableName}.rgb);\\r\\n`;\r\n        }\r\n        state.compilationString += `${output.associatedVariableName} = applyImageProcessing(${output.associatedVariableName});\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        codeString += `${this._codeVariableName}.convertInputToLinearSpace = ${this.convertInputToLinearSpace};\\r\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertInputToLinearSpace = this.convertInputToLinearSpace;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertInputToLinearSpace = serializationObject.convertInputToLinearSpace ?? true;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ImageProcessingBlock\", ImageProcessingBlock);\r\n"]},"metadata":{},"sourceType":"module"}