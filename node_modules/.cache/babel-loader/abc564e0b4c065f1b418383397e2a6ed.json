{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport { InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\n/**\n * Wrapper around a render target (either single or multi textures)\n */\n\nvar RenderTargetWrapper =\n/** @class */\nfunction () {\n  /**\n   * Initializes the render target wrapper\n   * @param isMulti true if the wrapper is a multi render target\n   * @param isCube true if the wrapper should render to a cube texture\n   * @param size size of the render target (width/height/layers)\n   * @param engine engine used to create the render target\n   */\n  function RenderTargetWrapper(isMulti, isCube, size, engine) {\n    this._textures = null;\n    /** @hidden */\n\n    this._attachments = null;\n    /** @hidden */\n\n    this._generateStencilBuffer = false;\n    /** @hidden */\n\n    this._generateDepthBuffer = false;\n    /** @hidden */\n\n    this._depthStencilTextureWithStencil = false;\n    this._isMulti = isMulti;\n    this._isCube = isCube;\n    this._size = size;\n    this._engine = engine;\n    this._depthStencilTexture = null;\n  }\n\n  Object.defineProperty(RenderTargetWrapper.prototype, \"depthStencilTexture\", {\n    /**\n     * Gets the depth/stencil texture (if created by a createDepthStencilTexture() call)\n     */\n    get: function get() {\n      return this._depthStencilTexture;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderTargetWrapper.prototype, \"depthStencilTextureWithStencil\", {\n    /**\n     * Indicates if the depth/stencil texture has a stencil aspect\n     */\n    get: function get() {\n      return this._depthStencilTextureWithStencil;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderTargetWrapper.prototype, \"isCube\", {\n    /**\n     * Defines if the render target wrapper is for a cube texture or if false a 2d texture\n     */\n    get: function get() {\n      return this._isCube;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderTargetWrapper.prototype, \"isMulti\", {\n    /**\n     * Defines if the render target wrapper is for a single or multi target render wrapper\n     */\n    get: function get() {\n      return this._isMulti;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderTargetWrapper.prototype, \"is2DArray\", {\n    /**\n     * Defines if the render target wrapper is for a single or an array of textures\n     */\n    get: function get() {\n      return this.layers > 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderTargetWrapper.prototype, \"size\", {\n    /**\n     * Gets the size of the render target wrapper (used for cubes, as width=height in this case)\n     */\n    get: function get() {\n      return this.width;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderTargetWrapper.prototype, \"width\", {\n    /**\n     * Gets the width of the render target wrapper\n     */\n    get: function get() {\n      return this._size.width || this._size;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderTargetWrapper.prototype, \"height\", {\n    /**\n     * Gets the height of the render target wrapper\n     */\n    get: function get() {\n      return this._size.height || this._size;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderTargetWrapper.prototype, \"layers\", {\n    /**\n     * Gets the number of layers of the render target wrapper (only used if is2DArray is true)\n     */\n    get: function get() {\n      return this._size.layers || 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderTargetWrapper.prototype, \"texture\", {\n    /**\n     * Gets the render texture. If this is a multi render target, gets the first texture\n     */\n    get: function get() {\n      var _a, _b;\n\n      return (_b = (_a = this._textures) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderTargetWrapper.prototype, \"textures\", {\n    /**\n     * Gets the list of render textures. If we are not in a multi render target, the list will be null (use the texture getter instead)\n     */\n    get: function get() {\n      return this._textures;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderTargetWrapper.prototype, \"samples\", {\n    /**\n     * Gets the sample count of the render target\n     */\n    get: function get() {\n      var _a, _b;\n\n      return (_b = (_a = this.texture) === null || _a === void 0 ? void 0 : _a.samples) !== null && _b !== void 0 ? _b : 1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Sets the sample count of the render target\n   * @param value sample count\n   * @param initializeBuffers If set to true, the engine will make an initializing call to drawBuffers (only used when isMulti=true).\n   * @param force true to force calling the update sample count engine function even if the current sample count is equal to value\n   * @returns the sample count that has been set\n   */\n\n  RenderTargetWrapper.prototype.setSamples = function (value, initializeBuffers, force) {\n    if (initializeBuffers === void 0) {\n      initializeBuffers = true;\n    }\n\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (this.samples === value && !force) {\n      return value;\n    }\n\n    return this._isMulti ? this._engine.updateMultipleRenderTargetTextureSampleCount(this, value, initializeBuffers) : this._engine.updateRenderTargetTextureSampleCount(this, value);\n  };\n  /**\n   * Sets the render target texture(s)\n   * @param textures texture(s) to set\n   */\n\n\n  RenderTargetWrapper.prototype.setTextures = function (textures) {\n    if (Array.isArray(textures)) {\n      this._textures = textures;\n    } else if (textures) {\n      this._textures = [textures];\n    } else {\n      this._textures = null;\n    }\n  };\n  /**\n   * Set a texture in the textures array\n   * @param texture the texture to set\n   * @param index the index in the textures array to set\n   * @param disposePrevious If this function should dispose the previous texture\n   */\n\n\n  RenderTargetWrapper.prototype.setTexture = function (texture, index, disposePrevious) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    if (disposePrevious === void 0) {\n      disposePrevious = true;\n    }\n\n    if (!this._textures) {\n      this._textures = [];\n    }\n\n    if (this._textures[index] && disposePrevious) {\n      this._textures[index].dispose();\n    }\n\n    this._textures[index] = texture;\n  };\n  /**\n   * Creates the depth/stencil texture\n   * @param comparisonFunction Comparison function to use for the texture\n   * @param bilinearFiltering true if bilinear filtering should be used when sampling the texture\n   * @param generateStencil true if the stencil aspect should also be created\n   * @param samples sample count to use when creating the texture\n   * @param format format of the depth texture\n   * @returns the depth/stencil created texture\n   */\n\n\n  RenderTargetWrapper.prototype.createDepthStencilTexture = function (comparisonFunction, bilinearFiltering, generateStencil, samples, format) {\n    var _a;\n\n    if (comparisonFunction === void 0) {\n      comparisonFunction = 0;\n    }\n\n    if (bilinearFiltering === void 0) {\n      bilinearFiltering = true;\n    }\n\n    if (generateStencil === void 0) {\n      generateStencil = false;\n    }\n\n    if (samples === void 0) {\n      samples = 1;\n    }\n\n    if (format === void 0) {\n      format = 14;\n    }\n\n    (_a = this._depthStencilTexture) === null || _a === void 0 ? void 0 : _a.dispose();\n    this._depthStencilTextureWithStencil = generateStencil;\n    this._depthStencilTexture = this._engine.createDepthStencilTexture(this._size, {\n      bilinearFiltering: bilinearFiltering,\n      comparisonFunction: comparisonFunction,\n      generateStencil: generateStencil,\n      isCube: this._isCube,\n      samples: samples,\n      depthTextureFormat: format\n    }, this);\n    return this._depthStencilTexture;\n  };\n  /**\n   * Shares the depth buffer of this render target with another render target.\n   * @hidden\n   * @param renderTarget Destination renderTarget\n   */\n\n\n  RenderTargetWrapper.prototype._shareDepth = function (renderTarget) {\n    if (this._depthStencilTexture) {\n      if (renderTarget._depthStencilTexture) {\n        renderTarget._depthStencilTexture.dispose();\n      }\n\n      renderTarget._depthStencilTexture = this._depthStencilTexture;\n\n      this._depthStencilTexture.incrementReferences();\n    }\n  };\n  /**\n   * @param target\n   * @hidden\n   */\n\n\n  RenderTargetWrapper.prototype._swapAndDie = function (target) {\n    if (this.texture) {\n      this.texture._swapAndDie(target);\n    }\n\n    this._textures = null;\n    this.dispose(true);\n  };\n\n  RenderTargetWrapper.prototype._cloneRenderTargetWrapper = function () {\n    var _a, _b, _c, _d, _e, _f;\n\n    var rtw = null;\n\n    if (this._isMulti) {\n      var textureArray = this.textures;\n\n      if (textureArray && textureArray.length > 0) {\n        var generateDepthTexture = false;\n        var textureCount = textureArray.length;\n        var lastTextureSource = textureArray[textureArray.length - 1]._source;\n\n        if (lastTextureSource === InternalTextureSource.Depth || lastTextureSource === InternalTextureSource.DepthStencil) {\n          generateDepthTexture = true;\n          textureCount--;\n        }\n\n        var samplingModes = [];\n        var types = [];\n\n        for (var i = 0; i < textureCount; ++i) {\n          var texture = textureArray[i];\n          samplingModes.push(texture.samplingMode);\n          types.push(texture.type);\n        }\n\n        var optionsMRT = {\n          samplingModes: samplingModes,\n          generateMipMaps: textureArray[0].generateMipMaps,\n          generateDepthBuffer: this._generateDepthBuffer,\n          generateStencilBuffer: this._generateStencilBuffer,\n          generateDepthTexture: generateDepthTexture,\n          types: types,\n          textureCount: textureCount\n        };\n        var size = {\n          width: this.width,\n          height: this.height\n        };\n        rtw = this._engine.createMultipleRenderTarget(size, optionsMRT);\n      }\n    } else {\n      var options = {};\n      options.generateDepthBuffer = this._generateDepthBuffer;\n      options.generateMipMaps = (_b = (_a = this.texture) === null || _a === void 0 ? void 0 : _a.generateMipMaps) !== null && _b !== void 0 ? _b : false;\n      options.generateStencilBuffer = this._generateStencilBuffer;\n      options.samplingMode = (_c = this.texture) === null || _c === void 0 ? void 0 : _c.samplingMode;\n      options.type = (_d = this.texture) === null || _d === void 0 ? void 0 : _d.type;\n      options.format = (_e = this.texture) === null || _e === void 0 ? void 0 : _e.format;\n\n      if (this.isCube) {\n        rtw = this._engine.createRenderTargetCubeTexture(this.width, options);\n      } else {\n        var size = {\n          width: this.width,\n          height: this.height,\n          layers: this.is2DArray ? (_f = this.texture) === null || _f === void 0 ? void 0 : _f.depth : undefined\n        };\n        rtw = this._engine.createRenderTargetTexture(size, options);\n      }\n\n      rtw.texture.isReady = true;\n    }\n\n    return rtw;\n  };\n\n  RenderTargetWrapper.prototype._swapRenderTargetWrapper = function (target) {\n    if (this._textures && target._textures) {\n      for (var i = 0; i < this._textures.length; ++i) {\n        this._textures[i]._swapAndDie(target._textures[i], false);\n\n        target._textures[i].isReady = true;\n      }\n    }\n\n    if (this._depthStencilTexture && target._depthStencilTexture) {\n      this._depthStencilTexture._swapAndDie(target._depthStencilTexture);\n\n      target._depthStencilTexture.isReady = true;\n    }\n\n    this._textures = null;\n    this._depthStencilTexture = null;\n  };\n  /** @hidden */\n\n\n  RenderTargetWrapper.prototype._rebuild = function () {\n    var rtw = this._cloneRenderTargetWrapper();\n\n    if (!rtw) {\n      return;\n    }\n\n    if (this._depthStencilTexture) {\n      var samplingMode = this._depthStencilTexture.samplingMode;\n      var bilinear = samplingMode === 2 || samplingMode === 3 || samplingMode === 11;\n      rtw.createDepthStencilTexture(this._depthStencilTexture._comparisonFunction, bilinear, this._depthStencilTextureWithStencil, this._depthStencilTexture.samples);\n    }\n\n    if (this.samples > 1) {\n      rtw.setSamples(this.samples);\n    }\n\n    rtw._swapRenderTargetWrapper(this);\n\n    rtw.dispose();\n  };\n  /**\n   * Releases the internal render textures\n   */\n\n\n  RenderTargetWrapper.prototype.releaseTextures = function () {\n    var _a, _b;\n\n    if (this._textures) {\n      for (var i = 0; (_b = i < ((_a = this._textures) === null || _a === void 0 ? void 0 : _a.length)) !== null && _b !== void 0 ? _b : 0; ++i) {\n        this._textures[i].dispose();\n      }\n    }\n\n    this._textures = null;\n  };\n  /**\n   * Disposes the whole render target wrapper\n   * @param disposeOnlyFramebuffers true if only the frame buffers should be released (used for the WebGL engine). If false, all the textures will also be released\n   */\n\n\n  RenderTargetWrapper.prototype.dispose = function (disposeOnlyFramebuffers) {\n    var _a;\n\n    if (disposeOnlyFramebuffers === void 0) {\n      disposeOnlyFramebuffers = false;\n    }\n\n    if (!disposeOnlyFramebuffers) {\n      (_a = this._depthStencilTexture) === null || _a === void 0 ? void 0 : _a.dispose();\n      this._depthStencilTexture = null;\n      this.releaseTextures();\n    }\n\n    this._engine._releaseRenderTargetWrapper(this);\n  };\n\n  return RenderTargetWrapper;\n}();\n\nexport { RenderTargetWrapper };","map":{"version":3,"mappings":"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","names":["InternalTextureSource","isMulti","isCube","size","engine","_isMulti","_isCube","_size","_engine","_depthStencilTexture","Object","RenderTargetWrapper","_depthStencilTextureWithStencil","layers","width","height","_textures","_a","_b","texture","samples","value","initializeBuffers","force","updateMultipleRenderTargetTextureSampleCount","updateRenderTargetTextureSampleCount","textures","Array","isArray","index","disposePrevious","dispose","comparisonFunction","bilinearFiltering","generateStencil","format","createDepthStencilTexture","depthTextureFormat","renderTarget","incrementReferences","target","_swapAndDie","rtw","textureArray","length","generateDepthTexture","textureCount","lastTextureSource","_source","Depth","DepthStencil","samplingModes","types","i","push","samplingMode","type","optionsMRT","generateMipMaps","generateDepthBuffer","_generateDepthBuffer","generateStencilBuffer","_generateStencilBuffer","createMultipleRenderTarget","options","_c","_d","_e","createRenderTargetCubeTexture","is2DArray","_f","depth","undefined","createRenderTargetTexture","isReady","_cloneRenderTargetWrapper","bilinear","_comparisonFunction","setSamples","_swapRenderTargetWrapper","disposeOnlyFramebuffers","releaseTextures","_releaseRenderTargetWrapper"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Engines/renderTargetWrapper.ts"],"sourcesContent":["import type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport type { RenderTargetCreationOptions, TextureSize } from \"../Materials/Textures/textureCreationOptions\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Constants } from \"./constants\";\r\nimport type { ThinEngine } from \"./thinEngine\";\r\n\r\n/**\r\n * An interface enforcing the renderTarget accessor to used by render target textures.\r\n */\r\nexport interface IRenderTargetTexture {\r\n    /**\r\n     * Entry point to access the wrapper on a texture.\r\n     */\r\n    renderTarget: Nullable<RenderTargetWrapper>;\r\n}\r\n\r\n/**\r\n * Wrapper around a render target (either single or multi textures)\r\n */\r\nexport class RenderTargetWrapper {\r\n    protected _engine: ThinEngine;\r\n    private _size: TextureSize;\r\n    private _isCube: boolean;\r\n    private _isMulti: boolean;\r\n    private _textures: Nullable<InternalTexture[]> = null;\r\n\r\n    /** @hidden */\r\n    public _attachments: Nullable<number[]> = null;\r\n    /** @hidden */\r\n    public _generateStencilBuffer: boolean = false;\r\n    /** @hidden */\r\n    public _generateDepthBuffer: boolean = false;\r\n\r\n    /** @hidden */\r\n    public _depthStencilTexture: Nullable<InternalTexture>;\r\n    /** @hidden */\r\n    public _depthStencilTextureWithStencil: boolean = false;\r\n\r\n    /**\r\n     * Gets the depth/stencil texture (if created by a createDepthStencilTexture() call)\r\n     */\r\n    public get depthStencilTexture() {\r\n        return this._depthStencilTexture;\r\n    }\r\n\r\n    /**\r\n     * Indicates if the depth/stencil texture has a stencil aspect\r\n     */\r\n    public get depthStencilTextureWithStencil() {\r\n        return this._depthStencilTextureWithStencil;\r\n    }\r\n\r\n    /**\r\n     * Defines if the render target wrapper is for a cube texture or if false a 2d texture\r\n     */\r\n    public get isCube(): boolean {\r\n        return this._isCube;\r\n    }\r\n\r\n    /**\r\n     * Defines if the render target wrapper is for a single or multi target render wrapper\r\n     */\r\n    public get isMulti(): boolean {\r\n        return this._isMulti;\r\n    }\r\n\r\n    /**\r\n     * Defines if the render target wrapper is for a single or an array of textures\r\n     */\r\n    public get is2DArray(): boolean {\r\n        return this.layers > 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the size of the render target wrapper (used for cubes, as width=height in this case)\r\n     */\r\n    public get size(): number {\r\n        return this.width;\r\n    }\r\n\r\n    /**\r\n     * Gets the width of the render target wrapper\r\n     */\r\n    public get width(): number {\r\n        return (<{ width: number; height: number }>this._size).width || <number>this._size;\r\n    }\r\n\r\n    /**\r\n     * Gets the height of the render target wrapper\r\n     */\r\n    public get height(): number {\r\n        return (<{ width: number; height: number }>this._size).height || <number>this._size;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of layers of the render target wrapper (only used if is2DArray is true)\r\n     */\r\n    public get layers(): number {\r\n        return (<{ width: number; height: number; layers?: number }>this._size).layers || 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the render texture. If this is a multi render target, gets the first texture\r\n     */\r\n    public get texture(): Nullable<InternalTexture> {\r\n        return this._textures?.[0] ?? null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of render textures. If we are not in a multi render target, the list will be null (use the texture getter instead)\r\n     */\r\n    public get textures(): Nullable<InternalTexture[]> {\r\n        return this._textures;\r\n    }\r\n\r\n    /**\r\n     * Gets the sample count of the render target\r\n     */\r\n    public get samples(): number {\r\n        return this.texture?.samples ?? 1;\r\n    }\r\n\r\n    /**\r\n     * Sets the sample count of the render target\r\n     * @param value sample count\r\n     * @param initializeBuffers If set to true, the engine will make an initializing call to drawBuffers (only used when isMulti=true).\r\n     * @param force true to force calling the update sample count engine function even if the current sample count is equal to value\r\n     * @returns the sample count that has been set\r\n     */\r\n    public setSamples(value: number, initializeBuffers = true, force = false): number {\r\n        if (this.samples === value && !force) {\r\n            return value;\r\n        }\r\n\r\n        return this._isMulti\r\n            ? this._engine.updateMultipleRenderTargetTextureSampleCount(this, value, initializeBuffers)\r\n            : this._engine.updateRenderTargetTextureSampleCount(this, value);\r\n    }\r\n\r\n    /**\r\n     * Initializes the render target wrapper\r\n     * @param isMulti true if the wrapper is a multi render target\r\n     * @param isCube true if the wrapper should render to a cube texture\r\n     * @param size size of the render target (width/height/layers)\r\n     * @param engine engine used to create the render target\r\n     */\r\n    constructor(isMulti: boolean, isCube: boolean, size: TextureSize, engine: ThinEngine) {\r\n        this._isMulti = isMulti;\r\n        this._isCube = isCube;\r\n        this._size = size;\r\n        this._engine = engine;\r\n        this._depthStencilTexture = null;\r\n    }\r\n\r\n    /**\r\n     * Sets the render target texture(s)\r\n     * @param textures texture(s) to set\r\n     */\r\n    public setTextures(textures: Nullable<InternalTexture> | Nullable<InternalTexture[]>): void {\r\n        if (Array.isArray(textures)) {\r\n            this._textures = textures;\r\n        } else if (textures) {\r\n            this._textures = [textures];\r\n        } else {\r\n            this._textures = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the textures array\r\n     * @param texture the texture to set\r\n     * @param index the index in the textures array to set\r\n     * @param disposePrevious If this function should dispose the previous texture\r\n     */\r\n    public setTexture(texture: InternalTexture, index: number = 0, disposePrevious: boolean = true): void {\r\n        if (!this._textures) {\r\n            this._textures = [];\r\n        }\r\n        if (this._textures[index] && disposePrevious) {\r\n            this._textures[index].dispose();\r\n        }\r\n\r\n        this._textures[index] = texture;\r\n    }\r\n\r\n    /**\r\n     * Creates the depth/stencil texture\r\n     * @param comparisonFunction Comparison function to use for the texture\r\n     * @param bilinearFiltering true if bilinear filtering should be used when sampling the texture\r\n     * @param generateStencil true if the stencil aspect should also be created\r\n     * @param samples sample count to use when creating the texture\r\n     * @param format format of the depth texture\r\n     * @returns the depth/stencil created texture\r\n     */\r\n    public createDepthStencilTexture(\r\n        comparisonFunction: number = 0,\r\n        bilinearFiltering: boolean = true,\r\n        generateStencil: boolean = false,\r\n        samples: number = 1,\r\n        format: number = Constants.TEXTUREFORMAT_DEPTH32_FLOAT\r\n    ): InternalTexture {\r\n        this._depthStencilTexture?.dispose();\r\n\r\n        this._depthStencilTextureWithStencil = generateStencil;\r\n        this._depthStencilTexture = this._engine.createDepthStencilTexture(\r\n            this._size,\r\n            {\r\n                bilinearFiltering,\r\n                comparisonFunction,\r\n                generateStencil,\r\n                isCube: this._isCube,\r\n                samples,\r\n                depthTextureFormat: format,\r\n            },\r\n            this\r\n        );\r\n\r\n        return this._depthStencilTexture;\r\n    }\r\n\r\n    /**\r\n     * Shares the depth buffer of this render target with another render target.\r\n     * @hidden\r\n     * @param renderTarget Destination renderTarget\r\n     */\r\n    public _shareDepth(renderTarget: RenderTargetWrapper): void {\r\n        if (this._depthStencilTexture) {\r\n            if (renderTarget._depthStencilTexture) {\r\n                renderTarget._depthStencilTexture.dispose();\r\n            }\r\n\r\n            renderTarget._depthStencilTexture = this._depthStencilTexture;\r\n            this._depthStencilTexture.incrementReferences();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param target\r\n     * @hidden\r\n     */\r\n    public _swapAndDie(target: InternalTexture): void {\r\n        if (this.texture) {\r\n            this.texture._swapAndDie(target);\r\n        }\r\n        this._textures = null;\r\n        this.dispose(true);\r\n    }\r\n\r\n    protected _cloneRenderTargetWrapper(): Nullable<RenderTargetWrapper> {\r\n        let rtw: Nullable<RenderTargetWrapper> = null;\r\n\r\n        if (this._isMulti) {\r\n            const textureArray = this.textures;\r\n            if (textureArray && textureArray.length > 0) {\r\n                let generateDepthTexture = false;\r\n                let textureCount = textureArray.length;\r\n\r\n                const lastTextureSource = textureArray[textureArray.length - 1]._source;\r\n                if (lastTextureSource === InternalTextureSource.Depth || lastTextureSource === InternalTextureSource.DepthStencil) {\r\n                    generateDepthTexture = true;\r\n                    textureCount--;\r\n                }\r\n\r\n                const samplingModes: number[] = [];\r\n                const types: number[] = [];\r\n\r\n                for (let i = 0; i < textureCount; ++i) {\r\n                    const texture = textureArray[i];\r\n\r\n                    samplingModes.push(texture.samplingMode);\r\n                    types.push(texture.type);\r\n                }\r\n\r\n                const optionsMRT = {\r\n                    samplingModes,\r\n                    generateMipMaps: textureArray[0].generateMipMaps,\r\n                    generateDepthBuffer: this._generateDepthBuffer,\r\n                    generateStencilBuffer: this._generateStencilBuffer,\r\n                    generateDepthTexture,\r\n                    types,\r\n                    textureCount,\r\n                };\r\n                const size = {\r\n                    width: this.width,\r\n                    height: this.height,\r\n                };\r\n\r\n                rtw = this._engine.createMultipleRenderTarget(size, optionsMRT);\r\n            }\r\n        } else {\r\n            const options: RenderTargetCreationOptions = {};\r\n\r\n            options.generateDepthBuffer = this._generateDepthBuffer;\r\n            options.generateMipMaps = this.texture?.generateMipMaps ?? false;\r\n            options.generateStencilBuffer = this._generateStencilBuffer;\r\n            options.samplingMode = this.texture?.samplingMode;\r\n            options.type = this.texture?.type;\r\n            options.format = this.texture?.format;\r\n\r\n            if (this.isCube) {\r\n                rtw = this._engine.createRenderTargetCubeTexture(this.width, options);\r\n            } else {\r\n                const size = {\r\n                    width: this.width,\r\n                    height: this.height,\r\n                    layers: this.is2DArray ? this.texture?.depth : undefined,\r\n                };\r\n\r\n                rtw = this._engine.createRenderTargetTexture(size, options);\r\n            }\r\n            rtw.texture!.isReady = true;\r\n        }\r\n\r\n        return rtw;\r\n    }\r\n\r\n    protected _swapRenderTargetWrapper(target: RenderTargetWrapper): void {\r\n        if (this._textures && target._textures) {\r\n            for (let i = 0; i < this._textures.length; ++i) {\r\n                this._textures[i]._swapAndDie(target._textures[i], false);\r\n                target._textures[i].isReady = true;\r\n            }\r\n        }\r\n        if (this._depthStencilTexture && target._depthStencilTexture) {\r\n            this._depthStencilTexture._swapAndDie(target._depthStencilTexture);\r\n            target._depthStencilTexture.isReady = true;\r\n        }\r\n\r\n        this._textures = null;\r\n        this._depthStencilTexture = null;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        const rtw = this._cloneRenderTargetWrapper();\r\n        if (!rtw) {\r\n            return;\r\n        }\r\n\r\n        if (this._depthStencilTexture) {\r\n            const samplingMode = this._depthStencilTexture.samplingMode;\r\n            const bilinear =\r\n                samplingMode === Constants.TEXTURE_BILINEAR_SAMPLINGMODE ||\r\n                samplingMode === Constants.TEXTURE_TRILINEAR_SAMPLINGMODE ||\r\n                samplingMode === Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST;\r\n            rtw.createDepthStencilTexture(this._depthStencilTexture._comparisonFunction, bilinear, this._depthStencilTextureWithStencil, this._depthStencilTexture.samples);\r\n        }\r\n\r\n        if (this.samples > 1) {\r\n            rtw.setSamples(this.samples);\r\n        }\r\n\r\n        rtw._swapRenderTargetWrapper(this);\r\n        rtw.dispose();\r\n    }\r\n\r\n    /**\r\n     * Releases the internal render textures\r\n     */\r\n    public releaseTextures(): void {\r\n        if (this._textures) {\r\n            for (let i = 0; i < this._textures?.length ?? 0; ++i) {\r\n                this._textures[i].dispose();\r\n            }\r\n        }\r\n        this._textures = null;\r\n    }\r\n\r\n    /**\r\n     * Disposes the whole render target wrapper\r\n     * @param disposeOnlyFramebuffers true if only the frame buffers should be released (used for the WebGL engine). If false, all the textures will also be released\r\n     */\r\n    public dispose(disposeOnlyFramebuffers = false): void {\r\n        if (!disposeOnlyFramebuffers) {\r\n            this._depthStencilTexture?.dispose();\r\n            this._depthStencilTexture = null;\r\n            this.releaseTextures();\r\n        }\r\n\r\n        this._engine._releaseRenderTargetWrapper(this);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}