{"ast":null,"code":"import \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { __extends } from \"tslib\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Quaternion, Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport \"../Meshes/Builders/linesBuilder.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport { Effect } from \"../Materials/effect.js\";\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder.js\";\nimport { CreateTorus } from \"../Meshes/Builders/torusBuilder.js\";\n/**\n * Single plane rotation gizmo\n */\n\nvar PlaneRotationGizmo =\n/** @class */\nfunction (_super) {\n  __extends(PlaneRotationGizmo, _super);\n  /**\n   * Creates a PlaneRotationGizmo\n   * @param planeNormal The normal of the plane which the gizmo will be able to rotate on\n   * @param color The color of the gizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   * @param tessellation Amount of tessellation to be used when creating rotation circles\n   * @param parent\n   * @param useEulerRotation Use and update Euler angle instead of quaternion\n   * @param thickness display gizmo axis thickness\n   */\n\n\n  function PlaneRotationGizmo(planeNormal, color, gizmoLayer, tessellation, parent, // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  useEulerRotation, thickness) {\n    if (color === void 0) {\n      color = Color3.Gray();\n    }\n\n    if (gizmoLayer === void 0) {\n      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;\n    }\n\n    if (tessellation === void 0) {\n      tessellation = 32;\n    }\n\n    if (parent === void 0) {\n      parent = null;\n    }\n\n    if (useEulerRotation === void 0) {\n      useEulerRotation = false;\n    }\n\n    if (thickness === void 0) {\n      thickness = 1;\n    }\n\n    var _this = this;\n\n    var _a;\n\n    _this = _super.call(this, gizmoLayer) || this;\n    _this._pointerObserver = null;\n    /**\n     * Rotation distance in radians that the gizmo will snap to (Default: 0)\n     */\n\n    _this.snapDistance = 0;\n    /**\n     * Event that fires each time the gizmo snaps to a new location.\n     * * snapDistance is the the change in distance\n     */\n\n    _this.onSnapObservable = new Observable();\n    /**\n     * Accumulated relative angle value for rotation on the axis. Reset to 0 when a dragStart occurs\n     */\n\n    _this.angle = 0;\n    _this._isEnabled = true;\n    _this._parent = null;\n    _this._dragging = false;\n    _this._angles = new Vector3();\n    _this._parent = parent; // Create Material\n\n    _this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this._coloredMaterial.diffuseColor = color;\n    _this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));\n    _this._hoverMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this._hoverMaterial.diffuseColor = Color3.Yellow();\n    _this._disableMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this._disableMaterial.diffuseColor = Color3.Gray();\n    _this._disableMaterial.alpha = 0.4; // Build mesh on root node\n\n    _this._gizmoMesh = new Mesh(\"\", gizmoLayer.utilityLayerScene);\n\n    var _b = _this._createGizmoMesh(_this._gizmoMesh, thickness, tessellation),\n        rotationMesh = _b.rotationMesh,\n        collider = _b.collider; // Setup Rotation Circle\n\n\n    _this._rotationDisplayPlane = CreatePlane(\"rotationDisplay\", {\n      size: 0.6,\n      updatable: false\n    }, _this.gizmoLayer.utilityLayerScene);\n    _this._rotationDisplayPlane.rotation.z = Math.PI * 0.5;\n    _this._rotationDisplayPlane.parent = _this._gizmoMesh;\n\n    _this._rotationDisplayPlane.setEnabled(false);\n\n    Effect.ShadersStore[\"rotationGizmoVertexShader\"] = PlaneRotationGizmo._RotationGizmoVertexShader;\n    Effect.ShadersStore[\"rotationGizmoFragmentShader\"] = PlaneRotationGizmo._RotationGizmoFragmentShader;\n    _this._rotationShaderMaterial = new ShaderMaterial(\"shader\", _this.gizmoLayer.utilityLayerScene, {\n      vertex: \"rotationGizmo\",\n      fragment: \"rotationGizmo\"\n    }, {\n      attributes: [\"position\", \"uv\"],\n      uniforms: [\"worldViewProjection\", \"angles\"]\n    });\n    _this._rotationShaderMaterial.backFaceCulling = false;\n    _this._rotationDisplayPlane.material = _this._rotationShaderMaterial;\n    _this._rotationDisplayPlane.visibility = 0.999;\n\n    _this._gizmoMesh.lookAt(_this._rootMesh.position.add(planeNormal));\n\n    _this._rootMesh.addChild(_this._gizmoMesh, Gizmo.PreserveScaling);\n\n    _this._gizmoMesh.scaling.scaleInPlace(1 / 3); // Add drag behavior to handle events when the gizmo is dragged\n\n\n    _this.dragBehavior = new PointerDragBehavior({\n      dragPlaneNormal: planeNormal\n    });\n    _this.dragBehavior.moveAttached = false;\n    _this.dragBehavior.maxDragAngle = PlaneRotationGizmo.MaxDragAngle;\n    _this.dragBehavior._useAlternatePickedPointAboveMaxDragAngle = true;\n\n    _this._rootMesh.addBehavior(_this.dragBehavior); // Closures for drag logic\n\n\n    var lastDragPosition = new Vector3();\n    var rotationMatrix = new Matrix();\n    var planeNormalTowardsCamera = new Vector3();\n    var localPlaneNormalTowardsCamera = new Vector3();\n\n    _this.dragBehavior.onDragStartObservable.add(function (e) {\n      if (_this.attachedNode) {\n        lastDragPosition.copyFrom(e.dragPlanePoint);\n\n        _this._rotationDisplayPlane.setEnabled(true);\n\n        _this._rotationDisplayPlane.getWorldMatrix().invertToRef(rotationMatrix);\n\n        Vector3.TransformCoordinatesToRef(e.dragPlanePoint, rotationMatrix, lastDragPosition);\n        _this._angles.x = Math.atan2(lastDragPosition.y, lastDragPosition.x) + Math.PI;\n        _this._angles.y = 0;\n        _this._angles.z = _this.updateGizmoRotationToMatchAttachedMesh ? 1 : 0;\n        _this._dragging = true;\n        lastDragPosition.copyFrom(e.dragPlanePoint);\n\n        _this._rotationShaderMaterial.setVector3(\"angles\", _this._angles);\n\n        _this.angle = 0;\n      }\n    });\n\n    _this.dragBehavior.onDragEndObservable.add(function () {\n      _this._dragging = false;\n\n      _this._rotationDisplayPlane.setEnabled(false);\n    });\n\n    var tmpSnapEvent = {\n      snapDistance: 0\n    };\n    var currentSnapDragDistance = 0;\n    var tmpMatrix = new Matrix();\n    var amountToRotate = new Quaternion();\n\n    _this.dragBehavior.onDragObservable.add(function (event) {\n      if (_this.attachedNode) {\n        // Calc angle over full 360 degree (https://stackoverflow.com/questions/43493711/the-angle-between-two-3d-vectors-with-a-result-range-0-360)\n        var nodeScale = new Vector3(1, 1, 1);\n        var nodeQuaternion = new Quaternion(0, 0, 0, 1);\n        var nodeTranslation = new Vector3(0, 0, 0);\n\n        _this._handlePivot();\n\n        _this.attachedNode.getWorldMatrix().decompose(nodeScale, nodeQuaternion, nodeTranslation);\n\n        var newVector = event.dragPlanePoint.subtract(nodeTranslation).normalize();\n        var originalVector = lastDragPosition.subtract(nodeTranslation).normalize();\n        var cross = Vector3.Cross(newVector, originalVector);\n        var dot = Vector3.Dot(newVector, originalVector);\n        var angle = Math.atan2(cross.length(), dot);\n        planeNormalTowardsCamera.copyFrom(planeNormal);\n        localPlaneNormalTowardsCamera.copyFrom(planeNormal);\n\n        if (_this.updateGizmoRotationToMatchAttachedMesh) {\n          nodeQuaternion.toRotationMatrix(rotationMatrix);\n          localPlaneNormalTowardsCamera = Vector3.TransformCoordinates(planeNormalTowardsCamera, rotationMatrix);\n        } // Flip up vector depending on which side the camera is on\n\n\n        var cameraFlipped = false;\n\n        if (gizmoLayer.utilityLayerScene.activeCamera) {\n          var camVec = gizmoLayer.utilityLayerScene.activeCamera.position.subtract(nodeTranslation).normalize();\n\n          if (Vector3.Dot(camVec, localPlaneNormalTowardsCamera) > 0) {\n            planeNormalTowardsCamera.scaleInPlace(-1);\n            localPlaneNormalTowardsCamera.scaleInPlace(-1);\n            cameraFlipped = true;\n          }\n        }\n\n        var halfCircleSide = Vector3.Dot(localPlaneNormalTowardsCamera, cross) > 0.0;\n\n        if (halfCircleSide) {\n          angle = -angle;\n        } // Snapping logic\n\n\n        var snapped = false;\n\n        if (_this.snapDistance != 0) {\n          currentSnapDragDistance += angle;\n\n          if (Math.abs(currentSnapDragDistance) > _this.snapDistance) {\n            var dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / _this.snapDistance);\n\n            if (currentSnapDragDistance < 0) {\n              dragSteps *= -1;\n            }\n\n            currentSnapDragDistance = currentSnapDragDistance % _this.snapDistance;\n            angle = _this.snapDistance * dragSteps;\n            snapped = true;\n          } else {\n            angle = 0;\n          }\n        } // Convert angle and axis to quaternion (http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm)\n\n\n        var quaternionCoefficient = Math.sin(angle / 2);\n        amountToRotate.set(planeNormalTowardsCamera.x * quaternionCoefficient, planeNormalTowardsCamera.y * quaternionCoefficient, planeNormalTowardsCamera.z * quaternionCoefficient, Math.cos(angle / 2)); // If the meshes local scale is inverted (eg. loaded gltf file parent with z scale of -1) the rotation needs to be inverted on the y axis\n\n        if (tmpMatrix.determinant() > 0) {\n          var tmpVector = new Vector3();\n          amountToRotate.toEulerAnglesToRef(tmpVector);\n          Quaternion.RotationYawPitchRollToRef(tmpVector.y, -tmpVector.x, -tmpVector.z, amountToRotate);\n        }\n\n        if (_this.updateGizmoRotationToMatchAttachedMesh) {\n          // Rotate selected mesh quaternion over fixed axis\n          nodeQuaternion.multiplyToRef(amountToRotate, nodeQuaternion);\n        } else {\n          // Rotate selected mesh quaternion over rotated axis\n          amountToRotate.multiplyToRef(nodeQuaternion, nodeQuaternion);\n        } // recompose matrix\n\n\n        _this.attachedNode.getWorldMatrix().copyFrom(Matrix.Compose(nodeScale, nodeQuaternion, nodeTranslation));\n\n        lastDragPosition.copyFrom(event.dragPlanePoint);\n\n        if (snapped) {\n          tmpSnapEvent.snapDistance = angle;\n\n          _this.onSnapObservable.notifyObservers(tmpSnapEvent);\n        }\n\n        _this._angles.y += angle;\n        _this.angle += cameraFlipped ? -angle : angle;\n\n        _this._rotationShaderMaterial.setVector3(\"angles\", _this._angles);\n\n        _this._matrixChanged();\n      }\n    });\n\n    var light = gizmoLayer._getSharedGizmoLight();\n\n    light.includedOnlyMeshes = light.includedOnlyMeshes.concat(_this._rootMesh.getChildMeshes(false));\n    var cache = {\n      colliderMeshes: [collider],\n      gizmoMeshes: [rotationMesh],\n      material: _this._coloredMaterial,\n      hoverMaterial: _this._hoverMaterial,\n      disableMaterial: _this._disableMaterial,\n      active: false,\n      dragBehavior: _this.dragBehavior\n    };\n    (_a = _this._parent) === null || _a === void 0 ? void 0 : _a.addToAxisCache(_this._gizmoMesh, cache);\n    _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function (pointerInfo) {\n      var _a;\n\n      if (_this._customMeshSet) {\n        return;\n      } // updating here the maxangle because ondragstart is too late (value already used) and the updated value is not taken into account\n\n\n      _this.dragBehavior.maxDragAngle = PlaneRotationGizmo.MaxDragAngle;\n      _this._isHovered = !!(cache.colliderMeshes.indexOf((_a = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _a === void 0 ? void 0 : _a.pickedMesh) != -1);\n\n      if (!_this._parent) {\n        var material = cache.dragBehavior.enabled ? _this._isHovered || _this._dragging ? _this._hoverMaterial : _this._coloredMaterial : _this._disableMaterial;\n\n        _this._setGizmoMeshMaterial(cache.gizmoMeshes, material);\n      }\n    });\n\n    _this.dragBehavior.onEnabledObservable.add(function (newState) {\n      _this._setGizmoMeshMaterial(cache.gizmoMeshes, newState ? _this._coloredMaterial : _this._disableMaterial);\n    });\n\n    return _this;\n  }\n  /**\n   * Create Geometry for Gizmo\n   * @param parentMesh\n   * @param thickness\n   * @param tessellation\n   */\n\n\n  PlaneRotationGizmo.prototype._createGizmoMesh = function (parentMesh, thickness, tessellation) {\n    var collider = CreateTorus(\"ignore\", {\n      diameter: 0.6,\n      thickness: 0.03 * thickness,\n      tessellation: tessellation\n    }, this.gizmoLayer.utilityLayerScene);\n    collider.visibility = 0;\n    var rotationMesh = CreateTorus(\"\", {\n      diameter: 0.6,\n      thickness: 0.005 * thickness,\n      tessellation: tessellation\n    }, this.gizmoLayer.utilityLayerScene);\n    rotationMesh.material = this._coloredMaterial; // Position arrow pointing in its drag axis\n\n    rotationMesh.rotation.x = Math.PI / 2;\n    collider.rotation.x = Math.PI / 2;\n    parentMesh.addChild(rotationMesh, Gizmo.PreserveScaling);\n    parentMesh.addChild(collider, Gizmo.PreserveScaling);\n    return {\n      rotationMesh: rotationMesh,\n      collider: collider\n    };\n  };\n\n  PlaneRotationGizmo.prototype._attachedNodeChanged = function (value) {\n    if (this.dragBehavior) {\n      this.dragBehavior.enabled = value ? true : false;\n    }\n  };\n\n  Object.defineProperty(PlaneRotationGizmo.prototype, \"isEnabled\", {\n    get: function get() {\n      return this._isEnabled;\n    },\n\n    /**\n     * If the gizmo is enabled\n     */\n    set: function set(value) {\n      this._isEnabled = value;\n\n      if (!value) {\n        this.attachedMesh = null;\n      } else {\n        if (this._parent) {\n          this.attachedMesh = this._parent.attachedMesh;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Disposes of the gizmo\n   */\n\n  PlaneRotationGizmo.prototype.dispose = function () {\n    this.onSnapObservable.clear();\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n    this.dragBehavior.detach();\n\n    if (this._gizmoMesh) {\n      this._gizmoMesh.dispose();\n    }\n\n    if (this._rotationDisplayPlane) {\n      this._rotationDisplayPlane.dispose();\n    }\n\n    if (this._rotationShaderMaterial) {\n      this._rotationShaderMaterial.dispose();\n    }\n\n    [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach(function (matl) {\n      if (matl) {\n        matl.dispose();\n      }\n    });\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\n   * The maximum angle between the camera and the rotation allowed for interaction\n   * If a rotation plane appears 'flat', a lower value allows interaction.\n   */\n\n\n  PlaneRotationGizmo.MaxDragAngle = Math.PI * 9 / 20;\n  PlaneRotationGizmo._RotationGizmoVertexShader = \"\\n        precision highp float;\\n        attribute vec3 position;\\n        attribute vec2 uv;\\n        uniform mat4 worldViewProjection;\\n        varying vec3 vPosition;\\n        varying vec2 vUV;\\n        void main(void) {\\n            gl_Position = worldViewProjection * vec4(position, 1.0);\\n            vUV = uv;\\n        }\";\n  PlaneRotationGizmo._RotationGizmoFragmentShader = \"\\n        precision highp float;\\n        varying vec2 vUV;\\n        varying vec3 vPosition;\\n        uniform vec3 angles;\\n        #define twopi 6.283185307\\n        void main(void) {\\n            vec2 uv = vUV - vec2(0.5);\\n            float angle = atan(uv.y, uv.x) + 3.141592;\\n            float delta = gl_FrontFacing ? angles.y : -angles.y;\\n            float begin = angles.x - delta * angles.z;\\n            float start = (begin < (begin + delta)) ? begin : (begin + delta);\\n            float end = (begin > (begin + delta)) ? begin : (begin + delta);\\n            float len = sqrt(dot(uv,uv));\\n            float opacity = 1. - step(0.5, len);\\n\\n            float base = abs(floor(start / twopi)) * twopi;\\n            start += base;\\n            end += base;\\n\\n            float intensity = 0.;\\n            for (int i = 0; i < 5; i++)\\n            {\\n                intensity += max(step(start, angle) - step(end, angle), 0.);\\n                angle += twopi;\\n            }\\n            gl_FragColor = vec4(1.,1.,0., min(intensity * 0.25, 0.8)) * opacity;\\n        }\";\n  return PlaneRotationGizmo;\n}(Gizmo);\n\nexport { PlaneRotationGizmo };","map":{"version":3,"mappings":"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","names":["Observable","Quaternion","Matrix","Vector3","Color3","Mesh","PointerDragBehavior","Gizmo","UtilityLayerRenderer","StandardMaterial","ShaderMaterial","Effect","CreatePlane","CreateTorus","__extends","planeNormal","color","gizmoLayer","tessellation","parent","useEulerRotation","thickness","Gray","DefaultUtilityLayer","_super","_this","_parent","_coloredMaterial","utilityLayerScene","diffuseColor","specularColor","subtract","_hoverMaterial","Yellow","_disableMaterial","alpha","_gizmoMesh","_createGizmoMesh","rotationMesh","collider","_rotationDisplayPlane","size","updatable","rotation","z","Math","PI","setEnabled","ShadersStore","PlaneRotationGizmo","_RotationGizmoVertexShader","_RotationGizmoFragmentShader","_rotationShaderMaterial","vertex","fragment","attributes","uniforms","backFaceCulling","material","visibility","lookAt","_rootMesh","position","add","addChild","PreserveScaling","scaling","scaleInPlace","dragBehavior","dragPlaneNormal","moveAttached","maxDragAngle","MaxDragAngle","_useAlternatePickedPointAboveMaxDragAngle","addBehavior","lastDragPosition","rotationMatrix","planeNormalTowardsCamera","localPlaneNormalTowardsCamera","onDragStartObservable","e","attachedNode","copyFrom","dragPlanePoint","getWorldMatrix","invertToRef","TransformCoordinatesToRef","_angles","x","atan2","y","updateGizmoRotationToMatchAttachedMesh","_dragging","setVector3","angle","onDragEndObservable","tmpSnapEvent","snapDistance","currentSnapDragDistance","tmpMatrix","amountToRotate","onDragObservable","event","nodeScale","nodeQuaternion","nodeTranslation","_handlePivot","decompose","newVector","normalize","originalVector","cross","Cross","dot","Dot","length","toRotationMatrix","TransformCoordinates","cameraFlipped","activeCamera","camVec","halfCircleSide","snapped","abs","dragSteps","floor","quaternionCoefficient","sin","set","cos","determinant","tmpVector","toEulerAnglesToRef","RotationYawPitchRollToRef","multiplyToRef","Compose","onSnapObservable","notifyObservers","_matrixChanged","light","_getSharedGizmoLight","includedOnlyMeshes","concat","getChildMeshes","cache","colliderMeshes","gizmoMeshes","hoverMaterial","disableMaterial","active","_a","addToAxisCache","_pointerObserver","onPointerObservable","pointerInfo","_customMeshSet","_isHovered","indexOf","pickInfo","pickedMesh","enabled","_setGizmoMeshMaterial","onEnabledObservable","newState","parentMesh","diameter","value","Object","_isEnabled","attachedMesh","clear","remove","detach","dispose","forEach","matl","call"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Gizmos/planeRotationGizmo.ts"],"sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport { Quaternion, Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport \"../Meshes/Builders/linesBuilder\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Node } from \"../node\";\r\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\r\nimport type { GizmoAxisCache } from \"./gizmo\";\r\nimport { Gizmo } from \"./gizmo\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport type { RotationGizmo } from \"./rotationGizmo\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder\";\r\nimport { CreateTorus } from \"../Meshes/Builders/torusBuilder\";\r\n\r\n/**\r\n * Single plane rotation gizmo\r\n */\r\nexport class PlaneRotationGizmo extends Gizmo {\r\n    /**\r\n     * Drag behavior responsible for the gizmos dragging interactions\r\n     */\r\n    public dragBehavior: PointerDragBehavior;\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>> = null;\r\n\r\n    /**\r\n     * Rotation distance in radians that the gizmo will snap to (Default: 0)\r\n     */\r\n    public snapDistance = 0;\r\n    /**\r\n     * Event that fires each time the gizmo snaps to a new location.\r\n     * * snapDistance is the the change in distance\r\n     */\r\n    public onSnapObservable = new Observable<{ snapDistance: number }>();\r\n\r\n    /**\r\n     * The maximum angle between the camera and the rotation allowed for interaction\r\n     * If a rotation plane appears 'flat', a lower value allows interaction.\r\n     */\r\n    public static MaxDragAngle: number = (Math.PI * 9) / 20;\r\n\r\n    /**\r\n     * Accumulated relative angle value for rotation on the axis. Reset to 0 when a dragStart occurs\r\n     */\r\n    public angle: number = 0;\r\n\r\n    private _isEnabled: boolean = true;\r\n    private _parent: Nullable<RotationGizmo> = null;\r\n    private _coloredMaterial: StandardMaterial;\r\n    private _hoverMaterial: StandardMaterial;\r\n    private _disableMaterial: StandardMaterial;\r\n    private _gizmoMesh: Mesh;\r\n    private _rotationDisplayPlane: Mesh;\r\n    private _dragging: boolean = false;\r\n    private _angles = new Vector3();\r\n\r\n    private static _RotationGizmoVertexShader = `\r\n        precision highp float;\r\n        attribute vec3 position;\r\n        attribute vec2 uv;\r\n        uniform mat4 worldViewProjection;\r\n        varying vec3 vPosition;\r\n        varying vec2 vUV;\r\n        void main(void) {\r\n            gl_Position = worldViewProjection * vec4(position, 1.0);\r\n            vUV = uv;\r\n        }`;\r\n\r\n    private static _RotationGizmoFragmentShader = `\r\n        precision highp float;\r\n        varying vec2 vUV;\r\n        varying vec3 vPosition;\r\n        uniform vec3 angles;\r\n        #define twopi 6.283185307\r\n        void main(void) {\r\n            vec2 uv = vUV - vec2(0.5);\r\n            float angle = atan(uv.y, uv.x) + 3.141592;\r\n            float delta = gl_FrontFacing ? angles.y : -angles.y;\r\n            float begin = angles.x - delta * angles.z;\r\n            float start = (begin < (begin + delta)) ? begin : (begin + delta);\r\n            float end = (begin > (begin + delta)) ? begin : (begin + delta);\r\n            float len = sqrt(dot(uv,uv));\r\n            float opacity = 1. - step(0.5, len);\r\n\r\n            float base = abs(floor(start / twopi)) * twopi;\r\n            start += base;\r\n            end += base;\r\n\r\n            float intensity = 0.;\r\n            for (int i = 0; i < 5; i++)\r\n            {\r\n                intensity += max(step(start, angle) - step(end, angle), 0.);\r\n                angle += twopi;\r\n            }\r\n            gl_FragColor = vec4(1.,1.,0., min(intensity * 0.25, 0.8)) * opacity;\r\n        }`;\r\n\r\n    private _rotationShaderMaterial: ShaderMaterial;\r\n\r\n    /**\r\n     * Creates a PlaneRotationGizmo\r\n     * @param planeNormal The normal of the plane which the gizmo will be able to rotate on\r\n     * @param color The color of the gizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     * @param tessellation Amount of tessellation to be used when creating rotation circles\r\n     * @param parent\r\n     * @param useEulerRotation Use and update Euler angle instead of quaternion\r\n     * @param thickness display gizmo axis thickness\r\n     */\r\n    constructor(\r\n        planeNormal: Vector3,\r\n        color: Color3 = Color3.Gray(),\r\n        gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer,\r\n        tessellation = 32,\r\n        parent: Nullable<RotationGizmo> = null,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        useEulerRotation = false,\r\n        thickness: number = 1\r\n    ) {\r\n        super(gizmoLayer);\r\n        this._parent = parent;\r\n        // Create Material\r\n        this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\r\n        this._coloredMaterial.diffuseColor = color;\r\n        this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));\r\n\r\n        this._hoverMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\r\n        this._hoverMaterial.diffuseColor = Color3.Yellow();\r\n\r\n        this._disableMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\r\n        this._disableMaterial.diffuseColor = Color3.Gray();\r\n        this._disableMaterial.alpha = 0.4;\r\n\r\n        // Build mesh on root node\r\n        this._gizmoMesh = new Mesh(\"\", gizmoLayer.utilityLayerScene);\r\n        const { rotationMesh, collider } = this._createGizmoMesh(this._gizmoMesh, thickness, tessellation);\r\n\r\n        // Setup Rotation Circle\r\n        this._rotationDisplayPlane = CreatePlane(\"rotationDisplay\", { size: 0.6, updatable: false }, this.gizmoLayer.utilityLayerScene);\r\n        this._rotationDisplayPlane.rotation.z = Math.PI * 0.5;\r\n        this._rotationDisplayPlane.parent = this._gizmoMesh;\r\n        this._rotationDisplayPlane.setEnabled(false);\r\n\r\n        Effect.ShadersStore[\"rotationGizmoVertexShader\"] = PlaneRotationGizmo._RotationGizmoVertexShader;\r\n        Effect.ShadersStore[\"rotationGizmoFragmentShader\"] = PlaneRotationGizmo._RotationGizmoFragmentShader;\r\n        this._rotationShaderMaterial = new ShaderMaterial(\r\n            \"shader\",\r\n            this.gizmoLayer.utilityLayerScene,\r\n            {\r\n                vertex: \"rotationGizmo\",\r\n                fragment: \"rotationGizmo\",\r\n            },\r\n            {\r\n                attributes: [\"position\", \"uv\"],\r\n                uniforms: [\"worldViewProjection\", \"angles\"],\r\n            }\r\n        );\r\n        this._rotationShaderMaterial.backFaceCulling = false;\r\n\r\n        this._rotationDisplayPlane.material = this._rotationShaderMaterial;\r\n        this._rotationDisplayPlane.visibility = 0.999;\r\n\r\n        this._gizmoMesh.lookAt(this._rootMesh.position.add(planeNormal));\r\n        this._rootMesh.addChild(this._gizmoMesh, Gizmo.PreserveScaling);\r\n        this._gizmoMesh.scaling.scaleInPlace(1 / 3);\r\n        // Add drag behavior to handle events when the gizmo is dragged\r\n        this.dragBehavior = new PointerDragBehavior({ dragPlaneNormal: planeNormal });\r\n        this.dragBehavior.moveAttached = false;\r\n        this.dragBehavior.maxDragAngle = PlaneRotationGizmo.MaxDragAngle;\r\n        this.dragBehavior._useAlternatePickedPointAboveMaxDragAngle = true;\r\n        this._rootMesh.addBehavior(this.dragBehavior);\r\n\r\n        // Closures for drag logic\r\n        const lastDragPosition = new Vector3();\r\n\r\n        const rotationMatrix = new Matrix();\r\n        const planeNormalTowardsCamera = new Vector3();\r\n        let localPlaneNormalTowardsCamera = new Vector3();\r\n\r\n        this.dragBehavior.onDragStartObservable.add((e) => {\r\n            if (this.attachedNode) {\r\n                lastDragPosition.copyFrom(e.dragPlanePoint);\r\n                this._rotationDisplayPlane.setEnabled(true);\r\n\r\n                this._rotationDisplayPlane.getWorldMatrix().invertToRef(rotationMatrix);\r\n                Vector3.TransformCoordinatesToRef(e.dragPlanePoint, rotationMatrix, lastDragPosition);\r\n\r\n                this._angles.x = Math.atan2(lastDragPosition.y, lastDragPosition.x) + Math.PI;\r\n                this._angles.y = 0;\r\n                this._angles.z = this.updateGizmoRotationToMatchAttachedMesh ? 1 : 0;\r\n                this._dragging = true;\r\n                lastDragPosition.copyFrom(e.dragPlanePoint);\r\n                this._rotationShaderMaterial.setVector3(\"angles\", this._angles);\r\n                this.angle = 0;\r\n            }\r\n        });\r\n\r\n        this.dragBehavior.onDragEndObservable.add(() => {\r\n            this._dragging = false;\r\n            this._rotationDisplayPlane.setEnabled(false);\r\n        });\r\n\r\n        const tmpSnapEvent = { snapDistance: 0 };\r\n        let currentSnapDragDistance = 0;\r\n        const tmpMatrix = new Matrix();\r\n        const amountToRotate = new Quaternion();\r\n        this.dragBehavior.onDragObservable.add((event) => {\r\n            if (this.attachedNode) {\r\n                // Calc angle over full 360 degree (https://stackoverflow.com/questions/43493711/the-angle-between-two-3d-vectors-with-a-result-range-0-360)\r\n                const nodeScale = new Vector3(1, 1, 1);\r\n                const nodeQuaternion = new Quaternion(0, 0, 0, 1);\r\n                const nodeTranslation = new Vector3(0, 0, 0);\r\n                this._handlePivot();\r\n                this.attachedNode.getWorldMatrix().decompose(nodeScale, nodeQuaternion, nodeTranslation);\r\n\r\n                const newVector = event.dragPlanePoint.subtract(nodeTranslation).normalize();\r\n                const originalVector = lastDragPosition.subtract(nodeTranslation).normalize();\r\n                const cross = Vector3.Cross(newVector, originalVector);\r\n                const dot = Vector3.Dot(newVector, originalVector);\r\n                let angle = Math.atan2(cross.length(), dot);\r\n                planeNormalTowardsCamera.copyFrom(planeNormal);\r\n                localPlaneNormalTowardsCamera.copyFrom(planeNormal);\r\n                if (this.updateGizmoRotationToMatchAttachedMesh) {\r\n                    nodeQuaternion.toRotationMatrix(rotationMatrix);\r\n                    localPlaneNormalTowardsCamera = Vector3.TransformCoordinates(planeNormalTowardsCamera, rotationMatrix);\r\n                }\r\n                // Flip up vector depending on which side the camera is on\r\n                let cameraFlipped = false;\r\n                if (gizmoLayer.utilityLayerScene.activeCamera) {\r\n                    const camVec = gizmoLayer.utilityLayerScene.activeCamera.position.subtract(nodeTranslation).normalize();\r\n                    if (Vector3.Dot(camVec, localPlaneNormalTowardsCamera) > 0) {\r\n                        planeNormalTowardsCamera.scaleInPlace(-1);\r\n                        localPlaneNormalTowardsCamera.scaleInPlace(-1);\r\n                        cameraFlipped = true;\r\n                    }\r\n                }\r\n                const halfCircleSide = Vector3.Dot(localPlaneNormalTowardsCamera, cross) > 0.0;\r\n                if (halfCircleSide) {\r\n                    angle = -angle;\r\n                }\r\n\r\n                // Snapping logic\r\n                let snapped = false;\r\n                if (this.snapDistance != 0) {\r\n                    currentSnapDragDistance += angle;\r\n                    if (Math.abs(currentSnapDragDistance) > this.snapDistance) {\r\n                        let dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / this.snapDistance);\r\n                        if (currentSnapDragDistance < 0) {\r\n                            dragSteps *= -1;\r\n                        }\r\n                        currentSnapDragDistance = currentSnapDragDistance % this.snapDistance;\r\n                        angle = this.snapDistance * dragSteps;\r\n                        snapped = true;\r\n                    } else {\r\n                        angle = 0;\r\n                    }\r\n                }\r\n\r\n                // Convert angle and axis to quaternion (http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm)\r\n                const quaternionCoefficient = Math.sin(angle / 2);\r\n                amountToRotate.set(\r\n                    planeNormalTowardsCamera.x * quaternionCoefficient,\r\n                    planeNormalTowardsCamera.y * quaternionCoefficient,\r\n                    planeNormalTowardsCamera.z * quaternionCoefficient,\r\n                    Math.cos(angle / 2)\r\n                );\r\n\r\n                // If the meshes local scale is inverted (eg. loaded gltf file parent with z scale of -1) the rotation needs to be inverted on the y axis\r\n                if (tmpMatrix.determinant() > 0) {\r\n                    const tmpVector = new Vector3();\r\n                    amountToRotate.toEulerAnglesToRef(tmpVector);\r\n                    Quaternion.RotationYawPitchRollToRef(tmpVector.y, -tmpVector.x, -tmpVector.z, amountToRotate);\r\n                }\r\n\r\n                if (this.updateGizmoRotationToMatchAttachedMesh) {\r\n                    // Rotate selected mesh quaternion over fixed axis\r\n                    nodeQuaternion.multiplyToRef(amountToRotate, nodeQuaternion);\r\n                } else {\r\n                    // Rotate selected mesh quaternion over rotated axis\r\n                    amountToRotate.multiplyToRef(nodeQuaternion, nodeQuaternion);\r\n                }\r\n\r\n                // recompose matrix\r\n                this.attachedNode.getWorldMatrix().copyFrom(Matrix.Compose(nodeScale, nodeQuaternion, nodeTranslation));\r\n\r\n                lastDragPosition.copyFrom(event.dragPlanePoint);\r\n                if (snapped) {\r\n                    tmpSnapEvent.snapDistance = angle;\r\n                    this.onSnapObservable.notifyObservers(tmpSnapEvent);\r\n                }\r\n                this._angles.y += angle;\r\n                this.angle += cameraFlipped ? -angle : angle;\r\n                this._rotationShaderMaterial.setVector3(\"angles\", this._angles);\r\n                this._matrixChanged();\r\n            }\r\n        });\r\n\r\n        const light = gizmoLayer._getSharedGizmoLight();\r\n        light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._rootMesh.getChildMeshes(false));\r\n\r\n        const cache: GizmoAxisCache = {\r\n            colliderMeshes: [collider],\r\n            gizmoMeshes: [rotationMesh],\r\n            material: this._coloredMaterial,\r\n            hoverMaterial: this._hoverMaterial,\r\n            disableMaterial: this._disableMaterial,\r\n            active: false,\r\n            dragBehavior: this.dragBehavior,\r\n        };\r\n        this._parent?.addToAxisCache(this._gizmoMesh, cache);\r\n\r\n        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\r\n            if (this._customMeshSet) {\r\n                return;\r\n            }\r\n            // updating here the maxangle because ondragstart is too late (value already used) and the updated value is not taken into account\r\n            this.dragBehavior.maxDragAngle = PlaneRotationGizmo.MaxDragAngle;\r\n            this._isHovered = !!(cache.colliderMeshes.indexOf(<Mesh>pointerInfo?.pickInfo?.pickedMesh) != -1);\r\n            if (!this._parent) {\r\n                const material = cache.dragBehavior.enabled ? (this._isHovered || this._dragging ? this._hoverMaterial : this._coloredMaterial) : this._disableMaterial;\r\n                this._setGizmoMeshMaterial(cache.gizmoMeshes, material);\r\n            }\r\n        });\r\n\r\n        this.dragBehavior.onEnabledObservable.add((newState) => {\r\n            this._setGizmoMeshMaterial(cache.gizmoMeshes, newState ? this._coloredMaterial : this._disableMaterial);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create Geometry for Gizmo\r\n     * @param parentMesh\r\n     * @param thickness\r\n     * @param tessellation\r\n     */\r\n    private _createGizmoMesh(parentMesh: AbstractMesh, thickness: number, tessellation: number) {\r\n        const collider = CreateTorus(\r\n            \"ignore\",\r\n            {\r\n                diameter: 0.6,\r\n                thickness: 0.03 * thickness,\r\n                tessellation,\r\n            },\r\n            this.gizmoLayer.utilityLayerScene\r\n        );\r\n        collider.visibility = 0;\r\n        const rotationMesh = CreateTorus(\r\n            \"\",\r\n            {\r\n                diameter: 0.6,\r\n                thickness: 0.005 * thickness,\r\n                tessellation,\r\n            },\r\n            this.gizmoLayer.utilityLayerScene\r\n        );\r\n        rotationMesh.material = this._coloredMaterial;\r\n\r\n        // Position arrow pointing in its drag axis\r\n        rotationMesh.rotation.x = Math.PI / 2;\r\n        collider.rotation.x = Math.PI / 2;\r\n\r\n        parentMesh.addChild(rotationMesh, Gizmo.PreserveScaling);\r\n        parentMesh.addChild(collider, Gizmo.PreserveScaling);\r\n        return { rotationMesh, collider };\r\n    }\r\n\r\n    protected _attachedNodeChanged(value: Nullable<Node>) {\r\n        if (this.dragBehavior) {\r\n            this.dragBehavior.enabled = value ? true : false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If the gizmo is enabled\r\n     */\r\n    public set isEnabled(value: boolean) {\r\n        this._isEnabled = value;\r\n        if (!value) {\r\n            this.attachedMesh = null;\r\n        } else {\r\n            if (this._parent) {\r\n                this.attachedMesh = this._parent.attachedMesh;\r\n            }\r\n        }\r\n    }\r\n    public get isEnabled(): boolean {\r\n        return this._isEnabled;\r\n    }\r\n    /**\r\n     * Disposes of the gizmo\r\n     */\r\n    public dispose() {\r\n        this.onSnapObservable.clear();\r\n        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\r\n        this.dragBehavior.detach();\r\n        if (this._gizmoMesh) {\r\n            this._gizmoMesh.dispose();\r\n        }\r\n        if (this._rotationDisplayPlane) {\r\n            this._rotationDisplayPlane.dispose();\r\n        }\r\n        if (this._rotationShaderMaterial) {\r\n            this._rotationShaderMaterial.dispose();\r\n        }\r\n        [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach((matl) => {\r\n            if (matl) {\r\n                matl.dispose();\r\n            }\r\n        });\r\n        super.dispose();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}