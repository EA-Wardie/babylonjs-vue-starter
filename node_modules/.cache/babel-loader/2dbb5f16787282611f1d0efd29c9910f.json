{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { SphericalPolynomial, SphericalHarmonics } from \"../../Maths/sphericalPolynomial.js\";\nimport { ToLinearSpace } from \"../../Maths/math.constants.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\n\nvar FileFaceOrientation =\n/** @class */\nfunction () {\n  function FileFaceOrientation(name, worldAxisForNormal, worldAxisForFileX, worldAxisForFileY) {\n    this.name = name;\n    this.worldAxisForNormal = worldAxisForNormal;\n    this.worldAxisForFileX = worldAxisForFileX;\n    this.worldAxisForFileY = worldAxisForFileY;\n  }\n\n  return FileFaceOrientation;\n}();\n/**\n * Helper class dealing with the extraction of spherical polynomial dataArray\n * from a cube map.\n */\n\n\nvar CubeMapToSphericalPolynomialTools =\n/** @class */\nfunction () {\n  function CubeMapToSphericalPolynomialTools() {}\n  /**\n   * Converts a texture to the according Spherical Polynomial data.\n   * This extracts the first 3 orders only as they are the only one used in the lighting.\n   *\n   * @param texture The texture to extract the information from.\n   * @return The Spherical Polynomial data.\n   */\n\n\n  CubeMapToSphericalPolynomialTools.ConvertCubeMapTextureToSphericalPolynomial = function (texture) {\n    var _this = this;\n\n    var _a;\n\n    if (!texture.isCube) {\n      // Only supports cube Textures currently.\n      return null;\n    }\n\n    (_a = texture.getScene()) === null || _a === void 0 ? void 0 : _a.getEngine().flushFramebuffer();\n    var size = texture.getSize().width;\n    var rightPromise = texture.readPixels(0, undefined, undefined, false);\n    var leftPromise = texture.readPixels(1, undefined, undefined, false);\n    var upPromise;\n    var downPromise;\n\n    if (texture.isRenderTarget) {\n      upPromise = texture.readPixels(3, undefined, undefined, false);\n      downPromise = texture.readPixels(2, undefined, undefined, false);\n    } else {\n      upPromise = texture.readPixels(2, undefined, undefined, false);\n      downPromise = texture.readPixels(3, undefined, undefined, false);\n    }\n\n    var frontPromise = texture.readPixels(4, undefined, undefined, false);\n    var backPromise = texture.readPixels(5, undefined, undefined, false);\n    var gammaSpace = texture.gammaSpace; // Always read as RGBA.\n\n    var format = 5;\n    var type = 0;\n\n    if (texture.textureType == 1 || texture.textureType == 2) {\n      type = 1;\n    }\n\n    return new Promise(function (resolve) {\n      Promise.all([leftPromise, rightPromise, upPromise, downPromise, frontPromise, backPromise]).then(function (_a) {\n        var left = _a[0],\n            right = _a[1],\n            up = _a[2],\n            down = _a[3],\n            front = _a[4],\n            back = _a[5];\n        var cubeInfo = {\n          size: size,\n          right: right,\n          left: left,\n          up: up,\n          down: down,\n          front: front,\n          back: back,\n          format: format,\n          type: type,\n          gammaSpace: gammaSpace\n        };\n        resolve(_this.ConvertCubeMapToSphericalPolynomial(cubeInfo));\n      });\n    });\n  };\n  /**\n   * Compute the area on the unit sphere of the rectangle defined by (x,y) and the origin\n   * See https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/\n   * @param x\n   * @param y\n   */\n\n\n  CubeMapToSphericalPolynomialTools._AreaElement = function (x, y) {\n    return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));\n  };\n  /**\n   * Converts a cubemap to the according Spherical Polynomial data.\n   * This extracts the first 3 orders only as they are the only one used in the lighting.\n   *\n   * @param cubeInfo The Cube map to extract the information from.\n   * @return The Spherical Polynomial data.\n   */\n\n\n  CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial = function (cubeInfo) {\n    var sphericalHarmonics = new SphericalHarmonics();\n    var totalSolidAngle = 0.0; // The (u,v) range is [-1,+1], so the distance between each texel is 2/Size.\n\n    var du = 2.0 / cubeInfo.size;\n    var dv = du;\n    var halfTexel = 0.5 * du; // The (u,v) of the first texel is half a texel from the corner (-1,-1).\n\n    var minUV = halfTexel - 1.0;\n\n    for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\n      var fileFace = this._FileFaces[faceIndex];\n      var dataArray = cubeInfo[fileFace.name];\n      var v = minUV; // TODO: we could perform the summation directly into a SphericalPolynomial (SP), which is more efficient than SphericalHarmonic (SH).\n      // This is possible because during the summation we do not need the SH-specific properties, e.g. orthogonality.\n      // Because SP is still linear, so summation is fine in that basis.\n\n      var stride = cubeInfo.format === 5 ? 4 : 3;\n\n      for (var y = 0; y < cubeInfo.size; y++) {\n        var u = minUV;\n\n        for (var x = 0; x < cubeInfo.size; x++) {\n          // World direction (not normalised)\n          var worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);\n          worldDirection.normalize();\n\n          var deltaSolidAngle = this._AreaElement(u - halfTexel, v - halfTexel) - this._AreaElement(u - halfTexel, v + halfTexel) - this._AreaElement(u + halfTexel, v - halfTexel) + this._AreaElement(u + halfTexel, v + halfTexel);\n\n          var r = dataArray[y * cubeInfo.size * stride + x * stride + 0];\n          var g = dataArray[y * cubeInfo.size * stride + x * stride + 1];\n          var b = dataArray[y * cubeInfo.size * stride + x * stride + 2]; // Prevent NaN harmonics with extreme HDRI data.\n\n          if (isNaN(r)) {\n            r = 0;\n          }\n\n          if (isNaN(g)) {\n            g = 0;\n          }\n\n          if (isNaN(b)) {\n            b = 0;\n          } // Handle Integer types.\n\n\n          if (cubeInfo.type === 0) {\n            r /= 255;\n            g /= 255;\n            b /= 255;\n          } // Handle Gamma space textures.\n\n\n          if (cubeInfo.gammaSpace) {\n            r = Math.pow(Scalar.Clamp(r), ToLinearSpace);\n            g = Math.pow(Scalar.Clamp(g), ToLinearSpace);\n            b = Math.pow(Scalar.Clamp(b), ToLinearSpace);\n          } // Prevent to explode in case of really high dynamic ranges.\n          // sh 3 would not be enough to accurately represent it.\n\n\n          var max = 4096;\n          r = Scalar.Clamp(r, 0, max);\n          g = Scalar.Clamp(g, 0, max);\n          b = Scalar.Clamp(b, 0, max);\n          var color = new Color3(r, g, b);\n          sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);\n          totalSolidAngle += deltaSolidAngle;\n          u += du;\n        }\n\n        v += dv;\n      }\n    } // Solid angle for entire sphere is 4*pi\n\n\n    var sphereSolidAngle = 4.0 * Math.PI; // Adjust the solid angle to allow for how many faces we processed.\n\n    var facesProcessed = 6.0;\n    var expectedSolidAngle = sphereSolidAngle * facesProcessed / 6.0; // Adjust the harmonics so that the accumulated solid angle matches the expected solid angle.\n    // This is needed because the numerical integration over the cube uses a\n    // small angle approximation of solid angle for each texel (see deltaSolidAngle),\n    // and also to compensate for accumulative error due to float precision in the summation.\n\n    var correctionFactor = expectedSolidAngle / totalSolidAngle;\n    sphericalHarmonics.scaleInPlace(correctionFactor);\n    sphericalHarmonics.convertIncidentRadianceToIrradiance();\n    sphericalHarmonics.convertIrradianceToLambertianRadiance();\n    return SphericalPolynomial.FromHarmonics(sphericalHarmonics);\n  };\n\n  CubeMapToSphericalPolynomialTools._FileFaces = [new FileFaceOrientation(\"right\", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)), new FileFaceOrientation(\"left\", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)), new FileFaceOrientation(\"up\", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)), new FileFaceOrientation(\"down\", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)), new FileFaceOrientation(\"front\", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)), new FileFaceOrientation(\"back\", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0)) // -Z bottom\n  ];\n  return CubeMapToSphericalPolynomialTools;\n}();\n\nexport { CubeMapToSphericalPolynomialTools };","map":{"version":3,"mappings":"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","names":["Vector3","Scalar","SphericalPolynomial","SphericalHarmonics","ToLinearSpace","Color3","name","worldAxisForNormal","worldAxisForFileX","worldAxisForFileY","CubeMapToSphericalPolynomialTools","texture","isCube","getScene","_a","getEngine","flushFramebuffer","size","getSize","width","rightPromise","readPixels","undefined","leftPromise","upPromise","downPromise","isRenderTarget","frontPromise","backPromise","gammaSpace","format","type","textureType","Promise","resolve","all","then","left","right","up","down","front","back","cubeInfo","_this","ConvertCubeMapToSphericalPolynomial","x","y","Math","atan2","sqrt","sphericalHarmonics","totalSolidAngle","du","dv","halfTexel","minUV","faceIndex","fileFace","_FileFaces","dataArray","v","stride","u","worldDirection","scale","add","normalize","deltaSolidAngle","_AreaElement","r","g","b","isNaN","pow","Clamp","max","color","addLight","sphereSolidAngle","PI","facesProcessed","expectedSolidAngle","correctionFactor","scaleInPlace","convertIncidentRadianceToIrradiance","convertIrradianceToLambertianRadiance","FromHarmonics","FileFaceOrientation"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Misc/HighDynamicRange/cubemapToSphericalPolynomial.ts"],"sourcesContent":["import { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { SphericalPolynomial, SphericalHarmonics } from \"../../Maths/sphericalPolynomial\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { CubeMapInfo } from \"./panoramaToCubemap\";\r\nimport { ToLinearSpace } from \"../../Maths/math.constants\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\n\r\nclass FileFaceOrientation {\r\n    public name: string;\r\n    public worldAxisForNormal: Vector3; // the world axis corresponding to the normal to the face\r\n    public worldAxisForFileX: Vector3; // the world axis corresponding to texture right x-axis in file\r\n    public worldAxisForFileY: Vector3; // the world axis corresponding to texture down y-axis in file\r\n\r\n    public constructor(name: string, worldAxisForNormal: Vector3, worldAxisForFileX: Vector3, worldAxisForFileY: Vector3) {\r\n        this.name = name;\r\n        this.worldAxisForNormal = worldAxisForNormal;\r\n        this.worldAxisForFileX = worldAxisForFileX;\r\n        this.worldAxisForFileY = worldAxisForFileY;\r\n    }\r\n}\r\n\r\n/**\r\n * Helper class dealing with the extraction of spherical polynomial dataArray\r\n * from a cube map.\r\n */\r\nexport class CubeMapToSphericalPolynomialTools {\r\n    private static _FileFaces: FileFaceOrientation[] = [\r\n        new FileFaceOrientation(\"right\", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)), // +X east\r\n        new FileFaceOrientation(\"left\", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)), // -X west\r\n        new FileFaceOrientation(\"up\", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)), // +Y north\r\n        new FileFaceOrientation(\"down\", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)), // -Y south\r\n        new FileFaceOrientation(\"front\", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)), // +Z top\r\n        new FileFaceOrientation(\"back\", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0)), // -Z bottom\r\n    ];\r\n\r\n    /**\r\n     * Converts a texture to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param texture The texture to extract the information from.\r\n     * @return The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapTextureToSphericalPolynomial(texture: BaseTexture): Nullable<Promise<SphericalPolynomial>> {\r\n        if (!texture.isCube) {\r\n            // Only supports cube Textures currently.\r\n            return null;\r\n        }\r\n\r\n        texture.getScene()?.getEngine().flushFramebuffer();\r\n\r\n        const size = texture.getSize().width;\r\n        const rightPromise = texture.readPixels(0, undefined, undefined, false);\r\n        const leftPromise = texture.readPixels(1, undefined, undefined, false);\r\n\r\n        let upPromise: Nullable<Promise<ArrayBufferView>>;\r\n        let downPromise: Nullable<Promise<ArrayBufferView>>;\r\n        if (texture.isRenderTarget) {\r\n            upPromise = texture.readPixels(3, undefined, undefined, false);\r\n            downPromise = texture.readPixels(2, undefined, undefined, false);\r\n        } else {\r\n            upPromise = texture.readPixels(2, undefined, undefined, false);\r\n            downPromise = texture.readPixels(3, undefined, undefined, false);\r\n        }\r\n\r\n        const frontPromise = texture.readPixels(4, undefined, undefined, false);\r\n        const backPromise = texture.readPixels(5, undefined, undefined, false);\r\n\r\n        const gammaSpace = texture.gammaSpace;\r\n        // Always read as RGBA.\r\n        const format = Constants.TEXTUREFORMAT_RGBA;\r\n        let type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        if (texture.textureType == Constants.TEXTURETYPE_FLOAT || texture.textureType == Constants.TEXTURETYPE_HALF_FLOAT) {\r\n            type = Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            Promise.all([leftPromise, rightPromise, upPromise, downPromise, frontPromise, backPromise]).then(([left, right, up, down, front, back]) => {\r\n                const cubeInfo: CubeMapInfo = {\r\n                    size,\r\n                    right,\r\n                    left,\r\n                    up,\r\n                    down,\r\n                    front,\r\n                    back,\r\n                    format,\r\n                    type,\r\n                    gammaSpace,\r\n                };\r\n\r\n                resolve(this.ConvertCubeMapToSphericalPolynomial(cubeInfo));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Compute the area on the unit sphere of the rectangle defined by (x,y) and the origin\r\n     * See https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/\r\n     * @param x\r\n     * @param y\r\n     */\r\n    private static _AreaElement(x: number, y: number): number {\r\n        return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));\r\n    }\r\n\r\n    /**\r\n     * Converts a cubemap to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param cubeInfo The Cube map to extract the information from.\r\n     * @return The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapToSphericalPolynomial(cubeInfo: CubeMapInfo): SphericalPolynomial {\r\n        const sphericalHarmonics = new SphericalHarmonics();\r\n        let totalSolidAngle = 0.0;\r\n\r\n        // The (u,v) range is [-1,+1], so the distance between each texel is 2/Size.\r\n        const du = 2.0 / cubeInfo.size;\r\n        const dv = du;\r\n\r\n        const halfTexel = 0.5 * du;\r\n\r\n        // The (u,v) of the first texel is half a texel from the corner (-1,-1).\r\n        const minUV = halfTexel - 1.0;\r\n\r\n        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n            const fileFace = this._FileFaces[faceIndex];\r\n            const dataArray = (<any>cubeInfo)[fileFace.name];\r\n            let v = minUV;\r\n\r\n            // TODO: we could perform the summation directly into a SphericalPolynomial (SP), which is more efficient than SphericalHarmonic (SH).\r\n            // This is possible because during the summation we do not need the SH-specific properties, e.g. orthogonality.\r\n            // Because SP is still linear, so summation is fine in that basis.\r\n            const stride = cubeInfo.format === Constants.TEXTUREFORMAT_RGBA ? 4 : 3;\r\n            for (let y = 0; y < cubeInfo.size; y++) {\r\n                let u = minUV;\r\n\r\n                for (let x = 0; x < cubeInfo.size; x++) {\r\n                    // World direction (not normalised)\r\n                    const worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);\r\n                    worldDirection.normalize();\r\n\r\n                    const deltaSolidAngle =\r\n                        this._AreaElement(u - halfTexel, v - halfTexel) -\r\n                        this._AreaElement(u - halfTexel, v + halfTexel) -\r\n                        this._AreaElement(u + halfTexel, v - halfTexel) +\r\n                        this._AreaElement(u + halfTexel, v + halfTexel);\r\n\r\n                    let r = dataArray[y * cubeInfo.size * stride + x * stride + 0];\r\n                    let g = dataArray[y * cubeInfo.size * stride + x * stride + 1];\r\n                    let b = dataArray[y * cubeInfo.size * stride + x * stride + 2];\r\n\r\n                    // Prevent NaN harmonics with extreme HDRI data.\r\n                    if (isNaN(r)) {\r\n                        r = 0;\r\n                    }\r\n                    if (isNaN(g)) {\r\n                        g = 0;\r\n                    }\r\n                    if (isNaN(b)) {\r\n                        b = 0;\r\n                    }\r\n\r\n                    // Handle Integer types.\r\n                    if (cubeInfo.type === Constants.TEXTURETYPE_UNSIGNED_INT) {\r\n                        r /= 255;\r\n                        g /= 255;\r\n                        b /= 255;\r\n                    }\r\n\r\n                    // Handle Gamma space textures.\r\n                    if (cubeInfo.gammaSpace) {\r\n                        r = Math.pow(Scalar.Clamp(r), ToLinearSpace);\r\n                        g = Math.pow(Scalar.Clamp(g), ToLinearSpace);\r\n                        b = Math.pow(Scalar.Clamp(b), ToLinearSpace);\r\n                    }\r\n\r\n                    // Prevent to explode in case of really high dynamic ranges.\r\n                    // sh 3 would not be enough to accurately represent it.\r\n                    const max = 4096;\r\n                    r = Scalar.Clamp(r, 0, max);\r\n                    g = Scalar.Clamp(g, 0, max);\r\n                    b = Scalar.Clamp(b, 0, max);\r\n\r\n                    const color = new Color3(r, g, b);\r\n\r\n                    sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);\r\n\r\n                    totalSolidAngle += deltaSolidAngle;\r\n\r\n                    u += du;\r\n                }\r\n\r\n                v += dv;\r\n            }\r\n        }\r\n\r\n        // Solid angle for entire sphere is 4*pi\r\n        const sphereSolidAngle = 4.0 * Math.PI;\r\n\r\n        // Adjust the solid angle to allow for how many faces we processed.\r\n        const facesProcessed = 6.0;\r\n        const expectedSolidAngle = (sphereSolidAngle * facesProcessed) / 6.0;\r\n\r\n        // Adjust the harmonics so that the accumulated solid angle matches the expected solid angle.\r\n        // This is needed because the numerical integration over the cube uses a\r\n        // small angle approximation of solid angle for each texel (see deltaSolidAngle),\r\n        // and also to compensate for accumulative error due to float precision in the summation.\r\n        const correctionFactor = expectedSolidAngle / totalSolidAngle;\r\n        sphericalHarmonics.scaleInPlace(correctionFactor);\r\n\r\n        sphericalHarmonics.convertIncidentRadianceToIrradiance();\r\n        sphericalHarmonics.convertIrradianceToLambertianRadiance();\r\n\r\n        return SphericalPolynomial.FromHarmonics(sphericalHarmonics);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}