{"ast":null,"code":"import \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.timers.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport { __assign } from \"tslib\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder.js\";\nimport { Ray } from \"../Culling/ray.js\";\n/**\n * A helper for physics simulations\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\n */\n\nvar PhysicsHelper =\n/** @class */\nfunction () {\n  /**\n   * Initializes the Physics helper\n   * @param scene Babylon.js scene\n   */\n  function PhysicsHelper(scene) {\n    this._scene = scene;\n    this._physicsEngine = this._scene.getPhysicsEngine();\n\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you can use the methods.\");\n      return;\n    }\n  }\n  /**\n   * Applies a radial explosion impulse\n   * @param origin the origin of the explosion\n   * @param radiusOrEventOptions the radius or the options of radial explosion\n   * @param strength the explosion strength\n   * @param falloff possible options: Constant & Linear. Defaults to Constant\n   * @returns A physics radial explosion event, or null\n   */\n\n\n  PhysicsHelper.prototype.applyRadialExplosionImpulse = function (origin, radiusOrEventOptions, strength, falloff) {\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call this method.\");\n      return null;\n    }\n\n    var impostors = this._physicsEngine.getImpostors();\n\n    if (impostors.length === 0) {\n      return null;\n    }\n\n    if (typeof radiusOrEventOptions === \"number\") {\n      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\n      radiusOrEventOptions.radius = radiusOrEventOptions;\n      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\n      radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;\n    }\n\n    var event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);\n    var affectedImpostorsWithData = Array();\n    impostors.forEach(function (impostor) {\n      var impostorHitData = event.getImpostorHitData(impostor, origin);\n\n      if (!impostorHitData) {\n        return;\n      }\n\n      impostor.applyImpulse(impostorHitData.force, impostorHitData.contactPoint);\n      affectedImpostorsWithData.push({\n        impostor: impostor,\n        hitData: impostorHitData\n      });\n    });\n    event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);\n    event.dispose(false);\n    return event;\n  };\n  /**\n   * Applies a radial explosion force\n   * @param origin the origin of the explosion\n   * @param radiusOrEventOptions the radius or the options of radial explosion\n   * @param strength the explosion strength\n   * @param falloff possible options: Constant & Linear. Defaults to Constant\n   * @returns A physics radial explosion event, or null\n   */\n\n\n  PhysicsHelper.prototype.applyRadialExplosionForce = function (origin, radiusOrEventOptions, strength, falloff) {\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\n      return null;\n    }\n\n    var impostors = this._physicsEngine.getImpostors();\n\n    if (impostors.length === 0) {\n      return null;\n    }\n\n    if (typeof radiusOrEventOptions === \"number\") {\n      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\n      radiusOrEventOptions.radius = radiusOrEventOptions;\n      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\n      radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;\n    }\n\n    var event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);\n    var affectedImpostorsWithData = Array();\n    impostors.forEach(function (impostor) {\n      var impostorHitData = event.getImpostorHitData(impostor, origin);\n\n      if (!impostorHitData) {\n        return;\n      }\n\n      impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);\n      affectedImpostorsWithData.push({\n        impostor: impostor,\n        hitData: impostorHitData\n      });\n    });\n    event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);\n    event.dispose(false);\n    return event;\n  };\n  /**\n   * Creates a gravitational field\n   * @param origin the origin of the explosion\n   * @param radiusOrEventOptions the radius or the options of radial explosion\n   * @param strength the explosion strength\n   * @param falloff possible options: Constant & Linear. Defaults to Constant\n   * @returns A physics gravitational field event, or null\n   */\n\n\n  PhysicsHelper.prototype.gravitationalField = function (origin, radiusOrEventOptions, strength, falloff) {\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\n      return null;\n    }\n\n    var impostors = this._physicsEngine.getImpostors();\n\n    if (impostors.length === 0) {\n      return null;\n    }\n\n    if (typeof radiusOrEventOptions === \"number\") {\n      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\n      radiusOrEventOptions.radius = radiusOrEventOptions;\n      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\n      radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;\n    }\n\n    var event = new PhysicsGravitationalFieldEvent(this, this._scene, origin, radiusOrEventOptions);\n    event.dispose(false);\n    return event;\n  };\n  /**\n   * Creates a physics updraft event\n   * @param origin the origin of the updraft\n   * @param radiusOrEventOptions the radius or the options of the updraft\n   * @param strength the strength of the updraft\n   * @param height the height of the updraft\n   * @param updraftMode possible options: Center & Perpendicular. Defaults to Center\n   * @returns A physics updraft event, or null\n   */\n\n\n  PhysicsHelper.prototype.updraft = function (origin, radiusOrEventOptions, strength, height, updraftMode) {\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\n      return null;\n    }\n\n    if (this._physicsEngine.getImpostors().length === 0) {\n      return null;\n    }\n\n    if (typeof radiusOrEventOptions === \"number\") {\n      radiusOrEventOptions = new PhysicsUpdraftEventOptions();\n      radiusOrEventOptions.radius = radiusOrEventOptions;\n      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\n      radiusOrEventOptions.height = height || radiusOrEventOptions.height;\n      radiusOrEventOptions.updraftMode = updraftMode || radiusOrEventOptions.updraftMode;\n    }\n\n    var event = new PhysicsUpdraftEvent(this._scene, origin, radiusOrEventOptions);\n    event.dispose(false);\n    return event;\n  };\n  /**\n   * Creates a physics vortex event\n   * @param origin the of the vortex\n   * @param radiusOrEventOptions the radius or the options of the vortex\n   * @param strength the strength of the vortex\n   * @param height   the height of the vortex\n   * @returns a Physics vortex event, or null\n   * A physics vortex event or null\n   */\n\n\n  PhysicsHelper.prototype.vortex = function (origin, radiusOrEventOptions, strength, height) {\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\n      return null;\n    }\n\n    if (this._physicsEngine.getImpostors().length === 0) {\n      return null;\n    }\n\n    if (typeof radiusOrEventOptions === \"number\") {\n      radiusOrEventOptions = new PhysicsVortexEventOptions();\n      radiusOrEventOptions.radius = radiusOrEventOptions;\n      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\n      radiusOrEventOptions.height = height || radiusOrEventOptions.height;\n    }\n\n    var event = new PhysicsVortexEvent(this._scene, origin, radiusOrEventOptions);\n    event.dispose(false);\n    return event;\n  };\n\n  return PhysicsHelper;\n}();\n\nexport { PhysicsHelper };\n/**\n * Represents a physics radial explosion event\n */\n\nvar PhysicsRadialExplosionEvent =\n/** @class */\nfunction () {\n  /**\n   * Initializes a radial explosion event\n   * @param _scene BabylonJS scene\n   * @param _options The options for the vortex event\n   */\n  function PhysicsRadialExplosionEvent(_scene, _options) {\n    this._scene = _scene;\n    this._options = _options;\n    this._dataFetched = false; // check if the data has been fetched. If not, do cleanup\n\n    this._options = __assign(__assign({}, new PhysicsRadialExplosionEventOptions()), this._options);\n  }\n  /**\n   * Returns the data related to the radial explosion event (sphere).\n   * @returns The radial explosion event data\n   */\n\n\n  PhysicsRadialExplosionEvent.prototype.getData = function () {\n    this._dataFetched = true;\n    return {\n      sphere: this._sphere\n    };\n  };\n  /**\n   * Returns the force and contact point of the impostor or false, if the impostor is not affected by the force/impulse.\n   * @param impostor A physics imposter\n   * @param origin the origin of the explosion\n   * @returns {Nullable<PhysicsHitData>} A physics force and contact point, or null\n   */\n\n\n  PhysicsRadialExplosionEvent.prototype.getImpostorHitData = function (impostor, origin) {\n    if (impostor.mass === 0) {\n      return null;\n    }\n\n    if (!this._intersectsWithSphere(impostor, origin, this._options.radius)) {\n      return null;\n    }\n\n    if (impostor.object.getClassName() !== \"Mesh\" && impostor.object.getClassName() !== \"InstancedMesh\") {\n      return null;\n    }\n\n    var impostorObjectCenter = impostor.getObjectCenter();\n    var direction = impostorObjectCenter.subtract(origin);\n    var ray = new Ray(origin, direction, this._options.radius);\n    var hit = ray.intersectsMesh(impostor.object);\n    var contactPoint = hit.pickedPoint;\n\n    if (!contactPoint) {\n      return null;\n    }\n\n    var distanceFromOrigin = Vector3.Distance(origin, contactPoint);\n\n    if (distanceFromOrigin > this._options.radius) {\n      return null;\n    }\n\n    var multiplier = this._options.falloff === PhysicsRadialImpulseFalloff.Constant ? this._options.strength : this._options.strength * (1 - distanceFromOrigin / this._options.radius);\n    var force = direction.multiplyByFloats(multiplier, multiplier, multiplier);\n    return {\n      force: force,\n      contactPoint: contactPoint,\n      distanceFromOrigin: distanceFromOrigin\n    };\n  };\n  /**\n   * Triggers affected impostors callbacks\n   * @param affectedImpostorsWithData defines the list of affected impostors (including associated data)\n   */\n\n\n  PhysicsRadialExplosionEvent.prototype.triggerAffectedImpostorsCallback = function (affectedImpostorsWithData) {\n    if (this._options.affectedImpostorsCallback) {\n      this._options.affectedImpostorsCallback(affectedImpostorsWithData);\n    }\n  };\n  /**\n   * Disposes the sphere.\n   * @param force Specifies if the sphere should be disposed by force\n   */\n\n\n  PhysicsRadialExplosionEvent.prototype.dispose = function (force) {\n    var _this = this;\n\n    if (force === void 0) {\n      force = true;\n    }\n\n    if (force) {\n      this._sphere.dispose();\n    } else {\n      setTimeout(function () {\n        if (!_this._dataFetched) {\n          _this._sphere.dispose();\n        }\n      }, 0);\n    }\n  };\n  /*** Helpers ***/\n\n\n  PhysicsRadialExplosionEvent.prototype._prepareSphere = function () {\n    if (!this._sphere) {\n      this._sphere = CreateSphere(\"radialExplosionEventSphere\", this._options.sphere, this._scene);\n      this._sphere.isVisible = false;\n    }\n  };\n\n  PhysicsRadialExplosionEvent.prototype._intersectsWithSphere = function (impostor, origin, radius) {\n    var impostorObject = impostor.object;\n\n    this._prepareSphere();\n\n    this._sphere.position = origin;\n    this._sphere.scaling = new Vector3(radius * 2, radius * 2, radius * 2);\n\n    this._sphere._updateBoundingInfo();\n\n    this._sphere.computeWorldMatrix(true);\n\n    return this._sphere.intersectsMesh(impostorObject, true);\n  };\n\n  return PhysicsRadialExplosionEvent;\n}();\n/**\n * Represents a gravitational field event\n */\n\n\nvar PhysicsGravitationalFieldEvent =\n/** @class */\nfunction () {\n  /**\n   * Initializes the physics gravitational field event\n   * @param _physicsHelper A physics helper\n   * @param _scene BabylonJS scene\n   * @param _origin The origin position of the gravitational field event\n   * @param _options The options for the vortex event\n   */\n  function PhysicsGravitationalFieldEvent(_physicsHelper, _scene, _origin, _options) {\n    this._physicsHelper = _physicsHelper;\n    this._scene = _scene;\n    this._origin = _origin;\n    this._options = _options;\n    this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup\n\n    this._options = __assign(__assign({}, new PhysicsRadialExplosionEventOptions()), this._options);\n    this._tickCallback = this._tick.bind(this);\n    this._options.strength = this._options.strength * -1;\n  }\n  /**\n   * Returns the data related to the gravitational field event (sphere).\n   * @returns A gravitational field event\n   */\n\n\n  PhysicsGravitationalFieldEvent.prototype.getData = function () {\n    this._dataFetched = true;\n    return {\n      sphere: this._sphere\n    };\n  };\n  /**\n   * Enables the gravitational field.\n   */\n\n\n  PhysicsGravitationalFieldEvent.prototype.enable = function () {\n    this._tickCallback.call(this);\n\n    this._scene.registerBeforeRender(this._tickCallback);\n  };\n  /**\n   * Disables the gravitational field.\n   */\n\n\n  PhysicsGravitationalFieldEvent.prototype.disable = function () {\n    this._scene.unregisterBeforeRender(this._tickCallback);\n  };\n  /**\n   * Disposes the sphere.\n   * @param force The force to dispose from the gravitational field event\n   */\n\n\n  PhysicsGravitationalFieldEvent.prototype.dispose = function (force) {\n    var _this = this;\n\n    if (force === void 0) {\n      force = true;\n    }\n\n    if (force) {\n      this._sphere.dispose();\n    } else {\n      setTimeout(function () {\n        if (!_this._dataFetched) {\n          _this._sphere.dispose();\n        }\n      }, 0);\n    }\n  };\n\n  PhysicsGravitationalFieldEvent.prototype._tick = function () {\n    // Since the params won't change, we fetch the event only once\n    if (this._sphere) {\n      this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);\n    } else {\n      var radialExplosionEvent = this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);\n\n      if (radialExplosionEvent) {\n        this._sphere = radialExplosionEvent.getData().sphere.clone(\"radialExplosionEventSphereClone\");\n      }\n    }\n  };\n\n  return PhysicsGravitationalFieldEvent;\n}();\n/**\n * Represents a physics updraft event\n */\n\n\nvar PhysicsUpdraftEvent =\n/** @class */\nfunction () {\n  /**\n   * Initializes the physics updraft event\n   * @param _scene BabylonJS scene\n   * @param _origin The origin position of the updraft\n   * @param _options The options for the updraft event\n   */\n  function PhysicsUpdraftEvent(_scene, _origin, _options) {\n    this._scene = _scene;\n    this._origin = _origin;\n    this._options = _options;\n    this._originTop = Vector3.Zero(); // the most upper part of the cylinder\n\n    this._originDirection = Vector3.Zero(); // used if the updraftMode is perpendicular\n\n    this._cylinderPosition = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom\n\n    this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup\n\n    this._physicsEngine = this._scene.getPhysicsEngine();\n    this._options = __assign(__assign({}, new PhysicsUpdraftEventOptions()), this._options);\n\n    this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);\n\n    this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);\n\n    if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {\n      this._originDirection = this._origin.subtract(this._originTop).normalize();\n    }\n\n    this._tickCallback = this._tick.bind(this);\n\n    this._prepareCylinder();\n  }\n  /**\n   * Returns the data related to the updraft event (cylinder).\n   * @returns A physics updraft event\n   */\n\n\n  PhysicsUpdraftEvent.prototype.getData = function () {\n    this._dataFetched = true;\n    return {\n      cylinder: this._cylinder\n    };\n  };\n  /**\n   * Enables the updraft.\n   */\n\n\n  PhysicsUpdraftEvent.prototype.enable = function () {\n    this._tickCallback.call(this);\n\n    this._scene.registerBeforeRender(this._tickCallback);\n  };\n  /**\n   * Disables the updraft.\n   */\n\n\n  PhysicsUpdraftEvent.prototype.disable = function () {\n    this._scene.unregisterBeforeRender(this._tickCallback);\n  };\n  /**\n   * Disposes the cylinder.\n   * @param force Specifies if the updraft should be disposed by force\n   */\n\n\n  PhysicsUpdraftEvent.prototype.dispose = function (force) {\n    var _this = this;\n\n    if (force === void 0) {\n      force = true;\n    }\n\n    if (!this._cylinder) {\n      return;\n    }\n\n    if (force) {\n      this._cylinder.dispose();\n    } else {\n      setTimeout(function () {\n        if (!_this._dataFetched) {\n          _this._cylinder.dispose();\n        }\n      }, 0);\n    }\n  };\n\n  PhysicsUpdraftEvent.prototype._getImpostorHitData = function (impostor) {\n    if (impostor.mass === 0) {\n      return null;\n    }\n\n    if (!this._intersectsWithCylinder(impostor)) {\n      return null;\n    }\n\n    var impostorObjectCenter = impostor.getObjectCenter();\n    var direction;\n\n    if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {\n      direction = this._originDirection;\n    } else {\n      direction = impostorObjectCenter.subtract(this._originTop);\n    }\n\n    var distanceFromOrigin = Vector3.Distance(this._origin, impostorObjectCenter);\n    var multiplier = this._options.strength * -1;\n    var force = direction.multiplyByFloats(multiplier, multiplier, multiplier);\n    return {\n      force: force,\n      contactPoint: impostorObjectCenter,\n      distanceFromOrigin: distanceFromOrigin\n    };\n  };\n\n  PhysicsUpdraftEvent.prototype._tick = function () {\n    var _this = this;\n\n    this._physicsEngine.getImpostors().forEach(function (impostor) {\n      var impostorHitData = _this._getImpostorHitData(impostor);\n\n      if (!impostorHitData) {\n        return;\n      }\n\n      impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);\n    });\n  };\n  /*** Helpers ***/\n\n\n  PhysicsUpdraftEvent.prototype._prepareCylinder = function () {\n    if (!this._cylinder) {\n      this._cylinder = CreateCylinder(\"updraftEventCylinder\", {\n        height: this._options.height,\n        diameter: this._options.radius * 2\n      }, this._scene);\n      this._cylinder.isVisible = false;\n    }\n  };\n\n  PhysicsUpdraftEvent.prototype._intersectsWithCylinder = function (impostor) {\n    var impostorObject = impostor.object;\n    this._cylinder.position = this._cylinderPosition;\n    return this._cylinder.intersectsMesh(impostorObject, true);\n  };\n\n  return PhysicsUpdraftEvent;\n}();\n/**\n * Represents a physics vortex event\n */\n\n\nvar PhysicsVortexEvent =\n/** @class */\nfunction () {\n  /**\n   * Initializes the physics vortex event\n   * @param _scene The BabylonJS scene\n   * @param _origin The origin position of the vortex\n   * @param _options The options for the vortex event\n   */\n  function PhysicsVortexEvent(_scene, _origin, _options) {\n    this._scene = _scene;\n    this._origin = _origin;\n    this._options = _options;\n    this._originTop = Vector3.Zero(); // the most upper part of the cylinder\n\n    this._cylinderPosition = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom\n\n    this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup\n\n    this._physicsEngine = this._scene.getPhysicsEngine();\n    this._options = __assign(__assign({}, new PhysicsVortexEventOptions()), this._options);\n\n    this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);\n\n    this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);\n\n    this._tickCallback = this._tick.bind(this);\n\n    this._prepareCylinder();\n  }\n  /**\n   * Returns the data related to the vortex event (cylinder).\n   * @returns The physics vortex event data\n   */\n\n\n  PhysicsVortexEvent.prototype.getData = function () {\n    this._dataFetched = true;\n    return {\n      cylinder: this._cylinder\n    };\n  };\n  /**\n   * Enables the vortex.\n   */\n\n\n  PhysicsVortexEvent.prototype.enable = function () {\n    this._tickCallback.call(this);\n\n    this._scene.registerBeforeRender(this._tickCallback);\n  };\n  /**\n   * Disables the cortex.\n   */\n\n\n  PhysicsVortexEvent.prototype.disable = function () {\n    this._scene.unregisterBeforeRender(this._tickCallback);\n  };\n  /**\n   * Disposes the sphere.\n   * @param force\n   */\n\n\n  PhysicsVortexEvent.prototype.dispose = function (force) {\n    var _this = this;\n\n    if (force === void 0) {\n      force = true;\n    }\n\n    if (force) {\n      this._cylinder.dispose();\n    } else {\n      setTimeout(function () {\n        if (!_this._dataFetched) {\n          _this._cylinder.dispose();\n        }\n      }, 0);\n    }\n  };\n\n  PhysicsVortexEvent.prototype._getImpostorHitData = function (impostor) {\n    if (impostor.mass === 0) {\n      return null;\n    }\n\n    if (!this._intersectsWithCylinder(impostor)) {\n      return null;\n    }\n\n    if (impostor.object.getClassName() !== \"Mesh\" && impostor.object.getClassName() !== \"InstancedMesh\") {\n      return null;\n    }\n\n    var impostorObjectCenter = impostor.getObjectCenter();\n    var originOnPlane = new Vector3(this._origin.x, impostorObjectCenter.y, this._origin.z); // the distance to the origin as if both objects were on a plane (Y-axis)\n\n    var originToImpostorDirection = impostorObjectCenter.subtract(originOnPlane);\n    var ray = new Ray(originOnPlane, originToImpostorDirection, this._options.radius);\n    var hit = ray.intersectsMesh(impostor.object);\n    var contactPoint = hit.pickedPoint;\n\n    if (!contactPoint) {\n      return null;\n    }\n\n    var absoluteDistanceFromOrigin = hit.distance / this._options.radius;\n    var directionToOrigin = contactPoint.normalize();\n\n    if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {\n      directionToOrigin = directionToOrigin.negate();\n    }\n\n    var forceX;\n    var forceY;\n    var forceZ;\n\n    if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {\n      forceX = directionToOrigin.x * this._options.centripetalForceMultiplier;\n      forceY = directionToOrigin.y * this._options.updraftForceMultiplier;\n      forceZ = directionToOrigin.z * this._options.centripetalForceMultiplier;\n    } else {\n      var perpendicularDirection = Vector3.Cross(originOnPlane, impostorObjectCenter).normalize();\n      forceX = (perpendicularDirection.x + directionToOrigin.x) * this._options.centrifugalForceMultiplier;\n      forceY = this._originTop.y * this._options.updraftForceMultiplier;\n      forceZ = (perpendicularDirection.z + directionToOrigin.z) * this._options.centrifugalForceMultiplier;\n    }\n\n    var force = new Vector3(forceX, forceY, forceZ);\n    force = force.multiplyByFloats(this._options.strength, this._options.strength, this._options.strength);\n    return {\n      force: force,\n      contactPoint: impostorObjectCenter,\n      distanceFromOrigin: absoluteDistanceFromOrigin\n    };\n  };\n\n  PhysicsVortexEvent.prototype._tick = function () {\n    var _this = this;\n\n    this._physicsEngine.getImpostors().forEach(function (impostor) {\n      var impostorHitData = _this._getImpostorHitData(impostor);\n\n      if (!impostorHitData) {\n        return;\n      }\n\n      impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);\n    });\n  };\n  /*** Helpers ***/\n\n\n  PhysicsVortexEvent.prototype._prepareCylinder = function () {\n    if (!this._cylinder) {\n      this._cylinder = CreateCylinder(\"vortexEventCylinder\", {\n        height: this._options.height,\n        diameter: this._options.radius * 2\n      }, this._scene);\n      this._cylinder.isVisible = false;\n    }\n  };\n\n  PhysicsVortexEvent.prototype._intersectsWithCylinder = function (impostor) {\n    var impostorObject = impostor.object;\n    this._cylinder.position = this._cylinderPosition;\n    return this._cylinder.intersectsMesh(impostorObject, true);\n  };\n\n  return PhysicsVortexEvent;\n}();\n/**\n * Options fot the radial explosion event\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\n */\n\n\nvar PhysicsRadialExplosionEventOptions =\n/** @class */\nfunction () {\n  function PhysicsRadialExplosionEventOptions() {\n    /**\n     * The radius of the sphere for the radial explosion.\n     */\n    this.radius = 5;\n    /**\n     * The strength of the explosion.\n     */\n\n    this.strength = 10;\n    /**\n     * The strength of the force in correspondence to the distance of the affected object\n     */\n\n    this.falloff = PhysicsRadialImpulseFalloff.Constant;\n    /**\n     * Sphere options for the radial explosion.\n     */\n\n    this.sphere = {\n      segments: 32,\n      diameter: 1\n    };\n  }\n\n  return PhysicsRadialExplosionEventOptions;\n}();\n\nexport { PhysicsRadialExplosionEventOptions };\n/**\n * Options fot the updraft event\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\n */\n\nvar PhysicsUpdraftEventOptions =\n/** @class */\nfunction () {\n  function PhysicsUpdraftEventOptions() {\n    /**\n     * The radius of the cylinder for the vortex\n     */\n    this.radius = 5;\n    /**\n     * The strength of the updraft.\n     */\n\n    this.strength = 10;\n    /**\n     * The height of the cylinder for the updraft.\n     */\n\n    this.height = 10;\n    /**\n     * The mode for the the updraft.\n     */\n\n    this.updraftMode = PhysicsUpdraftMode.Center;\n  }\n\n  return PhysicsUpdraftEventOptions;\n}();\n\nexport { PhysicsUpdraftEventOptions };\n/**\n * Options fot the vortex event\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\n */\n\nvar PhysicsVortexEventOptions =\n/** @class */\nfunction () {\n  function PhysicsVortexEventOptions() {\n    /**\n     * The radius of the cylinder for the vortex\n     */\n    this.radius = 5;\n    /**\n     * The strength of the vortex.\n     */\n\n    this.strength = 10;\n    /**\n     * The height of the cylinder for the vortex.\n     */\n\n    this.height = 10;\n    /**\n     * At which distance, relative to the radius the centripetal forces should kick in? Range: 0-1\n     */\n\n    this.centripetalForceThreshold = 0.7;\n    /**\n     * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when below the threshold.\n     */\n\n    this.centripetalForceMultiplier = 5;\n    /**\n     * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when above the threshold.\n     */\n\n    this.centrifugalForceMultiplier = 0.5;\n    /**\n     * This multiplier determines with how much force the objects will be pushed upwards, when in the vortex.\n     */\n\n    this.updraftForceMultiplier = 0.02;\n  }\n\n  return PhysicsVortexEventOptions;\n}();\n\nexport { PhysicsVortexEventOptions };\n/**\n * The strength of the force in correspondence to the distance of the affected object\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\n */\n\nexport var PhysicsRadialImpulseFalloff;\n\n(function (PhysicsRadialImpulseFalloff) {\n  /** Defines that impulse is constant in strength across it's whole radius */\n  PhysicsRadialImpulseFalloff[PhysicsRadialImpulseFalloff[\"Constant\"] = 0] = \"Constant\";\n  /** Defines that impulse gets weaker if it's further from the origin */\n\n  PhysicsRadialImpulseFalloff[PhysicsRadialImpulseFalloff[\"Linear\"] = 1] = \"Linear\";\n})(PhysicsRadialImpulseFalloff || (PhysicsRadialImpulseFalloff = {}));\n/**\n * The strength of the force in correspondence to the distance of the affected object\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\n */\n\n\nexport var PhysicsUpdraftMode;\n\n(function (PhysicsUpdraftMode) {\n  /** Defines that the upstream forces will pull towards the top center of the cylinder */\n  PhysicsUpdraftMode[PhysicsUpdraftMode[\"Center\"] = 0] = \"Center\";\n  /** Defines that once a impostor is inside the cylinder, it will shoot out perpendicular from the ground of the cylinder */\n\n  PhysicsUpdraftMode[PhysicsUpdraftMode[\"Perpendicular\"] = 1] = \"Perpendicular\";\n})(PhysicsUpdraftMode || (PhysicsUpdraftMode = {}));","map":{"version":3,"mappings":"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","names":["Logger","Vector3","CreateSphere","CreateCylinder","Ray","scene","_scene","_physicsEngine","getPhysicsEngine","Warn","PhysicsHelper","origin","radiusOrEventOptions","strength","falloff","impostors","getImpostors","length","PhysicsRadialExplosionEventOptions","radius","event","PhysicsRadialExplosionEvent","affectedImpostorsWithData","Array","forEach","impostor","impostorHitData","getImpostorHitData","applyImpulse","force","contactPoint","push","hitData","triggerAffectedImpostorsCallback","dispose","applyForce","PhysicsGravitationalFieldEvent","height","updraftMode","PhysicsUpdraftEventOptions","PhysicsUpdraftEvent","PhysicsVortexEventOptions","PhysicsVortexEvent","_options","__assign","_dataFetched","sphere","_sphere","mass","_intersectsWithSphere","object","getClassName","impostorObjectCenter","getObjectCenter","direction","subtract","ray","hit","intersectsMesh","pickedPoint","distanceFromOrigin","Distance","multiplier","PhysicsRadialImpulseFalloff","Constant","multiplyByFloats","affectedImpostorsCallback","setTimeout","_this","isVisible","impostorObject","_prepareSphere","position","scaling","_updateBoundingInfo","computeWorldMatrix","_physicsHelper","_origin","_tickCallback","_tick","bind","call","registerBeforeRender","unregisterBeforeRender","applyRadialExplosionForce","radialExplosionEvent","getData","clone","Zero","addToRef","_cylinderPosition","_originTop","PhysicsUpdraftMode","Perpendicular","_originDirection","normalize","_prepareCylinder","cylinder","_cylinder","_intersectsWithCylinder","_getImpostorHitData","diameter","originOnPlane","x","y","z","originToImpostorDirection","absoluteDistanceFromOrigin","distance","directionToOrigin","centripetalForceThreshold","negate","forceX","forceY","forceZ","centripetalForceMultiplier","updraftForceMultiplier","perpendicularDirection","Cross","centrifugalForceMultiplier","segments","Center"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Physics/physicsHelper.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder\";\r\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder\";\r\nimport { Ray } from \"../Culling/ray\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { IPhysicsEngine } from \"./IPhysicsEngine\";\r\nimport type { PhysicsEngine } from \"./physicsEngine\";\r\nimport type { PhysicsImpostor } from \"./physicsImpostor\";\r\n\r\n/**\r\n * A helper for physics simulations\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\r\nexport class PhysicsHelper {\r\n    private _scene: Scene;\r\n    private _physicsEngine: Nullable<IPhysicsEngine>;\r\n\r\n    /**\r\n     * Initializes the Physics helper\r\n     * @param scene Babylon.js scene\r\n     */\r\n    constructor(scene: Scene) {\r\n        this._scene = scene;\r\n        this._physicsEngine = this._scene.getPhysicsEngine();\r\n\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you can use the methods.\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Applies a radial explosion impulse\r\n     * @param origin the origin of the explosion\r\n     * @param radiusOrEventOptions the radius or the options of radial explosion\r\n     * @param strength the explosion strength\r\n     * @param falloff possible options: Constant & Linear. Defaults to Constant\r\n     * @returns A physics radial explosion event, or null\r\n     */\r\n    public applyRadialExplosionImpulse(\r\n        origin: Vector3,\r\n        radiusOrEventOptions: number | PhysicsRadialExplosionEventOptions,\r\n        strength?: number,\r\n        falloff?: PhysicsRadialImpulseFalloff\r\n    ): Nullable<PhysicsRadialExplosionEvent> {\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call this method.\");\r\n            return null;\r\n        }\r\n\r\n        const impostors = this._physicsEngine.getImpostors();\r\n        if (impostors.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (typeof radiusOrEventOptions === \"number\") {\r\n            radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\r\n            radiusOrEventOptions.radius = <number>(<any>radiusOrEventOptions);\r\n            radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\r\n            radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;\r\n        }\r\n\r\n        const event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);\r\n        const affectedImpostorsWithData = Array<PhysicsAffectedImpostorWithData>();\r\n\r\n        impostors.forEach((impostor) => {\r\n            const impostorHitData = event.getImpostorHitData(impostor, origin);\r\n            if (!impostorHitData) {\r\n                return;\r\n            }\r\n\r\n            impostor.applyImpulse(impostorHitData.force, impostorHitData.contactPoint);\r\n\r\n            affectedImpostorsWithData.push({\r\n                impostor: impostor,\r\n                hitData: impostorHitData,\r\n            });\r\n        });\r\n\r\n        event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);\r\n\r\n        event.dispose(false);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Applies a radial explosion force\r\n     * @param origin the origin of the explosion\r\n     * @param radiusOrEventOptions the radius or the options of radial explosion\r\n     * @param strength the explosion strength\r\n     * @param falloff possible options: Constant & Linear. Defaults to Constant\r\n     * @returns A physics radial explosion event, or null\r\n     */\r\n    public applyRadialExplosionForce(\r\n        origin: Vector3,\r\n        radiusOrEventOptions: number | PhysicsRadialExplosionEventOptions,\r\n        strength?: number,\r\n        falloff?: PhysicsRadialImpulseFalloff\r\n    ): Nullable<PhysicsRadialExplosionEvent> {\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\r\n            return null;\r\n        }\r\n\r\n        const impostors = this._physicsEngine.getImpostors();\r\n        if (impostors.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (typeof radiusOrEventOptions === \"number\") {\r\n            radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\r\n            radiusOrEventOptions.radius = <number>(<any>radiusOrEventOptions);\r\n            radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\r\n            radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;\r\n        }\r\n\r\n        const event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);\r\n        const affectedImpostorsWithData = Array<PhysicsAffectedImpostorWithData>();\r\n\r\n        impostors.forEach((impostor) => {\r\n            const impostorHitData = event.getImpostorHitData(impostor, origin);\r\n            if (!impostorHitData) {\r\n                return;\r\n            }\r\n\r\n            impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);\r\n\r\n            affectedImpostorsWithData.push({\r\n                impostor: impostor,\r\n                hitData: impostorHitData,\r\n            });\r\n        });\r\n\r\n        event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);\r\n\r\n        event.dispose(false);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Creates a gravitational field\r\n     * @param origin the origin of the explosion\r\n     * @param radiusOrEventOptions the radius or the options of radial explosion\r\n     * @param strength the explosion strength\r\n     * @param falloff possible options: Constant & Linear. Defaults to Constant\r\n     * @returns A physics gravitational field event, or null\r\n     */\r\n    public gravitationalField(\r\n        origin: Vector3,\r\n        radiusOrEventOptions: number | PhysicsRadialExplosionEventOptions,\r\n        strength?: number,\r\n        falloff?: PhysicsRadialImpulseFalloff\r\n    ): Nullable<PhysicsGravitationalFieldEvent> {\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\r\n            return null;\r\n        }\r\n\r\n        const impostors = this._physicsEngine.getImpostors();\r\n        if (impostors.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (typeof radiusOrEventOptions === \"number\") {\r\n            radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\r\n            radiusOrEventOptions.radius = <number>(<any>radiusOrEventOptions);\r\n            radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\r\n            radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;\r\n        }\r\n\r\n        const event = new PhysicsGravitationalFieldEvent(this, this._scene, origin, radiusOrEventOptions);\r\n\r\n        event.dispose(false);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Creates a physics updraft event\r\n     * @param origin the origin of the updraft\r\n     * @param radiusOrEventOptions the radius or the options of the updraft\r\n     * @param strength the strength of the updraft\r\n     * @param height the height of the updraft\r\n     * @param updraftMode possible options: Center & Perpendicular. Defaults to Center\r\n     * @returns A physics updraft event, or null\r\n     */\r\n    public updraft(\r\n        origin: Vector3,\r\n        radiusOrEventOptions: number | PhysicsUpdraftEventOptions,\r\n        strength?: number,\r\n        height?: number,\r\n        updraftMode?: PhysicsUpdraftMode\r\n    ): Nullable<PhysicsUpdraftEvent> {\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\r\n            return null;\r\n        }\r\n\r\n        if (this._physicsEngine.getImpostors().length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (typeof radiusOrEventOptions === \"number\") {\r\n            radiusOrEventOptions = new PhysicsUpdraftEventOptions();\r\n            radiusOrEventOptions.radius = <number>(<any>radiusOrEventOptions);\r\n            radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\r\n            radiusOrEventOptions.height = height || radiusOrEventOptions.height;\r\n            radiusOrEventOptions.updraftMode = updraftMode || radiusOrEventOptions.updraftMode;\r\n        }\r\n\r\n        const event = new PhysicsUpdraftEvent(this._scene, origin, radiusOrEventOptions);\r\n\r\n        event.dispose(false);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Creates a physics vortex event\r\n     * @param origin the of the vortex\r\n     * @param radiusOrEventOptions the radius or the options of the vortex\r\n     * @param strength the strength of the vortex\r\n     * @param height   the height of the vortex\r\n     * @returns a Physics vortex event, or null\r\n     * A physics vortex event or null\r\n     */\r\n    public vortex(origin: Vector3, radiusOrEventOptions: number | PhysicsVortexEventOptions, strength?: number, height?: number): Nullable<PhysicsVortexEvent> {\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\r\n            return null;\r\n        }\r\n\r\n        if (this._physicsEngine.getImpostors().length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (typeof radiusOrEventOptions === \"number\") {\r\n            radiusOrEventOptions = new PhysicsVortexEventOptions();\r\n            radiusOrEventOptions.radius = <number>(<any>radiusOrEventOptions);\r\n            radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\r\n            radiusOrEventOptions.height = height || radiusOrEventOptions.height;\r\n        }\r\n\r\n        const event = new PhysicsVortexEvent(this._scene, origin, radiusOrEventOptions);\r\n\r\n        event.dispose(false);\r\n\r\n        return event;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a physics radial explosion event\r\n */\r\nclass PhysicsRadialExplosionEvent {\r\n    private _sphere: Mesh; // create a sphere, so we can get the intersecting meshes inside\r\n    private _dataFetched: boolean = false; // check if the data has been fetched. If not, do cleanup\r\n\r\n    /**\r\n     * Initializes a radial explosion event\r\n     * @param _scene BabylonJS scene\r\n     * @param _options The options for the vortex event\r\n     */\r\n    constructor(private _scene: Scene, private _options: PhysicsRadialExplosionEventOptions) {\r\n        this._options = { ...new PhysicsRadialExplosionEventOptions(), ...this._options };\r\n    }\r\n\r\n    /**\r\n     * Returns the data related to the radial explosion event (sphere).\r\n     * @returns The radial explosion event data\r\n     */\r\n    public getData(): PhysicsRadialExplosionEventData {\r\n        this._dataFetched = true;\r\n\r\n        return {\r\n            sphere: this._sphere,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns the force and contact point of the impostor or false, if the impostor is not affected by the force/impulse.\r\n     * @param impostor A physics imposter\r\n     * @param origin the origin of the explosion\r\n     * @returns {Nullable<PhysicsHitData>} A physics force and contact point, or null\r\n     */\r\n    public getImpostorHitData(impostor: PhysicsImpostor, origin: Vector3): Nullable<PhysicsHitData> {\r\n        if (impostor.mass === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (!this._intersectsWithSphere(impostor, origin, this._options.radius)) {\r\n            return null;\r\n        }\r\n\r\n        if (impostor.object.getClassName() !== \"Mesh\" && impostor.object.getClassName() !== \"InstancedMesh\") {\r\n            return null;\r\n        }\r\n\r\n        const impostorObjectCenter = impostor.getObjectCenter();\r\n        const direction = impostorObjectCenter.subtract(origin);\r\n\r\n        const ray = new Ray(origin, direction, this._options.radius);\r\n        const hit = ray.intersectsMesh(<AbstractMesh>impostor.object);\r\n\r\n        const contactPoint = hit.pickedPoint;\r\n        if (!contactPoint) {\r\n            return null;\r\n        }\r\n\r\n        const distanceFromOrigin = Vector3.Distance(origin, contactPoint);\r\n\r\n        if (distanceFromOrigin > this._options.radius) {\r\n            return null;\r\n        }\r\n\r\n        const multiplier =\r\n            this._options.falloff === PhysicsRadialImpulseFalloff.Constant ? this._options.strength : this._options.strength * (1 - distanceFromOrigin / this._options.radius);\r\n\r\n        const force = direction.multiplyByFloats(multiplier, multiplier, multiplier);\r\n\r\n        return { force: force, contactPoint: contactPoint, distanceFromOrigin: distanceFromOrigin };\r\n    }\r\n\r\n    /**\r\n     * Triggers affected impostors callbacks\r\n     * @param affectedImpostorsWithData defines the list of affected impostors (including associated data)\r\n     */\r\n    public triggerAffectedImpostorsCallback(affectedImpostorsWithData: Array<PhysicsAffectedImpostorWithData>) {\r\n        if (this._options.affectedImpostorsCallback) {\r\n            this._options.affectedImpostorsCallback(affectedImpostorsWithData);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the sphere.\r\n     * @param force Specifies if the sphere should be disposed by force\r\n     */\r\n    public dispose(force: boolean = true) {\r\n        if (force) {\r\n            this._sphere.dispose();\r\n        } else {\r\n            setTimeout(() => {\r\n                if (!this._dataFetched) {\r\n                    this._sphere.dispose();\r\n                }\r\n            }, 0);\r\n        }\r\n    }\r\n\r\n    /*** Helpers ***/\r\n\r\n    private _prepareSphere(): void {\r\n        if (!this._sphere) {\r\n            this._sphere = CreateSphere(\"radialExplosionEventSphere\", this._options.sphere, this._scene);\r\n            this._sphere.isVisible = false;\r\n        }\r\n    }\r\n\r\n    private _intersectsWithSphere(impostor: PhysicsImpostor, origin: Vector3, radius: number): boolean {\r\n        const impostorObject = <AbstractMesh>impostor.object;\r\n\r\n        this._prepareSphere();\r\n\r\n        this._sphere.position = origin;\r\n        this._sphere.scaling = new Vector3(radius * 2, radius * 2, radius * 2);\r\n        this._sphere._updateBoundingInfo();\r\n        this._sphere.computeWorldMatrix(true);\r\n\r\n        return this._sphere.intersectsMesh(impostorObject, true);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a gravitational field event\r\n */\r\nclass PhysicsGravitationalFieldEvent {\r\n    private _tickCallback: any;\r\n    private _sphere: Mesh;\r\n    private _dataFetched: boolean = false; // check if the has been fetched the data. If not, do cleanup\r\n\r\n    /**\r\n     * Initializes the physics gravitational field event\r\n     * @param _physicsHelper A physics helper\r\n     * @param _scene BabylonJS scene\r\n     * @param _origin The origin position of the gravitational field event\r\n     * @param _options The options for the vortex event\r\n     */\r\n    constructor(private _physicsHelper: PhysicsHelper, private _scene: Scene, private _origin: Vector3, private _options: PhysicsRadialExplosionEventOptions) {\r\n        this._options = { ...new PhysicsRadialExplosionEventOptions(), ...this._options };\r\n\r\n        this._tickCallback = this._tick.bind(this);\r\n\r\n        this._options.strength = this._options.strength * -1;\r\n    }\r\n\r\n    /**\r\n     * Returns the data related to the gravitational field event (sphere).\r\n     * @returns A gravitational field event\r\n     */\r\n    public getData(): PhysicsGravitationalFieldEventData {\r\n        this._dataFetched = true;\r\n\r\n        return {\r\n            sphere: this._sphere,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Enables the gravitational field.\r\n     */\r\n    public enable() {\r\n        this._tickCallback.call(this);\r\n        this._scene.registerBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disables the gravitational field.\r\n     */\r\n    public disable() {\r\n        this._scene.unregisterBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disposes the sphere.\r\n     * @param force The force to dispose from the gravitational field event\r\n     */\r\n    public dispose(force: boolean = true) {\r\n        if (force) {\r\n            this._sphere.dispose();\r\n        } else {\r\n            setTimeout(() => {\r\n                if (!this._dataFetched) {\r\n                    this._sphere.dispose();\r\n                }\r\n            }, 0);\r\n        }\r\n    }\r\n\r\n    private _tick() {\r\n        // Since the params won't change, we fetch the event only once\r\n        if (this._sphere) {\r\n            this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);\r\n        } else {\r\n            const radialExplosionEvent = this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);\r\n            if (radialExplosionEvent) {\r\n                this._sphere = <Mesh>radialExplosionEvent.getData().sphere.clone(\"radialExplosionEventSphereClone\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a physics updraft event\r\n */\r\nclass PhysicsUpdraftEvent {\r\n    private _physicsEngine: PhysicsEngine;\r\n    private _originTop: Vector3 = Vector3.Zero(); // the most upper part of the cylinder\r\n    private _originDirection: Vector3 = Vector3.Zero(); // used if the updraftMode is perpendicular\r\n    private _tickCallback: any;\r\n    private _cylinder: Mesh;\r\n    private _cylinderPosition: Vector3 = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom\r\n    private _dataFetched: boolean = false; // check if the has been fetched the data. If not, do cleanup\r\n\r\n    /**\r\n     * Initializes the physics updraft event\r\n     * @param _scene BabylonJS scene\r\n     * @param _origin The origin position of the updraft\r\n     * @param _options The options for the updraft event\r\n     */\r\n    constructor(private _scene: Scene, private _origin: Vector3, private _options: PhysicsUpdraftEventOptions) {\r\n        this._physicsEngine = <PhysicsEngine>this._scene.getPhysicsEngine();\r\n        this._options = { ...new PhysicsUpdraftEventOptions(), ...this._options };\r\n\r\n        this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);\r\n        this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);\r\n\r\n        if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {\r\n            this._originDirection = this._origin.subtract(this._originTop).normalize();\r\n        }\r\n\r\n        this._tickCallback = this._tick.bind(this);\r\n\r\n        this._prepareCylinder();\r\n    }\r\n\r\n    /**\r\n     * Returns the data related to the updraft event (cylinder).\r\n     * @returns A physics updraft event\r\n     */\r\n    public getData(): PhysicsUpdraftEventData {\r\n        this._dataFetched = true;\r\n\r\n        return {\r\n            cylinder: this._cylinder,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Enables the updraft.\r\n     */\r\n    public enable() {\r\n        this._tickCallback.call(this);\r\n        this._scene.registerBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disables the updraft.\r\n     */\r\n    public disable() {\r\n        this._scene.unregisterBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disposes the cylinder.\r\n     * @param force Specifies if the updraft should be disposed by force\r\n     */\r\n    public dispose(force: boolean = true) {\r\n        if (!this._cylinder) {\r\n            return;\r\n        }\r\n        if (force) {\r\n            this._cylinder.dispose();\r\n        } else {\r\n            setTimeout(() => {\r\n                if (!this._dataFetched) {\r\n                    this._cylinder.dispose();\r\n                }\r\n            }, 0);\r\n        }\r\n    }\r\n\r\n    private _getImpostorHitData(impostor: PhysicsImpostor): Nullable<PhysicsHitData> {\r\n        if (impostor.mass === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (!this._intersectsWithCylinder(impostor)) {\r\n            return null;\r\n        }\r\n\r\n        const impostorObjectCenter = impostor.getObjectCenter();\r\n\r\n        let direction: Vector3;\r\n        if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {\r\n            direction = this._originDirection;\r\n        } else {\r\n            direction = impostorObjectCenter.subtract(this._originTop);\r\n        }\r\n\r\n        const distanceFromOrigin = Vector3.Distance(this._origin, impostorObjectCenter);\r\n\r\n        const multiplier = this._options.strength * -1;\r\n\r\n        const force = direction.multiplyByFloats(multiplier, multiplier, multiplier);\r\n\r\n        return { force: force, contactPoint: impostorObjectCenter, distanceFromOrigin: distanceFromOrigin };\r\n    }\r\n\r\n    private _tick() {\r\n        this._physicsEngine.getImpostors().forEach((impostor) => {\r\n            const impostorHitData = this._getImpostorHitData(impostor);\r\n            if (!impostorHitData) {\r\n                return;\r\n            }\r\n\r\n            impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);\r\n        });\r\n    }\r\n\r\n    /*** Helpers ***/\r\n\r\n    private _prepareCylinder(): void {\r\n        if (!this._cylinder) {\r\n            this._cylinder = CreateCylinder(\r\n                \"updraftEventCylinder\",\r\n                {\r\n                    height: this._options.height,\r\n                    diameter: this._options.radius * 2,\r\n                },\r\n                this._scene\r\n            );\r\n            this._cylinder.isVisible = false;\r\n        }\r\n    }\r\n\r\n    private _intersectsWithCylinder(impostor: PhysicsImpostor): boolean {\r\n        const impostorObject = <AbstractMesh>impostor.object;\r\n\r\n        this._cylinder.position = this._cylinderPosition;\r\n\r\n        return this._cylinder.intersectsMesh(impostorObject, true);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a physics vortex event\r\n */\r\nclass PhysicsVortexEvent {\r\n    private _physicsEngine: PhysicsEngine;\r\n    private _originTop: Vector3 = Vector3.Zero(); // the most upper part of the cylinder\r\n    private _tickCallback: any;\r\n    private _cylinder: Mesh;\r\n    private _cylinderPosition: Vector3 = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom\r\n    private _dataFetched: boolean = false; // check if the has been fetched the data. If not, do cleanup\r\n\r\n    /**\r\n     * Initializes the physics vortex event\r\n     * @param _scene The BabylonJS scene\r\n     * @param _origin The origin position of the vortex\r\n     * @param _options The options for the vortex event\r\n     */\r\n    constructor(private _scene: Scene, private _origin: Vector3, private _options: PhysicsVortexEventOptions) {\r\n        this._physicsEngine = <PhysicsEngine>this._scene.getPhysicsEngine();\r\n        this._options = { ...new PhysicsVortexEventOptions(), ...this._options };\r\n\r\n        this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);\r\n        this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);\r\n\r\n        this._tickCallback = this._tick.bind(this);\r\n\r\n        this._prepareCylinder();\r\n    }\r\n\r\n    /**\r\n     * Returns the data related to the vortex event (cylinder).\r\n     * @returns The physics vortex event data\r\n     */\r\n    public getData(): PhysicsVortexEventData {\r\n        this._dataFetched = true;\r\n\r\n        return {\r\n            cylinder: this._cylinder,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Enables the vortex.\r\n     */\r\n    public enable() {\r\n        this._tickCallback.call(this);\r\n        this._scene.registerBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disables the cortex.\r\n     */\r\n    public disable() {\r\n        this._scene.unregisterBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disposes the sphere.\r\n     * @param force\r\n     */\r\n    public dispose(force: boolean = true) {\r\n        if (force) {\r\n            this._cylinder.dispose();\r\n        } else {\r\n            setTimeout(() => {\r\n                if (!this._dataFetched) {\r\n                    this._cylinder.dispose();\r\n                }\r\n            }, 0);\r\n        }\r\n    }\r\n\r\n    private _getImpostorHitData(impostor: PhysicsImpostor): Nullable<PhysicsHitData> {\r\n        if (impostor.mass === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (!this._intersectsWithCylinder(impostor)) {\r\n            return null;\r\n        }\r\n\r\n        if (impostor.object.getClassName() !== \"Mesh\" && impostor.object.getClassName() !== \"InstancedMesh\") {\r\n            return null;\r\n        }\r\n\r\n        const impostorObjectCenter = impostor.getObjectCenter();\r\n        const originOnPlane = new Vector3(this._origin.x, impostorObjectCenter.y, this._origin.z); // the distance to the origin as if both objects were on a plane (Y-axis)\r\n        const originToImpostorDirection = impostorObjectCenter.subtract(originOnPlane);\r\n\r\n        const ray = new Ray(originOnPlane, originToImpostorDirection, this._options.radius);\r\n        const hit = ray.intersectsMesh(<AbstractMesh>impostor.object);\r\n        const contactPoint = hit.pickedPoint;\r\n        if (!contactPoint) {\r\n            return null;\r\n        }\r\n        const absoluteDistanceFromOrigin = hit.distance / this._options.radius;\r\n\r\n        let directionToOrigin = contactPoint.normalize();\r\n        if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {\r\n            directionToOrigin = directionToOrigin.negate();\r\n        }\r\n\r\n        let forceX: number;\r\n        let forceY: number;\r\n        let forceZ: number;\r\n\r\n        if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {\r\n            forceX = directionToOrigin.x * this._options.centripetalForceMultiplier;\r\n            forceY = directionToOrigin.y * this._options.updraftForceMultiplier;\r\n            forceZ = directionToOrigin.z * this._options.centripetalForceMultiplier;\r\n        } else {\r\n            const perpendicularDirection = Vector3.Cross(originOnPlane, impostorObjectCenter).normalize();\r\n\r\n            forceX = (perpendicularDirection.x + directionToOrigin.x) * this._options.centrifugalForceMultiplier;\r\n            forceY = this._originTop.y * this._options.updraftForceMultiplier;\r\n            forceZ = (perpendicularDirection.z + directionToOrigin.z) * this._options.centrifugalForceMultiplier;\r\n        }\r\n\r\n        let force = new Vector3(forceX, forceY, forceZ);\r\n        force = force.multiplyByFloats(this._options.strength, this._options.strength, this._options.strength);\r\n\r\n        return { force: force, contactPoint: impostorObjectCenter, distanceFromOrigin: absoluteDistanceFromOrigin };\r\n    }\r\n\r\n    private _tick() {\r\n        this._physicsEngine.getImpostors().forEach((impostor) => {\r\n            const impostorHitData = this._getImpostorHitData(impostor);\r\n            if (!impostorHitData) {\r\n                return;\r\n            }\r\n\r\n            impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);\r\n        });\r\n    }\r\n\r\n    /*** Helpers ***/\r\n\r\n    private _prepareCylinder(): void {\r\n        if (!this._cylinder) {\r\n            this._cylinder = CreateCylinder(\r\n                \"vortexEventCylinder\",\r\n                {\r\n                    height: this._options.height,\r\n                    diameter: this._options.radius * 2,\r\n                },\r\n                this._scene\r\n            );\r\n            this._cylinder.isVisible = false;\r\n        }\r\n    }\r\n\r\n    private _intersectsWithCylinder(impostor: PhysicsImpostor): boolean {\r\n        const impostorObject = <AbstractMesh>impostor.object;\r\n\r\n        this._cylinder.position = this._cylinderPosition;\r\n\r\n        return this._cylinder.intersectsMesh(impostorObject, true);\r\n    }\r\n}\r\n\r\n/**\r\n * Options fot the radial explosion event\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\r\nexport class PhysicsRadialExplosionEventOptions {\r\n    /**\r\n     * The radius of the sphere for the radial explosion.\r\n     */\r\n    radius: number = 5;\r\n\r\n    /**\r\n     * The strength of the explosion.\r\n     */\r\n    strength: number = 10;\r\n\r\n    /**\r\n     * The strength of the force in correspondence to the distance of the affected object\r\n     */\r\n    falloff: PhysicsRadialImpulseFalloff = PhysicsRadialImpulseFalloff.Constant;\r\n\r\n    /**\r\n     * Sphere options for the radial explosion.\r\n     */\r\n    sphere: { segments: number; diameter: number } = { segments: 32, diameter: 1 };\r\n\r\n    /**\r\n     * Sphere options for the radial explosion.\r\n     */\r\n    affectedImpostorsCallback: (affectedImpostorsWithData: Array<PhysicsAffectedImpostorWithData>) => void;\r\n}\r\n\r\n/**\r\n * Options fot the updraft event\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\r\nexport class PhysicsUpdraftEventOptions {\r\n    /**\r\n     * The radius of the cylinder for the vortex\r\n     */\r\n    radius: number = 5;\r\n\r\n    /**\r\n     * The strength of the updraft.\r\n     */\r\n    strength: number = 10;\r\n\r\n    /**\r\n     * The height of the cylinder for the updraft.\r\n     */\r\n    height: number = 10;\r\n\r\n    /**\r\n     * The mode for the the updraft.\r\n     */\r\n    updraftMode: PhysicsUpdraftMode = PhysicsUpdraftMode.Center;\r\n}\r\n\r\n/**\r\n * Options fot the vortex event\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\r\nexport class PhysicsVortexEventOptions {\r\n    /**\r\n     * The radius of the cylinder for the vortex\r\n     */\r\n    radius: number = 5;\r\n\r\n    /**\r\n     * The strength of the vortex.\r\n     */\r\n    strength: number = 10;\r\n\r\n    /**\r\n     * The height of the cylinder for the vortex.\r\n     */\r\n    height: number = 10;\r\n\r\n    /**\r\n     * At which distance, relative to the radius the centripetal forces should kick in? Range: 0-1\r\n     */\r\n    centripetalForceThreshold: number = 0.7;\r\n\r\n    /**\r\n     * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when below the threshold.\r\n     */\r\n    centripetalForceMultiplier: number = 5;\r\n\r\n    /**\r\n     * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when above the threshold.\r\n     */\r\n    centrifugalForceMultiplier: number = 0.5;\r\n\r\n    /**\r\n     * This multiplier determines with how much force the objects will be pushed upwards, when in the vortex.\r\n     */\r\n    updraftForceMultiplier: number = 0.02;\r\n}\r\n\r\n/**\r\n * The strength of the force in correspondence to the distance of the affected object\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\r\nexport enum PhysicsRadialImpulseFalloff {\r\n    /** Defines that impulse is constant in strength across it's whole radius */\r\n    Constant,\r\n    /** Defines that impulse gets weaker if it's further from the origin */\r\n    Linear,\r\n}\r\n\r\n/**\r\n * The strength of the force in correspondence to the distance of the affected object\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\r\nexport enum PhysicsUpdraftMode {\r\n    /** Defines that the upstream forces will pull towards the top center of the cylinder */\r\n    Center,\r\n    /** Defines that once a impostor is inside the cylinder, it will shoot out perpendicular from the ground of the cylinder */\r\n    Perpendicular,\r\n}\r\n\r\n/**\r\n * Interface for a physics hit data\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsHitData {\r\n    /**\r\n     * The force applied at the contact point\r\n     */\r\n    force: Vector3;\r\n    /**\r\n     * The contact point\r\n     */\r\n    contactPoint: Vector3;\r\n    /**\r\n     * The distance from the origin to the contact point\r\n     */\r\n    distanceFromOrigin: number;\r\n}\r\n\r\n/**\r\n * Interface for radial explosion event data\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsRadialExplosionEventData {\r\n    /**\r\n     * A sphere used for the radial explosion event\r\n     */\r\n    sphere: Mesh;\r\n}\r\n\r\n/**\r\n * Interface for gravitational field event data\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsGravitationalFieldEventData {\r\n    /**\r\n     * A sphere mesh used for the gravitational field event\r\n     */\r\n    sphere: Mesh;\r\n}\r\n\r\n/**\r\n * Interface for updraft event data\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsUpdraftEventData {\r\n    /**\r\n     * A cylinder used for the updraft event\r\n     */\r\n    cylinder: Mesh;\r\n}\r\n\r\n/**\r\n * Interface for vortex event data\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsVortexEventData {\r\n    /**\r\n     * A cylinder used for the vortex event\r\n     */\r\n    cylinder: Mesh;\r\n}\r\n\r\n/**\r\n * Interface for an affected physics impostor\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsAffectedImpostorWithData {\r\n    /**\r\n     * The impostor affected by the effect\r\n     */\r\n    impostor: PhysicsImpostor;\r\n\r\n    /**\r\n     * The data about the hit/force from the explosion\r\n     */\r\n    hitData: PhysicsHitData;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}