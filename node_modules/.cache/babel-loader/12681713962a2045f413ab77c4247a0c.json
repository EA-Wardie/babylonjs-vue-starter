{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { DeepCopier } from \"../../Misc/deepCopier.js\";\n/**\n * Particle emitter emitting particles from the inside of a sphere.\n * It emits the particles alongside the sphere radius. The emission direction might be randomized.\n */\n\nvar SphereParticleEmitter =\n/** @class */\nfunction () {\n  /**\n   * Creates a new instance SphereParticleEmitter\n   * @param radius the radius of the emission sphere (1 by default)\n   * @param radiusRange the range of the emission sphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)\n   * @param directionRandomizer defines how much to randomize the particle direction [0-1]\n   */\n  function SphereParticleEmitter(\n  /**\n   * The radius of the emission sphere.\n   */\n  radius,\n  /**\n   * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\n   */\n  radiusRange,\n  /**\n   * How much to randomize the particle direction [0-1].\n   */\n  directionRandomizer) {\n    if (radius === void 0) {\n      radius = 1;\n    }\n\n    if (radiusRange === void 0) {\n      radiusRange = 1;\n    }\n\n    if (directionRandomizer === void 0) {\n      directionRandomizer = 0;\n    }\n\n    this.radius = radius;\n    this.radiusRange = radiusRange;\n    this.directionRandomizer = directionRandomizer;\n  }\n  /**\n   * Called by the particle System when the direction is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param directionToUpdate is the direction vector to update with the result\n   * @param particle is the particle we are computed the direction for\n   * @param isLocal defines if the direction should be set in local space\n   */\n\n\n  SphereParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate, particle, isLocal) {\n    var direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();\n    var randX = Scalar.RandomRange(0, this.directionRandomizer);\n    var randY = Scalar.RandomRange(0, this.directionRandomizer);\n    var randZ = Scalar.RandomRange(0, this.directionRandomizer);\n    direction.x += randX;\n    direction.y += randY;\n    direction.z += randZ;\n    direction.normalize();\n\n    if (isLocal) {\n      directionToUpdate.copyFrom(direction);\n      return;\n    }\n\n    Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);\n  };\n  /**\n   * Called by the particle System when the position is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param positionToUpdate is the position vector to update with the result\n   * @param particle is the particle we are computed the position for\n   * @param isLocal defines if the position should be set in local space\n   */\n\n\n  SphereParticleEmitter.prototype.startPositionFunction = function (worldMatrix, positionToUpdate, particle, isLocal) {\n    var randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);\n    var v = Scalar.RandomRange(0, 1.0);\n    var phi = Scalar.RandomRange(0, 2 * Math.PI);\n    var theta = Math.acos(2 * v - 1);\n    var randX = randRadius * Math.cos(phi) * Math.sin(theta);\n    var randY = randRadius * Math.cos(theta);\n    var randZ = randRadius * Math.sin(phi) * Math.sin(theta);\n\n    if (isLocal) {\n      positionToUpdate.copyFromFloats(randX, randY, randZ);\n      return;\n    }\n\n    Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\n  };\n  /**\n   * Clones the current emitter and returns a copy of it\n   * @returns the new emitter\n   */\n\n\n  SphereParticleEmitter.prototype.clone = function () {\n    var newOne = new SphereParticleEmitter(this.radius, this.directionRandomizer);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  };\n  /**\n   * Called by the GPUParticleSystem to setup the update shader\n   * @param uboOrEffect defines the update shader\n   */\n\n\n  SphereParticleEmitter.prototype.applyToShader = function (uboOrEffect) {\n    uboOrEffect.setFloat(\"radius\", this.radius);\n    uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\n    uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\n  };\n  /**\n   * Creates the structure of the ubo for this particle emitter\n   * @param ubo ubo to create the structure for\n   */\n\n\n  SphereParticleEmitter.prototype.buildUniformLayout = function (ubo) {\n    ubo.addUniform(\"radius\", 1);\n    ubo.addUniform(\"radiusRange\", 1);\n    ubo.addUniform(\"directionRandomizer\", 1);\n  };\n  /**\n   * Returns a string to use to update the GPU particles update shader\n   * @returns a string containing the defines string\n   */\n\n\n  SphereParticleEmitter.prototype.getEffectDefines = function () {\n    return \"#define SPHEREEMITTER\";\n  };\n  /**\n   * Returns the string \"SphereParticleEmitter\"\n   * @returns a string containing the class name\n   */\n\n\n  SphereParticleEmitter.prototype.getClassName = function () {\n    return \"SphereParticleEmitter\";\n  };\n  /**\n   * Serializes the particle system to a JSON object.\n   * @returns the JSON object\n   */\n\n\n  SphereParticleEmitter.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.type = this.getClassName();\n    serializationObject.radius = this.radius;\n    serializationObject.radiusRange = this.radiusRange;\n    serializationObject.directionRandomizer = this.directionRandomizer;\n    return serializationObject;\n  };\n  /**\n   * Parse properties from a JSON object\n   * @param serializationObject defines the JSON object\n   */\n\n\n  SphereParticleEmitter.prototype.parse = function (serializationObject) {\n    this.radius = serializationObject.radius;\n    this.radiusRange = serializationObject.radiusRange;\n    this.directionRandomizer = serializationObject.directionRandomizer;\n  };\n\n  return SphereParticleEmitter;\n}();\n\nexport { SphereParticleEmitter };\n/**\n * Particle emitter emitting particles from the inside of a sphere.\n * It emits the particles randomly between two vectors.\n */\n\nvar SphereDirectedParticleEmitter =\n/** @class */\nfunction (_super) {\n  __extends(SphereDirectedParticleEmitter, _super);\n  /**\n   * Creates a new instance SphereDirectedParticleEmitter\n   * @param radius the radius of the emission sphere (1 by default)\n   * @param direction1 the min limit of the emission direction (up vector by default)\n   * @param direction2 the max limit of the emission direction (up vector by default)\n   */\n\n\n  function SphereDirectedParticleEmitter(radius,\n  /**\n   * The min limit of the emission direction.\n   */\n  direction1,\n  /**\n   * The max limit of the emission direction.\n   */\n  direction2) {\n    if (radius === void 0) {\n      radius = 1;\n    }\n\n    if (direction1 === void 0) {\n      direction1 = new Vector3(0, 1, 0);\n    }\n\n    if (direction2 === void 0) {\n      direction2 = new Vector3(0, 1, 0);\n    }\n\n    var _this = _super.call(this, radius) || this;\n\n    _this.direction1 = direction1;\n    _this.direction2 = direction2;\n    return _this;\n  }\n  /**\n   * Called by the particle System when the direction is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param directionToUpdate is the direction vector to update with the result\n   */\n\n\n  SphereDirectedParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate) {\n    var randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\n    var randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\n    var randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\n    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\n  };\n  /**\n   * Clones the current emitter and returns a copy of it\n   * @returns the new emitter\n   */\n\n\n  SphereDirectedParticleEmitter.prototype.clone = function () {\n    var newOne = new SphereDirectedParticleEmitter(this.radius, this.direction1, this.direction2);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  };\n  /**\n   * Called by the GPUParticleSystem to setup the update shader\n   * @param uboOrEffect defines the update shader\n   */\n\n\n  SphereDirectedParticleEmitter.prototype.applyToShader = function (uboOrEffect) {\n    uboOrEffect.setFloat(\"radius\", this.radius);\n    uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\n    uboOrEffect.setVector3(\"direction1\", this.direction1);\n    uboOrEffect.setVector3(\"direction2\", this.direction2);\n  };\n  /**\n   * Creates the structure of the ubo for this particle emitter\n   * @param ubo ubo to create the structure for\n   */\n\n\n  SphereDirectedParticleEmitter.prototype.buildUniformLayout = function (ubo) {\n    ubo.addUniform(\"radius\", 1);\n    ubo.addUniform(\"radiusRange\", 1);\n    ubo.addUniform(\"direction1\", 3);\n    ubo.addUniform(\"direction2\", 3);\n  };\n  /**\n   * Returns a string to use to update the GPU particles update shader\n   * @returns a string containing the defines string\n   */\n\n\n  SphereDirectedParticleEmitter.prototype.getEffectDefines = function () {\n    return \"#define SPHEREEMITTER\\n#define DIRECTEDSPHEREEMITTER\";\n  };\n  /**\n   * Returns the string \"SphereDirectedParticleEmitter\"\n   * @returns a string containing the class name\n   */\n\n\n  SphereDirectedParticleEmitter.prototype.getClassName = function () {\n    return \"SphereDirectedParticleEmitter\";\n  };\n  /**\n   * Serializes the particle system to a JSON object.\n   * @returns the JSON object\n   */\n\n\n  SphereDirectedParticleEmitter.prototype.serialize = function () {\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    serializationObject.direction1 = this.direction1.asArray();\n    serializationObject.direction2 = this.direction2.asArray();\n    return serializationObject;\n  };\n  /**\n   * Parse properties from a JSON object\n   * @param serializationObject defines the JSON object\n   */\n\n\n  SphereDirectedParticleEmitter.prototype.parse = function (serializationObject) {\n    _super.prototype.parse.call(this, serializationObject);\n\n    this.direction1.copyFrom(serializationObject.direction1);\n    this.direction2.copyFrom(serializationObject.direction2);\n  };\n\n  return SphereDirectedParticleEmitter;\n}(SphereParticleEmitter);\n\nexport { SphereDirectedParticleEmitter };","map":{"version":3,"mappings":";AACA,SAASA,OAAT,QAAwB,4BAAxB;AACA,SAASC,MAAT,QAAuB,4BAAvB;AAGA,SAASC,UAAT,QAA2B,0BAA3B;AAGA;;;;;AAIA;AAAA;AAAA;AACI;;;;;;AAMA;AACI;;;AAGOC,QAJX;AAKI;;;AAGOC,aARX;AASI;;;AAGOC,qBAZX,EAYkC;AARvB;AAAAF;AAAU;;AAIV;AAAAC;AAAe;;AAIf;AAAAC;AAAuB;;AARvB;AAIA;AAIA;AACP;AAEJ;;;;;;;;;AAOOC,2DAAP,UAA8BC,WAA9B,EAAmDC,iBAAnD,EAA+EC,QAA/E,EAAmGC,OAAnG,EAAmH;AAC/G,QAAMC,SAAS,GAAGF,QAAQ,CAACG,QAAT,CAAkBC,QAAlB,CAA2BN,WAAW,CAACO,cAAZ,EAA3B,EAAyDC,SAAzD,EAAlB;AACA,QAAMC,KAAK,GAAGf,MAAM,CAACgB,WAAP,CAAmB,CAAnB,EAAsB,KAAKZ,mBAA3B,CAAd;AACA,QAAMa,KAAK,GAAGjB,MAAM,CAACgB,WAAP,CAAmB,CAAnB,EAAsB,KAAKZ,mBAA3B,CAAd;AACA,QAAMc,KAAK,GAAGlB,MAAM,CAACgB,WAAP,CAAmB,CAAnB,EAAsB,KAAKZ,mBAA3B,CAAd;AACAM,aAAS,CAACS,CAAV,IAAeJ,KAAf;AACAL,aAAS,CAACU,CAAV,IAAeH,KAAf;AACAP,aAAS,CAACW,CAAV,IAAeH,KAAf;AACAR,aAAS,CAACI,SAAV;;AAEA,QAAIL,OAAJ,EAAa;AACTF,uBAAiB,CAACe,QAAlB,CAA2BZ,SAA3B;AACA;AACH;;AAEDX,WAAO,CAACwB,8BAAR,CAAuCb,SAAS,CAACS,CAAjD,EAAoDT,SAAS,CAACU,CAA9D,EAAiEV,SAAS,CAACW,CAA3E,EAA8Ef,WAA9E,EAA2FC,iBAA3F;AACH,GAhBM;AAkBP;;;;;;;;;AAOOF,0DAAP,UAA6BC,WAA7B,EAAkDkB,gBAAlD,EAA6EhB,QAA7E,EAAiGC,OAAjG,EAAiH;AAC7G,QAAMgB,UAAU,GAAG,KAAKvB,MAAL,GAAcF,MAAM,CAACgB,WAAP,CAAmB,CAAnB,EAAsB,KAAKd,MAAL,GAAc,KAAKC,WAAzC,CAAjC;AACA,QAAMuB,CAAC,GAAG1B,MAAM,CAACgB,WAAP,CAAmB,CAAnB,EAAsB,GAAtB,CAAV;AACA,QAAMW,GAAG,GAAG3B,MAAM,CAACgB,WAAP,CAAmB,CAAnB,EAAsB,IAAIY,IAAI,CAACC,EAA/B,CAAZ;AACA,QAAMC,KAAK,GAAGF,IAAI,CAACG,IAAL,CAAU,IAAIL,CAAJ,GAAQ,CAAlB,CAAd;AACA,QAAMX,KAAK,GAAGU,UAAU,GAAGG,IAAI,CAACI,GAAL,CAASL,GAAT,CAAb,GAA6BC,IAAI,CAACK,GAAL,CAASH,KAAT,CAA3C;AACA,QAAMb,KAAK,GAAGQ,UAAU,GAAGG,IAAI,CAACI,GAAL,CAASF,KAAT,CAA3B;AACA,QAAMZ,KAAK,GAAGO,UAAU,GAAGG,IAAI,CAACK,GAAL,CAASN,GAAT,CAAb,GAA6BC,IAAI,CAACK,GAAL,CAASH,KAAT,CAA3C;;AAEA,QAAIrB,OAAJ,EAAa;AACTe,sBAAgB,CAACU,cAAjB,CAAgCnB,KAAhC,EAAuCE,KAAvC,EAA8CC,KAA9C;AACA;AACH;;AAEDnB,WAAO,CAACoC,mCAAR,CAA4CpB,KAA5C,EAAmDE,KAAnD,EAA0DC,KAA1D,EAAiEZ,WAAjE,EAA8EkB,gBAA9E;AACH,GAfM;AAiBP;;;;;;AAIOnB,0CAAP;AACI,QAAM+B,MAAM,GAAG,IAAI/B,qBAAJ,CAA0B,KAAKH,MAA/B,EAAuC,KAAKE,mBAA5C,CAAf;AAEAH,cAAU,CAACoC,QAAX,CAAoB,IAApB,EAA0BD,MAA1B;AAEA,WAAOA,MAAP;AACH,GANM;AAQP;;;;;;AAIO/B,kDAAP,UAAqBiC,WAArB,EAAmE;AAC/DA,eAAW,CAACC,QAAZ,CAAqB,QAArB,EAA+B,KAAKrC,MAApC;AACAoC,eAAW,CAACC,QAAZ,CAAqB,aAArB,EAAoC,KAAKpC,WAAzC;AACAmC,eAAW,CAACC,QAAZ,CAAqB,qBAArB,EAA4C,KAAKnC,mBAAjD;AACH,GAJM;AAMP;;;;;;AAIOC,uDAAP,UAA0BmC,GAA1B,EAA4C;AACxCA,OAAG,CAACC,UAAJ,CAAe,QAAf,EAAyB,CAAzB;AACAD,OAAG,CAACC,UAAJ,CAAe,aAAf,EAA8B,CAA9B;AACAD,OAAG,CAACC,UAAJ,CAAe,qBAAf,EAAsC,CAAtC;AACH,GAJM;AAMP;;;;;;AAIOpC,qDAAP;AACI,WAAO,uBAAP;AACH,GAFM;AAIP;;;;;;AAIOA,iDAAP;AACI,WAAO,uBAAP;AACH,GAFM;AAIP;;;;;;AAIOA,8CAAP;AACI,QAAMqC,mBAAmB,GAAQ,EAAjC;AACAA,uBAAmB,CAACC,IAApB,GAA2B,KAAKC,YAAL,EAA3B;AACAF,uBAAmB,CAACxC,MAApB,GAA6B,KAAKA,MAAlC;AACAwC,uBAAmB,CAACvC,WAApB,GAAkC,KAAKA,WAAvC;AACAuC,uBAAmB,CAACtC,mBAApB,GAA0C,KAAKA,mBAA/C;AAEA,WAAOsC,mBAAP;AACH,GARM;AAUP;;;;;;AAIOrC,0CAAP,UAAaqC,mBAAb,EAAqC;AACjC,SAAKxC,MAAL,GAAcwC,mBAAmB,CAACxC,MAAlC;AACA,SAAKC,WAAL,GAAmBuC,mBAAmB,CAACvC,WAAvC;AACA,SAAKC,mBAAL,GAA2BsC,mBAAmB,CAACtC,mBAA/C;AACH,GAJM;;AAKX;AAAC,CA9ID;;;AAgJA;;;;;AAIA;AAAA;AAAA;AAAmDyC;AAC/C;;;;;;;;AAMA,yCACI3C,MADJ;AAEI;;;AAGO4C,YALX;AAMI;;;AAGOC,YATX,EAS4C;AARxC;AAAA7C;AAAU;;AAIH;AAAA4C,uBAAiB/C,OAAjB,CAAyB,CAAzB,EAA4B,CAA5B,EAA+B,CAA/B;AAAiC;;AAIjC;AAAAgD,uBAAiBhD,OAAjB,CAAyB,CAAzB,EAA4B,CAA5B,EAA+B,CAA/B;AAAiC;;AAT5C,gBAWIiD,kBAAM9C,MAAN,KAAa,IAXjB;;AAKW+C;AAIAA;;AAGV;AAED;;;;;;;AAKOC,mEAAP,UAA8B5C,WAA9B,EAAmDC,iBAAnD,EAA6E;AACzE,QAAMQ,KAAK,GAAGf,MAAM,CAACgB,WAAP,CAAmB,KAAK8B,UAAL,CAAgB3B,CAAnC,EAAsC,KAAK4B,UAAL,CAAgB5B,CAAtD,CAAd;AACA,QAAMF,KAAK,GAAGjB,MAAM,CAACgB,WAAP,CAAmB,KAAK8B,UAAL,CAAgB1B,CAAnC,EAAsC,KAAK2B,UAAL,CAAgB3B,CAAtD,CAAd;AACA,QAAMF,KAAK,GAAGlB,MAAM,CAACgB,WAAP,CAAmB,KAAK8B,UAAL,CAAgBzB,CAAnC,EAAsC,KAAK0B,UAAL,CAAgB1B,CAAtD,CAAd;AACAtB,WAAO,CAACwB,8BAAR,CAAuCR,KAAvC,EAA8CE,KAA9C,EAAqDC,KAArD,EAA4DZ,WAA5D,EAAyEC,iBAAzE;AACH,GALM;AAOP;;;;;;AAIO2C,kDAAP;AACI,QAAMd,MAAM,GAAG,IAAIc,6BAAJ,CAAkC,KAAKhD,MAAvC,EAA+C,KAAK4C,UAApD,EAAgE,KAAKC,UAArE,CAAf;AAEA9C,cAAU,CAACoC,QAAX,CAAoB,IAApB,EAA0BD,MAA1B;AAEA,WAAOA,MAAP;AACH,GANM;AAQP;;;;;;AAIOc,0DAAP,UAAqBZ,WAArB,EAAmE;AAC/DA,eAAW,CAACC,QAAZ,CAAqB,QAArB,EAA+B,KAAKrC,MAApC;AACAoC,eAAW,CAACC,QAAZ,CAAqB,aAArB,EAAoC,KAAKpC,WAAzC;AACAmC,eAAW,CAACa,UAAZ,CAAuB,YAAvB,EAAqC,KAAKL,UAA1C;AACAR,eAAW,CAACa,UAAZ,CAAuB,YAAvB,EAAqC,KAAKJ,UAA1C;AACH,GALM;AAOP;;;;;;AAIOG,+DAAP,UAA0BV,GAA1B,EAA4C;AACxCA,OAAG,CAACC,UAAJ,CAAe,QAAf,EAAyB,CAAzB;AACAD,OAAG,CAACC,UAAJ,CAAe,aAAf,EAA8B,CAA9B;AACAD,OAAG,CAACC,UAAJ,CAAe,YAAf,EAA6B,CAA7B;AACAD,OAAG,CAACC,UAAJ,CAAe,YAAf,EAA6B,CAA7B;AACH,GALM;AAOP;;;;;;AAIOS,6DAAP;AACI,WAAO,sDAAP;AACH,GAFM;AAIP;;;;;;AAIOA,yDAAP;AACI,WAAO,+BAAP;AACH,GAFM;AAIP;;;;;;AAIOA,sDAAP;AACI,QAAMR,mBAAmB,GAAGM,iBAAMI,SAAN,CAAeC,IAAf,CAAe,IAAf,CAA5B;;AAEAX,uBAAmB,CAACI,UAApB,GAAiC,KAAKA,UAAL,CAAgBQ,OAAhB,EAAjC;AACAZ,uBAAmB,CAACK,UAApB,GAAiC,KAAKA,UAAL,CAAgBO,OAAhB,EAAjC;AAEA,WAAOZ,mBAAP;AACH,GAPM;AASP;;;;;;AAIOQ,kDAAP,UAAaR,mBAAb,EAAqC;AACjCM,qBAAMO,KAAN,CAAWF,IAAX,CAAW,IAAX,EAAYX,mBAAZ;;AACA,SAAKI,UAAL,CAAgBxB,QAAhB,CAAyBoB,mBAAmB,CAACI,UAA7C;AACA,SAAKC,UAAL,CAAgBzB,QAAhB,CAAyBoB,mBAAmB,CAACK,UAA7C;AACH,GAJM;;AAKX;AAAC,CAzGD,CAAmD1C,qBAAnD","names":["Vector3","Scalar","DeepCopier","radius","radiusRange","directionRandomizer","SphereParticleEmitter","worldMatrix","directionToUpdate","particle","isLocal","direction","position","subtract","getTranslation","normalize","randX","RandomRange","randY","randZ","x","y","z","copyFrom","TransformNormalFromFloatsToRef","positionToUpdate","randRadius","v","phi","Math","PI","theta","acos","cos","sin","copyFromFloats","TransformCoordinatesFromFloatsToRef","newOne","DeepCopy","uboOrEffect","setFloat","ubo","addUniform","serializationObject","type","getClassName","__extends","direction1","direction2","_super","_this","SphereDirectedParticleEmitter","setVector3","serialize","call","asArray","parse"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Particles/EmitterTypes/sphereParticleEmitter.ts"],"sourcesContent":["import type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a sphere.\r\n * It emits the particles alongside the sphere radius. The emission direction might be randomized.\r\n */\r\nexport class SphereParticleEmitter implements IParticleEmitterType {\r\n    /**\r\n     * Creates a new instance SphereParticleEmitter\r\n     * @param radius the radius of the emission sphere (1 by default)\r\n     * @param radiusRange the range of the emission sphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n     * @param directionRandomizer defines how much to randomize the particle direction [0-1]\r\n     */\r\n    constructor(\r\n        /**\r\n         * The radius of the emission sphere.\r\n         */\r\n        public radius = 1,\r\n        /**\r\n         * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\r\n         */\r\n        public radiusRange = 1,\r\n        /**\r\n         * How much to randomize the particle direction [0-1].\r\n         */\r\n        public directionRandomizer = 0\r\n    ) {}\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();\r\n        const randX = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randY = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randZ = Scalar.RandomRange(0, this.directionRandomizer);\r\n        direction.x += randX;\r\n        direction.y += randY;\r\n        direction.z += randZ;\r\n        direction.normalize();\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFrom(direction);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);\r\n        const v = Scalar.RandomRange(0, 1.0);\r\n        const phi = Scalar.RandomRange(0, 2 * Math.PI);\r\n        const theta = Math.acos(2 * v - 1);\r\n        const randX = randRadius * Math.cos(phi) * Math.sin(theta);\r\n        const randY = randRadius * Math.cos(theta);\r\n        const randZ = randRadius * Math.sin(phi) * Math.sin(theta);\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.copyFromFloats(randX, randY, randZ);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): SphereParticleEmitter {\r\n        const newOne = new SphereParticleEmitter(this.radius, this.directionRandomizer);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat(\"radius\", this.radius);\r\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\r\n        uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 1);\r\n        ubo.addUniform(\"radiusRange\", 1);\r\n        ubo.addUniform(\"directionRandomizer\", 1);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define SPHEREEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"SphereParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"SphereParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.radius = this.radius;\r\n        serializationObject.radiusRange = this.radiusRange;\r\n        serializationObject.directionRandomizer = this.directionRandomizer;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        this.radius = serializationObject.radius;\r\n        this.radiusRange = serializationObject.radiusRange;\r\n        this.directionRandomizer = serializationObject.directionRandomizer;\r\n    }\r\n}\r\n\r\n/**\r\n * Particle emitter emitting particles from the inside of a sphere.\r\n * It emits the particles randomly between two vectors.\r\n */\r\nexport class SphereDirectedParticleEmitter extends SphereParticleEmitter {\r\n    /**\r\n     * Creates a new instance SphereDirectedParticleEmitter\r\n     * @param radius the radius of the emission sphere (1 by default)\r\n     * @param direction1 the min limit of the emission direction (up vector by default)\r\n     * @param direction2 the max limit of the emission direction (up vector by default)\r\n     */\r\n    constructor(\r\n        radius = 1,\r\n        /**\r\n         * The min limit of the emission direction.\r\n         */\r\n        public direction1 = new Vector3(0, 1, 0),\r\n        /**\r\n         * The max limit of the emission direction.\r\n         */\r\n        public direction2 = new Vector3(0, 1, 0)\r\n    ) {\r\n        super(radius);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3): void {\r\n        const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\r\n        const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\r\n        const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\r\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): SphereDirectedParticleEmitter {\r\n        const newOne = new SphereDirectedParticleEmitter(this.radius, this.direction1, this.direction2);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat(\"radius\", this.radius);\r\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\r\n        uboOrEffect.setVector3(\"direction1\", this.direction1);\r\n        uboOrEffect.setVector3(\"direction2\", this.direction2);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 1);\r\n        ubo.addUniform(\"radiusRange\", 1);\r\n        ubo.addUniform(\"direction1\", 3);\r\n        ubo.addUniform(\"direction2\", 3);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define SPHEREEMITTER\\n#define DIRECTEDSPHEREEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"SphereDirectedParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"SphereDirectedParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.direction1 = this.direction1.asArray();\r\n        serializationObject.direction2 = this.direction2.asArray();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        super.parse(serializationObject);\r\n        this.direction1.copyFrom(serializationObject.direction1);\r\n        this.direction2.copyFrom(serializationObject.direction2);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}