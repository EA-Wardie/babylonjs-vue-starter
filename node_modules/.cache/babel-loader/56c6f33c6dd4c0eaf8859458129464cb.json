{"ast":null,"code":"import \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { StartsWith } from \"../../Misc/stringTools.js\";\n/** @hidden */\n\nvar ShaderCodeNode =\n/** @class */\nfunction () {\n  function ShaderCodeNode() {\n    this.children = [];\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  ShaderCodeNode.prototype.isValid = function (preprocessors) {\n    return true;\n  };\n\n  ShaderCodeNode.prototype.process = function (preprocessors, options) {\n    var result = \"\";\n\n    if (this.line) {\n      var value = this.line;\n      var processor = options.processor;\n\n      if (processor) {\n        // This must be done before other replacements to avoid mistakenly changing something that was already changed.\n        if (processor.lineProcessor) {\n          value = processor.lineProcessor(value, options.isFragment, options.processingContext);\n        }\n\n        if (processor.attributeProcessor && StartsWith(this.line, \"attribute\")) {\n          value = processor.attributeProcessor(this.line, preprocessors, options.processingContext);\n        } else if (processor.varyingProcessor && StartsWith(this.line, \"varying\")) {\n          value = processor.varyingProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\n        } else if (processor.uniformProcessor && processor.uniformRegexp && processor.uniformRegexp.test(this.line)) {\n          if (!options.lookForClosingBracketForUniformBuffer) {\n            value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\n          }\n        } else if (processor.uniformBufferProcessor && processor.uniformBufferRegexp && processor.uniformBufferRegexp.test(this.line)) {\n          if (!options.lookForClosingBracketForUniformBuffer) {\n            value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);\n            options.lookForClosingBracketForUniformBuffer = true;\n          }\n        } else if (processor.textureProcessor && processor.textureRegexp && processor.textureRegexp.test(this.line)) {\n          value = processor.textureProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\n        } else if ((processor.uniformProcessor || processor.uniformBufferProcessor) && StartsWith(this.line, \"uniform\") && !options.lookForClosingBracketForUniformBuffer) {\n          var regex = /uniform\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/;\n\n          if (regex.test(this.line)) {\n            // uniform\n            if (processor.uniformProcessor) {\n              value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\n            }\n          } else {\n            // Uniform buffer\n            if (processor.uniformBufferProcessor) {\n              value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);\n              options.lookForClosingBracketForUniformBuffer = true;\n            }\n          }\n        }\n\n        if (options.lookForClosingBracketForUniformBuffer && this.line.indexOf(\"}\") !== -1) {\n          options.lookForClosingBracketForUniformBuffer = false;\n\n          if (processor.endOfUniformBufferProcessor) {\n            value = processor.endOfUniformBufferProcessor(this.line, options.isFragment, options.processingContext);\n          }\n        }\n      }\n\n      result += value + \"\\r\\n\";\n    }\n\n    this.children.forEach(function (child) {\n      result += child.process(preprocessors, options);\n    });\n\n    if (this.additionalDefineKey) {\n      preprocessors[this.additionalDefineKey] = this.additionalDefineValue || \"true\";\n    }\n\n    return result;\n  };\n\n  return ShaderCodeNode;\n}();\n\nexport { ShaderCodeNode };","map":{"version":3,"mappings":"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","names":["StartsWith","ShaderCodeNode","preprocessors","options","result","line","value","processor","lineProcessor","isFragment","processingContext","attributeProcessor","varyingProcessor","uniformProcessor","uniformRegexp","test","lookForClosingBracketForUniformBuffer","uniformBufferProcessor","uniformBufferRegexp","textureProcessor","textureRegexp","regex","indexOf","endOfUniformBufferProcessor","children","forEach","child","process","additionalDefineKey","additionalDefineValue"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Engines/Processors/shaderCodeNode.ts"],"sourcesContent":["import type { ProcessingOptions } from \"./shaderProcessingOptions\";\r\nimport { StartsWith } from \"../../Misc/stringTools\";\r\n\r\n/** @hidden */\r\nexport class ShaderCodeNode {\r\n    line: string;\r\n    children: ShaderCodeNode[] = [];\r\n    additionalDefineKey?: string;\r\n    additionalDefineValue?: string;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    isValid(preprocessors: { [key: string]: string }): boolean {\r\n        return true;\r\n    }\r\n\r\n    process(preprocessors: { [key: string]: string }, options: ProcessingOptions): string {\r\n        let result = \"\";\r\n        if (this.line) {\r\n            let value: string = this.line;\r\n            const processor = options.processor;\r\n            if (processor) {\r\n                // This must be done before other replacements to avoid mistakenly changing something that was already changed.\r\n                if (processor.lineProcessor) {\r\n                    value = processor.lineProcessor(value, options.isFragment, options.processingContext);\r\n                }\r\n\r\n                if (processor.attributeProcessor && StartsWith(this.line, \"attribute\")) {\r\n                    value = processor.attributeProcessor(this.line, preprocessors, options.processingContext);\r\n                } else if (processor.varyingProcessor && StartsWith(this.line, \"varying\")) {\r\n                    value = processor.varyingProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                } else if (processor.uniformProcessor && processor.uniformRegexp && processor.uniformRegexp.test(this.line)) {\r\n                    if (!options.lookForClosingBracketForUniformBuffer) {\r\n                        value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                    }\r\n                } else if (processor.uniformBufferProcessor && processor.uniformBufferRegexp && processor.uniformBufferRegexp.test(this.line)) {\r\n                    if (!options.lookForClosingBracketForUniformBuffer) {\r\n                        value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);\r\n                        options.lookForClosingBracketForUniformBuffer = true;\r\n                    }\r\n                } else if (processor.textureProcessor && processor.textureRegexp && processor.textureRegexp.test(this.line)) {\r\n                    value = processor.textureProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                } else if ((processor.uniformProcessor || processor.uniformBufferProcessor) && StartsWith(this.line, \"uniform\") && !options.lookForClosingBracketForUniformBuffer) {\r\n                    const regex = /uniform\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/;\r\n\r\n                    if (regex.test(this.line)) {\r\n                        // uniform\r\n                        if (processor.uniformProcessor) {\r\n                            value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                        }\r\n                    } else {\r\n                        // Uniform buffer\r\n                        if (processor.uniformBufferProcessor) {\r\n                            value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);\r\n                            options.lookForClosingBracketForUniformBuffer = true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (options.lookForClosingBracketForUniformBuffer && this.line.indexOf(\"}\") !== -1) {\r\n                    options.lookForClosingBracketForUniformBuffer = false;\r\n                    if (processor.endOfUniformBufferProcessor) {\r\n                        value = processor.endOfUniformBufferProcessor(this.line, options.isFragment, options.processingContext);\r\n                    }\r\n                }\r\n            }\r\n\r\n            result += value + \"\\r\\n\";\r\n        }\r\n\r\n        this.children.forEach((child) => {\r\n            result += child.process(preprocessors, options);\r\n        });\r\n\r\n        if (this.additionalDefineKey) {\r\n            preprocessors[this.additionalDefineKey] = this.additionalDefineValue || \"true\";\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}