{"ast":null,"code":"import \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport { Scene } from \"../scene.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Light } from \"../Lights/light.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { ThinMaterialHelper } from \"./thinMaterialHelper.js\";\n/**\n * \"Static Class\" containing the most commonly used helper while dealing with material for rendering purpose.\n *\n * It contains the basic tools to help defining defines, binding uniform for the common part of the materials.\n *\n * This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.\n */\n\nvar MaterialHelper =\n/** @class */\nfunction () {\n  function MaterialHelper() {}\n  /**\n   * Binds the scene's uniform buffer to the effect.\n   * @param effect defines the effect to bind to the scene uniform buffer\n   * @param sceneUbo defines the uniform buffer storing scene data\n   */\n\n\n  MaterialHelper.BindSceneUniformBuffer = function (effect, sceneUbo) {\n    sceneUbo.bindToEffect(effect, \"Scene\");\n  };\n  /**\n   * Helps preparing the defines values about the UVs in used in the effect.\n   * UVs are shared as much as we can across channels in the shaders.\n   * @param texture The texture we are preparing the UVs for\n   * @param defines The defines to update\n   * @param key The channel key \"diffuse\", \"specular\"... used in the shader\n   */\n\n\n  MaterialHelper.PrepareDefinesForMergedUV = function (texture, defines, key) {\n    defines._needUVs = true;\n    defines[key] = true;\n\n    if (texture.getTextureMatrix().isIdentityAs3x2()) {\n      defines[key + \"DIRECTUV\"] = texture.coordinatesIndex + 1;\n      defines[\"MAINUV\" + (texture.coordinatesIndex + 1)] = true;\n    } else {\n      defines[key + \"DIRECTUV\"] = 0;\n    }\n  };\n  /**\n   * Binds a texture matrix value to its corresponding uniform\n   * @param texture The texture to bind the matrix for\n   * @param uniformBuffer The uniform buffer receiving the data\n   * @param key The channel key \"diffuse\", \"specular\"... used in the shader\n   */\n\n\n  MaterialHelper.BindTextureMatrix = function (texture, uniformBuffer, key) {\n    var matrix = texture.getTextureMatrix();\n    uniformBuffer.updateMatrix(key + \"Matrix\", matrix);\n  };\n  /**\n   * Gets the current status of the fog (should it be enabled?)\n   * @param mesh defines the mesh to evaluate for fog support\n   * @param scene defines the hosting scene\n   * @returns true if fog must be enabled\n   */\n\n\n  MaterialHelper.GetFogState = function (mesh, scene) {\n    return scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE;\n  };\n  /**\n   * Helper used to prepare the list of defines associated with misc. values for shader compilation\n   * @param mesh defines the current mesh\n   * @param scene defines the current scene\n   * @param useLogarithmicDepth defines if logarithmic depth has to be turned on\n   * @param pointsCloud defines if point cloud rendering has to be turned on\n   * @param fogEnabled defines if fog has to be turned on\n   * @param alphaTest defines if alpha testing has to be turned on\n   * @param defines defines the current list of defines\n   */\n\n\n  MaterialHelper.PrepareDefinesForMisc = function (mesh, scene, useLogarithmicDepth, pointsCloud, fogEnabled, alphaTest, defines) {\n    if (defines._areMiscDirty) {\n      defines[\"LOGARITHMICDEPTH\"] = useLogarithmicDepth;\n      defines[\"POINTSIZE\"] = pointsCloud;\n      defines[\"FOG\"] = fogEnabled && this.GetFogState(mesh, scene);\n      defines[\"NONUNIFORMSCALING\"] = mesh.nonUniformScaling;\n      defines[\"ALPHATEST\"] = alphaTest;\n    }\n  };\n  /**\n   * Helper used to prepare the list of defines associated with frame values for shader compilation\n   * @param scene defines the current scene\n   * @param engine defines the current engine\n   * @param defines specifies the list of active defines\n   * @param useInstances defines if instances have to be turned on\n   * @param useClipPlane defines if clip plane have to be turned on\n   * @param useThinInstances defines if thin instances have to be turned on\n   */\n\n\n  MaterialHelper.PrepareDefinesForFrameBoundValues = function (scene, engine, defines, useInstances, useClipPlane, useThinInstances) {\n    if (useClipPlane === void 0) {\n      useClipPlane = null;\n    }\n\n    if (useThinInstances === void 0) {\n      useThinInstances = false;\n    }\n\n    var changed = false;\n    var useClipPlane1 = false;\n    var useClipPlane2 = false;\n    var useClipPlane3 = false;\n    var useClipPlane4 = false;\n    var useClipPlane5 = false;\n    var useClipPlane6 = false;\n    useClipPlane1 = useClipPlane == null ? scene.clipPlane !== undefined && scene.clipPlane !== null : useClipPlane;\n    useClipPlane2 = useClipPlane == null ? scene.clipPlane2 !== undefined && scene.clipPlane2 !== null : useClipPlane;\n    useClipPlane3 = useClipPlane == null ? scene.clipPlane3 !== undefined && scene.clipPlane3 !== null : useClipPlane;\n    useClipPlane4 = useClipPlane == null ? scene.clipPlane4 !== undefined && scene.clipPlane4 !== null : useClipPlane;\n    useClipPlane5 = useClipPlane == null ? scene.clipPlane5 !== undefined && scene.clipPlane5 !== null : useClipPlane;\n    useClipPlane6 = useClipPlane == null ? scene.clipPlane6 !== undefined && scene.clipPlane6 !== null : useClipPlane;\n\n    if (defines[\"CLIPPLANE\"] !== useClipPlane1) {\n      defines[\"CLIPPLANE\"] = useClipPlane1;\n      changed = true;\n    }\n\n    if (defines[\"CLIPPLANE2\"] !== useClipPlane2) {\n      defines[\"CLIPPLANE2\"] = useClipPlane2;\n      changed = true;\n    }\n\n    if (defines[\"CLIPPLANE3\"] !== useClipPlane3) {\n      defines[\"CLIPPLANE3\"] = useClipPlane3;\n      changed = true;\n    }\n\n    if (defines[\"CLIPPLANE4\"] !== useClipPlane4) {\n      defines[\"CLIPPLANE4\"] = useClipPlane4;\n      changed = true;\n    }\n\n    if (defines[\"CLIPPLANE5\"] !== useClipPlane5) {\n      defines[\"CLIPPLANE5\"] = useClipPlane5;\n      changed = true;\n    }\n\n    if (defines[\"CLIPPLANE6\"] !== useClipPlane6) {\n      defines[\"CLIPPLANE6\"] = useClipPlane6;\n      changed = true;\n    }\n\n    if (defines[\"DEPTHPREPASS\"] !== !engine.getColorWrite()) {\n      defines[\"DEPTHPREPASS\"] = !defines[\"DEPTHPREPASS\"];\n      changed = true;\n    }\n\n    if (defines[\"INSTANCES\"] !== useInstances) {\n      defines[\"INSTANCES\"] = useInstances;\n      changed = true;\n    } // ensure defines.INSTANCESCOLOR is not out of sync with instances\n\n\n    if (defines[\"INSTANCESCOLOR\"] && !defines[\"INSTANCES\"]) {\n      defines[\"INSTANCESCOLOR\"] = false;\n      changed = true;\n    }\n\n    if (defines[\"THIN_INSTANCES\"] !== useThinInstances) {\n      defines[\"THIN_INSTANCES\"] = useThinInstances;\n      changed = true;\n    }\n\n    if (changed) {\n      defines.markAsUnprocessed();\n    }\n  };\n  /**\n   * Prepares the defines for bones\n   * @param mesh The mesh containing the geometry data we will draw\n   * @param defines The defines to update\n   */\n\n\n  MaterialHelper.PrepareDefinesForBones = function (mesh, defines) {\n    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n      defines[\"NUM_BONE_INFLUENCERS\"] = mesh.numBoneInfluencers;\n      var materialSupportsBoneTexture = defines[\"BONETEXTURE\"] !== undefined;\n\n      if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {\n        defines[\"BONETEXTURE\"] = true;\n      } else {\n        defines[\"BonesPerMesh\"] = mesh.skeleton.bones.length + 1;\n        defines[\"BONETEXTURE\"] = materialSupportsBoneTexture ? false : undefined;\n        var prePassRenderer = mesh.getScene().prePassRenderer;\n\n        if (prePassRenderer && prePassRenderer.enabled) {\n          var nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;\n          defines[\"BONES_VELOCITY_ENABLED\"] = nonExcluded;\n        }\n      }\n    } else {\n      defines[\"NUM_BONE_INFLUENCERS\"] = 0;\n      defines[\"BonesPerMesh\"] = 0;\n    }\n  };\n  /**\n   * Prepares the defines for morph targets\n   * @param mesh The mesh containing the geometry data we will draw\n   * @param defines The defines to update\n   */\n\n\n  MaterialHelper.PrepareDefinesForMorphTargets = function (mesh, defines) {\n    var manager = mesh.morphTargetManager;\n\n    if (manager) {\n      defines[\"MORPHTARGETS_UV\"] = manager.supportsUVs && defines[\"UV1\"];\n      defines[\"MORPHTARGETS_TANGENT\"] = manager.supportsTangents && defines[\"TANGENT\"];\n      defines[\"MORPHTARGETS_NORMAL\"] = manager.supportsNormals && defines[\"NORMAL\"];\n      defines[\"MORPHTARGETS\"] = manager.numInfluencers > 0;\n      defines[\"NUM_MORPH_INFLUENCERS\"] = manager.numInfluencers;\n      defines[\"MORPHTARGETS_TEXTURE\"] = manager.isUsingTextureForTargets;\n    } else {\n      defines[\"MORPHTARGETS_UV\"] = false;\n      defines[\"MORPHTARGETS_TANGENT\"] = false;\n      defines[\"MORPHTARGETS_NORMAL\"] = false;\n      defines[\"MORPHTARGETS\"] = false;\n      defines[\"NUM_MORPH_INFLUENCERS\"] = 0;\n    }\n  };\n  /**\n   * Prepares the defines for baked vertex animation\n   * @param mesh The mesh containing the geometry data we will draw\n   * @param defines The defines to update\n   */\n\n\n  MaterialHelper.PrepareDefinesForBakedVertexAnimation = function (mesh, defines) {\n    var manager = mesh.bakedVertexAnimationManager;\n    defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] = manager && manager.isEnabled ? true : false;\n  };\n  /**\n   * Prepares the defines used in the shader depending on the attributes data available in the mesh\n   * @param mesh The mesh containing the geometry data we will draw\n   * @param defines The defines to update\n   * @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)\n   * @param useBones Precise whether bones should be used or not (override mesh info)\n   * @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)\n   * @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)\n   * @param useBakedVertexAnimation Precise whether baked vertex animation should be used or not (override mesh info)\n   * @returns false if defines are considered not dirty and have not been checked\n   */\n\n\n  MaterialHelper.PrepareDefinesForAttributes = function (mesh, defines, useVertexColor, useBones, useMorphTargets, useVertexAlpha, useBakedVertexAnimation) {\n    if (useMorphTargets === void 0) {\n      useMorphTargets = false;\n    }\n\n    if (useVertexAlpha === void 0) {\n      useVertexAlpha = true;\n    }\n\n    if (useBakedVertexAnimation === void 0) {\n      useBakedVertexAnimation = true;\n    }\n\n    if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {\n      return false;\n    }\n\n    defines._normals = defines._needNormals;\n    defines._uvs = defines._needUVs;\n    defines[\"NORMAL\"] = defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.NormalKind);\n\n    if (defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n      defines[\"TANGENT\"] = true;\n    }\n\n    for (var i = 1; i <= 6; ++i) {\n      defines[\"UV\" + i] = defines._needUVs ? mesh.isVerticesDataPresent(\"uv\".concat(i === 1 ? \"\" : i)) : false;\n    }\n\n    if (useVertexColor) {\n      var hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);\n      defines[\"VERTEXCOLOR\"] = hasVertexColors;\n      defines[\"VERTEXALPHA\"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;\n    }\n\n    if (mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind)) {\n      defines[\"INSTANCESCOLOR\"] = true;\n    }\n\n    if (useBones) {\n      this.PrepareDefinesForBones(mesh, defines);\n    }\n\n    if (useMorphTargets) {\n      this.PrepareDefinesForMorphTargets(mesh, defines);\n    }\n\n    if (useBakedVertexAnimation) {\n      this.PrepareDefinesForBakedVertexAnimation(mesh, defines);\n    }\n\n    return true;\n  };\n  /**\n   * Prepares the defines related to multiview\n   * @param scene The scene we are intending to draw\n   * @param defines The defines to update\n   */\n\n\n  MaterialHelper.PrepareDefinesForMultiview = function (scene, defines) {\n    if (scene.activeCamera) {\n      var previousMultiview = defines.MULTIVIEW;\n      defines.MULTIVIEW = scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1;\n\n      if (defines.MULTIVIEW != previousMultiview) {\n        defines.markAsUnprocessed();\n      }\n    }\n  };\n  /**\n   * Prepares the defines related to order independant transparency\n   * @param scene The scene we are intending to draw\n   * @param defines The defines to update\n   * @param needAlphaBlending Determines if the material needs alpha blending\n   */\n\n\n  MaterialHelper.PrepareDefinesForOIT = function (scene, defines, needAlphaBlending) {\n    var previousDefine = defines.ORDER_INDEPENDENT_TRANSPARENCY;\n    var previousDefine16Bits = defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;\n    defines.ORDER_INDEPENDENT_TRANSPARENCY = scene.useOrderIndependentTransparency && needAlphaBlending;\n    defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !scene.getEngine().getCaps().textureFloatLinearFiltering;\n\n    if (previousDefine !== defines.ORDER_INDEPENDENT_TRANSPARENCY || previousDefine16Bits !== defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) {\n      defines.markAsUnprocessed();\n    }\n  };\n  /**\n   * Prepares the defines related to the prepass\n   * @param scene The scene we are intending to draw\n   * @param defines The defines to update\n   * @param canRenderToMRT Indicates if this material renders to several textures in the prepass\n   */\n\n\n  MaterialHelper.PrepareDefinesForPrePass = function (scene, defines, canRenderToMRT) {\n    var previousPrePass = defines.PREPASS;\n\n    if (!defines._arePrePassDirty) {\n      return;\n    }\n\n    var texturesList = [{\n      type: 1,\n      define: \"PREPASS_POSITION\",\n      index: \"PREPASS_POSITION_INDEX\"\n    }, {\n      type: 2,\n      define: \"PREPASS_VELOCITY\",\n      index: \"PREPASS_VELOCITY_INDEX\"\n    }, {\n      type: 3,\n      define: \"PREPASS_REFLECTIVITY\",\n      index: \"PREPASS_REFLECTIVITY_INDEX\"\n    }, {\n      type: 0,\n      define: \"PREPASS_IRRADIANCE\",\n      index: \"PREPASS_IRRADIANCE_INDEX\"\n    }, {\n      type: 7,\n      define: \"PREPASS_ALBEDO_SQRT\",\n      index: \"PREPASS_ALBEDO_SQRT_INDEX\"\n    }, {\n      type: 5,\n      define: \"PREPASS_DEPTH\",\n      index: \"PREPASS_DEPTH_INDEX\"\n    }, {\n      type: 6,\n      define: \"PREPASS_NORMAL\",\n      index: \"PREPASS_NORMAL_INDEX\"\n    }];\n\n    if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {\n      defines.PREPASS = true;\n      defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;\n\n      for (var i = 0; i < texturesList.length; i++) {\n        var index = scene.prePassRenderer.getIndex(texturesList[i].type);\n\n        if (index !== -1) {\n          defines[texturesList[i].define] = true;\n          defines[texturesList[i].index] = index;\n        } else {\n          defines[texturesList[i].define] = false;\n        }\n      }\n    } else {\n      defines.PREPASS = false;\n\n      for (var i = 0; i < texturesList.length; i++) {\n        defines[texturesList[i].define] = false;\n      }\n    }\n\n    if (defines.PREPASS != previousPrePass) {\n      defines.markAsUnprocessed();\n      defines.markAsImageProcessingDirty();\n    }\n  };\n  /**\n   * Prepares the defines related to the light information passed in parameter\n   * @param scene The scene we are intending to draw\n   * @param mesh The mesh the effect is compiling for\n   * @param light The light the effect is compiling for\n   * @param lightIndex The index of the light\n   * @param defines The defines to update\n   * @param specularSupported Specifies whether specular is supported or not (override lights data)\n   * @param state Defines the current state regarding what is needed (normals, etc...)\n   * @param state.needNormals\n   * @param state.needRebuild\n   * @param state.shadowEnabled\n   * @param state.specularEnabled\n   * @param state.lightmapMode\n   */\n\n\n  MaterialHelper.PrepareDefinesForLight = function (scene, mesh, light, lightIndex, defines, specularSupported, state) {\n    state.needNormals = true;\n\n    if (defines[\"LIGHT\" + lightIndex] === undefined) {\n      state.needRebuild = true;\n    }\n\n    defines[\"LIGHT\" + lightIndex] = true;\n    defines[\"SPOTLIGHT\" + lightIndex] = false;\n    defines[\"HEMILIGHT\" + lightIndex] = false;\n    defines[\"POINTLIGHT\" + lightIndex] = false;\n    defines[\"DIRLIGHT\" + lightIndex] = false;\n    light.prepareLightSpecificDefines(defines, lightIndex); // FallOff.\n\n    defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = false;\n    defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = false;\n    defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = false;\n\n    switch (light.falloffType) {\n      case Light.FALLOFF_GLTF:\n        defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = true;\n        break;\n\n      case Light.FALLOFF_PHYSICAL:\n        defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = true;\n        break;\n\n      case Light.FALLOFF_STANDARD:\n        defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = true;\n        break;\n    } // Specular\n\n\n    if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {\n      state.specularEnabled = true;\n    } // Shadows\n\n\n    defines[\"SHADOW\" + lightIndex] = false;\n    defines[\"SHADOWCSM\" + lightIndex] = false;\n    defines[\"SHADOWCSMDEBUG\" + lightIndex] = false;\n    defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = false;\n    defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = false;\n    defines[\"SHADOWCSMNOBLEND\" + lightIndex] = false;\n    defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = false;\n    defines[\"SHADOWPCF\" + lightIndex] = false;\n    defines[\"SHADOWPCSS\" + lightIndex] = false;\n    defines[\"SHADOWPOISSON\" + lightIndex] = false;\n    defines[\"SHADOWESM\" + lightIndex] = false;\n    defines[\"SHADOWCLOSEESM\" + lightIndex] = false;\n    defines[\"SHADOWCUBE\" + lightIndex] = false;\n    defines[\"SHADOWLOWQUALITY\" + lightIndex] = false;\n    defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = false;\n\n    if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {\n      var shadowGenerator = light.getShadowGenerator();\n\n      if (shadowGenerator) {\n        var shadowMap = shadowGenerator.getShadowMap();\n\n        if (shadowMap) {\n          if (shadowMap.renderList && shadowMap.renderList.length > 0) {\n            state.shadowEnabled = true;\n            shadowGenerator.prepareDefines(defines, lightIndex);\n          }\n        }\n      }\n    }\n\n    if (light.lightmapMode != Light.LIGHTMAP_DEFAULT) {\n      state.lightmapMode = true;\n      defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = true;\n      defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = light.lightmapMode == Light.LIGHTMAP_SHADOWSONLY;\n    } else {\n      defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = false;\n      defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = false;\n    }\n  };\n  /**\n   * Prepares the defines related to the light information passed in parameter\n   * @param scene The scene we are intending to draw\n   * @param mesh The mesh the effect is compiling for\n   * @param defines The defines to update\n   * @param specularSupported Specifies whether specular is supported or not (override lights data)\n   * @param maxSimultaneousLights Specifies how manuy lights can be added to the effect at max\n   * @param disableLighting Specifies whether the lighting is disabled (override scene and light)\n   * @returns true if normals will be required for the rest of the effect\n   */\n\n\n  MaterialHelper.PrepareDefinesForLights = function (scene, mesh, defines, specularSupported, maxSimultaneousLights, disableLighting) {\n    if (maxSimultaneousLights === void 0) {\n      maxSimultaneousLights = 4;\n    }\n\n    if (disableLighting === void 0) {\n      disableLighting = false;\n    }\n\n    if (!defines._areLightsDirty) {\n      return defines._needNormals;\n    }\n\n    var lightIndex = 0;\n    var state = {\n      needNormals: false,\n      needRebuild: false,\n      lightmapMode: false,\n      shadowEnabled: false,\n      specularEnabled: false\n    };\n\n    if (scene.lightsEnabled && !disableLighting) {\n      for (var _i = 0, _a = mesh.lightSources; _i < _a.length; _i++) {\n        var light = _a[_i];\n        this.PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);\n        lightIndex++;\n\n        if (lightIndex === maxSimultaneousLights) {\n          break;\n        }\n      }\n    }\n\n    defines[\"SPECULARTERM\"] = state.specularEnabled;\n    defines[\"SHADOWS\"] = state.shadowEnabled; // Resetting all other lights if any\n\n    for (var index = lightIndex; index < maxSimultaneousLights; index++) {\n      if (defines[\"LIGHT\" + index] !== undefined) {\n        defines[\"LIGHT\" + index] = false;\n        defines[\"HEMILIGHT\" + index] = false;\n        defines[\"POINTLIGHT\" + index] = false;\n        defines[\"DIRLIGHT\" + index] = false;\n        defines[\"SPOTLIGHT\" + index] = false;\n        defines[\"SHADOW\" + index] = false;\n        defines[\"SHADOWCSM\" + index] = false;\n        defines[\"SHADOWCSMDEBUG\" + index] = false;\n        defines[\"SHADOWCSMNUM_CASCADES\" + index] = false;\n        defines[\"SHADOWCSMUSESHADOWMAXZ\" + index] = false;\n        defines[\"SHADOWCSMNOBLEND\" + index] = false;\n        defines[\"SHADOWCSM_RIGHTHANDED\" + index] = false;\n        defines[\"SHADOWPCF\" + index] = false;\n        defines[\"SHADOWPCSS\" + index] = false;\n        defines[\"SHADOWPOISSON\" + index] = false;\n        defines[\"SHADOWESM\" + index] = false;\n        defines[\"SHADOWCLOSEESM\" + index] = false;\n        defines[\"SHADOWCUBE\" + index] = false;\n        defines[\"SHADOWLOWQUALITY\" + index] = false;\n        defines[\"SHADOWMEDIUMQUALITY\" + index] = false;\n      }\n    }\n\n    var caps = scene.getEngine().getCaps();\n\n    if (defines[\"SHADOWFLOAT\"] === undefined) {\n      state.needRebuild = true;\n    }\n\n    defines[\"SHADOWFLOAT\"] = state.shadowEnabled && (caps.textureFloatRender && caps.textureFloatLinearFiltering || caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering);\n    defines[\"LIGHTMAPEXCLUDED\"] = state.lightmapMode;\n\n    if (state.needRebuild) {\n      defines.rebuild();\n    }\n\n    return state.needNormals;\n  };\n  /**\n   * Prepares the uniforms and samplers list to be used in the effect (for a specific light)\n   * @param lightIndex defines the light index\n   * @param uniformsList The uniform list\n   * @param samplersList The sampler list\n   * @param projectedLightTexture defines if projected texture must be used\n   * @param uniformBuffersList defines an optional list of uniform buffers\n   * @param updateOnlyBuffersList True to only update the uniformBuffersList array\n   */\n\n\n  MaterialHelper.PrepareUniformsAndSamplersForLight = function (lightIndex, uniformsList, samplersList, projectedLightTexture, uniformBuffersList, updateOnlyBuffersList) {\n    if (uniformBuffersList === void 0) {\n      uniformBuffersList = null;\n    }\n\n    if (updateOnlyBuffersList === void 0) {\n      updateOnlyBuffersList = false;\n    }\n\n    if (uniformBuffersList) {\n      uniformBuffersList.push(\"Light\" + lightIndex);\n    }\n\n    if (updateOnlyBuffersList) {\n      return;\n    }\n\n    uniformsList.push(\"vLightData\" + lightIndex, \"vLightDiffuse\" + lightIndex, \"vLightSpecular\" + lightIndex, \"vLightDirection\" + lightIndex, \"vLightFalloff\" + lightIndex, \"vLightGround\" + lightIndex, \"lightMatrix\" + lightIndex, \"shadowsInfo\" + lightIndex, \"depthValues\" + lightIndex);\n    samplersList.push(\"shadowSampler\" + lightIndex);\n    samplersList.push(\"depthSampler\" + lightIndex);\n    uniformsList.push(\"viewFrustumZ\" + lightIndex, \"cascadeBlendFactor\" + lightIndex, \"lightSizeUVCorrection\" + lightIndex, \"depthCorrection\" + lightIndex, \"penumbraDarkness\" + lightIndex, \"frustumLengths\" + lightIndex);\n\n    if (projectedLightTexture) {\n      samplersList.push(\"projectionLightSampler\" + lightIndex);\n      uniformsList.push(\"textureProjectionMatrix\" + lightIndex);\n    }\n  };\n  /**\n   * Prepares the uniforms and samplers list to be used in the effect\n   * @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the list and extra information\n   * @param samplersList The sampler list\n   * @param defines The defines helping in the list generation\n   * @param maxSimultaneousLights The maximum number of simultaneous light allowed in the effect\n   */\n\n\n  MaterialHelper.PrepareUniformsAndSamplersList = function (uniformsListOrOptions, samplersList, defines, maxSimultaneousLights) {\n    if (maxSimultaneousLights === void 0) {\n      maxSimultaneousLights = 4;\n    }\n\n    var uniformsList;\n    var uniformBuffersList = null;\n\n    if (uniformsListOrOptions.uniformsNames) {\n      var options = uniformsListOrOptions;\n      uniformsList = options.uniformsNames;\n      uniformBuffersList = options.uniformBuffersNames;\n      samplersList = options.samplers;\n      defines = options.defines;\n      maxSimultaneousLights = options.maxSimultaneousLights || 0;\n    } else {\n      uniformsList = uniformsListOrOptions;\n\n      if (!samplersList) {\n        samplersList = [];\n      }\n    }\n\n    for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\n      if (!defines[\"LIGHT\" + lightIndex]) {\n        break;\n      }\n\n      this.PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffersList);\n    }\n\n    if (defines[\"NUM_MORPH_INFLUENCERS\"]) {\n      uniformsList.push(\"morphTargetInfluences\");\n    }\n\n    if (defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"]) {\n      uniformsList.push(\"bakedVertexAnimationSettings\");\n      uniformsList.push(\"bakedVertexAnimationTextureSizeInverted\");\n      uniformsList.push(\"bakedVertexAnimationTime\");\n      samplersList.push(\"bakedVertexAnimationTexture\");\n    }\n  };\n  /**\n   * This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)\n   * @param defines The defines to update while falling back\n   * @param fallbacks The authorized effect fallbacks\n   * @param maxSimultaneousLights The maximum number of lights allowed\n   * @param rank the current rank of the Effect\n   * @returns The newly affected rank\n   */\n\n\n  MaterialHelper.HandleFallbacksForShadows = function (defines, fallbacks, maxSimultaneousLights, rank) {\n    if (maxSimultaneousLights === void 0) {\n      maxSimultaneousLights = 4;\n    }\n\n    if (rank === void 0) {\n      rank = 0;\n    }\n\n    var lightFallbackRank = 0;\n\n    for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\n      if (!defines[\"LIGHT\" + lightIndex]) {\n        break;\n      }\n\n      if (lightIndex > 0) {\n        lightFallbackRank = rank + lightIndex;\n        fallbacks.addFallback(lightFallbackRank, \"LIGHT\" + lightIndex);\n      }\n\n      if (!defines[\"SHADOWS\"]) {\n        if (defines[\"SHADOW\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOW\" + lightIndex);\n        }\n\n        if (defines[\"SHADOWPCF\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWPCF\" + lightIndex);\n        }\n\n        if (defines[\"SHADOWPCSS\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWPCSS\" + lightIndex);\n        }\n\n        if (defines[\"SHADOWPOISSON\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWPOISSON\" + lightIndex);\n        }\n\n        if (defines[\"SHADOWESM\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWESM\" + lightIndex);\n        }\n\n        if (defines[\"SHADOWCLOSEESM\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWCLOSEESM\" + lightIndex);\n        }\n      }\n    }\n\n    return lightFallbackRank++;\n  };\n  /**\n   * Prepares the list of attributes required for morph targets according to the effect defines.\n   * @param attribs The current list of supported attribs\n   * @param mesh The mesh to prepare the morph targets attributes for\n   * @param influencers The number of influencers\n   */\n\n\n  MaterialHelper.PrepareAttributesForMorphTargetsInfluencers = function (attribs, mesh, influencers) {\n    this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;\n    this.PrepareAttributesForMorphTargets(attribs, mesh, this._TmpMorphInfluencers);\n  };\n  /**\n   * Prepares the list of attributes required for morph targets according to the effect defines.\n   * @param attribs The current list of supported attribs\n   * @param mesh The mesh to prepare the morph targets attributes for\n   * @param defines The current Defines of the effect\n   */\n\n\n  MaterialHelper.PrepareAttributesForMorphTargets = function (attribs, mesh, defines) {\n    var influencers = defines[\"NUM_MORPH_INFLUENCERS\"];\n\n    if (influencers > 0 && EngineStore.LastCreatedEngine) {\n      var maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;\n      var manager = mesh.morphTargetManager;\n\n      if (manager === null || manager === void 0 ? void 0 : manager.isUsingTextureForTargets) {\n        return;\n      }\n\n      var normal = manager && manager.supportsNormals && defines[\"NORMAL\"];\n      var tangent = manager && manager.supportsTangents && defines[\"TANGENT\"];\n      var uv = manager && manager.supportsUVs && defines[\"UV1\"];\n\n      for (var index = 0; index < influencers; index++) {\n        attribs.push(VertexBuffer.PositionKind + index);\n\n        if (normal) {\n          attribs.push(VertexBuffer.NormalKind + index);\n        }\n\n        if (tangent) {\n          attribs.push(VertexBuffer.TangentKind + index);\n        }\n\n        if (uv) {\n          attribs.push(VertexBuffer.UVKind + \"_\" + index);\n        }\n\n        if (attribs.length > maxAttributesCount) {\n          Logger.Error(\"Cannot add more vertex attributes for mesh \" + mesh.name);\n        }\n      }\n    }\n  };\n  /**\n   * Prepares the list of attributes required for baked vertex animations according to the effect defines.\n   * @param attribs The current list of supported attribs\n   * @param mesh The mesh to prepare the morph targets attributes for\n   * @param defines The current Defines of the effect\n   */\n\n\n  MaterialHelper.PrepareAttributesForBakedVertexAnimation = function (attribs, mesh, defines) {\n    var enabled = defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] && defines[\"INSTANCES\"];\n\n    if (enabled) {\n      attribs.push(\"bakedVertexAnimationSettingsInstanced\");\n    }\n  };\n  /**\n   * Prepares the list of attributes required for bones according to the effect defines.\n   * @param attribs The current list of supported attribs\n   * @param mesh The mesh to prepare the bones attributes for\n   * @param defines The current Defines of the effect\n   * @param fallbacks The current effect fallback strategy\n   */\n\n\n  MaterialHelper.PrepareAttributesForBones = function (attribs, mesh, defines, fallbacks) {\n    if (defines[\"NUM_BONE_INFLUENCERS\"] > 0) {\n      fallbacks.addCPUSkinningFallback(0, mesh);\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n\n      if (defines[\"NUM_BONE_INFLUENCERS\"] > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n    }\n  };\n  /**\n   * Check and prepare the list of attributes required for instances according to the effect defines.\n   * @param attribs The current list of supported attribs\n   * @param defines The current MaterialDefines of the effect\n   */\n\n\n  MaterialHelper.PrepareAttributesForInstances = function (attribs, defines) {\n    if (defines[\"INSTANCES\"] || defines[\"THIN_INSTANCES\"]) {\n      this.PushAttributesForInstances(attribs, !!defines[\"PREPASS_VELOCITY\"]);\n    }\n  };\n  /**\n   * Add the list of attributes required for instances to the attribs array.\n   * @param attribs The current list of supported attribs\n   * @param needsPreviousMatrices If the shader needs previous matrices\n   */\n\n\n  MaterialHelper.PushAttributesForInstances = function (attribs, needsPreviousMatrices) {\n    if (needsPreviousMatrices === void 0) {\n      needsPreviousMatrices = false;\n    }\n\n    attribs.push(\"world0\");\n    attribs.push(\"world1\");\n    attribs.push(\"world2\");\n    attribs.push(\"world3\");\n\n    if (needsPreviousMatrices) {\n      attribs.push(\"previousWorld0\");\n      attribs.push(\"previousWorld1\");\n      attribs.push(\"previousWorld2\");\n      attribs.push(\"previousWorld3\");\n    }\n  };\n  /**\n   * Binds the light information to the effect.\n   * @param light The light containing the generator\n   * @param effect The effect we are binding the data to\n   * @param lightIndex The light index in the effect used to render\n   */\n\n\n  MaterialHelper.BindLightProperties = function (light, effect, lightIndex) {\n    light.transferToEffect(effect, lightIndex + \"\");\n  };\n  /**\n   * Binds the lights information from the scene to the effect for the given mesh.\n   * @param light Light to bind\n   * @param lightIndex Light index\n   * @param scene The scene where the light belongs to\n   * @param effect The effect we are binding the data to\n   * @param useSpecular Defines if specular is supported\n   * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\n   */\n\n\n  MaterialHelper.BindLight = function (light, lightIndex, scene, effect, useSpecular, receiveShadows) {\n    if (receiveShadows === void 0) {\n      receiveShadows = true;\n    }\n\n    light._bindLight(lightIndex, scene, effect, useSpecular, receiveShadows);\n  };\n  /**\n   * Binds the lights information from the scene to the effect for the given mesh.\n   * @param scene The scene the lights belongs to\n   * @param mesh The mesh we are binding the information to render\n   * @param effect The effect we are binding the data to\n   * @param defines The generated defines for the effect\n   * @param maxSimultaneousLights The maximum number of light that can be bound to the effect\n   */\n\n\n  MaterialHelper.BindLights = function (scene, mesh, effect, defines, maxSimultaneousLights) {\n    if (maxSimultaneousLights === void 0) {\n      maxSimultaneousLights = 4;\n    }\n\n    var len = Math.min(mesh.lightSources.length, maxSimultaneousLights);\n\n    for (var i = 0; i < len; i++) {\n      var light = mesh.lightSources[i];\n      this.BindLight(light, i, scene, effect, typeof defines === \"boolean\" ? defines : defines[\"SPECULARTERM\"], mesh.receiveShadows);\n    }\n  };\n  /**\n   * Binds the fog information from the scene to the effect for the given mesh.\n   * @param scene The scene the lights belongs to\n   * @param mesh The mesh we are binding the information to render\n   * @param effect The effect we are binding the data to\n   * @param linearSpace Defines if the fog effect is applied in linear space\n   */\n\n\n  MaterialHelper.BindFogParameters = function (scene, mesh, effect, linearSpace) {\n    if (linearSpace === void 0) {\n      linearSpace = false;\n    }\n\n    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\n      effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity); // Convert fog color to linear space if used in a linear space computed shader.\n\n      if (linearSpace) {\n        scene.fogColor.toLinearSpaceToRef(this._TempFogColor);\n        effect.setColor3(\"vFogColor\", this._TempFogColor);\n      } else {\n        effect.setColor3(\"vFogColor\", scene.fogColor);\n      }\n    }\n  };\n  /**\n   * Binds the bones information from the mesh to the effect.\n   * @param mesh The mesh we are binding the information to render\n   * @param effect The effect we are binding the data to\n   * @param prePassConfiguration Configuration for the prepass, in case prepass is activated\n   */\n\n\n  MaterialHelper.BindBonesParameters = function (mesh, effect, prePassConfiguration) {\n    if (!effect || !mesh) {\n      return;\n    }\n\n    if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {\n      mesh.computeBonesUsingShaders = false;\n    }\n\n    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n      var skeleton = mesh.skeleton;\n\n      if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex(\"boneTextureWidth\") > -1) {\n        var boneTexture = skeleton.getTransformMatrixTexture(mesh);\n        effect.setTexture(\"boneSampler\", boneTexture);\n        effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n      } else {\n        var matrices = skeleton.getTransformMatrices(mesh);\n\n        if (matrices) {\n          effect.setMatrices(\"mBones\", matrices);\n\n          if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer.getIndex(2)) {\n            if (!prePassConfiguration.previousBones[mesh.uniqueId]) {\n              prePassConfiguration.previousBones[mesh.uniqueId] = matrices.slice();\n            }\n\n            effect.setMatrices(\"mPreviousBones\", prePassConfiguration.previousBones[mesh.uniqueId]);\n\n            MaterialHelper._CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);\n          }\n        }\n      }\n    }\n  }; // Copies the bones transformation matrices into the target array and returns the target's reference\n\n\n  MaterialHelper._CopyBonesTransformationMatrices = function (source, target) {\n    target.set(source);\n    return target;\n  };\n  /**\n   * Binds the morph targets information from the mesh to the effect.\n   * @param abstractMesh The mesh we are binding the information to render\n   * @param effect The effect we are binding the data to\n   */\n\n\n  MaterialHelper.BindMorphTargetParameters = function (abstractMesh, effect) {\n    var manager = abstractMesh.morphTargetManager;\n\n    if (!abstractMesh || !manager) {\n      return;\n    }\n\n    effect.setFloatArray(\"morphTargetInfluences\", manager.influences);\n  };\n  /**\n   * Binds the logarithmic depth information from the scene to the effect for the given defines.\n   * @param defines The generated defines used in the effect\n   * @param effect The effect we are binding the data to\n   * @param scene The scene we are willing to render with logarithmic scale for\n   */\n\n\n  MaterialHelper.BindLogDepth = function (defines, effect, scene) {\n    if (!defines || defines[\"LOGARITHMICDEPTH\"]) {\n      var camera = scene.activeCamera;\n\n      if (camera.mode === Camera.ORTHOGRAPHIC_CAMERA) {\n        Logger.Error(\"Logarithmic depth is not compatible with orthographic cameras!\", 20);\n      }\n\n      effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(camera.maxZ + 1.0) / Math.LN2));\n    }\n  };\n  /**\n   * Binds the clip plane information from the scene to the effect.\n   * @param effect The effect we are binding the data to\n   * @param scene The scene the clip plane information are extracted from\n   */\n\n\n  MaterialHelper.BindClipPlane = function (effect, scene) {\n    ThinMaterialHelper.BindClipPlane(effect, scene);\n  }; // eslint-disable-next-line @typescript-eslint/naming-convention\n\n\n  MaterialHelper._TmpMorphInfluencers = {\n    NUM_MORPH_INFLUENCERS: 0\n  };\n  MaterialHelper._TempFogColor = Color3.Black();\n  return MaterialHelper;\n}();\n\nexport { MaterialHelper };","map":{"version":3,"mappings":"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","names":["Logger","Camera","Scene","EngineStore","VertexBuffer","Light","Color3","ThinMaterialHelper","MaterialHelper","effect","sceneUbo","bindToEffect","texture","defines","key","_needUVs","getTextureMatrix","isIdentityAs3x2","coordinatesIndex","uniformBuffer","matrix","updateMatrix","mesh","scene","fogEnabled","applyFog","fogMode","FOGMODE_NONE","useLogarithmicDepth","pointsCloud","alphaTest","_areMiscDirty","GetFogState","nonUniformScaling","engine","useInstances","useClipPlane","useThinInstances","changed","useClipPlane1","useClipPlane2","useClipPlane3","useClipPlane4","useClipPlane5","useClipPlane6","clipPlane","undefined","clipPlane2","clipPlane3","clipPlane4","clipPlane5","clipPlane6","getColorWrite","markAsUnprocessed","useBones","computeBonesUsingShaders","skeleton","numBoneInfluencers","materialSupportsBoneTexture","isUsingTextureForMatrices","bones","length","prePassRenderer","getScene","enabled","nonExcluded","excludedSkinnedMesh","indexOf","manager","morphTargetManager","supportsUVs","supportsTangents","supportsNormals","numInfluencers","isUsingTextureForTargets","bakedVertexAnimationManager","isEnabled","useVertexColor","useMorphTargets","useVertexAlpha","useBakedVertexAnimation","_areAttributesDirty","_needNormals","_normals","_uvs","isVerticesDataPresent","NormalKind","TangentKind","i","hasVertexColors","useVertexColors","ColorKind","hasVertexAlpha","ColorInstanceKind","PrepareDefinesForBones","PrepareDefinesForMorphTargets","PrepareDefinesForBakedVertexAnimation","activeCamera","previousMultiview","MULTIVIEW","outputRenderTarget","getViewCount","needAlphaBlending","previousDefine","ORDER_INDEPENDENT_TRANSPARENCY","previousDefine16Bits","ORDER_INDEPENDENT_TRANSPARENCY_16BITS","useOrderIndependentTransparency","getEngine","getCaps","textureFloatLinearFiltering","canRenderToMRT","previousPrePass","PREPASS","_arePrePassDirty","texturesList","type","define","index","SCENE_MRT_COUNT","mrtCount","getIndex","markAsImageProcessingDirty","light","lightIndex","specularSupported","state","needNormals","needRebuild","prepareLightSpecificDefines","falloffType","FALLOFF_GLTF","FALLOFF_PHYSICAL","FALLOFF_STANDARD","specular","equalsFloats","specularEnabled","receiveShadows","shadowsEnabled","shadowEnabled","shadowGenerator","getShadowGenerator","shadowMap","getShadowMap","renderList","prepareDefines","lightmapMode","LIGHTMAP_DEFAULT","LIGHTMAP_SHADOWSONLY","maxSimultaneousLights","disableLighting","_areLightsDirty","lightsEnabled","lightSources","_i","PrepareDefinesForLight","caps","textureFloatRender","textureHalfFloatRender","textureHalfFloatLinearFiltering","rebuild","uniformsList","samplersList","projectedLightTexture","uniformBuffersList","updateOnlyBuffersList","push","uniformsListOrOptions","uniformsNames","options","uniformBuffersNames","samplers","PrepareUniformsAndSamplersForLight","fallbacks","rank","lightFallbackRank","addFallback","attribs","influencers","_TmpMorphInfluencers","NUM_MORPH_INFLUENCERS","PrepareAttributesForMorphTargets","LastCreatedEngine","maxAttributesCount","maxVertexAttribs","normal","tangent","uv","PositionKind","UVKind","Error","name","addCPUSkinningFallback","MatricesIndicesKind","MatricesWeightsKind","MatricesIndicesExtraKind","MatricesWeightsExtraKind","PushAttributesForInstances","needsPreviousMatrices","transferToEffect","useSpecular","_bindLight","len","Math","min","BindLight","linearSpace","setFloat4","fogStart","fogEnd","fogDensity","fogColor","toLinearSpaceToRef","_TempFogColor","setColor3","prePassConfiguration","_bonesComputationForcedToCPU","getUniformIndex","boneTexture","getTransformMatrixTexture","setTexture","setFloat","matrices","getTransformMatrices","setMatrices","previousBones","uniqueId","slice","_CopyBonesTransformationMatrices","source","target","set","abstractMesh","setFloatArray","influences","camera","mode","ORTHOGRAPHIC_CAMERA","log","maxZ","LN2","BindClipPlane","Black"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Materials/materialHelper.ts"],"sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Scene } from \"../scene\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Light } from \"../Lights/light\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { PrePassConfiguration } from \"../Materials/prePassConfiguration\";\r\n\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { Effect, IEffectCreationOptions } from \"./effect\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { MaterialDefines } from \"./materialDefines\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { EffectFallbacks } from \"./effectFallbacks\";\r\nimport { ThinMaterialHelper } from \"./thinMaterialHelper\";\r\n\r\n/**\r\n * \"Static Class\" containing the most commonly used helper while dealing with material for rendering purpose.\r\n *\r\n * It contains the basic tools to help defining defines, binding uniform for the common part of the materials.\r\n *\r\n * This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.\r\n */\r\nexport class MaterialHelper {\r\n    /**\r\n     * Binds the scene's uniform buffer to the effect.\r\n     * @param effect defines the effect to bind to the scene uniform buffer\r\n     * @param sceneUbo defines the uniform buffer storing scene data\r\n     */\r\n    public static BindSceneUniformBuffer(effect: Effect, sceneUbo: UniformBuffer): void {\r\n        sceneUbo.bindToEffect(effect, \"Scene\");\r\n    }\r\n\r\n    /**\r\n     * Helps preparing the defines values about the UVs in used in the effect.\r\n     * UVs are shared as much as we can across channels in the shaders.\r\n     * @param texture The texture we are preparing the UVs for\r\n     * @param defines The defines to update\r\n     * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n     */\r\n    public static PrepareDefinesForMergedUV(texture: BaseTexture, defines: any, key: string): void {\r\n        defines._needUVs = true;\r\n        defines[key] = true;\r\n        if (texture.getTextureMatrix().isIdentityAs3x2()) {\r\n            defines[key + \"DIRECTUV\"] = texture.coordinatesIndex + 1;\r\n            defines[\"MAINUV\" + (texture.coordinatesIndex + 1)] = true;\r\n        } else {\r\n            defines[key + \"DIRECTUV\"] = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds a texture matrix value to its corresponding uniform\r\n     * @param texture The texture to bind the matrix for\r\n     * @param uniformBuffer The uniform buffer receiving the data\r\n     * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n     */\r\n    public static BindTextureMatrix(texture: BaseTexture, uniformBuffer: UniformBuffer, key: string): void {\r\n        const matrix = texture.getTextureMatrix();\r\n\r\n        uniformBuffer.updateMatrix(key + \"Matrix\", matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the current status of the fog (should it be enabled?)\r\n     * @param mesh defines the mesh to evaluate for fog support\r\n     * @param scene defines the hosting scene\r\n     * @returns true if fog must be enabled\r\n     */\r\n    public static GetFogState(mesh: AbstractMesh, scene: Scene) {\r\n        return scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE;\r\n    }\r\n\r\n    /**\r\n     * Helper used to prepare the list of defines associated with misc. values for shader compilation\r\n     * @param mesh defines the current mesh\r\n     * @param scene defines the current scene\r\n     * @param useLogarithmicDepth defines if logarithmic depth has to be turned on\r\n     * @param pointsCloud defines if point cloud rendering has to be turned on\r\n     * @param fogEnabled defines if fog has to be turned on\r\n     * @param alphaTest defines if alpha testing has to be turned on\r\n     * @param defines defines the current list of defines\r\n     */\r\n    public static PrepareDefinesForMisc(\r\n        mesh: AbstractMesh,\r\n        scene: Scene,\r\n        useLogarithmicDepth: boolean,\r\n        pointsCloud: boolean,\r\n        fogEnabled: boolean,\r\n        alphaTest: boolean,\r\n        defines: any\r\n    ): void {\r\n        if (defines._areMiscDirty) {\r\n            defines[\"LOGARITHMICDEPTH\"] = useLogarithmicDepth;\r\n            defines[\"POINTSIZE\"] = pointsCloud;\r\n            defines[\"FOG\"] = fogEnabled && this.GetFogState(mesh, scene);\r\n            defines[\"NONUNIFORMSCALING\"] = mesh.nonUniformScaling;\r\n            defines[\"ALPHATEST\"] = alphaTest;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper used to prepare the list of defines associated with frame values for shader compilation\r\n     * @param scene defines the current scene\r\n     * @param engine defines the current engine\r\n     * @param defines specifies the list of active defines\r\n     * @param useInstances defines if instances have to be turned on\r\n     * @param useClipPlane defines if clip plane have to be turned on\r\n     * @param useThinInstances defines if thin instances have to be turned on\r\n     */\r\n    public static PrepareDefinesForFrameBoundValues(\r\n        scene: Scene,\r\n        engine: Engine,\r\n        defines: any,\r\n        useInstances: boolean,\r\n        useClipPlane: Nullable<boolean> = null,\r\n        useThinInstances: boolean = false\r\n    ): void {\r\n        let changed = false;\r\n        let useClipPlane1 = false;\r\n        let useClipPlane2 = false;\r\n        let useClipPlane3 = false;\r\n        let useClipPlane4 = false;\r\n        let useClipPlane5 = false;\r\n        let useClipPlane6 = false;\r\n\r\n        useClipPlane1 = useClipPlane == null ? scene.clipPlane !== undefined && scene.clipPlane !== null : useClipPlane;\r\n        useClipPlane2 = useClipPlane == null ? scene.clipPlane2 !== undefined && scene.clipPlane2 !== null : useClipPlane;\r\n        useClipPlane3 = useClipPlane == null ? scene.clipPlane3 !== undefined && scene.clipPlane3 !== null : useClipPlane;\r\n        useClipPlane4 = useClipPlane == null ? scene.clipPlane4 !== undefined && scene.clipPlane4 !== null : useClipPlane;\r\n        useClipPlane5 = useClipPlane == null ? scene.clipPlane5 !== undefined && scene.clipPlane5 !== null : useClipPlane;\r\n        useClipPlane6 = useClipPlane == null ? scene.clipPlane6 !== undefined && scene.clipPlane6 !== null : useClipPlane;\r\n\r\n        if (defines[\"CLIPPLANE\"] !== useClipPlane1) {\r\n            defines[\"CLIPPLANE\"] = useClipPlane1;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"CLIPPLANE2\"] !== useClipPlane2) {\r\n            defines[\"CLIPPLANE2\"] = useClipPlane2;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"CLIPPLANE3\"] !== useClipPlane3) {\r\n            defines[\"CLIPPLANE3\"] = useClipPlane3;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"CLIPPLANE4\"] !== useClipPlane4) {\r\n            defines[\"CLIPPLANE4\"] = useClipPlane4;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"CLIPPLANE5\"] !== useClipPlane5) {\r\n            defines[\"CLIPPLANE5\"] = useClipPlane5;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"CLIPPLANE6\"] !== useClipPlane6) {\r\n            defines[\"CLIPPLANE6\"] = useClipPlane6;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"DEPTHPREPASS\"] !== !engine.getColorWrite()) {\r\n            defines[\"DEPTHPREPASS\"] = !defines[\"DEPTHPREPASS\"];\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"INSTANCES\"] !== useInstances) {\r\n            defines[\"INSTANCES\"] = useInstances;\r\n            changed = true;\r\n        }\r\n\r\n        // ensure defines.INSTANCESCOLOR is not out of sync with instances\r\n        if (defines[\"INSTANCESCOLOR\"] && !defines[\"INSTANCES\"]) {\r\n            defines[\"INSTANCESCOLOR\"] = false;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"THIN_INSTANCES\"] !== useThinInstances) {\r\n            defines[\"THIN_INSTANCES\"] = useThinInstances;\r\n            changed = true;\r\n        }\r\n\r\n        if (changed) {\r\n            defines.markAsUnprocessed();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines for bones\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     */\r\n    public static PrepareDefinesForBones(mesh: AbstractMesh, defines: any) {\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            defines[\"NUM_BONE_INFLUENCERS\"] = mesh.numBoneInfluencers;\r\n\r\n            const materialSupportsBoneTexture = defines[\"BONETEXTURE\"] !== undefined;\r\n\r\n            if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {\r\n                defines[\"BONETEXTURE\"] = true;\r\n            } else {\r\n                defines[\"BonesPerMesh\"] = mesh.skeleton.bones.length + 1;\r\n                defines[\"BONETEXTURE\"] = materialSupportsBoneTexture ? false : undefined;\r\n\r\n                const prePassRenderer = mesh.getScene().prePassRenderer;\r\n                if (prePassRenderer && prePassRenderer.enabled) {\r\n                    const nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;\r\n                    defines[\"BONES_VELOCITY_ENABLED\"] = nonExcluded;\r\n                }\r\n            }\r\n        } else {\r\n            defines[\"NUM_BONE_INFLUENCERS\"] = 0;\r\n            defines[\"BonesPerMesh\"] = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines for morph targets\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     */\r\n    public static PrepareDefinesForMorphTargets(mesh: AbstractMesh, defines: any) {\r\n        const manager = (<Mesh>mesh).morphTargetManager;\r\n        if (manager) {\r\n            defines[\"MORPHTARGETS_UV\"] = manager.supportsUVs && defines[\"UV1\"];\r\n            defines[\"MORPHTARGETS_TANGENT\"] = manager.supportsTangents && defines[\"TANGENT\"];\r\n            defines[\"MORPHTARGETS_NORMAL\"] = manager.supportsNormals && defines[\"NORMAL\"];\r\n            defines[\"MORPHTARGETS\"] = manager.numInfluencers > 0;\r\n            defines[\"NUM_MORPH_INFLUENCERS\"] = manager.numInfluencers;\r\n\r\n            defines[\"MORPHTARGETS_TEXTURE\"] = manager.isUsingTextureForTargets;\r\n        } else {\r\n            defines[\"MORPHTARGETS_UV\"] = false;\r\n            defines[\"MORPHTARGETS_TANGENT\"] = false;\r\n            defines[\"MORPHTARGETS_NORMAL\"] = false;\r\n            defines[\"MORPHTARGETS\"] = false;\r\n            defines[\"NUM_MORPH_INFLUENCERS\"] = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines for baked vertex animation\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     */\r\n    public static PrepareDefinesForBakedVertexAnimation(mesh: AbstractMesh, defines: any) {\r\n        const manager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n        defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] = manager && manager.isEnabled ? true : false;\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines used in the shader depending on the attributes data available in the mesh\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     * @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)\r\n     * @param useBones Precise whether bones should be used or not (override mesh info)\r\n     * @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)\r\n     * @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)\r\n     * @param useBakedVertexAnimation Precise whether baked vertex animation should be used or not (override mesh info)\r\n     * @returns false if defines are considered not dirty and have not been checked\r\n     */\r\n    public static PrepareDefinesForAttributes(\r\n        mesh: AbstractMesh,\r\n        defines: any,\r\n        useVertexColor: boolean,\r\n        useBones: boolean,\r\n        useMorphTargets = false,\r\n        useVertexAlpha = true,\r\n        useBakedVertexAnimation = true\r\n    ): boolean {\r\n        if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {\r\n            return false;\r\n        }\r\n\r\n        defines._normals = defines._needNormals;\r\n        defines._uvs = defines._needUVs;\r\n\r\n        defines[\"NORMAL\"] = defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.NormalKind);\r\n\r\n        if (defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            defines[\"TANGENT\"] = true;\r\n        }\r\n\r\n        for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n            defines[\"UV\" + i] = defines._needUVs ? mesh.isVerticesDataPresent(`uv${i === 1 ? \"\" : i}`) : false;\r\n        }\r\n\r\n        if (useVertexColor) {\r\n            const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);\r\n            defines[\"VERTEXCOLOR\"] = hasVertexColors;\r\n            defines[\"VERTEXALPHA\"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;\r\n        }\r\n\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind)) {\r\n            defines[\"INSTANCESCOLOR\"] = true;\r\n        }\r\n\r\n        if (useBones) {\r\n            this.PrepareDefinesForBones(mesh, defines);\r\n        }\r\n\r\n        if (useMorphTargets) {\r\n            this.PrepareDefinesForMorphTargets(mesh, defines);\r\n        }\r\n\r\n        if (useBakedVertexAnimation) {\r\n            this.PrepareDefinesForBakedVertexAnimation(mesh, defines);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines related to multiview\r\n     * @param scene The scene we are intending to draw\r\n     * @param defines The defines to update\r\n     */\r\n    public static PrepareDefinesForMultiview(scene: Scene, defines: any) {\r\n        if (scene.activeCamera) {\r\n            const previousMultiview = defines.MULTIVIEW;\r\n            defines.MULTIVIEW = scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1;\r\n            if (defines.MULTIVIEW != previousMultiview) {\r\n                defines.markAsUnprocessed();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines related to order independant transparency\r\n     * @param scene The scene we are intending to draw\r\n     * @param defines The defines to update\r\n     * @param needAlphaBlending Determines if the material needs alpha blending\r\n     */\r\n    public static PrepareDefinesForOIT(scene: Scene, defines: any, needAlphaBlending: boolean) {\r\n        const previousDefine = defines.ORDER_INDEPENDENT_TRANSPARENCY;\r\n        const previousDefine16Bits = defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;\r\n\r\n        defines.ORDER_INDEPENDENT_TRANSPARENCY = scene.useOrderIndependentTransparency && needAlphaBlending;\r\n        defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !scene.getEngine().getCaps().textureFloatLinearFiltering;\r\n\r\n        if (previousDefine !== defines.ORDER_INDEPENDENT_TRANSPARENCY || previousDefine16Bits !== defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) {\r\n            defines.markAsUnprocessed();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines related to the prepass\r\n     * @param scene The scene we are intending to draw\r\n     * @param defines The defines to update\r\n     * @param canRenderToMRT Indicates if this material renders to several textures in the prepass\r\n     */\r\n    public static PrepareDefinesForPrePass(scene: Scene, defines: any, canRenderToMRT: boolean) {\r\n        const previousPrePass = defines.PREPASS;\r\n\r\n        if (!defines._arePrePassDirty) {\r\n            return;\r\n        }\r\n\r\n        const texturesList = [\r\n            {\r\n                type: Constants.PREPASS_POSITION_TEXTURE_TYPE,\r\n                define: \"PREPASS_POSITION\",\r\n                index: \"PREPASS_POSITION_INDEX\",\r\n            },\r\n            {\r\n                type: Constants.PREPASS_VELOCITY_TEXTURE_TYPE,\r\n                define: \"PREPASS_VELOCITY\",\r\n                index: \"PREPASS_VELOCITY_INDEX\",\r\n            },\r\n            {\r\n                type: Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE,\r\n                define: \"PREPASS_REFLECTIVITY\",\r\n                index: \"PREPASS_REFLECTIVITY_INDEX\",\r\n            },\r\n            {\r\n                type: Constants.PREPASS_IRRADIANCE_TEXTURE_TYPE,\r\n                define: \"PREPASS_IRRADIANCE\",\r\n                index: \"PREPASS_IRRADIANCE_INDEX\",\r\n            },\r\n            {\r\n                type: Constants.PREPASS_ALBEDO_SQRT_TEXTURE_TYPE,\r\n                define: \"PREPASS_ALBEDO_SQRT\",\r\n                index: \"PREPASS_ALBEDO_SQRT_INDEX\",\r\n            },\r\n            {\r\n                type: Constants.PREPASS_DEPTH_TEXTURE_TYPE,\r\n                define: \"PREPASS_DEPTH\",\r\n                index: \"PREPASS_DEPTH_INDEX\",\r\n            },\r\n            {\r\n                type: Constants.PREPASS_NORMAL_TEXTURE_TYPE,\r\n                define: \"PREPASS_NORMAL\",\r\n                index: \"PREPASS_NORMAL_INDEX\",\r\n            },\r\n        ];\r\n\r\n        if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {\r\n            defines.PREPASS = true;\r\n            defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;\r\n\r\n            for (let i = 0; i < texturesList.length; i++) {\r\n                const index = scene.prePassRenderer.getIndex(texturesList[i].type);\r\n                if (index !== -1) {\r\n                    defines[texturesList[i].define] = true;\r\n                    defines[texturesList[i].index] = index;\r\n                } else {\r\n                    defines[texturesList[i].define] = false;\r\n                }\r\n            }\r\n        } else {\r\n            defines.PREPASS = false;\r\n            for (let i = 0; i < texturesList.length; i++) {\r\n                defines[texturesList[i].define] = false;\r\n            }\r\n        }\r\n\r\n        if (defines.PREPASS != previousPrePass) {\r\n            defines.markAsUnprocessed();\r\n            defines.markAsImageProcessingDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines related to the light information passed in parameter\r\n     * @param scene The scene we are intending to draw\r\n     * @param mesh The mesh the effect is compiling for\r\n     * @param light The light the effect is compiling for\r\n     * @param lightIndex The index of the light\r\n     * @param defines The defines to update\r\n     * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n     * @param state Defines the current state regarding what is needed (normals, etc...)\r\n     * @param state.needNormals\r\n     * @param state.needRebuild\r\n     * @param state.shadowEnabled\r\n     * @param state.specularEnabled\r\n     * @param state.lightmapMode\r\n     */\r\n    public static PrepareDefinesForLight(\r\n        scene: Scene,\r\n        mesh: AbstractMesh,\r\n        light: Light,\r\n        lightIndex: number,\r\n        defines: any,\r\n        specularSupported: boolean,\r\n        state: {\r\n            needNormals: boolean;\r\n            needRebuild: boolean;\r\n            shadowEnabled: boolean;\r\n            specularEnabled: boolean;\r\n            lightmapMode: boolean;\r\n        }\r\n    ) {\r\n        state.needNormals = true;\r\n\r\n        if (defines[\"LIGHT\" + lightIndex] === undefined) {\r\n            state.needRebuild = true;\r\n        }\r\n\r\n        defines[\"LIGHT\" + lightIndex] = true;\r\n\r\n        defines[\"SPOTLIGHT\" + lightIndex] = false;\r\n        defines[\"HEMILIGHT\" + lightIndex] = false;\r\n        defines[\"POINTLIGHT\" + lightIndex] = false;\r\n        defines[\"DIRLIGHT\" + lightIndex] = false;\r\n\r\n        light.prepareLightSpecificDefines(defines, lightIndex);\r\n\r\n        // FallOff.\r\n        defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = false;\r\n        defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = false;\r\n        defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = false;\r\n\r\n        switch (light.falloffType) {\r\n            case Light.FALLOFF_GLTF:\r\n                defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = true;\r\n                break;\r\n            case Light.FALLOFF_PHYSICAL:\r\n                defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = true;\r\n                break;\r\n            case Light.FALLOFF_STANDARD:\r\n                defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = true;\r\n                break;\r\n        }\r\n\r\n        // Specular\r\n        if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {\r\n            state.specularEnabled = true;\r\n        }\r\n\r\n        // Shadows\r\n        defines[\"SHADOW\" + lightIndex] = false;\r\n        defines[\"SHADOWCSM\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMDEBUG\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMNOBLEND\" + lightIndex] = false;\r\n        defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = false;\r\n        defines[\"SHADOWPCF\" + lightIndex] = false;\r\n        defines[\"SHADOWPCSS\" + lightIndex] = false;\r\n        defines[\"SHADOWPOISSON\" + lightIndex] = false;\r\n        defines[\"SHADOWESM\" + lightIndex] = false;\r\n        defines[\"SHADOWCLOSEESM\" + lightIndex] = false;\r\n        defines[\"SHADOWCUBE\" + lightIndex] = false;\r\n        defines[\"SHADOWLOWQUALITY\" + lightIndex] = false;\r\n        defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = false;\r\n\r\n        if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {\r\n            const shadowGenerator = light.getShadowGenerator();\r\n            if (shadowGenerator) {\r\n                const shadowMap = shadowGenerator.getShadowMap();\r\n                if (shadowMap) {\r\n                    if (shadowMap.renderList && shadowMap.renderList.length > 0) {\r\n                        state.shadowEnabled = true;\r\n                        shadowGenerator.prepareDefines(defines, lightIndex);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (light.lightmapMode != Light.LIGHTMAP_DEFAULT) {\r\n            state.lightmapMode = true;\r\n            defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = true;\r\n            defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = light.lightmapMode == Light.LIGHTMAP_SHADOWSONLY;\r\n        } else {\r\n            defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = false;\r\n            defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines related to the light information passed in parameter\r\n     * @param scene The scene we are intending to draw\r\n     * @param mesh The mesh the effect is compiling for\r\n     * @param defines The defines to update\r\n     * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n     * @param maxSimultaneousLights Specifies how manuy lights can be added to the effect at max\r\n     * @param disableLighting Specifies whether the lighting is disabled (override scene and light)\r\n     * @returns true if normals will be required for the rest of the effect\r\n     */\r\n    public static PrepareDefinesForLights(scene: Scene, mesh: AbstractMesh, defines: any, specularSupported: boolean, maxSimultaneousLights = 4, disableLighting = false): boolean {\r\n        if (!defines._areLightsDirty) {\r\n            return defines._needNormals;\r\n        }\r\n\r\n        let lightIndex = 0;\r\n        const state = {\r\n            needNormals: false,\r\n            needRebuild: false,\r\n            lightmapMode: false,\r\n            shadowEnabled: false,\r\n            specularEnabled: false,\r\n        };\r\n\r\n        if (scene.lightsEnabled && !disableLighting) {\r\n            for (const light of mesh.lightSources) {\r\n                this.PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);\r\n\r\n                lightIndex++;\r\n                if (lightIndex === maxSimultaneousLights) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        defines[\"SPECULARTERM\"] = state.specularEnabled;\r\n        defines[\"SHADOWS\"] = state.shadowEnabled;\r\n\r\n        // Resetting all other lights if any\r\n        for (let index = lightIndex; index < maxSimultaneousLights; index++) {\r\n            if (defines[\"LIGHT\" + index] !== undefined) {\r\n                defines[\"LIGHT\" + index] = false;\r\n                defines[\"HEMILIGHT\" + index] = false;\r\n                defines[\"POINTLIGHT\" + index] = false;\r\n                defines[\"DIRLIGHT\" + index] = false;\r\n                defines[\"SPOTLIGHT\" + index] = false;\r\n                defines[\"SHADOW\" + index] = false;\r\n                defines[\"SHADOWCSM\" + index] = false;\r\n                defines[\"SHADOWCSMDEBUG\" + index] = false;\r\n                defines[\"SHADOWCSMNUM_CASCADES\" + index] = false;\r\n                defines[\"SHADOWCSMUSESHADOWMAXZ\" + index] = false;\r\n                defines[\"SHADOWCSMNOBLEND\" + index] = false;\r\n                defines[\"SHADOWCSM_RIGHTHANDED\" + index] = false;\r\n                defines[\"SHADOWPCF\" + index] = false;\r\n                defines[\"SHADOWPCSS\" + index] = false;\r\n                defines[\"SHADOWPOISSON\" + index] = false;\r\n                defines[\"SHADOWESM\" + index] = false;\r\n                defines[\"SHADOWCLOSEESM\" + index] = false;\r\n                defines[\"SHADOWCUBE\" + index] = false;\r\n                defines[\"SHADOWLOWQUALITY\" + index] = false;\r\n                defines[\"SHADOWMEDIUMQUALITY\" + index] = false;\r\n            }\r\n        }\r\n\r\n        const caps = scene.getEngine().getCaps();\r\n\r\n        if (defines[\"SHADOWFLOAT\"] === undefined) {\r\n            state.needRebuild = true;\r\n        }\r\n\r\n        defines[\"SHADOWFLOAT\"] =\r\n            state.shadowEnabled && ((caps.textureFloatRender && caps.textureFloatLinearFiltering) || (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering));\r\n        defines[\"LIGHTMAPEXCLUDED\"] = state.lightmapMode;\r\n\r\n        if (state.needRebuild) {\r\n            defines.rebuild();\r\n        }\r\n\r\n        return state.needNormals;\r\n    }\r\n\r\n    /**\r\n     * Prepares the uniforms and samplers list to be used in the effect (for a specific light)\r\n     * @param lightIndex defines the light index\r\n     * @param uniformsList The uniform list\r\n     * @param samplersList The sampler list\r\n     * @param projectedLightTexture defines if projected texture must be used\r\n     * @param uniformBuffersList defines an optional list of uniform buffers\r\n     * @param updateOnlyBuffersList True to only update the uniformBuffersList array\r\n     */\r\n    public static PrepareUniformsAndSamplersForLight(\r\n        lightIndex: number,\r\n        uniformsList: string[],\r\n        samplersList: string[],\r\n        projectedLightTexture?: any,\r\n        uniformBuffersList: Nullable<string[]> = null,\r\n        updateOnlyBuffersList = false\r\n    ) {\r\n        if (uniformBuffersList) {\r\n            uniformBuffersList.push(\"Light\" + lightIndex);\r\n        }\r\n\r\n        if (updateOnlyBuffersList) {\r\n            return;\r\n        }\r\n\r\n        uniformsList.push(\r\n            \"vLightData\" + lightIndex,\r\n            \"vLightDiffuse\" + lightIndex,\r\n            \"vLightSpecular\" + lightIndex,\r\n            \"vLightDirection\" + lightIndex,\r\n            \"vLightFalloff\" + lightIndex,\r\n            \"vLightGround\" + lightIndex,\r\n            \"lightMatrix\" + lightIndex,\r\n            \"shadowsInfo\" + lightIndex,\r\n            \"depthValues\" + lightIndex\r\n        );\r\n\r\n        samplersList.push(\"shadowSampler\" + lightIndex);\r\n        samplersList.push(\"depthSampler\" + lightIndex);\r\n\r\n        uniformsList.push(\r\n            \"viewFrustumZ\" + lightIndex,\r\n            \"cascadeBlendFactor\" + lightIndex,\r\n            \"lightSizeUVCorrection\" + lightIndex,\r\n            \"depthCorrection\" + lightIndex,\r\n            \"penumbraDarkness\" + lightIndex,\r\n            \"frustumLengths\" + lightIndex\r\n        );\r\n\r\n        if (projectedLightTexture) {\r\n            samplersList.push(\"projectionLightSampler\" + lightIndex);\r\n            uniformsList.push(\"textureProjectionMatrix\" + lightIndex);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the uniforms and samplers list to be used in the effect\r\n     * @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the list and extra information\r\n     * @param samplersList The sampler list\r\n     * @param defines The defines helping in the list generation\r\n     * @param maxSimultaneousLights The maximum number of simultaneous light allowed in the effect\r\n     */\r\n    public static PrepareUniformsAndSamplersList(\r\n        uniformsListOrOptions: string[] | IEffectCreationOptions,\r\n        samplersList?: string[],\r\n        defines?: any,\r\n        maxSimultaneousLights = 4\r\n    ): void {\r\n        let uniformsList: string[];\r\n        let uniformBuffersList: Nullable<string[]> = null;\r\n\r\n        if ((<IEffectCreationOptions>uniformsListOrOptions).uniformsNames) {\r\n            const options = <IEffectCreationOptions>uniformsListOrOptions;\r\n            uniformsList = options.uniformsNames;\r\n            uniformBuffersList = options.uniformBuffersNames;\r\n            samplersList = options.samplers;\r\n            defines = options.defines;\r\n            maxSimultaneousLights = options.maxSimultaneousLights || 0;\r\n        } else {\r\n            uniformsList = <string[]>uniformsListOrOptions;\r\n            if (!samplersList) {\r\n                samplersList = [];\r\n            }\r\n        }\r\n\r\n        for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n            if (!defines[\"LIGHT\" + lightIndex]) {\r\n                break;\r\n            }\r\n            this.PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffersList);\r\n        }\r\n\r\n        if (defines[\"NUM_MORPH_INFLUENCERS\"]) {\r\n            uniformsList.push(\"morphTargetInfluences\");\r\n        }\r\n\r\n        if (defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"]) {\r\n            uniformsList.push(\"bakedVertexAnimationSettings\");\r\n            uniformsList.push(\"bakedVertexAnimationTextureSizeInverted\");\r\n            uniformsList.push(\"bakedVertexAnimationTime\");\r\n            samplersList.push(\"bakedVertexAnimationTexture\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)\r\n     * @param defines The defines to update while falling back\r\n     * @param fallbacks The authorized effect fallbacks\r\n     * @param maxSimultaneousLights The maximum number of lights allowed\r\n     * @param rank the current rank of the Effect\r\n     * @returns The newly affected rank\r\n     */\r\n    public static HandleFallbacksForShadows(defines: any, fallbacks: EffectFallbacks, maxSimultaneousLights = 4, rank = 0): number {\r\n        let lightFallbackRank = 0;\r\n        for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n            if (!defines[\"LIGHT\" + lightIndex]) {\r\n                break;\r\n            }\r\n\r\n            if (lightIndex > 0) {\r\n                lightFallbackRank = rank + lightIndex;\r\n                fallbacks.addFallback(lightFallbackRank, \"LIGHT\" + lightIndex);\r\n            }\r\n\r\n            if (!defines[\"SHADOWS\"]) {\r\n                if (defines[\"SHADOW\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOW\" + lightIndex);\r\n                }\r\n\r\n                if (defines[\"SHADOWPCF\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWPCF\" + lightIndex);\r\n                }\r\n\r\n                if (defines[\"SHADOWPCSS\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWPCSS\" + lightIndex);\r\n                }\r\n\r\n                if (defines[\"SHADOWPOISSON\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWPOISSON\" + lightIndex);\r\n                }\r\n\r\n                if (defines[\"SHADOWESM\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWESM\" + lightIndex);\r\n                }\r\n\r\n                if (defines[\"SHADOWCLOSEESM\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWCLOSEESM\" + lightIndex);\r\n                }\r\n            }\r\n        }\r\n        return lightFallbackRank++;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private static _TmpMorphInfluencers = { NUM_MORPH_INFLUENCERS: 0 };\r\n    /**\r\n     * Prepares the list of attributes required for morph targets according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the morph targets attributes for\r\n     * @param influencers The number of influencers\r\n     */\r\n    public static PrepareAttributesForMorphTargetsInfluencers(attribs: string[], mesh: AbstractMesh, influencers: number): void {\r\n        this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;\r\n        this.PrepareAttributesForMorphTargets(attribs, mesh, this._TmpMorphInfluencers);\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of attributes required for morph targets according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the morph targets attributes for\r\n     * @param defines The current Defines of the effect\r\n     */\r\n    public static PrepareAttributesForMorphTargets(attribs: string[], mesh: AbstractMesh, defines: any): void {\r\n        const influencers = defines[\"NUM_MORPH_INFLUENCERS\"];\r\n\r\n        if (influencers > 0 && EngineStore.LastCreatedEngine) {\r\n            const maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;\r\n            const manager = (<Mesh>mesh).morphTargetManager;\r\n            if (manager?.isUsingTextureForTargets) {\r\n                return;\r\n            }\r\n            const normal = manager && manager.supportsNormals && defines[\"NORMAL\"];\r\n            const tangent = manager && manager.supportsTangents && defines[\"TANGENT\"];\r\n            const uv = manager && manager.supportsUVs && defines[\"UV1\"];\r\n            for (let index = 0; index < influencers; index++) {\r\n                attribs.push(VertexBuffer.PositionKind + index);\r\n\r\n                if (normal) {\r\n                    attribs.push(VertexBuffer.NormalKind + index);\r\n                }\r\n\r\n                if (tangent) {\r\n                    attribs.push(VertexBuffer.TangentKind + index);\r\n                }\r\n\r\n                if (uv) {\r\n                    attribs.push(VertexBuffer.UVKind + \"_\" + index);\r\n                }\r\n\r\n                if (attribs.length > maxAttributesCount) {\r\n                    Logger.Error(\"Cannot add more vertex attributes for mesh \" + mesh.name);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of attributes required for baked vertex animations according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the morph targets attributes for\r\n     * @param defines The current Defines of the effect\r\n     */\r\n    public static PrepareAttributesForBakedVertexAnimation(attribs: string[], mesh: AbstractMesh, defines: any): void {\r\n        const enabled = defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] && defines[\"INSTANCES\"];\r\n\r\n        if (enabled) {\r\n            attribs.push(\"bakedVertexAnimationSettingsInstanced\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of attributes required for bones according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the bones attributes for\r\n     * @param defines The current Defines of the effect\r\n     * @param fallbacks The current effect fallback strategy\r\n     */\r\n    public static PrepareAttributesForBones(attribs: string[], mesh: AbstractMesh, defines: any, fallbacks: EffectFallbacks): void {\r\n        if (defines[\"NUM_BONE_INFLUENCERS\"] > 0) {\r\n            fallbacks.addCPUSkinningFallback(0, mesh);\r\n\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (defines[\"NUM_BONE_INFLUENCERS\"] > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check and prepare the list of attributes required for instances according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param defines The current MaterialDefines of the effect\r\n     */\r\n    public static PrepareAttributesForInstances(attribs: string[], defines: MaterialDefines): void {\r\n        if (defines[\"INSTANCES\"] || defines[\"THIN_INSTANCES\"]) {\r\n            this.PushAttributesForInstances(attribs, !!defines[\"PREPASS_VELOCITY\"]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add the list of attributes required for instances to the attribs array.\r\n     * @param attribs The current list of supported attribs\r\n     * @param needsPreviousMatrices If the shader needs previous matrices\r\n     */\r\n    public static PushAttributesForInstances(attribs: string[], needsPreviousMatrices: boolean = false): void {\r\n        attribs.push(\"world0\");\r\n        attribs.push(\"world1\");\r\n        attribs.push(\"world2\");\r\n        attribs.push(\"world3\");\r\n        if (needsPreviousMatrices) {\r\n            attribs.push(\"previousWorld0\");\r\n            attribs.push(\"previousWorld1\");\r\n            attribs.push(\"previousWorld2\");\r\n            attribs.push(\"previousWorld3\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the light information to the effect.\r\n     * @param light The light containing the generator\r\n     * @param effect The effect we are binding the data to\r\n     * @param lightIndex The light index in the effect used to render\r\n     */\r\n    public static BindLightProperties(light: Light, effect: Effect, lightIndex: number): void {\r\n        light.transferToEffect(effect, lightIndex + \"\");\r\n    }\r\n\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param light Light to bind\r\n     * @param lightIndex Light index\r\n     * @param scene The scene where the light belongs to\r\n     * @param effect The effect we are binding the data to\r\n     * @param useSpecular Defines if specular is supported\r\n     * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\r\n     */\r\n    public static BindLight(light: Light, lightIndex: number, scene: Scene, effect: Effect, useSpecular: boolean, receiveShadows = true): void {\r\n        light._bindLight(lightIndex, scene, effect, useSpecular, receiveShadows);\r\n    }\r\n\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param scene The scene the lights belongs to\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     * @param defines The generated defines for the effect\r\n     * @param maxSimultaneousLights The maximum number of light that can be bound to the effect\r\n     */\r\n    public static BindLights(scene: Scene, mesh: AbstractMesh, effect: Effect, defines: any, maxSimultaneousLights = 4): void {\r\n        const len = Math.min(mesh.lightSources.length, maxSimultaneousLights);\r\n\r\n        for (let i = 0; i < len; i++) {\r\n            const light = mesh.lightSources[i];\r\n            this.BindLight(light, i, scene, effect, typeof defines === \"boolean\" ? defines : defines[\"SPECULARTERM\"], mesh.receiveShadows);\r\n        }\r\n    }\r\n\r\n    private static _TempFogColor = Color3.Black();\r\n    /**\r\n     * Binds the fog information from the scene to the effect for the given mesh.\r\n     * @param scene The scene the lights belongs to\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     * @param linearSpace Defines if the fog effect is applied in linear space\r\n     */\r\n    public static BindFogParameters(scene: Scene, mesh: AbstractMesh, effect: Effect, linearSpace = false): void {\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\r\n            // Convert fog color to linear space if used in a linear space computed shader.\r\n            if (linearSpace) {\r\n                scene.fogColor.toLinearSpaceToRef(this._TempFogColor);\r\n                effect.setColor3(\"vFogColor\", this._TempFogColor);\r\n            } else {\r\n                effect.setColor3(\"vFogColor\", scene.fogColor);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the bones information from the mesh to the effect.\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     * @param prePassConfiguration Configuration for the prepass, in case prepass is activated\r\n     */\r\n    public static BindBonesParameters(mesh?: AbstractMesh, effect?: Effect, prePassConfiguration?: PrePassConfiguration): void {\r\n        if (!effect || !mesh) {\r\n            return;\r\n        }\r\n        if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {\r\n            mesh.computeBonesUsingShaders = false;\r\n        }\r\n\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            const skeleton = mesh.skeleton;\r\n\r\n            if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex(\"boneTextureWidth\") > -1) {\r\n                const boneTexture = skeleton.getTransformMatrixTexture(mesh);\r\n                effect.setTexture(\"boneSampler\", boneTexture);\r\n                effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n            } else {\r\n                const matrices = skeleton.getTransformMatrices(mesh);\r\n\r\n                if (matrices) {\r\n                    effect.setMatrices(\"mBones\", matrices);\r\n                    if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer!.getIndex(Constants.PREPASS_VELOCITY_TEXTURE_TYPE)) {\r\n                        if (!prePassConfiguration.previousBones[mesh.uniqueId]) {\r\n                            prePassConfiguration.previousBones[mesh.uniqueId] = matrices.slice();\r\n                        }\r\n                        effect.setMatrices(\"mPreviousBones\", prePassConfiguration.previousBones[mesh.uniqueId]);\r\n                        MaterialHelper._CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Copies the bones transformation matrices into the target array and returns the target's reference\r\n    private static _CopyBonesTransformationMatrices(source: Float32Array, target: Float32Array): Float32Array {\r\n        target.set(source);\r\n\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     * Binds the morph targets information from the mesh to the effect.\r\n     * @param abstractMesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     */\r\n    public static BindMorphTargetParameters(abstractMesh: AbstractMesh, effect: Effect): void {\r\n        const manager = (<Mesh>abstractMesh).morphTargetManager;\r\n        if (!abstractMesh || !manager) {\r\n            return;\r\n        }\r\n\r\n        effect.setFloatArray(\"morphTargetInfluences\", manager.influences);\r\n    }\r\n\r\n    /**\r\n     * Binds the logarithmic depth information from the scene to the effect for the given defines.\r\n     * @param defines The generated defines used in the effect\r\n     * @param effect The effect we are binding the data to\r\n     * @param scene The scene we are willing to render with logarithmic scale for\r\n     */\r\n    public static BindLogDepth(defines: any, effect: Effect, scene: Scene): void {\r\n        if (!defines || defines[\"LOGARITHMICDEPTH\"]) {\r\n            const camera = <Camera>scene.activeCamera;\r\n            if (camera.mode === Camera.ORTHOGRAPHIC_CAMERA) {\r\n                Logger.Error(\"Logarithmic depth is not compatible with orthographic cameras!\", 20);\r\n            }\r\n            effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(camera.maxZ + 1.0) / Math.LN2));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the clip plane information from the scene to the effect.\r\n     * @param effect The effect we are binding the data to\r\n     * @param scene The scene the clip plane information are extracted from\r\n     */\r\n    public static BindClipPlane(effect: Effect, scene: Scene): void {\r\n        ThinMaterialHelper.BindClipPlane(effect, scene);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}