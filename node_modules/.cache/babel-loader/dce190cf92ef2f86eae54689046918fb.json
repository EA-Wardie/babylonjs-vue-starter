{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { __extends } from \"tslib\";\nimport { Vector3, Matrix, Quaternion, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport { FreeCamera } from \"../Cameras/freeCamera.js\";\nimport { TargetCamera } from \"../Cameras/targetCamera.js\";\nimport { Viewport } from \"../Maths/math.viewport.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { WebXRTrackingState } from \"./webXRTypes.js\";\n/**\n * WebXR Camera which holds the views for the xrSession\n * @see https://doc.babylonjs.com/how_to/webxr_camera\n */\n\nvar WebXRCamera =\n/** @class */\nfunction (_super) {\n  __extends(WebXRCamera, _super);\n  /**\n   * Creates a new webXRCamera, this should only be set at the camera after it has been updated by the xrSessionManager\n   * @param name the name of the camera\n   * @param scene the scene to add the camera to\n   * @param _xrSessionManager a constructed xr session manager\n   */\n\n\n  function WebXRCamera(name, scene, _xrSessionManager) {\n    var _this = _super.call(this, name, Vector3.Zero(), scene) || this;\n\n    _this._xrSessionManager = _xrSessionManager;\n    _this._firstFrame = false;\n    _this._referenceQuaternion = Quaternion.Identity();\n    _this._referencedPosition = new Vector3();\n    _this._trackingState = WebXRTrackingState.NOT_TRACKING;\n    /**\n     * Observable raised before camera teleportation\n     */\n\n    _this.onBeforeCameraTeleport = new Observable();\n    /**\n     *  Observable raised after camera teleportation\n     */\n\n    _this.onAfterCameraTeleport = new Observable();\n    /**\n     * Notifies when the camera's tracking state has changed.\n     * Notice - will also be triggered when tracking has started (at the beginning of the session)\n     */\n\n    _this.onTrackingStateChanged = new Observable();\n    /**\n     * Should position compensation execute on first frame.\n     * This is used when copying the position from a native (non XR) camera\n     */\n\n    _this.compensateOnFirstFrame = true;\n    _this._rotate180 = new Quaternion(0, 1, 0, 0); // Initial camera configuration\n\n    _this.minZ = 0.1;\n    _this.rotationQuaternion = new Quaternion();\n    _this.cameraRigMode = Camera.RIG_MODE_CUSTOM;\n    _this.updateUpVectorFromRotation = true;\n\n    _this._updateNumberOfRigCameras(1); // freeze projection matrix, which will be copied later\n\n\n    _this.freezeProjectionMatrix();\n\n    _this._xrSessionManager.onXRSessionInit.add(function () {\n      _this._referencedPosition.copyFromFloats(0, 0, 0);\n\n      _this._referenceQuaternion.copyFromFloats(0, 0, 0, 1); // first frame - camera's y position should be 0 for the correct offset\n\n\n      _this._firstFrame = _this.compensateOnFirstFrame;\n    }); // Check transformation changes on each frame. Callback is added to be first so that the transformation will be\n    // applied to the rest of the elements using the referenceSpace object\n\n\n    _this._xrSessionManager.onXRFrameObservable.add(function () {\n      if (_this._firstFrame) {\n        _this._updateFromXRSession();\n      }\n\n      _this._updateReferenceSpace();\n\n      _this._updateFromXRSession();\n    }, undefined, true);\n\n    return _this;\n  }\n\n  Object.defineProperty(WebXRCamera.prototype, \"trackingState\", {\n    /**\n     * Get the current XR tracking state of the camera\n     */\n    get: function get() {\n      return this._trackingState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  WebXRCamera.prototype._setTrackingState = function (newState) {\n    if (this._trackingState !== newState) {\n      this._trackingState = newState;\n      this.onTrackingStateChanged.notifyObservers(newState);\n    }\n  };\n\n  Object.defineProperty(WebXRCamera.prototype, \"realWorldHeight\", {\n    /**\n     * Return the user's height, unrelated to the current ground.\n     * This will be the y position of this camera, when ground level is 0.\n     */\n    get: function get() {\n      var basePose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.baseReferenceSpace);\n\n      if (basePose && basePose.transform) {\n        return basePose.transform.position.y;\n      } else {\n        return 0;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  WebXRCamera.prototype._updateForDualEyeDebugging = function\n    /*pupilDistance = 0.01*/\n  () {\n    // Create initial camera rigs\n    this._updateNumberOfRigCameras(2);\n\n    this.rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0); // this.rigCameras[0].position.x = -pupilDistance / 2;\n\n    this.rigCameras[0].outputRenderTarget = null;\n    this.rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0); // this.rigCameras[1].position.x = pupilDistance / 2;\n\n    this.rigCameras[1].outputRenderTarget = null;\n  };\n  /**\n   * Sets this camera's transformation based on a non-vr camera\n   * @param otherCamera the non-vr camera to copy the transformation from\n   * @param resetToBaseReferenceSpace should XR reset to the base reference space\n   */\n\n\n  WebXRCamera.prototype.setTransformationFromNonVRCamera = function (otherCamera, resetToBaseReferenceSpace) {\n    if (otherCamera === void 0) {\n      otherCamera = this.getScene().activeCamera;\n    }\n\n    if (resetToBaseReferenceSpace === void 0) {\n      resetToBaseReferenceSpace = true;\n    }\n\n    if (!otherCamera || otherCamera === this) {\n      return;\n    }\n\n    var mat = otherCamera.computeWorldMatrix();\n    mat.decompose(undefined, this.rotationQuaternion, this.position); // set the ground level\n\n    this.position.y = 0;\n    Quaternion.FromEulerAnglesToRef(0, this.rotationQuaternion.toEulerAngles().y, 0, this.rotationQuaternion);\n    this._firstFrame = true;\n\n    if (resetToBaseReferenceSpace) {\n      this._xrSessionManager.resetReferenceSpace();\n    }\n  };\n  /**\n   * Gets the current instance class name (\"WebXRCamera\").\n   * @returns the class name\n   */\n\n\n  WebXRCamera.prototype.getClassName = function () {\n    return \"WebXRCamera\";\n  };\n\n  WebXRCamera.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._lastXRViewerPose = undefined;\n  };\n\n  WebXRCamera.prototype._updateFromXRSession = function () {\n    var _this = this;\n\n    var pose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.referenceSpace);\n\n    this._lastXRViewerPose = pose || undefined;\n\n    if (!pose) {\n      this._setTrackingState(WebXRTrackingState.NOT_TRACKING);\n\n      return;\n    } // Set the tracking state. if it didn't change it is a no-op\n\n\n    var trackingState = pose.emulatedPosition ? WebXRTrackingState.TRACKING_LOST : WebXRTrackingState.TRACKING;\n\n    this._setTrackingState(trackingState);\n\n    if (pose.transform) {\n      var orientation_1 = pose.transform.orientation;\n\n      if (pose.transform.orientation.x === undefined) {\n        // Babylon native polyfill can return an undefined orientation value\n        // When not initialized\n        return;\n      }\n\n      var pos = pose.transform.position;\n\n      this._referencedPosition.set(pos.x, pos.y, pos.z);\n\n      this._referenceQuaternion.set(orientation_1.x, orientation_1.y, orientation_1.z, orientation_1.w);\n\n      if (!this._scene.useRightHandedSystem) {\n        this._referencedPosition.z *= -1;\n        this._referenceQuaternion.z *= -1;\n        this._referenceQuaternion.w *= -1;\n      }\n\n      if (this._firstFrame) {\n        this._firstFrame = false; // we have the XR reference, now use this to find the offset to get the camera to be\n        // in the right position\n        // set the height to correlate to the current height\n\n        this.position.y += this._referencedPosition.y; // avoid using the head rotation on the first frame.\n\n        this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);\n      } else {\n        // update position and rotation as reference\n        this.rotationQuaternion.copyFrom(this._referenceQuaternion);\n        this.position.copyFrom(this._referencedPosition);\n      }\n    } // Update camera rigs\n\n\n    if (this.rigCameras.length !== pose.views.length) {\n      this._updateNumberOfRigCameras(pose.views.length);\n    }\n\n    pose.views.forEach(function (view, i) {\n      var _a;\n\n      var currentRig = _this.rigCameras[i]; // update right and left, where applicable\n\n      if (!currentRig.isLeftCamera && !currentRig.isRightCamera) {\n        if (view.eye === \"right\") {\n          currentRig._isRightCamera = true;\n        } else if (view.eye === \"left\") {\n          currentRig._isLeftCamera = true;\n        }\n      } // Update view/projection matrix\n\n\n      var pos = view.transform.position;\n      var orientation = view.transform.orientation;\n      currentRig.parent = _this.parent;\n      currentRig.position.set(pos.x, pos.y, pos.z);\n      currentRig.rotationQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\n\n      if (!_this._scene.useRightHandedSystem) {\n        currentRig.position.z *= -1;\n        currentRig.rotationQuaternion.z *= -1;\n        currentRig.rotationQuaternion.w *= -1;\n      } else {\n        currentRig.rotationQuaternion.multiplyInPlace(_this._rotate180);\n      }\n\n      Matrix.FromFloat32ArrayToRefScaled(view.projectionMatrix, 0, 1, currentRig._projectionMatrix);\n\n      if (!_this._scene.useRightHandedSystem) {\n        currentRig._projectionMatrix.toggleProjectionMatrixHandInPlace();\n      } // first camera?\n\n\n      if (i === 0) {\n        _this._projectionMatrix.copyFrom(currentRig._projectionMatrix);\n      }\n\n      var renderTargetTexture = _this._xrSessionManager.getRenderTargetTextureForView(view);\n\n      _this._renderingMultiview = ((_a = renderTargetTexture === null || renderTargetTexture === void 0 ? void 0 : renderTargetTexture._texture) === null || _a === void 0 ? void 0 : _a.isMultiview) || false;\n\n      if (_this._renderingMultiview) {\n        // For multiview, the render target texture is the same per-view (just the slice index is different),\n        // so we only need to set the output render target once for the rig parent.\n        if (i == 0) {\n          _this._xrSessionManager.trySetViewportForView(_this.viewport, view);\n\n          _this.outputRenderTarget = renderTargetTexture;\n        }\n      } else {\n        // Update viewport\n        _this._xrSessionManager.trySetViewportForView(currentRig.viewport, view); // Set cameras to render to the session's render target\n\n\n        currentRig.outputRenderTarget = renderTargetTexture || _this._xrSessionManager.getRenderTargetTextureForView(view);\n      }\n    });\n  };\n\n  WebXRCamera.prototype._updateNumberOfRigCameras = function (viewCount) {\n    if (viewCount === void 0) {\n      viewCount = 1;\n    }\n\n    while (this.rigCameras.length < viewCount) {\n      var newCamera = new TargetCamera(\"XR-RigCamera: \" + this.rigCameras.length, Vector3.Zero(), this.getScene());\n      newCamera.minZ = 0.1;\n      newCamera.rotationQuaternion = new Quaternion();\n      newCamera.updateUpVectorFromRotation = true;\n      newCamera.isRigCamera = true;\n      newCamera.rigParent = this; // do not compute projection matrix, provided by XR\n\n      newCamera.freezeProjectionMatrix();\n      this.rigCameras.push(newCamera);\n    }\n\n    while (this.rigCameras.length > viewCount) {\n      var removedCamera = this.rigCameras.pop();\n\n      if (removedCamera) {\n        removedCamera.dispose();\n      }\n    }\n  };\n\n  WebXRCamera.prototype._updateReferenceSpace = function () {\n    // were position & rotation updated OUTSIDE of the xr update loop\n    if (!this.position.equals(this._referencedPosition) || !this.rotationQuaternion.equals(this._referenceQuaternion)) {\n      var referencedMat = TmpVectors.Matrix[0];\n      var poseMat = TmpVectors.Matrix[1];\n      var transformMat = TmpVectors.Matrix[2];\n      Matrix.ComposeToRef(WebXRCamera._ScaleReadOnly, this._referenceQuaternion, this._referencedPosition, referencedMat);\n      Matrix.ComposeToRef(WebXRCamera._ScaleReadOnly, this.rotationQuaternion, this.position, poseMat);\n      referencedMat.invert().multiplyToRef(poseMat, transformMat);\n      transformMat.invert();\n\n      if (!this._scene.useRightHandedSystem) {\n        transformMat.toggleModelMatrixHandInPlace();\n      }\n\n      transformMat.decompose(undefined, this._referenceQuaternion, this._referencedPosition);\n      var transform = new XRRigidTransform({\n        x: this._referencedPosition.x,\n        y: this._referencedPosition.y,\n        z: this._referencedPosition.z\n      }, {\n        x: this._referenceQuaternion.x,\n        y: this._referenceQuaternion.y,\n        z: this._referenceQuaternion.z,\n        w: this._referenceQuaternion.w\n      });\n      this._xrSessionManager.referenceSpace = this._xrSessionManager.referenceSpace.getOffsetReferenceSpace(transform);\n    }\n  };\n\n  WebXRCamera._ScaleReadOnly = Vector3.One();\n  return WebXRCamera;\n}(FreeCamera);\n\nexport { WebXRCamera };","map":{"version":3,"mappings":";;;;;AAAA,SAASA,OAAT,EAAkBC,MAAlB,EAA0BC,UAA1B,EAAsCC,UAAtC,QAAwD,yBAAxD;AAEA,SAASC,MAAT,QAAuB,sBAAvB;AACA,SAASC,UAAT,QAA2B,0BAA3B;AACA,SAASC,YAAT,QAA6B,4BAA7B;AAEA,SAASC,QAAT,QAAyB,2BAAzB;AACA,SAASC,UAAT,QAA2B,uBAA3B;AACA,SAASC,kBAAT,QAAmC,iBAAnC;AAEA;;;;;AAIA;AAAA;AAAA;AAAiCC;AAmC7B;;;;;;;;AAMA,uBAAYC,IAAZ,EAA0BC,KAA1B,EAAgDC,iBAAhD,EAAsF;AAAtF,gBACIC,kBAAMH,IAAN,EAAYX,OAAO,CAACe,IAAR,EAAZ,EAA4BH,KAA5B,KAAkC,IADtC;;AAAgDI;AAtCxCA,wBAAc,KAAd;AACAA,iCAAmCd,UAAU,CAACe,QAAX,EAAnC;AACAD,gCAA+B,IAAIhB,OAAJ,EAA/B;AACAgB,2BAAqCP,kBAAkB,CAACS,YAAxD;AAER;;;;AAGOF,mCAAyB,IAAIR,UAAJ,EAAzB;AAEP;;;;AAGOQ,kCAAwB,IAAIR,UAAJ,EAAxB;AAEP;;;;;AAIOQ,mCAAyB,IAAIR,UAAJ,EAAzB;AACP;;;;;AAIOQ,mCAAkC,IAAlC;AAwHCA,uBAAa,IAAId,UAAJ,CAAe,CAAf,EAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,CAAb,CA1G8E,CAGlF;;AACAc,SAAI,CAACG,IAAL,GAAY,GAAZ;AACAH,SAAI,CAACI,kBAAL,GAA0B,IAAIlB,UAAJ,EAA1B;AACAc,SAAI,CAACK,aAAL,GAAqBjB,MAAM,CAACkB,eAA5B;AACAN,SAAI,CAACO,0BAAL,GAAkC,IAAlC;;AACAP,SAAI,CAACQ,yBAAL,CAA+B,CAA/B,EARkF,CASlF;;;AACAR,SAAI,CAACS,sBAAL;;AAEAT,SAAI,CAACH,iBAAL,CAAuBa,eAAvB,CAAuCC,GAAvC,CAA2C;AACvCX,WAAI,CAACY,mBAAL,CAAyBC,cAAzB,CAAwC,CAAxC,EAA2C,CAA3C,EAA8C,CAA9C;;AACAb,WAAI,CAACc,oBAAL,CAA0BD,cAA1B,CAAyC,CAAzC,EAA4C,CAA5C,EAA+C,CAA/C,EAAkD,CAAlD,EAFuC,CAGvC;;;AACAb,WAAI,CAACe,WAAL,GAAmBf,KAAI,CAACgB,sBAAxB;AACH,KALD,EAZkF,CAmBlF;AACA;;;AACAhB,SAAI,CAACH,iBAAL,CAAuBoB,mBAAvB,CAA2CN,GAA3C,CACI;AACI,UAAIX,KAAI,CAACe,WAAT,EAAsB;AAClBf,aAAI,CAACkB,oBAAL;AACH;;AACDlB,WAAI,CAACmB,qBAAL;;AACAnB,WAAI,CAACkB,oBAAL;AACH,KAPL,EAQIE,SARJ,EASI,IATJ;;;AAWH;;AAKDC,wBAAWC,qBAAX,EAAW,eAAX,EAAwB;AAHxB;;;SAGA;AACI,aAAO,KAAKC,cAAZ;AACH,KAFuB;qBAAA;;AAAA,GAAxB;;AAIQD,4CAAR,UAA0BE,QAA1B,EAAsD;AAClD,QAAI,KAAKD,cAAL,KAAwBC,QAA5B,EAAsC;AAClC,WAAKD,cAAL,GAAsBC,QAAtB;AACA,WAAKC,sBAAL,CAA4BC,eAA5B,CAA4CF,QAA5C;AACH;AACJ,GALO;;AAWRH,wBAAWC,qBAAX,EAAW,iBAAX,EAA0B;AAJ1B;;;;SAIA;AACI,UAAMK,QAAQ,GAAG,KAAK9B,iBAAL,CAAuB+B,YAAvB,IAAuC,KAAK/B,iBAAL,CAAuB+B,YAAvB,CAAoCC,aAApC,CAAkD,KAAKhC,iBAAL,CAAuBiC,kBAAzE,CAAxD;;AACA,UAAIH,QAAQ,IAAIA,QAAQ,CAACI,SAAzB,EAAoC;AAChC,eAAOJ,QAAQ,CAACI,SAAT,CAAmBC,QAAnB,CAA4BC,CAAnC;AACH,OAFD,MAEO;AACH,eAAO,CAAP;AACH;AACJ,KAPyB;qBAAA;;AAAA,GAA1B;AASA;;AACOX,qDAAP;AAAkC;AAAlC,KAA0D;AACtD;AACA,SAAKd,yBAAL,CAA+B,CAA/B;;AACA,SAAK0B,UAAL,CAAgB,CAAhB,EAAmBC,QAAnB,GAA8B,IAAI5C,QAAJ,CAAa,CAAb,EAAgB,CAAhB,EAAmB,GAAnB,EAAwB,GAAxB,CAA9B,CAHsD,CAItD;;AACA,SAAK2C,UAAL,CAAgB,CAAhB,EAAmBE,kBAAnB,GAAwC,IAAxC;AACA,SAAKF,UAAL,CAAgB,CAAhB,EAAmBC,QAAnB,GAA8B,IAAI5C,QAAJ,CAAa,GAAb,EAAkB,CAAlB,EAAqB,GAArB,EAA0B,GAA1B,CAA9B,CANsD,CAOtD;;AACA,SAAK2C,UAAL,CAAgB,CAAhB,EAAmBE,kBAAnB,GAAwC,IAAxC;AACH,GATM;AAWP;;;;;;;AAKOd,2DAAP,UAAwCe,WAAxC,EAA6FC,yBAA7F,EAAsI;AAA9F;AAAAD,oBAAsB,KAAKE,QAAL,GAAgBC,YAAtC;AAAmD;;AAAE;AAAAF;AAAyC;;AAClI,QAAI,CAACD,WAAD,IAAgBA,WAAW,KAAK,IAApC,EAA0C;AACtC;AACH;;AACD,QAAMI,GAAG,GAAGJ,WAAW,CAACK,kBAAZ,EAAZ;AACAD,OAAG,CAACE,SAAJ,CAAcvB,SAAd,EAAyB,KAAKhB,kBAA9B,EAAkD,KAAK4B,QAAvD,EALkI,CAMlI;;AACA,SAAKA,QAAL,CAAcC,CAAd,GAAkB,CAAlB;AACA/C,cAAU,CAAC0D,oBAAX,CAAgC,CAAhC,EAAmC,KAAKxC,kBAAL,CAAwByC,aAAxB,GAAwCZ,CAA3E,EAA8E,CAA9E,EAAiF,KAAK7B,kBAAtF;AACA,SAAKW,WAAL,GAAmB,IAAnB;;AACA,QAAIuB,yBAAJ,EAA+B;AAC3B,WAAKzC,iBAAL,CAAuBiD,mBAAvB;AACH;AACJ,GAbM;AAeP;;;;;;AAIOxB,uCAAP;AACI,WAAO,aAAP;AACH,GAFM;;AAIAA,kCAAP;AACIxB,qBAAMiD,OAAN,CAAaC,IAAb,CAAa,IAAb;;AACA,SAAKC,iBAAL,GAAyB7B,SAAzB;AACH,GAHM;;AAOCE,+CAAR;AAAA;;AACI,QAAM4B,IAAI,GAAG,KAAKrD,iBAAL,CAAuB+B,YAAvB,IAAuC,KAAK/B,iBAAL,CAAuB+B,YAAvB,CAAoCC,aAApC,CAAkD,KAAKhC,iBAAL,CAAuBsD,cAAzE,CAApD;;AACA,SAAKF,iBAAL,GAAyBC,IAAI,IAAI9B,SAAjC;;AACA,QAAI,CAAC8B,IAAL,EAAW;AACP,WAAKE,iBAAL,CAAuB3D,kBAAkB,CAACS,YAA1C;;AACA;AACH,KANL,CAQI;;;AACA,QAAMmD,aAAa,GAAGH,IAAI,CAACI,gBAAL,GAAwB7D,kBAAkB,CAAC8D,aAA3C,GAA2D9D,kBAAkB,CAAC+D,QAApG;;AACA,SAAKJ,iBAAL,CAAuBC,aAAvB;;AAEA,QAAIH,IAAI,CAACnB,SAAT,EAAoB;AAChB,UAAM0B,aAAW,GAAGP,IAAI,CAACnB,SAAL,CAAe2B,WAAnC;;AACA,UAAIR,IAAI,CAACnB,SAAL,CAAe2B,WAAf,CAA2BC,CAA3B,KAAiCvC,SAArC,EAAgD;AAC5C;AACA;AACA;AACH;;AACD,UAAMwC,GAAG,GAAGV,IAAI,CAACnB,SAAL,CAAeC,QAA3B;;AACA,WAAKpB,mBAAL,CAAyBiD,GAAzB,CAA6BD,GAAG,CAACD,CAAjC,EAAoCC,GAAG,CAAC3B,CAAxC,EAA2C2B,GAAG,CAACE,CAA/C;;AAEA,WAAKhD,oBAAL,CAA0B+C,GAA1B,CAA8BJ,aAAW,CAACE,CAA1C,EAA6CF,aAAW,CAACxB,CAAzD,EAA4DwB,aAAW,CAACK,CAAxE,EAA2EL,aAAW,CAACM,CAAvF;;AACA,UAAI,CAAC,KAAKC,MAAL,CAAYC,oBAAjB,EAAuC;AACnC,aAAKrD,mBAAL,CAAyBkD,CAAzB,IAA8B,CAAC,CAA/B;AACA,aAAKhD,oBAAL,CAA0BgD,CAA1B,IAA+B,CAAC,CAAhC;AACA,aAAKhD,oBAAL,CAA0BiD,CAA1B,IAA+B,CAAC,CAAhC;AACH;;AAED,UAAI,KAAKhD,WAAT,EAAsB;AAClB,aAAKA,WAAL,GAAmB,KAAnB,CADkB,CAElB;AACA;AAEA;;AACA,aAAKiB,QAAL,CAAcC,CAAd,IAAmB,KAAKrB,mBAAL,CAAyBqB,CAA5C,CANkB,CAOlB;;AACA,aAAKnB,oBAAL,CAA0BD,cAA1B,CAAyC,CAAzC,EAA4C,CAA5C,EAA+C,CAA/C,EAAkD,CAAlD;AACH,OATD,MASO;AACH;AACA,aAAKT,kBAAL,CAAwB8D,QAAxB,CAAiC,KAAKpD,oBAAtC;AACA,aAAKkB,QAAL,CAAckC,QAAd,CAAuB,KAAKtD,mBAA5B;AACH;AACJ,KA3CL,CA6CI;;;AACA,QAAI,KAAKsB,UAAL,CAAgBiC,MAAhB,KAA2BjB,IAAI,CAACkB,KAAL,CAAWD,MAA1C,EAAkD;AAC9C,WAAK3D,yBAAL,CAA+B0C,IAAI,CAACkB,KAAL,CAAWD,MAA1C;AACH;;AAEDjB,QAAI,CAACkB,KAAL,CAAWC,OAAX,CAAmB,UAACC,IAAD,EAAeC,CAAf,EAAwB;;;AACvC,UAAMC,UAAU,GAAiBxE,KAAI,CAACkC,UAAL,CAAgBqC,CAAhB,CAAjC,CADuC,CAEvC;;AACA,UAAI,CAACC,UAAU,CAACC,YAAZ,IAA4B,CAACD,UAAU,CAACE,aAA5C,EAA2D;AACvD,YAAIJ,IAAI,CAACK,GAAL,KAAa,OAAjB,EAA0B;AACtBH,oBAAU,CAACI,cAAX,GAA4B,IAA5B;AACH,SAFD,MAEO,IAAIN,IAAI,CAACK,GAAL,KAAa,MAAjB,EAAyB;AAC5BH,oBAAU,CAACK,aAAX,GAA2B,IAA3B;AACH;AACJ,OATsC,CAUvC;;;AACA,UAAMjB,GAAG,GAAGU,IAAI,CAACvC,SAAL,CAAeC,QAA3B;AACA,UAAM0B,WAAW,GAAGY,IAAI,CAACvC,SAAL,CAAe2B,WAAnC;AAEAc,gBAAU,CAACM,MAAX,GAAoB9E,KAAI,CAAC8E,MAAzB;AAEAN,gBAAU,CAACxC,QAAX,CAAoB6B,GAApB,CAAwBD,GAAG,CAACD,CAA5B,EAA+BC,GAAG,CAAC3B,CAAnC,EAAsC2B,GAAG,CAACE,CAA1C;AACAU,gBAAU,CAACpE,kBAAX,CAA8ByD,GAA9B,CAAkCH,WAAW,CAACC,CAA9C,EAAiDD,WAAW,CAACzB,CAA7D,EAAgEyB,WAAW,CAACI,CAA5E,EAA+EJ,WAAW,CAACK,CAA3F;;AACA,UAAI,CAAC/D,KAAI,CAACgE,MAAL,CAAYC,oBAAjB,EAAuC;AACnCO,kBAAU,CAACxC,QAAX,CAAoB8B,CAApB,IAAyB,CAAC,CAA1B;AACAU,kBAAU,CAACpE,kBAAX,CAA8B0D,CAA9B,IAAmC,CAAC,CAApC;AACAU,kBAAU,CAACpE,kBAAX,CAA8B2D,CAA9B,IAAmC,CAAC,CAApC;AACH,OAJD,MAIO;AACHS,kBAAU,CAACpE,kBAAX,CAA8B2E,eAA9B,CAA8C/E,KAAI,CAACgF,UAAnD;AACH;;AACD/F,YAAM,CAACgG,2BAAP,CAAmCX,IAAI,CAACY,gBAAxC,EAA0D,CAA1D,EAA6D,CAA7D,EAAgEV,UAAU,CAACW,iBAA3E;;AAEA,UAAI,CAACnF,KAAI,CAACgE,MAAL,CAAYC,oBAAjB,EAAuC;AACnCO,kBAAU,CAACW,iBAAX,CAA6BC,iCAA7B;AACH,OA7BsC,CA+BvC;;;AACA,UAAIb,CAAC,KAAK,CAAV,EAAa;AACTvE,aAAI,CAACmF,iBAAL,CAAuBjB,QAAvB,CAAgCM,UAAU,CAACW,iBAA3C;AACH;;AAED,UAAME,mBAAmB,GAAGrF,KAAI,CAACH,iBAAL,CAAuByF,6BAAvB,CAAqDhB,IAArD,CAA5B;;AACAtE,WAAI,CAACuF,mBAAL,GAA2B,0BAAmB,SAAnB,uBAAmB,WAAnB,GAAmB,MAAnB,sBAAmB,CAAEC,QAArB,MAA6B,IAA7B,IAA6BC,aAA7B,GAA6B,MAA7B,GAA6BA,GAAEC,WAA/B,KAA8C,KAAzE;;AACA,UAAI1F,KAAI,CAACuF,mBAAT,EAA8B;AAC1B;AACA;AACA,YAAIhB,CAAC,IAAI,CAAT,EAAY;AACRvE,eAAI,CAACH,iBAAL,CAAuB8F,qBAAvB,CAA6C3F,KAAI,CAACmC,QAAlD,EAA4DmC,IAA5D;;AACAtE,eAAI,CAACoC,kBAAL,GAA0BiD,mBAA1B;AACH;AACJ,OAPD,MAOO;AACH;AACArF,aAAI,CAACH,iBAAL,CAAuB8F,qBAAvB,CAA6CnB,UAAU,CAACrC,QAAxD,EAAkEmC,IAAlE,EAFG,CAIH;;;AACAE,kBAAU,CAACpC,kBAAX,GAAgCiD,mBAAmB,IAAIrF,KAAI,CAACH,iBAAL,CAAuByF,6BAAvB,CAAqDhB,IAArD,CAAvD;AACH;AACJ,KApDD;AAqDH,GAvGO;;AAyGAhD,oDAAR,UAAkCsE,SAAlC,EAA+C;AAAb;AAAAA;AAAa;;AAC3C,WAAO,KAAK1D,UAAL,CAAgBiC,MAAhB,GAAyByB,SAAhC,EAA2C;AACvC,UAAMC,SAAS,GAAG,IAAIvG,YAAJ,CAAiB,mBAAmB,KAAK4C,UAAL,CAAgBiC,MAApD,EAA4DnF,OAAO,CAACe,IAAR,EAA5D,EAA4E,KAAKwC,QAAL,EAA5E,CAAlB;AACAsD,eAAS,CAAC1F,IAAV,GAAiB,GAAjB;AACA0F,eAAS,CAACzF,kBAAV,GAA+B,IAAIlB,UAAJ,EAA/B;AACA2G,eAAS,CAACtF,0BAAV,GAAuC,IAAvC;AACAsF,eAAS,CAACC,WAAV,GAAwB,IAAxB;AACAD,eAAS,CAACE,SAAV,GAAsB,IAAtB,CANuC,CAOvC;;AACAF,eAAS,CAACpF,sBAAV;AACA,WAAKyB,UAAL,CAAgB8D,IAAhB,CAAqBH,SAArB;AACH;;AACD,WAAO,KAAK3D,UAAL,CAAgBiC,MAAhB,GAAyByB,SAAhC,EAA2C;AACvC,UAAMK,aAAa,GAAG,KAAK/D,UAAL,CAAgBgE,GAAhB,EAAtB;;AACA,UAAID,aAAJ,EAAmB;AACfA,qBAAa,CAAClD,OAAd;AACH;AACJ;AACJ,GAlBO;;AAoBAzB,gDAAR;AACI;AACA,QAAI,CAAC,KAAKU,QAAL,CAAcmE,MAAd,CAAqB,KAAKvF,mBAA1B,CAAD,IAAmD,CAAC,KAAKR,kBAAL,CAAwB+F,MAAxB,CAA+B,KAAKrF,oBAApC,CAAxD,EAAmH;AAC/G,UAAMsF,aAAa,GAAGjH,UAAU,CAACF,MAAX,CAAkB,CAAlB,CAAtB;AACA,UAAMoH,OAAO,GAAGlH,UAAU,CAACF,MAAX,CAAkB,CAAlB,CAAhB;AACA,UAAMqH,YAAY,GAAGnH,UAAU,CAACF,MAAX,CAAkB,CAAlB,CAArB;AAEAA,YAAM,CAACsH,YAAP,CAAoBjF,WAAW,CAACkF,cAAhC,EAAgD,KAAK1F,oBAArD,EAA2E,KAAKF,mBAAhF,EAAqGwF,aAArG;AACAnH,YAAM,CAACsH,YAAP,CAAoBjF,WAAW,CAACkF,cAAhC,EAAgD,KAAKpG,kBAArD,EAAyE,KAAK4B,QAA9E,EAAwFqE,OAAxF;AACAD,mBAAa,CAACK,MAAd,GAAuBC,aAAvB,CAAqCL,OAArC,EAA8CC,YAA9C;AACAA,kBAAY,CAACG,MAAb;;AAEA,UAAI,CAAC,KAAKzC,MAAL,CAAYC,oBAAjB,EAAuC;AACnCqC,oBAAY,CAACK,4BAAb;AACH;;AAEDL,kBAAY,CAAC3D,SAAb,CAAuBvB,SAAvB,EAAkC,KAAKN,oBAAvC,EAA6D,KAAKF,mBAAlE;AACA,UAAMmB,SAAS,GAAG,IAAI6E,gBAAJ,CACd;AACIjD,SAAC,EAAE,KAAK/C,mBAAL,CAAyB+C,CADhC;AAEI1B,SAAC,EAAE,KAAKrB,mBAAL,CAAyBqB,CAFhC;AAGI6B,SAAC,EAAE,KAAKlD,mBAAL,CAAyBkD;AAHhC,OADc,EAMd;AACIH,SAAC,EAAE,KAAK7C,oBAAL,CAA0B6C,CADjC;AAEI1B,SAAC,EAAE,KAAKnB,oBAAL,CAA0BmB,CAFjC;AAGI6B,SAAC,EAAE,KAAKhD,oBAAL,CAA0BgD,CAHjC;AAIIC,SAAC,EAAE,KAAKjD,oBAAL,CAA0BiD;AAJjC,OANc,CAAlB;AAaA,WAAKlE,iBAAL,CAAuBsD,cAAvB,GAAwC,KAAKtD,iBAAL,CAAuBsD,cAAvB,CAAsC0D,uBAAtC,CAA8D9E,SAA9D,CAAxC;AACH;AACJ,GAhCO;;AAjROT,+BAAiBtC,OAAO,CAAC8H,GAAR,EAAjB;AAkTnB;AAAC,CAnTD,CAAiCzH,UAAjC;;SAAaiC","names":["Vector3","Matrix","Quaternion","TmpVectors","Camera","FreeCamera","TargetCamera","Viewport","Observable","WebXRTrackingState","__extends","name","scene","_xrSessionManager","_super","Zero","_this","Identity","NOT_TRACKING","minZ","rotationQuaternion","cameraRigMode","RIG_MODE_CUSTOM","updateUpVectorFromRotation","_updateNumberOfRigCameras","freezeProjectionMatrix","onXRSessionInit","add","_referencedPosition","copyFromFloats","_referenceQuaternion","_firstFrame","compensateOnFirstFrame","onXRFrameObservable","_updateFromXRSession","_updateReferenceSpace","undefined","Object","WebXRCamera","_trackingState","newState","onTrackingStateChanged","notifyObservers","basePose","currentFrame","getViewerPose","baseReferenceSpace","transform","position","y","rigCameras","viewport","outputRenderTarget","otherCamera","resetToBaseReferenceSpace","getScene","activeCamera","mat","computeWorldMatrix","decompose","FromEulerAnglesToRef","toEulerAngles","resetReferenceSpace","dispose","call","_lastXRViewerPose","pose","referenceSpace","_setTrackingState","trackingState","emulatedPosition","TRACKING_LOST","TRACKING","orientation_1","orientation","x","pos","set","z","w","_scene","useRightHandedSystem","copyFrom","length","views","forEach","view","i","currentRig","isLeftCamera","isRightCamera","eye","_isRightCamera","_isLeftCamera","parent","multiplyInPlace","_rotate180","FromFloat32ArrayToRefScaled","projectionMatrix","_projectionMatrix","toggleProjectionMatrixHandInPlace","renderTargetTexture","getRenderTargetTextureForView","_renderingMultiview","_texture","_a","isMultiview","trySetViewportForView","viewCount","newCamera","isRigCamera","rigParent","push","removedCamera","pop","equals","referencedMat","poseMat","transformMat","ComposeToRef","_ScaleReadOnly","invert","multiplyToRef","toggleModelMatrixHandInPlace","XRRigidTransform","getOffsetReferenceSpace","One"],"sourceRoot":"","sources":["../../../../../lts/core/generated/XR/webXRCamera.ts"],"sourcesContent":["import { Vector3, Matrix, Quaternion, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { FreeCamera } from \"../Cameras/freeCamera\";\r\nimport { TargetCamera } from \"../Cameras/targetCamera\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { Viewport } from \"../Maths/math.viewport\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { WebXRTrackingState } from \"./webXRTypes\";\r\n\r\n/**\r\n * WebXR Camera which holds the views for the xrSession\r\n * @see https://doc.babylonjs.com/how_to/webxr_camera\r\n */\r\nexport class WebXRCamera extends FreeCamera {\r\n    private static _ScaleReadOnly = Vector3.One();\r\n\r\n    private _firstFrame = false;\r\n    private _referenceQuaternion: Quaternion = Quaternion.Identity();\r\n    private _referencedPosition: Vector3 = new Vector3();\r\n    private _trackingState: WebXRTrackingState = WebXRTrackingState.NOT_TRACKING;\r\n\r\n    /**\r\n     * Observable raised before camera teleportation\r\n     */\r\n    public onBeforeCameraTeleport = new Observable<Vector3>();\r\n\r\n    /**\r\n     *  Observable raised after camera teleportation\r\n     */\r\n    public onAfterCameraTeleport = new Observable<Vector3>();\r\n\r\n    /**\r\n     * Notifies when the camera's tracking state has changed.\r\n     * Notice - will also be triggered when tracking has started (at the beginning of the session)\r\n     */\r\n    public onTrackingStateChanged = new Observable<WebXRTrackingState>();\r\n    /**\r\n     * Should position compensation execute on first frame.\r\n     * This is used when copying the position from a native (non XR) camera\r\n     */\r\n    public compensateOnFirstFrame: boolean = true;\r\n\r\n    /**\r\n     * The last XRViewerPose from the current XRFrame\r\n     * @hidden\r\n     */\r\n    public _lastXRViewerPose?: XRViewerPose;\r\n\r\n    /**\r\n     * Creates a new webXRCamera, this should only be set at the camera after it has been updated by the xrSessionManager\r\n     * @param name the name of the camera\r\n     * @param scene the scene to add the camera to\r\n     * @param _xrSessionManager a constructed xr session manager\r\n     */\r\n    constructor(name: string, scene: Scene, private _xrSessionManager: WebXRSessionManager) {\r\n        super(name, Vector3.Zero(), scene);\r\n\r\n        // Initial camera configuration\r\n        this.minZ = 0.1;\r\n        this.rotationQuaternion = new Quaternion();\r\n        this.cameraRigMode = Camera.RIG_MODE_CUSTOM;\r\n        this.updateUpVectorFromRotation = true;\r\n        this._updateNumberOfRigCameras(1);\r\n        // freeze projection matrix, which will be copied later\r\n        this.freezeProjectionMatrix();\r\n\r\n        this._xrSessionManager.onXRSessionInit.add(() => {\r\n            this._referencedPosition.copyFromFloats(0, 0, 0);\r\n            this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);\r\n            // first frame - camera's y position should be 0 for the correct offset\r\n            this._firstFrame = this.compensateOnFirstFrame;\r\n        });\r\n\r\n        // Check transformation changes on each frame. Callback is added to be first so that the transformation will be\r\n        // applied to the rest of the elements using the referenceSpace object\r\n        this._xrSessionManager.onXRFrameObservable.add(\r\n            () => {\r\n                if (this._firstFrame) {\r\n                    this._updateFromXRSession();\r\n                }\r\n                this._updateReferenceSpace();\r\n                this._updateFromXRSession();\r\n            },\r\n            undefined,\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the current XR tracking state of the camera\r\n     */\r\n    public get trackingState(): WebXRTrackingState {\r\n        return this._trackingState;\r\n    }\r\n\r\n    private _setTrackingState(newState: WebXRTrackingState) {\r\n        if (this._trackingState !== newState) {\r\n            this._trackingState = newState;\r\n            this.onTrackingStateChanged.notifyObservers(newState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the user's height, unrelated to the current ground.\r\n     * This will be the y position of this camera, when ground level is 0.\r\n     */\r\n    public get realWorldHeight(): number {\r\n        const basePose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.baseReferenceSpace);\r\n        if (basePose && basePose.transform) {\r\n            return basePose.transform.position.y;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _updateForDualEyeDebugging(/*pupilDistance = 0.01*/) {\r\n        // Create initial camera rigs\r\n        this._updateNumberOfRigCameras(2);\r\n        this.rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0);\r\n        // this.rigCameras[0].position.x = -pupilDistance / 2;\r\n        this.rigCameras[0].outputRenderTarget = null;\r\n        this.rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);\r\n        // this.rigCameras[1].position.x = pupilDistance / 2;\r\n        this.rigCameras[1].outputRenderTarget = null;\r\n    }\r\n\r\n    /**\r\n     * Sets this camera's transformation based on a non-vr camera\r\n     * @param otherCamera the non-vr camera to copy the transformation from\r\n     * @param resetToBaseReferenceSpace should XR reset to the base reference space\r\n     */\r\n    public setTransformationFromNonVRCamera(otherCamera: Camera = this.getScene().activeCamera!, resetToBaseReferenceSpace: boolean = true) {\r\n        if (!otherCamera || otherCamera === this) {\r\n            return;\r\n        }\r\n        const mat = otherCamera.computeWorldMatrix();\r\n        mat.decompose(undefined, this.rotationQuaternion, this.position);\r\n        // set the ground level\r\n        this.position.y = 0;\r\n        Quaternion.FromEulerAnglesToRef(0, this.rotationQuaternion.toEulerAngles().y, 0, this.rotationQuaternion);\r\n        this._firstFrame = true;\r\n        if (resetToBaseReferenceSpace) {\r\n            this._xrSessionManager.resetReferenceSpace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current instance class name (\"WebXRCamera\").\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"WebXRCamera\";\r\n    }\r\n\r\n    public dispose() {\r\n        super.dispose();\r\n        this._lastXRViewerPose = undefined;\r\n    }\r\n\r\n    private _rotate180 = new Quaternion(0, 1, 0, 0);\r\n\r\n    private _updateFromXRSession() {\r\n        const pose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.referenceSpace);\r\n        this._lastXRViewerPose = pose || undefined;\r\n        if (!pose) {\r\n            this._setTrackingState(WebXRTrackingState.NOT_TRACKING);\r\n            return;\r\n        }\r\n\r\n        // Set the tracking state. if it didn't change it is a no-op\r\n        const trackingState = pose.emulatedPosition ? WebXRTrackingState.TRACKING_LOST : WebXRTrackingState.TRACKING;\r\n        this._setTrackingState(trackingState);\r\n\r\n        if (pose.transform) {\r\n            const orientation = pose.transform.orientation;\r\n            if (pose.transform.orientation.x === undefined) {\r\n                // Babylon native polyfill can return an undefined orientation value\r\n                // When not initialized\r\n                return;\r\n            }\r\n            const pos = pose.transform.position;\r\n            this._referencedPosition.set(pos.x, pos.y, pos.z);\r\n\r\n            this._referenceQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                this._referencedPosition.z *= -1;\r\n                this._referenceQuaternion.z *= -1;\r\n                this._referenceQuaternion.w *= -1;\r\n            }\r\n\r\n            if (this._firstFrame) {\r\n                this._firstFrame = false;\r\n                // we have the XR reference, now use this to find the offset to get the camera to be\r\n                // in the right position\r\n\r\n                // set the height to correlate to the current height\r\n                this.position.y += this._referencedPosition.y;\r\n                // avoid using the head rotation on the first frame.\r\n                this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);\r\n            } else {\r\n                // update position and rotation as reference\r\n                this.rotationQuaternion.copyFrom(this._referenceQuaternion);\r\n                this.position.copyFrom(this._referencedPosition);\r\n            }\r\n        }\r\n\r\n        // Update camera rigs\r\n        if (this.rigCameras.length !== pose.views.length) {\r\n            this._updateNumberOfRigCameras(pose.views.length);\r\n        }\r\n\r\n        pose.views.forEach((view: XRView, i: number) => {\r\n            const currentRig = <TargetCamera>this.rigCameras[i];\r\n            // update right and left, where applicable\r\n            if (!currentRig.isLeftCamera && !currentRig.isRightCamera) {\r\n                if (view.eye === \"right\") {\r\n                    currentRig._isRightCamera = true;\r\n                } else if (view.eye === \"left\") {\r\n                    currentRig._isLeftCamera = true;\r\n                }\r\n            }\r\n            // Update view/projection matrix\r\n            const pos = view.transform.position;\r\n            const orientation = view.transform.orientation;\r\n\r\n            currentRig.parent = this.parent;\r\n\r\n            currentRig.position.set(pos.x, pos.y, pos.z);\r\n            currentRig.rotationQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                currentRig.position.z *= -1;\r\n                currentRig.rotationQuaternion.z *= -1;\r\n                currentRig.rotationQuaternion.w *= -1;\r\n            } else {\r\n                currentRig.rotationQuaternion.multiplyInPlace(this._rotate180);\r\n            }\r\n            Matrix.FromFloat32ArrayToRefScaled(view.projectionMatrix, 0, 1, currentRig._projectionMatrix);\r\n\r\n            if (!this._scene.useRightHandedSystem) {\r\n                currentRig._projectionMatrix.toggleProjectionMatrixHandInPlace();\r\n            }\r\n\r\n            // first camera?\r\n            if (i === 0) {\r\n                this._projectionMatrix.copyFrom(currentRig._projectionMatrix);\r\n            }\r\n\r\n            const renderTargetTexture = this._xrSessionManager.getRenderTargetTextureForView(view);\r\n            this._renderingMultiview = renderTargetTexture?._texture?.isMultiview || false;\r\n            if (this._renderingMultiview) {\r\n                // For multiview, the render target texture is the same per-view (just the slice index is different),\r\n                // so we only need to set the output render target once for the rig parent.\r\n                if (i == 0) {\r\n                    this._xrSessionManager.trySetViewportForView(this.viewport, view);\r\n                    this.outputRenderTarget = renderTargetTexture;\r\n                }\r\n            } else {\r\n                // Update viewport\r\n                this._xrSessionManager.trySetViewportForView(currentRig.viewport, view);\r\n\r\n                // Set cameras to render to the session's render target\r\n                currentRig.outputRenderTarget = renderTargetTexture || this._xrSessionManager.getRenderTargetTextureForView(view);\r\n            }\r\n        });\r\n    }\r\n\r\n    private _updateNumberOfRigCameras(viewCount = 1) {\r\n        while (this.rigCameras.length < viewCount) {\r\n            const newCamera = new TargetCamera(\"XR-RigCamera: \" + this.rigCameras.length, Vector3.Zero(), this.getScene());\r\n            newCamera.minZ = 0.1;\r\n            newCamera.rotationQuaternion = new Quaternion();\r\n            newCamera.updateUpVectorFromRotation = true;\r\n            newCamera.isRigCamera = true;\r\n            newCamera.rigParent = this;\r\n            // do not compute projection matrix, provided by XR\r\n            newCamera.freezeProjectionMatrix();\r\n            this.rigCameras.push(newCamera);\r\n        }\r\n        while (this.rigCameras.length > viewCount) {\r\n            const removedCamera = this.rigCameras.pop();\r\n            if (removedCamera) {\r\n                removedCamera.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _updateReferenceSpace() {\r\n        // were position & rotation updated OUTSIDE of the xr update loop\r\n        if (!this.position.equals(this._referencedPosition) || !this.rotationQuaternion.equals(this._referenceQuaternion)) {\r\n            const referencedMat = TmpVectors.Matrix[0];\r\n            const poseMat = TmpVectors.Matrix[1];\r\n            const transformMat = TmpVectors.Matrix[2];\r\n\r\n            Matrix.ComposeToRef(WebXRCamera._ScaleReadOnly, this._referenceQuaternion, this._referencedPosition, referencedMat);\r\n            Matrix.ComposeToRef(WebXRCamera._ScaleReadOnly, this.rotationQuaternion, this.position, poseMat);\r\n            referencedMat.invert().multiplyToRef(poseMat, transformMat);\r\n            transformMat.invert();\r\n\r\n            if (!this._scene.useRightHandedSystem) {\r\n                transformMat.toggleModelMatrixHandInPlace();\r\n            }\r\n\r\n            transformMat.decompose(undefined, this._referenceQuaternion, this._referencedPosition);\r\n            const transform = new XRRigidTransform(\r\n                {\r\n                    x: this._referencedPosition.x,\r\n                    y: this._referencedPosition.y,\r\n                    z: this._referencedPosition.z,\r\n                },\r\n                {\r\n                    x: this._referenceQuaternion.x,\r\n                    y: this._referenceQuaternion.y,\r\n                    z: this._referenceQuaternion.z,\r\n                    w: this._referenceQuaternion.w,\r\n                }\r\n            );\r\n            this._xrSessionManager.referenceSpace = this._xrSessionManager.referenceSpace.getOffsetReferenceSpace(transform);\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}