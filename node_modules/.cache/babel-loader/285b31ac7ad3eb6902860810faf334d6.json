{"ast":null,"code":"import \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { __extends } from \"tslib\";\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * The currently-working hit-test module.\n * Hit test (or Ray-casting) is used to interact with the real world.\n * For further information read here - https://github.com/immersive-web/hit-test\n *\n * Tested on chrome (mobile) 80.\n */\n\nvar WebXRHitTest =\n/** @class */\nfunction (_super) {\n  __extends(WebXRHitTest, _super);\n  /**\n   * Creates a new instance of the hit test feature\n   * @param _xrSessionManager an instance of WebXRSessionManager\n   * @param options options to use when constructing this feature\n   */\n\n\n  function WebXRHitTest(_xrSessionManager,\n  /**\n   * options to use when constructing this feature\n   */\n  options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this.options = options;\n    _this._tmpMat = new Matrix();\n    _this._tmpPos = new Vector3();\n    _this._tmpQuat = new Quaternion();\n\n    _this._initHitTestSource = function (referenceSpace) {\n      if (!referenceSpace) {\n        return;\n      }\n\n      var offsetRay = new XRRay(_this.options.offsetRay || {});\n      var hitTestOptions = {\n        space: _this.options.useReferenceSpace ? referenceSpace : _this._xrSessionManager.viewerReferenceSpace,\n        offsetRay: offsetRay\n      };\n\n      if (_this.options.entityTypes) {\n        hitTestOptions.entityTypes = _this.options.entityTypes;\n      }\n\n      if (!hitTestOptions.space) {\n        Tools.Warn(\"waiting for viewer reference space to initialize\");\n        return;\n      }\n\n      _this._xrSessionManager.session.requestHitTestSource(hitTestOptions).then(function (hitTestSource) {\n        if (_this._xrHitTestSource) {\n          _this._xrHitTestSource.cancel();\n        }\n\n        _this._xrHitTestSource = hitTestSource;\n      });\n    };\n    /**\n     * When set to true, each hit test will have its own position/rotation objects\n     * When set to false, position and rotation objects will be reused for each hit test. It is expected that\n     * the developers will clone them or copy them as they see fit.\n     */\n\n\n    _this.autoCloneTransformation = false;\n    /**\n     * Triggered when new babylon (transformed) hit test results are available\n     * Note - this will be called when results come back from the device. It can be an empty array!!\n     */\n\n    _this.onHitTestResultObservable = new Observable();\n    /**\n     * Use this to temporarily pause hit test checks.\n     */\n\n    _this.paused = false;\n    _this.xrNativeFeatureName = \"hit-test\";\n    Tools.Warn(\"Hit test is an experimental and unstable feature.\");\n    return _this;\n  }\n  /**\n   * attach this feature\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n\n\n  WebXRHitTest.prototype.attach = function () {\n    var _this = this;\n\n    if (!_super.prototype.attach.call(this)) {\n      return false;\n    } // Feature enabled, but not available\n\n\n    if (!this._xrSessionManager.session.requestHitTestSource) {\n      return false;\n    }\n\n    if (!this.options.disablePermanentHitTest) {\n      if (this._xrSessionManager.referenceSpace) {\n        this._initHitTestSource(this._xrSessionManager.referenceSpace);\n      }\n\n      this._xrSessionManager.onXRReferenceSpaceChanged.add(this._initHitTestSource);\n    }\n\n    if (this.options.enableTransientHitTest) {\n      var offsetRay = new XRRay(this.options.transientOffsetRay || {});\n\n      this._xrSessionManager.session.requestHitTestSourceForTransientInput({\n        profile: this.options.transientHitTestProfile || \"generic-touchscreen\",\n        offsetRay: offsetRay,\n        entityTypes: this.options.entityTypes\n      }).then(function (hitSource) {\n        _this._transientXrHitTestSource = hitSource;\n      });\n    }\n\n    return true;\n  };\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n\n\n  WebXRHitTest.prototype.detach = function () {\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    }\n\n    if (this._xrHitTestSource) {\n      this._xrHitTestSource.cancel();\n\n      this._xrHitTestSource = null;\n    }\n\n    this._xrSessionManager.onXRReferenceSpaceChanged.removeCallback(this._initHitTestSource);\n\n    if (this._transientXrHitTestSource) {\n      this._transientXrHitTestSource.cancel();\n\n      this._transientXrHitTestSource = null;\n    }\n\n    return true;\n  };\n  /**\n   * Dispose this feature and all of the resources attached\n   */\n\n\n  WebXRHitTest.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.onHitTestResultObservable.clear();\n  };\n\n  WebXRHitTest.prototype._onXRFrame = function (frame) {\n    var _this = this; // make sure we do nothing if (async) not attached\n\n\n    if (!this.attached || this.paused) {\n      return;\n    }\n\n    if (this._xrHitTestSource) {\n      var results = frame.getHitTestResults(this._xrHitTestSource);\n\n      this._processWebXRHitTestResult(results);\n    }\n\n    if (this._transientXrHitTestSource) {\n      var hitTestResultsPerInputSource = frame.getHitTestResultsForTransientInput(this._transientXrHitTestSource);\n      hitTestResultsPerInputSource.forEach(function (resultsPerInputSource) {\n        _this._processWebXRHitTestResult(resultsPerInputSource.results, resultsPerInputSource.inputSource);\n      });\n    }\n  };\n\n  WebXRHitTest.prototype._processWebXRHitTestResult = function (hitTestResults, inputSource) {\n    var _this = this;\n\n    var results = [];\n    hitTestResults.forEach(function (hitTestResult) {\n      var pose = hitTestResult.getPose(_this._xrSessionManager.referenceSpace);\n\n      if (!pose) {\n        return;\n      }\n\n      var pos = pose.transform.position;\n      var quat = pose.transform.orientation;\n\n      _this._tmpPos.set(pos.x, pos.y, pos.z);\n\n      _this._tmpQuat.set(quat.x, quat.y, quat.z, quat.w);\n\n      Matrix.FromFloat32ArrayToRefScaled(pose.transform.matrix, 0, 1, _this._tmpMat);\n\n      if (!_this._xrSessionManager.scene.useRightHandedSystem) {\n        _this._tmpPos.z *= -1;\n        _this._tmpQuat.z *= -1;\n        _this._tmpQuat.w *= -1;\n\n        _this._tmpMat.toggleModelMatrixHandInPlace();\n      }\n\n      var result = {\n        position: _this.autoCloneTransformation ? _this._tmpPos.clone() : _this._tmpPos,\n        rotationQuaternion: _this.autoCloneTransformation ? _this._tmpQuat.clone() : _this._tmpQuat,\n        transformationMatrix: _this.autoCloneTransformation ? _this._tmpMat.clone() : _this._tmpMat,\n        inputSource: inputSource,\n        isTransient: !!inputSource,\n        xrHitResult: hitTestResult\n      };\n      results.push(result);\n    });\n    this.onHitTestResultObservable.notifyObservers(results);\n  };\n  /**\n   * The module's name\n   */\n\n\n  WebXRHitTest.Name = WebXRFeatureName.HIT_TEST;\n  /**\n   * The (Babylon) version of this module.\n   * This is an integer representing the implementation version.\n   * This number does not correspond to the WebXR specs version\n   */\n\n  WebXRHitTest.Version = 2;\n  return WebXRHitTest;\n}(WebXRAbstractFeature);\n\nexport { WebXRHitTest }; //register the plugin versions\n\nWebXRFeaturesManager.AddWebXRFeature(WebXRHitTest.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRHitTest(xrSessionManager, options);\n  };\n}, WebXRHitTest.Version, false);","map":{"version":3,"mappings":"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","names":["WebXRFeaturesManager","WebXRFeatureName","Observable","Vector3","Matrix","Quaternion","WebXRAbstractFeature","Tools","__extends","_xrSessionManager","options","_super","_this","referenceSpace","offsetRay","XRRay","hitTestOptions","space","useReferenceSpace","viewerReferenceSpace","entityTypes","Warn","session","requestHitTestSource","then","hitTestSource","_xrHitTestSource","cancel","xrNativeFeatureName","WebXRHitTest","attach","call","disablePermanentHitTest","_initHitTestSource","onXRReferenceSpaceChanged","add","enableTransientHitTest","transientOffsetRay","requestHitTestSourceForTransientInput","profile","transientHitTestProfile","hitSource","_transientXrHitTestSource","detach","removeCallback","dispose","onHitTestResultObservable","clear","frame","attached","paused","results","getHitTestResults","_processWebXRHitTestResult","hitTestResultsPerInputSource","getHitTestResultsForTransientInput","forEach","resultsPerInputSource","inputSource","hitTestResults","hitTestResult","pose","getPose","pos","transform","position","quat","orientation","_tmpPos","set","x","y","z","_tmpQuat","w","FromFloat32ArrayToRefScaled","matrix","_tmpMat","scene","useRightHandedSystem","toggleModelMatrixHandInPlace","result","autoCloneTransformation","clone","rotationQuaternion","transformationMatrix","isTransient","xrHitResult","push","notifyObservers","HIT_TEST","AddWebXRFeature","Name","xrSessionManager","Version"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/XR/features/WebXRHitTest.ts"],"sourcesContent":["import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { IWebXRLegacyHitTestOptions, IWebXRLegacyHitResult, IWebXRHitTestFeature } from \"./WebXRHitTestLegacy\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Options used for hit testing (version 2)\r\n */\r\nexport interface IWebXRHitTestOptions extends IWebXRLegacyHitTestOptions {\r\n    /**\r\n     * Do not create a permanent hit test. Will usually be used when only\r\n     * transient inputs are needed.\r\n     */\r\n    disablePermanentHitTest?: boolean;\r\n    /**\r\n     * Enable transient (for example touch-based) hit test inspections\r\n     */\r\n    enableTransientHitTest?: boolean;\r\n    /**\r\n     * Override the default transient hit test profile (generic-touchscreen).\r\n     */\r\n    transientHitTestProfile?: string;\r\n    /**\r\n     * Offset ray for the permanent hit test\r\n     */\r\n    offsetRay?: Vector3;\r\n    /**\r\n     * Offset ray for the transient hit test\r\n     */\r\n    transientOffsetRay?: Vector3;\r\n    /**\r\n     * Instead of using viewer space for hit tests, use the reference space defined in the session manager\r\n     */\r\n    useReferenceSpace?: boolean;\r\n\r\n    /**\r\n     * Override the default entity type(s) of the hit-test result\r\n     */\r\n    entityTypes?: XRHitTestTrackableType[];\r\n}\r\n\r\n/**\r\n * Interface defining the babylon result of hit-test\r\n */\r\nexport interface IWebXRHitResult extends IWebXRLegacyHitResult {\r\n    /**\r\n     * The input source that generated this hit test (if transient)\r\n     */\r\n    inputSource?: XRInputSource;\r\n    /**\r\n     * Is this a transient hit test\r\n     */\r\n    isTransient?: boolean;\r\n    /**\r\n     * Position of the hit test result\r\n     */\r\n    position: Vector3;\r\n    /**\r\n     * Rotation of the hit test result\r\n     */\r\n    rotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * The native hit test result\r\n     */\r\n    xrHitResult: XRHitTestResult;\r\n}\r\n\r\n/**\r\n * The currently-working hit-test module.\r\n * Hit test (or Ray-casting) is used to interact with the real world.\r\n * For further information read here - https://github.com/immersive-web/hit-test\r\n *\r\n * Tested on chrome (mobile) 80.\r\n */\r\nexport class WebXRHitTest extends WebXRAbstractFeature implements IWebXRHitTestFeature<IWebXRHitResult> {\r\n    private _tmpMat: Matrix = new Matrix();\r\n    private _tmpPos: Vector3 = new Vector3();\r\n    private _tmpQuat: Quaternion = new Quaternion();\r\n    private _transientXrHitTestSource: Nullable<XRTransientInputHitTestSource>;\r\n    // in XR space z-forward is negative\r\n    private _xrHitTestSource: Nullable<XRHitTestSource>;\r\n    private _initHitTestSource = (referenceSpace: XRReferenceSpace) => {\r\n        if (!referenceSpace) {\r\n            return;\r\n        }\r\n        const offsetRay = new XRRay(this.options.offsetRay || {});\r\n        const hitTestOptions: XRHitTestOptionsInit = {\r\n            space: this.options.useReferenceSpace ? referenceSpace : this._xrSessionManager.viewerReferenceSpace,\r\n            offsetRay: offsetRay,\r\n        };\r\n        if (this.options.entityTypes) {\r\n            hitTestOptions.entityTypes = this.options.entityTypes;\r\n        }\r\n        if (!hitTestOptions.space) {\r\n            Tools.Warn(\"waiting for viewer reference space to initialize\");\r\n            return;\r\n        }\r\n        this._xrSessionManager.session.requestHitTestSource!(hitTestOptions).then((hitTestSource) => {\r\n            if (this._xrHitTestSource) {\r\n                this._xrHitTestSource.cancel();\r\n            }\r\n            this._xrHitTestSource = hitTestSource;\r\n        });\r\n    };\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.HIT_TEST;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 2;\r\n\r\n    /**\r\n     * When set to true, each hit test will have its own position/rotation objects\r\n     * When set to false, position and rotation objects will be reused for each hit test. It is expected that\r\n     * the developers will clone them or copy them as they see fit.\r\n     */\r\n    public autoCloneTransformation: boolean = false;\r\n    /**\r\n     * Triggered when new babylon (transformed) hit test results are available\r\n     * Note - this will be called when results come back from the device. It can be an empty array!!\r\n     */\r\n    public onHitTestResultObservable: Observable<IWebXRHitResult[]> = new Observable();\r\n    /**\r\n     * Use this to temporarily pause hit test checks.\r\n     */\r\n    public paused: boolean = false;\r\n\r\n    /**\r\n     * Creates a new instance of the hit test feature\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param options options to use when constructing this feature\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        /**\r\n         * options to use when constructing this feature\r\n         */\r\n        public readonly options: IWebXRHitTestOptions = {}\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"hit-test\";\r\n        Tools.Warn(\"Hit test is an experimental and unstable feature.\");\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        // Feature enabled, but not available\r\n        if (!this._xrSessionManager.session.requestHitTestSource) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.options.disablePermanentHitTest) {\r\n            if (this._xrSessionManager.referenceSpace) {\r\n                this._initHitTestSource(this._xrSessionManager.referenceSpace);\r\n            }\r\n            this._xrSessionManager.onXRReferenceSpaceChanged.add(this._initHitTestSource);\r\n        }\r\n        if (this.options.enableTransientHitTest) {\r\n            const offsetRay = new XRRay(this.options.transientOffsetRay || {});\r\n            this._xrSessionManager.session.requestHitTestSourceForTransientInput!({\r\n                profile: this.options.transientHitTestProfile || \"generic-touchscreen\",\r\n                offsetRay,\r\n                entityTypes: this.options.entityTypes,\r\n            }).then((hitSource) => {\r\n                this._transientXrHitTestSource = hitSource;\r\n            });\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n        if (this._xrHitTestSource) {\r\n            this._xrHitTestSource.cancel();\r\n            this._xrHitTestSource = null;\r\n        }\r\n        this._xrSessionManager.onXRReferenceSpaceChanged.removeCallback(this._initHitTestSource);\r\n        if (this._transientXrHitTestSource) {\r\n            this._transientXrHitTestSource.cancel();\r\n            this._transientXrHitTestSource = null;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this.onHitTestResultObservable.clear();\r\n    }\r\n\r\n    protected _onXRFrame(frame: XRFrame) {\r\n        // make sure we do nothing if (async) not attached\r\n        if (!this.attached || this.paused) {\r\n            return;\r\n        }\r\n\r\n        if (this._xrHitTestSource) {\r\n            const results = frame.getHitTestResults(this._xrHitTestSource);\r\n            this._processWebXRHitTestResult(results);\r\n        }\r\n        if (this._transientXrHitTestSource) {\r\n            const hitTestResultsPerInputSource = frame.getHitTestResultsForTransientInput(this._transientXrHitTestSource);\r\n\r\n            hitTestResultsPerInputSource.forEach((resultsPerInputSource) => {\r\n                this._processWebXRHitTestResult(resultsPerInputSource.results, resultsPerInputSource.inputSource);\r\n            });\r\n        }\r\n    }\r\n\r\n    private _processWebXRHitTestResult(hitTestResults: XRHitTestResult[], inputSource?: XRInputSource) {\r\n        const results: IWebXRHitResult[] = [];\r\n        hitTestResults.forEach((hitTestResult) => {\r\n            const pose = hitTestResult.getPose(this._xrSessionManager.referenceSpace);\r\n            if (!pose) {\r\n                return;\r\n            }\r\n            const pos = pose.transform.position;\r\n            const quat = pose.transform.orientation;\r\n            this._tmpPos.set(pos.x, pos.y, pos.z);\r\n            this._tmpQuat.set(quat.x, quat.y, quat.z, quat.w);\r\n            Matrix.FromFloat32ArrayToRefScaled(pose.transform.matrix, 0, 1, this._tmpMat);\r\n            if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                this._tmpPos.z *= -1;\r\n                this._tmpQuat.z *= -1;\r\n                this._tmpQuat.w *= -1;\r\n                this._tmpMat.toggleModelMatrixHandInPlace();\r\n            }\r\n\r\n            const result: IWebXRHitResult = {\r\n                position: this.autoCloneTransformation ? this._tmpPos.clone() : this._tmpPos,\r\n                rotationQuaternion: this.autoCloneTransformation ? this._tmpQuat.clone() : this._tmpQuat,\r\n                transformationMatrix: this.autoCloneTransformation ? this._tmpMat.clone() : this._tmpMat,\r\n                inputSource: inputSource,\r\n                isTransient: !!inputSource,\r\n                xrHitResult: hitTestResult,\r\n            };\r\n            results.push(result);\r\n        });\r\n\r\n        this.onHitTestResultObservable.notifyObservers(results);\r\n    }\r\n}\r\n\r\n//register the plugin versions\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRHitTest.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRHitTest(xrSessionManager, options);\r\n    },\r\n    WebXRHitTest.Version,\r\n    false\r\n);\r\n"]},"metadata":{},"sourceType":"module"}