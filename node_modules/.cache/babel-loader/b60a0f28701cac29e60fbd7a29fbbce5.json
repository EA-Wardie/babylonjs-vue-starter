{"ast":null,"code":"import \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Scene } from \"../scene.js\";\nimport { Ray } from \"../Culling/ray.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { ActionEvent } from \"../Actions/actionEvent.js\";\n\nScene.prototype._internalPickSprites = function (ray, predicate, fastCheck, camera) {\n  if (!PickingInfo) {\n    return null;\n  }\n\n  var pickingInfo = null;\n\n  if (!camera) {\n    if (!this.activeCamera) {\n      return null;\n    }\n\n    camera = this.activeCamera;\n  }\n\n  if (this.spriteManagers.length > 0) {\n    for (var spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\n      var spriteManager = this.spriteManagers[spriteIndex];\n\n      if (!spriteManager.isPickable) {\n        continue;\n      }\n\n      var result = spriteManager.intersects(ray, camera, predicate, fastCheck);\n\n      if (!result || !result.hit) {\n        continue;\n      }\n\n      if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\n        continue;\n      }\n\n      pickingInfo = result;\n\n      if (fastCheck) {\n        break;\n      }\n    }\n  }\n\n  return pickingInfo || new PickingInfo();\n};\n\nScene.prototype._internalMultiPickSprites = function (ray, predicate, camera) {\n  if (!PickingInfo) {\n    return null;\n  }\n\n  var pickingInfos = new Array();\n\n  if (!camera) {\n    if (!this.activeCamera) {\n      return null;\n    }\n\n    camera = this.activeCamera;\n  }\n\n  if (this.spriteManagers.length > 0) {\n    for (var spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\n      var spriteManager = this.spriteManagers[spriteIndex];\n\n      if (!spriteManager.isPickable) {\n        continue;\n      }\n\n      var results = spriteManager.multiIntersects(ray, camera, predicate);\n\n      if (results !== null) {\n        pickingInfos = pickingInfos.concat(results);\n      }\n    }\n  }\n\n  return pickingInfos;\n};\n\nScene.prototype.pickSprite = function (x, y, predicate, fastCheck, camera) {\n  if (!this._tempSpritePickingRay) {\n    return null;\n  }\n\n  this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay, camera);\n\n  var result = this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);\n\n  if (result) {\n    result.ray = this.createPickingRayInCameraSpace(x, y, camera);\n  }\n\n  return result;\n};\n\nScene.prototype.pickSpriteWithRay = function (ray, predicate, fastCheck, camera) {\n  if (!this._tempSpritePickingRay) {\n    return null;\n  }\n\n  if (!camera) {\n    if (!this.activeCamera) {\n      return null;\n    }\n\n    camera = this.activeCamera;\n  }\n\n  Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);\n\n  var result = this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);\n\n  if (result) {\n    result.ray = ray;\n  }\n\n  return result;\n};\n\nScene.prototype.multiPickSprite = function (x, y, predicate, camera) {\n  this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay, camera);\n  return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);\n};\n\nScene.prototype.multiPickSpriteWithRay = function (ray, predicate, camera) {\n  if (!this._tempSpritePickingRay) {\n    return null;\n  }\n\n  if (!camera) {\n    if (!this.activeCamera) {\n      return null;\n    }\n\n    camera = this.activeCamera;\n  }\n\n  Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);\n  return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);\n};\n\nScene.prototype.setPointerOverSprite = function (sprite) {\n  if (this._pointerOverSprite === sprite) {\n    return;\n  }\n\n  if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\n    this._pointerOverSprite.actionManager.processTrigger(10, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\n  }\n\n  this._pointerOverSprite = sprite;\n\n  if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\n    this._pointerOverSprite.actionManager.processTrigger(9, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\n  }\n};\n\nScene.prototype.getPointerOverSprite = function () {\n  return this._pointerOverSprite;\n};\n/**\n * Defines the sprite scene component responsible to manage sprites\n * in a given scene.\n */\n\n\nvar SpriteSceneComponent =\n/** @class */\nfunction () {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  function SpriteSceneComponent(scene) {\n    /**\n     * The component name helpfull to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_SPRITE;\n    this.scene = scene;\n    this.scene.spriteManagers = new Array();\n    this.scene._tempSpritePickingRay = Ray ? Ray.Zero() : null;\n    this.scene.onBeforeSpritesRenderingObservable = new Observable();\n    this.scene.onAfterSpritesRenderingObservable = new Observable();\n\n    this._spritePredicate = function (sprite) {\n      if (!sprite.actionManager) {\n        return false;\n      }\n\n      return sprite.isPickable && sprite.actionManager.hasPointerTriggers;\n    };\n  }\n  /**\n   * Registers the component in a given scene\n   */\n\n\n  SpriteSceneComponent.prototype.register = function () {\n    this.scene._pointerMoveStage.registerStep(SceneComponentConstants.STEP_POINTERMOVE_SPRITE, this, this._pointerMove);\n\n    this.scene._pointerDownStage.registerStep(SceneComponentConstants.STEP_POINTERDOWN_SPRITE, this, this._pointerDown);\n\n    this.scene._pointerUpStage.registerStep(SceneComponentConstants.STEP_POINTERUP_SPRITE, this, this._pointerUp);\n  };\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n\n\n  SpriteSceneComponent.prototype.rebuild = function () {\n    /** Nothing to do for sprites */\n  };\n  /**\n   * Disposes the component and the associated resources.\n   */\n\n\n  SpriteSceneComponent.prototype.dispose = function () {\n    this.scene.onBeforeSpritesRenderingObservable.clear();\n    this.scene.onAfterSpritesRenderingObservable.clear();\n    var spriteManagers = this.scene.spriteManagers;\n\n    while (spriteManagers.length) {\n      spriteManagers[0].dispose();\n    }\n  };\n\n  SpriteSceneComponent.prototype._pickSpriteButKeepRay = function (originalPointerInfo, x, y, fastCheck, camera) {\n    var result = this.scene.pickSprite(x, y, this._spritePredicate, fastCheck, camera);\n\n    if (result) {\n      result.ray = originalPointerInfo ? originalPointerInfo.ray : null;\n    }\n\n    return result;\n  };\n\n  SpriteSceneComponent.prototype._pointerMove = function (unTranslatedPointerX, unTranslatedPointerY, pickResult, isMeshPicked, element) {\n    var scene = this.scene;\n\n    if (isMeshPicked) {\n      scene.setPointerOverSprite(null);\n    } else {\n      pickResult = this._pickSpriteButKeepRay(pickResult, unTranslatedPointerX, unTranslatedPointerY, false, scene.cameraToUseForPointers || undefined);\n\n      if (pickResult && pickResult.hit && pickResult.pickedSprite) {\n        scene.setPointerOverSprite(pickResult.pickedSprite);\n\n        if (!scene.doNotHandleCursors && element) {\n          if (scene._pointerOverSprite && scene._pointerOverSprite.actionManager && scene._pointerOverSprite.actionManager.hoverCursor) {\n            element.style.cursor = scene._pointerOverSprite.actionManager.hoverCursor;\n          } else {\n            element.style.cursor = scene.hoverCursor;\n          }\n        }\n      } else {\n        scene.setPointerOverSprite(null);\n      }\n    }\n\n    return pickResult;\n  };\n\n  SpriteSceneComponent.prototype._pointerDown = function (unTranslatedPointerX, unTranslatedPointerY, pickResult, evt) {\n    var scene = this.scene;\n    scene._pickedDownSprite = null;\n\n    if (scene.spriteManagers.length > 0) {\n      pickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\n\n      if (pickResult && pickResult.hit && pickResult.pickedSprite) {\n        if (pickResult.pickedSprite.actionManager) {\n          scene._pickedDownSprite = pickResult.pickedSprite;\n\n          switch (evt.button) {\n            case 0:\n              pickResult.pickedSprite.actionManager.processTrigger(2, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n              break;\n\n            case 1:\n              pickResult.pickedSprite.actionManager.processTrigger(4, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n              break;\n\n            case 2:\n              pickResult.pickedSprite.actionManager.processTrigger(3, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n              break;\n          }\n\n          if (pickResult.pickedSprite.actionManager) {\n            pickResult.pickedSprite.actionManager.processTrigger(5, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n          }\n        }\n      }\n    }\n\n    return pickResult;\n  };\n\n  SpriteSceneComponent.prototype._pointerUp = function (unTranslatedPointerX, unTranslatedPointerY, pickResult, evt) {\n    var scene = this.scene;\n\n    if (scene.spriteManagers.length > 0) {\n      var spritePickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\n\n      if (spritePickResult) {\n        if (spritePickResult.hit && spritePickResult.pickedSprite) {\n          if (spritePickResult.pickedSprite.actionManager) {\n            spritePickResult.pickedSprite.actionManager.processTrigger(7, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));\n\n            if (spritePickResult.pickedSprite.actionManager) {\n              if (!this.scene._inputManager._isPointerSwiping()) {\n                spritePickResult.pickedSprite.actionManager.processTrigger(1, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));\n              }\n            }\n          }\n        }\n\n        if (scene._pickedDownSprite && scene._pickedDownSprite.actionManager && scene._pickedDownSprite !== spritePickResult.pickedSprite) {\n          scene._pickedDownSprite.actionManager.processTrigger(16, ActionEvent.CreateNewFromSprite(scene._pickedDownSprite, scene, evt));\n        }\n      }\n    }\n\n    return pickResult;\n  };\n\n  return SpriteSceneComponent;\n}();\n\nexport { SpriteSceneComponent };","map":{"version":3,"mappings":"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","names":["Observable","Scene","Ray","PickingInfo","SceneComponentConstants","ActionEvent","prototype","_internalPickSprites","ray","predicate","fastCheck","camera","pickingInfo","activeCamera","spriteManagers","length","spriteIndex","spriteManager","isPickable","result","intersects","hit","distance","_internalMultiPickSprites","pickingInfos","Array","results","multiIntersects","concat","pickSprite","x","y","_tempSpritePickingRay","createPickingRayInCameraSpaceToRef","createPickingRayInCameraSpace","pickSpriteWithRay","TransformToRef","getViewMatrix","multiPickSprite","multiPickSpriteWithRay","setPointerOverSprite","sprite","_pointerOverSprite","actionManager","processTrigger","getPointerOverSprite","scene","NAME_SPRITE","Zero","onBeforeSpritesRenderingObservable","onAfterSpritesRenderingObservable","_spritePredicate","hasPointerTriggers","SpriteSceneComponent","_pointerMoveStage","registerStep","STEP_POINTERMOVE_SPRITE","_pointerMove","_pointerDownStage","STEP_POINTERDOWN_SPRITE","_pointerDown","_pointerUpStage","STEP_POINTERUP_SPRITE","_pointerUp","clear","dispose","originalPointerInfo","unTranslatedPointerX","unTranslatedPointerY","pickResult","isMeshPicked","element","_pickSpriteButKeepRay","cameraToUseForPointers","undefined","pickedSprite","doNotHandleCursors","hoverCursor","style","cursor","evt","_pickedDownSprite","button","spritePickResult","_inputManager","_isPointerSwiping"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Sprites/spriteSceneComponent.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Scene } from \"../scene\";\r\nimport type { Sprite } from \"./sprite\";\r\nimport type { ISpriteManager } from \"./spriteManager\";\r\nimport { Ray } from \"../Culling/ray\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { ActionEvent } from \"../Actions/actionEvent\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { IPointerEvent } from \"../Events/deviceInputEvents\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @hidden */\r\n        _pointerOverSprite: Nullable<Sprite>;\r\n\r\n        /** @hidden */\r\n        _pickedDownSprite: Nullable<Sprite>;\r\n\r\n        /** @hidden */\r\n        _tempSpritePickingRay: Nullable<Ray>;\r\n\r\n        /**\r\n         * All of the sprite managers added to this scene\r\n         * @see https://doc.babylonjs.com/babylon101/sprites\r\n         */\r\n        spriteManagers: Array<ISpriteManager>;\r\n\r\n        /**\r\n         * An event triggered when sprites rendering is about to start\r\n         * Note: This event can be trigger more than once per frame (because sprites can be rendered by render target textures as well)\r\n         */\r\n        onBeforeSpritesRenderingObservable: Observable<Scene>;\r\n\r\n        /**\r\n         * An event triggered when sprites rendering is done\r\n         * Note: This event can be trigger more than once per frame (because sprites can be rendered by render target textures as well)\r\n         */\r\n        onAfterSpritesRenderingObservable: Observable<Scene>;\r\n\r\n        /** @hidden */\r\n        _internalPickSprites(ray: Ray, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo>;\r\n\r\n        /** Launch a ray to try to pick a sprite in the scene\r\n         * @param x position on screen\r\n         * @param y position on screen\r\n         * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true\r\n         * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n         * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n         * @returns a PickingInfo\r\n         */\r\n        pickSprite(x: number, y: number, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo>;\r\n\r\n        /** Use the given ray to pick a sprite in the scene\r\n         * @param ray The ray (in world space) to use to pick meshes\r\n         * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true\r\n         * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n         * @param camera camera to use. Can be set to null. In this case, the scene.activeCamera will be used\r\n         * @returns a PickingInfo\r\n         */\r\n        pickSpriteWithRay(ray: Ray, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo>;\r\n\r\n        /** @hidden */\r\n        _internalMultiPickSprites(ray: Ray, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]>;\r\n\r\n        /** Launch a ray to try to pick sprites in the scene\r\n         * @param x position on screen\r\n         * @param y position on screen\r\n         * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true\r\n         * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n         * @returns a PickingInfo array\r\n         */\r\n        multiPickSprite(x: number, y: number, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]>;\r\n\r\n        /** Use the given ray to pick sprites in the scene\r\n         * @param ray The ray (in world space) to use to pick meshes\r\n         * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true\r\n         * @param camera camera to use. Can be set to null. In this case, the scene.activeCamera will be used\r\n         * @returns a PickingInfo array\r\n         */\r\n        multiPickSpriteWithRay(ray: Ray, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]>;\r\n\r\n        /**\r\n         * Force the sprite under the pointer\r\n         * @param sprite defines the sprite to use\r\n         */\r\n        setPointerOverSprite(sprite: Nullable<Sprite>): void;\r\n\r\n        /**\r\n         * Gets the sprite under the pointer\r\n         * @returns a Sprite or null if no sprite is under the pointer\r\n         */\r\n        getPointerOverSprite(): Nullable<Sprite>;\r\n    }\r\n}\r\n\r\nScene.prototype._internalPickSprites = function (ray: Ray, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n\r\n    let pickingInfo = null;\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return null;\r\n        }\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    if (this.spriteManagers.length > 0) {\r\n        for (let spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\r\n            const spriteManager = this.spriteManagers[spriteIndex];\r\n\r\n            if (!spriteManager.isPickable) {\r\n                continue;\r\n            }\r\n\r\n            const result = spriteManager.intersects(ray, camera, predicate, fastCheck);\r\n            if (!result || !result.hit) {\r\n                continue;\r\n            }\r\n\r\n            if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\r\n                continue;\r\n            }\r\n\r\n            pickingInfo = result;\r\n\r\n            if (fastCheck) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfo || new PickingInfo();\r\n};\r\n\r\nScene.prototype._internalMultiPickSprites = function (ray: Ray, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n\r\n    let pickingInfos = new Array<PickingInfo>();\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return null;\r\n        }\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    if (this.spriteManagers.length > 0) {\r\n        for (let spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\r\n            const spriteManager = this.spriteManagers[spriteIndex];\r\n\r\n            if (!spriteManager.isPickable) {\r\n                continue;\r\n            }\r\n\r\n            const results = spriteManager.multiIntersects(ray, camera, predicate);\r\n\r\n            if (results !== null) {\r\n                pickingInfos = pickingInfos.concat(results);\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfos;\r\n};\r\n\r\nScene.prototype.pickSprite = function (x: number, y: number, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo> {\r\n    if (!this._tempSpritePickingRay) {\r\n        return null;\r\n    }\r\n\r\n    this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay, camera);\r\n\r\n    const result = this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);\r\n    if (result) {\r\n        result.ray = this.createPickingRayInCameraSpace(x, y, camera);\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.pickSpriteWithRay = function (ray: Ray, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo> {\r\n    if (!this._tempSpritePickingRay) {\r\n        return null;\r\n    }\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return null;\r\n        }\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);\r\n\r\n    const result = this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);\r\n    if (result) {\r\n        result.ray = ray;\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.multiPickSprite = function (x: number, y: number, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]> {\r\n    this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay!, camera);\r\n\r\n    return this._internalMultiPickSprites(this._tempSpritePickingRay!, predicate, camera);\r\n};\r\n\r\nScene.prototype.multiPickSpriteWithRay = function (ray: Ray, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]> {\r\n    if (!this._tempSpritePickingRay) {\r\n        return null;\r\n    }\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return null;\r\n        }\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);\r\n\r\n    return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);\r\n};\r\n\r\nScene.prototype.setPointerOverSprite = function (sprite: Nullable<Sprite>): void {\r\n    if (this._pointerOverSprite === sprite) {\r\n        return;\r\n    }\r\n\r\n    if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\r\n        this._pointerOverSprite.actionManager.processTrigger(Constants.ACTION_OnPointerOutTrigger, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\r\n    }\r\n\r\n    this._pointerOverSprite = sprite;\r\n    if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\r\n        this._pointerOverSprite.actionManager.processTrigger(Constants.ACTION_OnPointerOverTrigger, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\r\n    }\r\n};\r\n\r\nScene.prototype.getPointerOverSprite = function (): Nullable<Sprite> {\r\n    return this._pointerOverSprite;\r\n};\r\n\r\n/**\r\n * Defines the sprite scene component responsible to manage sprites\r\n * in a given scene.\r\n */\r\nexport class SpriteSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpfull to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_SPRITE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /** @hidden */\r\n    private _spritePredicate: (sprite: Sprite) => boolean;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this.scene.spriteManagers = new Array<ISpriteManager>();\r\n        this.scene._tempSpritePickingRay = Ray ? Ray.Zero() : null;\r\n        this.scene.onBeforeSpritesRenderingObservable = new Observable<Scene>();\r\n        this.scene.onAfterSpritesRenderingObservable = new Observable<Scene>();\r\n        this._spritePredicate = (sprite: Sprite): boolean => {\r\n            if (!sprite.actionManager) {\r\n                return false;\r\n            }\r\n            return sprite.isPickable && sprite.actionManager.hasPointerTriggers;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._pointerMoveStage.registerStep(SceneComponentConstants.STEP_POINTERMOVE_SPRITE, this, this._pointerMove);\r\n        this.scene._pointerDownStage.registerStep(SceneComponentConstants.STEP_POINTERDOWN_SPRITE, this, this._pointerDown);\r\n        this.scene._pointerUpStage.registerStep(SceneComponentConstants.STEP_POINTERUP_SPRITE, this, this._pointerUp);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        /** Nothing to do for sprites */\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        this.scene.onBeforeSpritesRenderingObservable.clear();\r\n        this.scene.onAfterSpritesRenderingObservable.clear();\r\n\r\n        const spriteManagers = this.scene.spriteManagers;\r\n        while (spriteManagers.length) {\r\n            spriteManagers[0].dispose();\r\n        }\r\n    }\r\n\r\n    private _pickSpriteButKeepRay(originalPointerInfo: Nullable<PickingInfo>, x: number, y: number, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo> {\r\n        const result = this.scene.pickSprite(x, y, this._spritePredicate, fastCheck, camera);\r\n        if (result) {\r\n            result.ray = originalPointerInfo ? originalPointerInfo.ray : null;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private _pointerMove(\r\n        unTranslatedPointerX: number,\r\n        unTranslatedPointerY: number,\r\n        pickResult: Nullable<PickingInfo>,\r\n        isMeshPicked: boolean,\r\n        element: Nullable<HTMLElement>\r\n    ): Nullable<PickingInfo> {\r\n        const scene = this.scene;\r\n        if (isMeshPicked) {\r\n            scene.setPointerOverSprite(null);\r\n        } else {\r\n            pickResult = this._pickSpriteButKeepRay(pickResult, unTranslatedPointerX, unTranslatedPointerY, false, scene.cameraToUseForPointers || undefined);\r\n\r\n            if (pickResult && pickResult.hit && pickResult.pickedSprite) {\r\n                scene.setPointerOverSprite(pickResult.pickedSprite);\r\n                if (!scene.doNotHandleCursors && element) {\r\n                    if (scene._pointerOverSprite && scene._pointerOverSprite.actionManager && scene._pointerOverSprite.actionManager.hoverCursor) {\r\n                        element.style.cursor = scene._pointerOverSprite.actionManager.hoverCursor;\r\n                    } else {\r\n                        element.style.cursor = scene.hoverCursor;\r\n                    }\r\n                }\r\n            } else {\r\n                scene.setPointerOverSprite(null);\r\n            }\r\n        }\r\n\r\n        return pickResult;\r\n    }\r\n\r\n    private _pointerDown(unTranslatedPointerX: number, unTranslatedPointerY: number, pickResult: Nullable<PickingInfo>, evt: IPointerEvent): Nullable<PickingInfo> {\r\n        const scene = this.scene;\r\n        scene._pickedDownSprite = null;\r\n        if (scene.spriteManagers.length > 0) {\r\n            pickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\r\n\r\n            if (pickResult && pickResult.hit && pickResult.pickedSprite) {\r\n                if (pickResult.pickedSprite.actionManager) {\r\n                    scene._pickedDownSprite = pickResult.pickedSprite;\r\n                    switch (evt.button) {\r\n                        case 0:\r\n                            pickResult.pickedSprite.actionManager.processTrigger(\r\n                                Constants.ACTION_OnLeftPickTrigger,\r\n                                ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt)\r\n                            );\r\n                            break;\r\n                        case 1:\r\n                            pickResult.pickedSprite.actionManager.processTrigger(\r\n                                Constants.ACTION_OnCenterPickTrigger,\r\n                                ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt)\r\n                            );\r\n                            break;\r\n                        case 2:\r\n                            pickResult.pickedSprite.actionManager.processTrigger(\r\n                                Constants.ACTION_OnRightPickTrigger,\r\n                                ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt)\r\n                            );\r\n                            break;\r\n                    }\r\n                    if (pickResult.pickedSprite.actionManager) {\r\n                        pickResult.pickedSprite.actionManager.processTrigger(\r\n                            Constants.ACTION_OnPickDownTrigger,\r\n                            ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt)\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return pickResult;\r\n    }\r\n\r\n    private _pointerUp(unTranslatedPointerX: number, unTranslatedPointerY: number, pickResult: Nullable<PickingInfo>, evt: IPointerEvent): Nullable<PickingInfo> {\r\n        const scene = this.scene;\r\n        if (scene.spriteManagers.length > 0) {\r\n            const spritePickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\r\n\r\n            if (spritePickResult) {\r\n                if (spritePickResult.hit && spritePickResult.pickedSprite) {\r\n                    if (spritePickResult.pickedSprite.actionManager) {\r\n                        spritePickResult.pickedSprite.actionManager.processTrigger(\r\n                            Constants.ACTION_OnPickUpTrigger,\r\n                            ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt)\r\n                        );\r\n                        if (spritePickResult.pickedSprite.actionManager) {\r\n                            if (!this.scene._inputManager._isPointerSwiping()) {\r\n                                spritePickResult.pickedSprite.actionManager.processTrigger(\r\n                                    Constants.ACTION_OnPickTrigger,\r\n                                    ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt)\r\n                                );\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (scene._pickedDownSprite && scene._pickedDownSprite.actionManager && scene._pickedDownSprite !== spritePickResult.pickedSprite) {\r\n                    scene._pickedDownSprite.actionManager.processTrigger(Constants.ACTION_OnPickOutTrigger, ActionEvent.CreateNewFromSprite(scene._pickedDownSprite, scene, evt));\r\n                }\r\n            }\r\n        }\r\n\r\n        return pickResult;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}