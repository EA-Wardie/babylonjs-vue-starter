{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport { __decorate } from \"tslib\";\nimport { SmartArray } from \"../Misc/smartArray.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector2 } from \"../Maths/math.vector.js\";\nimport \"../Shaders/postprocess.vertex.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport \"../Engines/Extensions/engine.renderTarget.js\";\nimport { serialize, serializeAsColor4, SerializationHelper } from \"../Misc/decorators.js\";\nimport { GetClass, RegisterClass } from \"../Misc/typeStore.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\n/**\n * PostProcess can be used to apply a shader to a texture after it has been rendered\n * See https://doc.babylonjs.com/how_to/how_to_use_postprocesses\n */\n\nvar PostProcess =\n/** @class */\nfunction () {\n  /**\n   * Creates a new instance PostProcess\n   * @param name The name of the PostProcess.\n   * @param fragmentUrl The url of the fragment shader to be used.\n   * @param parameters Array of the names of uniform non-sampler2D variables that will be passed to the shader.\n   * @param samplers Array of the names of uniform sampler2D variables that will be passed to the shader.\n   * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\n   * @param camera The camera to apply the render pass to.\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n   * @param engine The engine which the post process will be applied. (default: current engine)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   * @param defines String of defines that will be set when running the fragment shader. (default: null)\n   * @param textureType Type of textures used when performing the post process. (default: 0)\n   * @param vertexUrl The url of the vertex shader to be used. (default: \"postprocess\")\n   * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\n   * @param blockCompilation If the shader should not be compiled immediatly. (default: false)\n   * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\n   */\n  function PostProcess(name, fragmentUrl, parameters, samplers, options, camera, samplingMode, engine, reusable, defines, textureType, vertexUrl, indexParameters, blockCompilation, textureFormat) {\n    if (samplingMode === void 0) {\n      samplingMode = 1;\n    }\n\n    if (defines === void 0) {\n      defines = null;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    if (vertexUrl === void 0) {\n      vertexUrl = \"postprocess\";\n    }\n\n    if (blockCompilation === void 0) {\n      blockCompilation = false;\n    }\n\n    if (textureFormat === void 0) {\n      textureFormat = 5;\n    }\n    /** @hidden */\n\n\n    this._parentContainer = null;\n    /**\n     * Width of the texture to apply the post process on\n     */\n\n    this.width = -1;\n    /**\n     * Height of the texture to apply the post process on\n     */\n\n    this.height = -1;\n    /**\n     * Gets the node material used to create this postprocess (null if the postprocess was manually created)\n     */\n\n    this.nodeMaterialSource = null;\n    /**\n     * Internal, reference to the location where this postprocess was output to. (Typically the texture on the next postprocess in the chain)\n     * @hidden\n     */\n\n    this._outputTexture = null;\n    /**\n     * If the buffer needs to be cleared before applying the post process. (default: true)\n     * Should be set to false if shader will overwrite all previous pixels.\n     */\n\n    this.autoClear = true;\n    /**\n     * Type of alpha mode to use when performing the post process (default: Engine.ALPHA_DISABLE)\n     */\n\n    this.alphaMode = 0;\n    /**\n     * Animations to be used for the post processing\n     */\n\n    this.animations = new Array();\n    /**\n     * Enable Pixel Perfect mode where texture is not scaled to be power of 2.\n     * Can only be used on a single postprocess or on the last one of a chain. (default: false)\n     */\n\n    this.enablePixelPerfectMode = false;\n    /**\n     * Force the postprocess to be applied without taking in account viewport\n     */\n\n    this.forceFullscreenViewport = true;\n    /**\n     * Scale mode for the post process (default: Engine.SCALEMODE_FLOOR)\n     *\n     * | Value | Type                                | Description |\n     * | ----- | ----------------------------------- | ----------- |\n     * | 1     | SCALEMODE_FLOOR                     | [engine.scalemode_floor](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_floor) |\n     * | 2     | SCALEMODE_NEAREST                   | [engine.scalemode_nearest](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_nearest) |\n     * | 3     | SCALEMODE_CEILING                   | [engine.scalemode_ceiling](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_ceiling) |\n     *\n     */\n\n    this.scaleMode = 1;\n    /**\n     * Force textures to be a power of two (default: false)\n     */\n\n    this.alwaysForcePOT = false;\n    this._samples = 1;\n    /**\n     * Modify the scale of the post process to be the same as the viewport (default: false)\n     */\n\n    this.adaptScaleToCurrentViewport = false;\n    this._reusable = false;\n    this._renderId = 0;\n    /**\n     * if externalTextureSamplerBinding is true, the \"apply\" method won't bind the textureSampler texture, it is expected to be done by the \"outside\" (by the onApplyObservable observer most probably).\n     * counter-productive in some cases because if the texture bound by \"apply\" is different from the currently texture bound, (the one set by the onApplyObservable observer, for eg) some\n     * internal structures (materialContext) will be dirtified, which may impact performances\n     */\n\n    this.externalTextureSamplerBinding = false;\n    /**\n     * Smart array of input and output textures for the post process.\n     * @hidden\n     */\n\n    this._textures = new SmartArray(2);\n    /**\n     * Smart array of input and output textures for the post process.\n     * @hidden\n     */\n\n    this._textureCache = [];\n    /**\n     * The index in _textures that corresponds to the output texture.\n     * @hidden\n     */\n\n    this._currentRenderTextureInd = 0;\n    this._scaleRatio = new Vector2(1, 1);\n    this._texelSize = Vector2.Zero(); // Events\n\n    /**\n     * An event triggered when the postprocess is activated.\n     */\n\n    this.onActivateObservable = new Observable();\n    /**\n     * An event triggered when the postprocess changes its size.\n     */\n\n    this.onSizeChangedObservable = new Observable();\n    /**\n     * An event triggered when the postprocess applies its effect.\n     */\n\n    this.onApplyObservable = new Observable();\n    /**\n     * An event triggered before rendering the postprocess\n     */\n\n    this.onBeforeRenderObservable = new Observable();\n    /**\n     * An event triggered after rendering the postprocess\n     */\n\n    this.onAfterRenderObservable = new Observable();\n    this.name = name;\n\n    if (camera != null) {\n      this._camera = camera;\n      this._scene = camera.getScene();\n      camera.attachPostProcess(this);\n      this._engine = this._scene.getEngine();\n\n      this._scene.postProcesses.push(this);\n\n      this.uniqueId = this._scene.getUniqueId();\n    } else if (engine) {\n      this._engine = engine;\n\n      this._engine.postProcesses.push(this);\n    }\n\n    this._options = options;\n    this.renderTargetSamplingMode = samplingMode ? samplingMode : 1;\n    this._reusable = reusable || false;\n    this._textureType = textureType;\n    this._textureFormat = textureFormat;\n    this._samplers = samplers || [];\n\n    this._samplers.push(\"textureSampler\");\n\n    this._fragmentUrl = fragmentUrl;\n    this._vertexUrl = vertexUrl;\n    this._parameters = parameters || [];\n\n    this._parameters.push(\"scale\");\n\n    this._indexParameters = indexParameters;\n    this._drawWrapper = new DrawWrapper(this._engine);\n\n    if (!blockCompilation) {\n      this.updateEffect(defines);\n    }\n  }\n\n  Object.defineProperty(PostProcess.prototype, \"samples\", {\n    /**\n     * Number of sample textures (default: 1)\n     */\n    get: function get() {\n      return this._samples;\n    },\n    set: function set(n) {\n      var _this = this;\n\n      this._samples = Math.min(n, this._engine.getCaps().maxMSAASamples);\n\n      this._textures.forEach(function (texture) {\n        if (texture.samples !== _this._samples) {\n          _this._engine.updateRenderTargetTextureSampleCount(texture, _this._samples);\n        }\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Returns the fragment url or shader name used in the post process.\n   * @returns the fragment url or name in the shader store.\n   */\n\n  PostProcess.prototype.getEffectName = function () {\n    return this._fragmentUrl;\n  };\n\n  Object.defineProperty(PostProcess.prototype, \"onActivate\", {\n    /**\n     * A function that is added to the onActivateObservable\n     */\n    set: function set(callback) {\n      if (this._onActivateObserver) {\n        this.onActivateObservable.remove(this._onActivateObserver);\n      }\n\n      if (callback) {\n        this._onActivateObserver = this.onActivateObservable.add(callback);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PostProcess.prototype, \"onSizeChanged\", {\n    /**\n     * A function that is added to the onSizeChangedObservable\n     */\n    set: function set(callback) {\n      if (this._onSizeChangedObserver) {\n        this.onSizeChangedObservable.remove(this._onSizeChangedObserver);\n      }\n\n      this._onSizeChangedObserver = this.onSizeChangedObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PostProcess.prototype, \"onApply\", {\n    /**\n     * A function that is added to the onApplyObservable\n     */\n    set: function set(callback) {\n      if (this._onApplyObserver) {\n        this.onApplyObservable.remove(this._onApplyObserver);\n      }\n\n      this._onApplyObserver = this.onApplyObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PostProcess.prototype, \"onBeforeRender\", {\n    /**\n     * A function that is added to the onBeforeRenderObservable\n     */\n    set: function set(callback) {\n      if (this._onBeforeRenderObserver) {\n        this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n      }\n\n      this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PostProcess.prototype, \"onAfterRender\", {\n    /**\n     * A function that is added to the onAfterRenderObservable\n     */\n    set: function set(callback) {\n      if (this._onAfterRenderObserver) {\n        this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n      }\n\n      this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PostProcess.prototype, \"inputTexture\", {\n    /**\n     * The input texture for this post process and the output texture of the previous post process. When added to a pipeline the previous post process will\n     * render it's output into this texture and this texture will be used as textureSampler in the fragment shader of this post process.\n     */\n    get: function get() {\n      return this._textures.data[this._currentRenderTextureInd];\n    },\n    set: function set(value) {\n      this._forcedOutputTexture = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Since inputTexture should always be defined, if we previously manually set `inputTexture`,\n   * the only way to unset it is to use this function to restore its internal state\n   */\n\n  PostProcess.prototype.restoreDefaultInputTexture = function () {\n    if (this._forcedOutputTexture) {\n      this._forcedOutputTexture = null;\n      this.markTextureDirty();\n    }\n  };\n  /**\n   * Gets the camera which post process is applied to.\n   * @returns The camera the post process is applied to.\n   */\n\n\n  PostProcess.prototype.getCamera = function () {\n    return this._camera;\n  };\n\n  Object.defineProperty(PostProcess.prototype, \"texelSize\", {\n    /**\n     * Gets the texel size of the postprocess.\n     * See https://en.wikipedia.org/wiki/Texel_(graphics)\n     */\n    get: function get() {\n      if (this._shareOutputWithPostProcess) {\n        return this._shareOutputWithPostProcess.texelSize;\n      }\n\n      if (this._forcedOutputTexture) {\n        this._texelSize.copyFromFloats(1.0 / this._forcedOutputTexture.width, 1.0 / this._forcedOutputTexture.height);\n      }\n\n      return this._texelSize;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"PostProcess\" string\n   */\n\n  PostProcess.prototype.getClassName = function () {\n    return \"PostProcess\";\n  };\n  /**\n   * Gets the engine which this post process belongs to.\n   * @returns The engine the post process was enabled with.\n   */\n\n\n  PostProcess.prototype.getEngine = function () {\n    return this._engine;\n  };\n  /**\n   * The effect that is created when initializing the post process.\n   * @returns The created effect corresponding the the postprocess.\n   */\n\n\n  PostProcess.prototype.getEffect = function () {\n    return this._drawWrapper.effect;\n  };\n  /**\n   * To avoid multiple redundant textures for multiple post process, the output the output texture for this post process can be shared with another.\n   * @param postProcess The post process to share the output with.\n   * @returns This post process.\n   */\n\n\n  PostProcess.prototype.shareOutputWith = function (postProcess) {\n    this._disposeTextures();\n\n    this._shareOutputWithPostProcess = postProcess;\n    return this;\n  };\n  /**\n   * Reverses the effect of calling shareOutputWith and returns the post process back to its original state.\n   * This should be called if the post process that shares output with this post process is disabled/disposed.\n   */\n\n\n  PostProcess.prototype.useOwnOutput = function () {\n    if (this._textures.length == 0) {\n      this._textures = new SmartArray(2);\n    }\n\n    this._shareOutputWithPostProcess = null;\n  };\n  /**\n   * Updates the effect with the current post process compile time values and recompiles the shader.\n   * @param defines Define statements that should be added at the beginning of the shader. (default: null)\n   * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)\n   * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)\n   * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\n   * @param onCompiled Called when the shader has been compiled.\n   * @param onError Called if there is an error when compiling a shader.\n   * @param vertexUrl The url of the vertex shader to be used (default: the one given at construction time)\n   * @param fragmentUrl The url of the fragment shader to be used (default: the one given at construction time)\n   */\n\n\n  PostProcess.prototype.updateEffect = function (defines, uniforms, samplers, indexParameters, onCompiled, onError, vertexUrl, fragmentUrl) {\n    if (defines === void 0) {\n      defines = null;\n    }\n\n    if (uniforms === void 0) {\n      uniforms = null;\n    }\n\n    if (samplers === void 0) {\n      samplers = null;\n    }\n\n    this._postProcessDefines = defines;\n    this._drawWrapper.effect = this._engine.createEffect({\n      vertex: vertexUrl !== null && vertexUrl !== void 0 ? vertexUrl : this._vertexUrl,\n      fragment: fragmentUrl !== null && fragmentUrl !== void 0 ? fragmentUrl : this._fragmentUrl\n    }, [\"position\"], uniforms || this._parameters, samplers || this._samplers, defines !== null ? defines : \"\", undefined, onCompiled, onError, indexParameters || this._indexParameters);\n  };\n  /**\n   * The post process is reusable if it can be used multiple times within one frame.\n   * @returns If the post process is reusable\n   */\n\n\n  PostProcess.prototype.isReusable = function () {\n    return this._reusable;\n  };\n  /** invalidate frameBuffer to hint the postprocess to create a depth buffer */\n\n\n  PostProcess.prototype.markTextureDirty = function () {\n    this.width = -1;\n  };\n\n  PostProcess.prototype._createRenderTargetTexture = function (textureSize, textureOptions, channel) {\n    if (channel === void 0) {\n      channel = 0;\n    }\n\n    for (var i = 0; i < this._textureCache.length; i++) {\n      if (this._textureCache[i].texture.width === textureSize.width && this._textureCache[i].texture.height === textureSize.height && this._textureCache[i].postProcessChannel === channel && this._textureCache[i].texture._generateDepthBuffer === textureOptions.generateDepthBuffer) {\n        return this._textureCache[i].texture;\n      }\n    }\n\n    var tex = this._engine.createRenderTargetTexture(textureSize, textureOptions);\n\n    this._textureCache.push({\n      texture: tex,\n      postProcessChannel: channel,\n      lastUsedRenderId: -1\n    });\n\n    return tex;\n  };\n\n  PostProcess.prototype._flushTextureCache = function () {\n    var currentRenderId = this._renderId;\n\n    for (var i = this._textureCache.length - 1; i >= 0; i--) {\n      if (currentRenderId - this._textureCache[i].lastUsedRenderId > 100) {\n        var currentlyUsed = false;\n\n        for (var j = 0; j < this._textures.length; j++) {\n          if (this._textures.data[j] === this._textureCache[i].texture) {\n            currentlyUsed = true;\n            break;\n          }\n        }\n\n        if (!currentlyUsed) {\n          this._textureCache[i].texture.dispose();\n\n          this._textureCache.splice(i, 1);\n        }\n      }\n    }\n  };\n\n  PostProcess.prototype._resize = function (width, height, camera, needMipMaps, forceDepthStencil) {\n    if (this._textures.length > 0) {\n      this._textures.reset();\n    }\n\n    this.width = width;\n    this.height = height;\n    var firstPP = null;\n\n    for (var i = 0; i < camera._postProcesses.length; i++) {\n      if (camera._postProcesses[i] !== null) {\n        firstPP = camera._postProcesses[i];\n        break;\n      }\n    }\n\n    var textureSize = {\n      width: this.width,\n      height: this.height\n    };\n    var textureOptions = {\n      generateMipMaps: needMipMaps,\n      generateDepthBuffer: forceDepthStencil || firstPP === this,\n      generateStencilBuffer: (forceDepthStencil || firstPP === this) && this._engine.isStencilEnable,\n      samplingMode: this.renderTargetSamplingMode,\n      type: this._textureType,\n      format: this._textureFormat\n    };\n\n    this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 0));\n\n    if (this._reusable) {\n      this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 1));\n    }\n\n    this._texelSize.copyFromFloats(1.0 / this.width, 1.0 / this.height);\n\n    this.onSizeChangedObservable.notifyObservers(this);\n  };\n  /**\n   * Activates the post process by intializing the textures to be used when executed. Notifies onActivateObservable.\n   * When this post process is used in a pipeline, this is call will bind the input texture of this post process to the output of the previous.\n   * @param camera The camera that will be used in the post process. This camera will be used when calling onActivateObservable.\n   * @param sourceTexture The source texture to be inspected to get the width and height if not specified in the post process constructor. (default: null)\n   * @param forceDepthStencil If true, a depth and stencil buffer will be generated. (default: false)\n   * @returns The render target wrapper that was bound to be written to.\n   */\n\n\n  PostProcess.prototype.activate = function (camera, sourceTexture, forceDepthStencil) {\n    var _this = this;\n\n    var _a, _b;\n\n    if (sourceTexture === void 0) {\n      sourceTexture = null;\n    }\n\n    camera = camera || this._camera;\n    var scene = camera.getScene();\n    var engine = scene.getEngine();\n    var maxSize = engine.getCaps().maxTextureSize;\n    var requiredWidth = (sourceTexture ? sourceTexture.width : this._engine.getRenderWidth(true)) * this._options | 0;\n    var requiredHeight = (sourceTexture ? sourceTexture.height : this._engine.getRenderHeight(true)) * this._options | 0; // If rendering to a webvr camera's left or right eye only half the width should be used to avoid resize when rendered to screen\n\n    var webVRCamera = camera.parent;\n\n    if (webVRCamera && (webVRCamera.leftCamera == camera || webVRCamera.rightCamera == camera)) {\n      requiredWidth /= 2;\n    }\n\n    var desiredWidth = this._options.width || requiredWidth;\n    var desiredHeight = this._options.height || requiredHeight;\n    var needMipMaps = this.renderTargetSamplingMode !== 7 && this.renderTargetSamplingMode !== 1 && this.renderTargetSamplingMode !== 2;\n\n    if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {\n      if (this.adaptScaleToCurrentViewport) {\n        var currentViewport = engine.currentViewport;\n\n        if (currentViewport) {\n          desiredWidth *= currentViewport.width;\n          desiredHeight *= currentViewport.height;\n        }\n      }\n\n      if (needMipMaps || this.alwaysForcePOT) {\n        if (!this._options.width) {\n          desiredWidth = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredWidth, maxSize, this.scaleMode) : desiredWidth;\n        }\n\n        if (!this._options.height) {\n          desiredHeight = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredHeight, maxSize, this.scaleMode) : desiredHeight;\n        }\n      }\n\n      if (this.width !== desiredWidth || this.height !== desiredHeight) {\n        this._resize(desiredWidth, desiredHeight, camera, needMipMaps, forceDepthStencil);\n      }\n\n      this._textures.forEach(function (texture) {\n        if (texture.samples !== _this.samples) {\n          _this._engine.updateRenderTargetTextureSampleCount(texture, _this.samples);\n        }\n      });\n\n      this._flushTextureCache();\n\n      this._renderId++;\n    }\n\n    var target;\n\n    if (this._shareOutputWithPostProcess) {\n      target = this._shareOutputWithPostProcess.inputTexture;\n    } else if (this._forcedOutputTexture) {\n      target = this._forcedOutputTexture;\n      this.width = this._forcedOutputTexture.width;\n      this.height = this._forcedOutputTexture.height;\n    } else {\n      target = this.inputTexture;\n      var cache = void 0;\n\n      for (var i = 0; i < this._textureCache.length; i++) {\n        if (this._textureCache[i].texture === target) {\n          cache = this._textureCache[i];\n          break;\n        }\n      }\n\n      if (cache) {\n        cache.lastUsedRenderId = this._renderId;\n      }\n    } // Bind the input of this post process to be used as the output of the previous post process.\n\n\n    if (this.enablePixelPerfectMode) {\n      this._scaleRatio.copyFromFloats(requiredWidth / desiredWidth, requiredHeight / desiredHeight);\n\n      this._engine.bindFramebuffer(target, 0, requiredWidth, requiredHeight, this.forceFullscreenViewport);\n    } else {\n      this._scaleRatio.copyFromFloats(1, 1);\n\n      this._engine.bindFramebuffer(target, 0, undefined, undefined, this.forceFullscreenViewport);\n    }\n\n    (_b = (_a = this._engine)._debugInsertMarker) === null || _b === void 0 ? void 0 : _b.call(_a, \"post process \".concat(this.name, \" input\"));\n    this.onActivateObservable.notifyObservers(camera); // Clear\n\n    if (this.autoClear && this.alphaMode === 0) {\n      this._engine.clear(this.clearColor ? this.clearColor : scene.clearColor, scene._allowPostProcessClearColor, true, true);\n    }\n\n    if (this._reusable) {\n      this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2;\n    }\n\n    return target;\n  };\n\n  Object.defineProperty(PostProcess.prototype, \"isSupported\", {\n    /**\n     * If the post process is supported.\n     */\n    get: function get() {\n      return this._drawWrapper.effect.isSupported;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PostProcess.prototype, \"aspectRatio\", {\n    /**\n     * The aspect ratio of the output texture.\n     */\n    get: function get() {\n      if (this._shareOutputWithPostProcess) {\n        return this._shareOutputWithPostProcess.aspectRatio;\n      }\n\n      if (this._forcedOutputTexture) {\n        return this._forcedOutputTexture.width / this._forcedOutputTexture.height;\n      }\n\n      return this.width / this.height;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Get a value indicating if the post-process is ready to be used\n   * @returns true if the post-process is ready (shader is compiled)\n   */\n\n  PostProcess.prototype.isReady = function () {\n    var _a, _b;\n\n    return (_b = (_a = this._drawWrapper.effect) === null || _a === void 0 ? void 0 : _a.isReady()) !== null && _b !== void 0 ? _b : false;\n  };\n  /**\n   * Binds all textures and uniforms to the shader, this will be run on every pass.\n   * @returns the effect corresponding to this post process. Null if not compiled or not ready.\n   */\n\n\n  PostProcess.prototype.apply = function () {\n    var _a; // Check\n\n\n    if (!((_a = this._drawWrapper.effect) === null || _a === void 0 ? void 0 : _a.isReady())) {\n      return null;\n    } // States\n\n\n    this._engine.enableEffect(this._drawWrapper);\n\n    this._engine.setState(false);\n\n    this._engine.setDepthBuffer(false);\n\n    this._engine.setDepthWrite(false); // Alpha\n\n\n    this._engine.setAlphaMode(this.alphaMode);\n\n    if (this.alphaConstants) {\n      this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a);\n    } // Bind the output texture of the preivous post process as the input to this post process.\n\n\n    var source;\n\n    if (this._shareOutputWithPostProcess) {\n      source = this._shareOutputWithPostProcess.inputTexture;\n    } else if (this._forcedOutputTexture) {\n      source = this._forcedOutputTexture;\n    } else {\n      source = this.inputTexture;\n    }\n\n    if (!this.externalTextureSamplerBinding) {\n      this._drawWrapper.effect._bindTexture(\"textureSampler\", source === null || source === void 0 ? void 0 : source.texture);\n    } // Parameters\n\n\n    this._drawWrapper.effect.setVector2(\"scale\", this._scaleRatio);\n\n    this.onApplyObservable.notifyObservers(this._drawWrapper.effect);\n    return this._drawWrapper.effect;\n  };\n\n  PostProcess.prototype._disposeTextures = function () {\n    if (this._shareOutputWithPostProcess || this._forcedOutputTexture) {\n      this._disposeTextureCache();\n\n      return;\n    }\n\n    this._disposeTextureCache();\n\n    this._textures.dispose();\n  };\n\n  PostProcess.prototype._disposeTextureCache = function () {\n    for (var i = this._textureCache.length - 1; i >= 0; i--) {\n      this._textureCache[i].texture.dispose();\n    }\n\n    this._textureCache.length = 0;\n  };\n  /**\n   * Sets the required values to the prepass renderer.\n   * @param prePassRenderer defines the prepass renderer to setup.\n   * @returns true if the pre pass is needed.\n   */\n\n\n  PostProcess.prototype.setPrePassRenderer = function (prePassRenderer) {\n    if (this._prePassEffectConfiguration) {\n      this._prePassEffectConfiguration = prePassRenderer.addEffectConfiguration(this._prePassEffectConfiguration);\n      this._prePassEffectConfiguration.enabled = true;\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Disposes the post process.\n   * @param camera The camera to dispose the post process on.\n   */\n\n\n  PostProcess.prototype.dispose = function (camera) {\n    camera = camera || this._camera;\n\n    this._disposeTextures();\n\n    var index;\n\n    if (this._scene) {\n      index = this._scene.postProcesses.indexOf(this);\n\n      if (index !== -1) {\n        this._scene.postProcesses.splice(index, 1);\n      }\n    }\n\n    if (this._parentContainer) {\n      var index_1 = this._parentContainer.postProcesses.indexOf(this);\n\n      if (index_1 > -1) {\n        this._parentContainer.postProcesses.splice(index_1, 1);\n      }\n\n      this._parentContainer = null;\n    }\n\n    index = this._engine.postProcesses.indexOf(this);\n\n    if (index !== -1) {\n      this._engine.postProcesses.splice(index, 1);\n    }\n\n    if (!camera) {\n      return;\n    }\n\n    camera.detachPostProcess(this);\n    index = camera._postProcesses.indexOf(this);\n\n    if (index === 0 && camera._postProcesses.length > 0) {\n      var firstPostProcess = this._camera._getFirstPostProcess();\n\n      if (firstPostProcess) {\n        firstPostProcess.markTextureDirty();\n      }\n    }\n\n    this.onActivateObservable.clear();\n    this.onAfterRenderObservable.clear();\n    this.onApplyObservable.clear();\n    this.onBeforeRenderObservable.clear();\n    this.onSizeChangedObservable.clear();\n  };\n  /**\n   * Serializes the post process to a JSON object\n   * @returns the JSON object\n   */\n\n\n  PostProcess.prototype.serialize = function () {\n    var serializationObject = SerializationHelper.Serialize(this);\n\n    var camera = this.getCamera() || this._scene && this._scene.activeCamera;\n\n    serializationObject.customType = \"BABYLON.\" + this.getClassName();\n    serializationObject.cameraId = camera ? camera.id : null;\n    serializationObject.reusable = this._reusable;\n    serializationObject.textureType = this._textureType;\n    serializationObject.fragmentUrl = this._fragmentUrl;\n    serializationObject.parameters = this._parameters;\n    serializationObject.samplers = this._samplers;\n    serializationObject.options = this._options;\n    serializationObject.defines = this._postProcessDefines;\n    serializationObject.textureFormat = this._textureFormat;\n    serializationObject.vertexUrl = this._vertexUrl;\n    serializationObject.indexParameters = this._indexParameters;\n    return serializationObject;\n  };\n  /**\n   * Clones this post process\n   * @returns a new post process similar to this one\n   */\n\n\n  PostProcess.prototype.clone = function () {\n    var serializationObject = this.serialize();\n    serializationObject._engine = this._engine;\n    serializationObject.cameraId = null;\n    var result = PostProcess.Parse(serializationObject, this._scene, \"\");\n\n    if (!result) {\n      return null;\n    }\n\n    result.onActivateObservable = this.onActivateObservable.clone();\n    result.onSizeChangedObservable = this.onSizeChangedObservable.clone();\n    result.onApplyObservable = this.onApplyObservable.clone();\n    result.onBeforeRenderObservable = this.onBeforeRenderObservable.clone();\n    result.onAfterRenderObservable = this.onAfterRenderObservable.clone();\n    result._prePassEffectConfiguration = this._prePassEffectConfiguration;\n    return result;\n  };\n  /**\n   * Creates a material from parsed material data\n   * @param parsedPostProcess defines parsed post process data\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures\n   * @returns a new post process\n   */\n\n\n  PostProcess.Parse = function (parsedPostProcess, scene, rootUrl) {\n    var postProcessType = GetClass(parsedPostProcess.customType);\n\n    if (!postProcessType || !postProcessType._Parse) {\n      return null;\n    }\n\n    var camera = scene ? scene.getCameraById(parsedPostProcess.cameraId) : null;\n    return postProcessType._Parse(parsedPostProcess, camera, scene, rootUrl);\n  };\n  /**\n   * @param parsedPostProcess\n   * @param targetCamera\n   * @param scene\n   * @param rootUrl\n   * @hidden\n   */\n\n\n  PostProcess._Parse = function (parsedPostProcess, targetCamera, scene, rootUrl) {\n    return SerializationHelper.Parse(function () {\n      return new PostProcess(parsedPostProcess.name, parsedPostProcess.fragmentUrl, parsedPostProcess.parameters, parsedPostProcess.samplers, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, parsedPostProcess._engine, parsedPostProcess.reusable, parsedPostProcess.defines, parsedPostProcess.textureType, parsedPostProcess.vertexUrl, parsedPostProcess.indexParameters, false, parsedPostProcess.textureFormat);\n    }, parsedPostProcess, scene, rootUrl);\n  };\n\n  __decorate([serialize()], PostProcess.prototype, \"uniqueId\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"name\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"width\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"height\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"renderTargetSamplingMode\", void 0);\n\n  __decorate([serializeAsColor4()], PostProcess.prototype, \"clearColor\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"autoClear\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"alphaMode\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"alphaConstants\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"enablePixelPerfectMode\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"forceFullscreenViewport\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"scaleMode\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"alwaysForcePOT\", void 0);\n\n  __decorate([serialize(\"samples\")], PostProcess.prototype, \"_samples\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"adaptScaleToCurrentViewport\", void 0);\n\n  return PostProcess;\n}();\n\nexport { PostProcess };\nRegisterClass(\"BABYLON.PostProcess\", PostProcess);","map":{"version":3,"mappings":"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","names":["SmartArray","Observable","Vector2","Engine","serialize","serializeAsColor4","SerializationHelper","GetClass","RegisterClass","DrawWrapper","name","fragmentUrl","parameters","samplers","options","camera","samplingMode","engine","reusable","defines","textureType","vertexUrl","indexParameters","blockCompilation","textureFormat","Array","Zero","_camera","_scene","getScene","attachPostProcess","_engine","getEngine","postProcesses","push","uniqueId","getUniqueId","_options","renderTargetSamplingMode","_reusable","_textureType","_textureFormat","_samplers","_fragmentUrl","_vertexUrl","_parameters","_indexParameters","_drawWrapper","updateEffect","Object","PostProcess","_samples","n","Math","min","getCaps","maxMSAASamples","_textures","forEach","texture","samples","_this","updateRenderTargetTextureSampleCount","callback","_onActivateObserver","onActivateObservable","remove","add","_onSizeChangedObserver","onSizeChangedObservable","_onApplyObserver","onApplyObservable","_onBeforeRenderObserver","onBeforeRenderObservable","_onAfterRenderObserver","onAfterRenderObservable","data","_currentRenderTextureInd","value","_forcedOutputTexture","markTextureDirty","_shareOutputWithPostProcess","texelSize","_texelSize","copyFromFloats","width","height","effect","postProcess","_disposeTextures","length","uniforms","onCompiled","onError","_postProcessDefines","createEffect","vertex","fragment","undefined","textureSize","textureOptions","channel","i","_textureCache","postProcessChannel","_generateDepthBuffer","generateDepthBuffer","tex","createRenderTargetTexture","lastUsedRenderId","currentRenderId","_renderId","currentlyUsed","j","dispose","splice","needMipMaps","forceDepthStencil","reset","firstPP","_postProcesses","generateMipMaps","generateStencilBuffer","isStencilEnable","type","format","_createRenderTargetTexture","notifyObservers","sourceTexture","scene","maxSize","maxTextureSize","requiredWidth","getRenderWidth","requiredHeight","getRenderHeight","webVRCamera","parent","leftCamera","rightCamera","desiredWidth","desiredHeight","adaptScaleToCurrentViewport","currentViewport","alwaysForcePOT","needPOTTextures","GetExponentOfTwo","scaleMode","_resize","_flushTextureCache","target","inputTexture","cache","enablePixelPerfectMode","_scaleRatio","bindFramebuffer","forceFullscreenViewport","_debugInsertMarker","_b","autoClear","alphaMode","clear","clearColor","_allowPostProcessClearColor","isSupported","aspectRatio","_a","isReady","enableEffect","setState","setDepthBuffer","setDepthWrite","setAlphaMode","alphaConstants","setAlphaConstants","r","g","b","a","source","externalTextureSamplerBinding","_bindTexture","setVector2","_disposeTextureCache","prePassRenderer","_prePassEffectConfiguration","addEffectConfiguration","enabled","index","indexOf","_parentContainer","index_1","detachPostProcess","firstPostProcess","_getFirstPostProcess","serializationObject","Serialize","getCamera","activeCamera","customType","getClassName","cameraId","id","result","Parse","clone","parsedPostProcess","rootUrl","postProcessType","_Parse","getCameraById","targetCamera","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/PostProcesses/postProcess.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { RenderTargetCreationOptions } from \"../Materials/Textures/textureCreationOptions\";\r\nimport \"../Shaders/postprocess.vertex\";\r\nimport type { IInspectable } from \"../Misc/iInspectable\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport type { Color4 } from \"../Maths/math.color\";\r\n\r\nimport \"../Engines/Extensions/engine.renderTarget\";\r\nimport type { NodeMaterial } from \"../Materials/Node/nodeMaterial\";\r\nimport { serialize, serializeAsColor4, SerializationHelper } from \"../Misc/decorators\";\r\nimport { GetClass, RegisterClass } from \"../Misc/typeStore\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport type { AbstractScene } from \"../abstractScene\";\r\nimport type { RenderTargetWrapper } from \"../Engines/renderTargetWrapper\";\r\n\r\ndeclare type Scene = import(\"../scene\").Scene;\r\ndeclare type InternalTexture = import(\"../Materials/Textures/internalTexture\").InternalTexture;\r\ndeclare type WebVRFreeCamera = import(\"../Cameras/VR/webVRCamera\").WebVRFreeCamera;\r\ndeclare type Animation = import(\"../Animations/animation\").Animation;\r\ndeclare type PrePassRenderer = import(\"../Rendering/prePassRenderer\").PrePassRenderer;\r\ndeclare type PrePassEffectConfiguration = import(\"../Rendering/prePassEffectConfiguration\").PrePassEffectConfiguration;\r\n\r\n/**\r\n * Size options for a post process\r\n */\r\nexport type PostProcessOptions = { width: number; height: number };\r\n\r\ntype TextureCache = { texture: RenderTargetWrapper; postProcessChannel: number; lastUsedRenderId: number };\r\n\r\n/**\r\n * PostProcess can be used to apply a shader to a texture after it has been rendered\r\n * See https://doc.babylonjs.com/how_to/how_to_use_postprocesses\r\n */\r\nexport class PostProcess {\r\n    /** @hidden */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the post process\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /** Name of the PostProcess. */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Width of the texture to apply the post process on\r\n     */\r\n    @serialize()\r\n    public width = -1;\r\n\r\n    /**\r\n     * Height of the texture to apply the post process on\r\n     */\r\n    @serialize()\r\n    public height = -1;\r\n\r\n    /**\r\n     * Gets the node material used to create this postprocess (null if the postprocess was manually created)\r\n     */\r\n    public nodeMaterialSource: Nullable<NodeMaterial> = null;\r\n\r\n    /**\r\n     * Internal, reference to the location where this postprocess was output to. (Typically the texture on the next postprocess in the chain)\r\n     * @hidden\r\n     */\r\n    public _outputTexture: Nullable<RenderTargetWrapper> = null;\r\n    /**\r\n     * Sampling mode used by the shader\r\n     * See https://doc.babylonjs.com/classes/3.1/texture\r\n     */\r\n    @serialize()\r\n    public renderTargetSamplingMode: number;\r\n    /**\r\n     * Clear color to use when screen clearing\r\n     */\r\n    @serializeAsColor4()\r\n    public clearColor: Color4;\r\n    /**\r\n     * If the buffer needs to be cleared before applying the post process. (default: true)\r\n     * Should be set to false if shader will overwrite all previous pixels.\r\n     */\r\n    @serialize()\r\n    public autoClear = true;\r\n    /**\r\n     * Type of alpha mode to use when performing the post process (default: Engine.ALPHA_DISABLE)\r\n     */\r\n    @serialize()\r\n    public alphaMode = Constants.ALPHA_DISABLE;\r\n    /**\r\n     * Sets the setAlphaBlendConstants of the babylon engine\r\n     */\r\n    @serialize()\r\n    public alphaConstants: Color4;\r\n    /**\r\n     * Animations to be used for the post processing\r\n     */\r\n    public animations = new Array<Animation>();\r\n\r\n    /**\r\n     * Enable Pixel Perfect mode where texture is not scaled to be power of 2.\r\n     * Can only be used on a single postprocess or on the last one of a chain. (default: false)\r\n     */\r\n    @serialize()\r\n    public enablePixelPerfectMode = false;\r\n\r\n    /**\r\n     * Force the postprocess to be applied without taking in account viewport\r\n     */\r\n    @serialize()\r\n    public forceFullscreenViewport = true;\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/how_to/debug_layer#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    /**\r\n     * Scale mode for the post process (default: Engine.SCALEMODE_FLOOR)\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 1     | SCALEMODE_FLOOR                     | [engine.scalemode_floor](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_floor) |\r\n     * | 2     | SCALEMODE_NEAREST                   | [engine.scalemode_nearest](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_nearest) |\r\n     * | 3     | SCALEMODE_CEILING                   | [engine.scalemode_ceiling](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_ceiling) |\r\n     *\r\n     */\r\n    @serialize()\r\n    public scaleMode = Constants.SCALEMODE_FLOOR;\r\n    /**\r\n     * Force textures to be a power of two (default: false)\r\n     */\r\n    @serialize()\r\n    public alwaysForcePOT = false;\r\n\r\n    @serialize(\"samples\")\r\n    private _samples = 1;\r\n\r\n    /**\r\n     * Number of sample textures (default: 1)\r\n     */\r\n    public get samples() {\r\n        return this._samples;\r\n    }\r\n\r\n    public set samples(n: number) {\r\n        this._samples = Math.min(n, this._engine.getCaps().maxMSAASamples);\r\n\r\n        this._textures.forEach((texture) => {\r\n            if (texture.samples !== this._samples) {\r\n                this._engine.updateRenderTargetTextureSampleCount(texture, this._samples);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Modify the scale of the post process to be the same as the viewport (default: false)\r\n     */\r\n    @serialize()\r\n    public adaptScaleToCurrentViewport = false;\r\n\r\n    private _camera: Camera;\r\n    protected _scene: Scene;\r\n    private _engine: Engine;\r\n\r\n    private _options: number | PostProcessOptions;\r\n    private _reusable = false;\r\n    private _renderId = 0;\r\n    private _textureType: number;\r\n    private _textureFormat: number;\r\n\r\n    /**\r\n     * if externalTextureSamplerBinding is true, the \"apply\" method won't bind the textureSampler texture, it is expected to be done by the \"outside\" (by the onApplyObservable observer most probably).\r\n     * counter-productive in some cases because if the texture bound by \"apply\" is different from the currently texture bound, (the one set by the onApplyObservable observer, for eg) some\r\n     * internal structures (materialContext) will be dirtified, which may impact performances\r\n     */\r\n    public externalTextureSamplerBinding = false;\r\n\r\n    /**\r\n     * Smart array of input and output textures for the post process.\r\n     * @hidden\r\n     */\r\n    public _textures = new SmartArray<RenderTargetWrapper>(2);\r\n    /**\r\n     * Smart array of input and output textures for the post process.\r\n     * @hidden\r\n     */\r\n    private _textureCache: TextureCache[] = [];\r\n    /**\r\n     * The index in _textures that corresponds to the output texture.\r\n     * @hidden\r\n     */\r\n    public _currentRenderTextureInd = 0;\r\n    private _drawWrapper: DrawWrapper;\r\n    private _samplers: string[];\r\n    private _fragmentUrl: string;\r\n    private _vertexUrl: string;\r\n    private _parameters: string[];\r\n    protected _postProcessDefines: Nullable<string>;\r\n    private _scaleRatio = new Vector2(1, 1);\r\n    protected _indexParameters: any;\r\n    private _shareOutputWithPostProcess: Nullable<PostProcess>;\r\n    private _texelSize = Vector2.Zero();\r\n    /** @hidden */\r\n    public _forcedOutputTexture: Nullable<RenderTargetWrapper>;\r\n\r\n    /**\r\n     * Prepass configuration in case this post process needs a texture from prepass\r\n     * @hidden\r\n     */\r\n    public _prePassEffectConfiguration: PrePassEffectConfiguration;\r\n\r\n    /**\r\n     * Returns the fragment url or shader name used in the post process.\r\n     * @returns the fragment url or name in the shader store.\r\n     */\r\n    public getEffectName(): string {\r\n        return this._fragmentUrl;\r\n    }\r\n\r\n    // Events\r\n\r\n    /**\r\n     * An event triggered when the postprocess is activated.\r\n     */\r\n    public onActivateObservable = new Observable<Camera>();\r\n\r\n    private _onActivateObserver: Nullable<Observer<Camera>>;\r\n    /**\r\n     * A function that is added to the onActivateObservable\r\n     */\r\n    public set onActivate(callback: Nullable<(camera: Camera) => void>) {\r\n        if (this._onActivateObserver) {\r\n            this.onActivateObservable.remove(this._onActivateObserver);\r\n        }\r\n        if (callback) {\r\n            this._onActivateObserver = this.onActivateObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the postprocess changes its size.\r\n     */\r\n    public onSizeChangedObservable = new Observable<PostProcess>();\r\n\r\n    private _onSizeChangedObserver: Nullable<Observer<PostProcess>>;\r\n    /**\r\n     * A function that is added to the onSizeChangedObservable\r\n     */\r\n    public set onSizeChanged(callback: (postProcess: PostProcess) => void) {\r\n        if (this._onSizeChangedObserver) {\r\n            this.onSizeChangedObservable.remove(this._onSizeChangedObserver);\r\n        }\r\n        this._onSizeChangedObserver = this.onSizeChangedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the postprocess applies its effect.\r\n     */\r\n    public onApplyObservable = new Observable<Effect>();\r\n\r\n    private _onApplyObserver: Nullable<Observer<Effect>>;\r\n    /**\r\n     * A function that is added to the onApplyObservable\r\n     */\r\n    public set onApply(callback: (effect: Effect) => void) {\r\n        if (this._onApplyObserver) {\r\n            this.onApplyObservable.remove(this._onApplyObserver);\r\n        }\r\n        this._onApplyObserver = this.onApplyObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered before rendering the postprocess\r\n     */\r\n    public onBeforeRenderObservable = new Observable<Effect>();\r\n\r\n    private _onBeforeRenderObserver: Nullable<Observer<Effect>>;\r\n    /**\r\n     * A function that is added to the onBeforeRenderObservable\r\n     */\r\n    public set onBeforeRender(callback: (effect: Effect) => void) {\r\n        if (this._onBeforeRenderObserver) {\r\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\r\n        }\r\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered after rendering the postprocess\r\n     */\r\n    public onAfterRenderObservable = new Observable<Effect>();\r\n\r\n    private _onAfterRenderObserver: Nullable<Observer<Effect>>;\r\n    /**\r\n     * A function that is added to the onAfterRenderObservable\r\n     */\r\n    public set onAfterRender(callback: (efect: Effect) => void) {\r\n        if (this._onAfterRenderObserver) {\r\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\r\n        }\r\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * The input texture for this post process and the output texture of the previous post process. When added to a pipeline the previous post process will\r\n     * render it's output into this texture and this texture will be used as textureSampler in the fragment shader of this post process.\r\n     */\r\n    public get inputTexture(): RenderTargetWrapper {\r\n        return this._textures.data[this._currentRenderTextureInd];\r\n    }\r\n\r\n    public set inputTexture(value: RenderTargetWrapper) {\r\n        this._forcedOutputTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Since inputTexture should always be defined, if we previously manually set `inputTexture`,\r\n     * the only way to unset it is to use this function to restore its internal state\r\n     */\r\n    public restoreDefaultInputTexture() {\r\n        if (this._forcedOutputTexture) {\r\n            this._forcedOutputTexture = null;\r\n            this.markTextureDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the camera which post process is applied to.\r\n     * @returns The camera the post process is applied to.\r\n     */\r\n    public getCamera(): Camera {\r\n        return this._camera;\r\n    }\r\n\r\n    /**\r\n     * Gets the texel size of the postprocess.\r\n     * See https://en.wikipedia.org/wiki/Texel_(graphics)\r\n     */\r\n    public get texelSize(): Vector2 {\r\n        if (this._shareOutputWithPostProcess) {\r\n            return this._shareOutputWithPostProcess.texelSize;\r\n        }\r\n\r\n        if (this._forcedOutputTexture) {\r\n            this._texelSize.copyFromFloats(1.0 / this._forcedOutputTexture.width, 1.0 / this._forcedOutputTexture.height);\r\n        }\r\n\r\n        return this._texelSize;\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance PostProcess\r\n     * @param name The name of the PostProcess.\r\n     * @param fragmentUrl The url of the fragment shader to be used.\r\n     * @param parameters Array of the names of uniform non-sampler2D variables that will be passed to the shader.\r\n     * @param samplers Array of the names of uniform sampler2D variables that will be passed to the shader.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param defines String of defines that will be set when running the fragment shader. (default: null)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param vertexUrl The url of the vertex shader to be used. (default: \"postprocess\")\r\n     * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\r\n     * @param blockCompilation If the shader should not be compiled immediatly. (default: false)\r\n     * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        fragmentUrl: string,\r\n        parameters: Nullable<string[]>,\r\n        samplers: Nullable<string[]>,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode: number = Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        defines: Nullable<string> = null,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        vertexUrl: string = \"postprocess\",\r\n        indexParameters?: any,\r\n        blockCompilation = false,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA\r\n    ) {\r\n        this.name = name;\r\n        if (camera != null) {\r\n            this._camera = camera;\r\n            this._scene = camera.getScene();\r\n            camera.attachPostProcess(this);\r\n            this._engine = this._scene.getEngine();\r\n\r\n            this._scene.postProcesses.push(this);\r\n            this.uniqueId = this._scene.getUniqueId();\r\n        } else if (engine) {\r\n            this._engine = engine;\r\n            this._engine.postProcesses.push(this);\r\n        }\r\n        this._options = options;\r\n        this.renderTargetSamplingMode = samplingMode ? samplingMode : Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        this._reusable = reusable || false;\r\n        this._textureType = textureType;\r\n        this._textureFormat = textureFormat;\r\n\r\n        this._samplers = samplers || [];\r\n        this._samplers.push(\"textureSampler\");\r\n\r\n        this._fragmentUrl = fragmentUrl;\r\n        this._vertexUrl = vertexUrl;\r\n        this._parameters = parameters || [];\r\n\r\n        this._parameters.push(\"scale\");\r\n\r\n        this._indexParameters = indexParameters;\r\n        this._drawWrapper = new DrawWrapper(this._engine);\r\n\r\n        if (!blockCompilation) {\r\n            this.updateEffect(defines);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"PostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"PostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Gets the engine which this post process belongs to.\r\n     * @returns The engine the post process was enabled with.\r\n     */\r\n    public getEngine(): Engine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * The effect that is created when initializing the post process.\r\n     * @returns The created effect corresponding the the postprocess.\r\n     */\r\n    public getEffect(): Effect {\r\n        return this._drawWrapper.effect!;\r\n    }\r\n\r\n    /**\r\n     * To avoid multiple redundant textures for multiple post process, the output the output texture for this post process can be shared with another.\r\n     * @param postProcess The post process to share the output with.\r\n     * @returns This post process.\r\n     */\r\n    public shareOutputWith(postProcess: PostProcess): PostProcess {\r\n        this._disposeTextures();\r\n\r\n        this._shareOutputWithPostProcess = postProcess;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reverses the effect of calling shareOutputWith and returns the post process back to its original state.\r\n     * This should be called if the post process that shares output with this post process is disabled/disposed.\r\n     */\r\n    public useOwnOutput() {\r\n        if (this._textures.length == 0) {\r\n            this._textures = new SmartArray<RenderTargetWrapper>(2);\r\n        }\r\n\r\n        this._shareOutputWithPostProcess = null;\r\n    }\r\n\r\n    /**\r\n     * Updates the effect with the current post process compile time values and recompiles the shader.\r\n     * @param defines Define statements that should be added at the beginning of the shader. (default: null)\r\n     * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)\r\n     * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)\r\n     * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\r\n     * @param onCompiled Called when the shader has been compiled.\r\n     * @param onError Called if there is an error when compiling a shader.\r\n     * @param vertexUrl The url of the vertex shader to be used (default: the one given at construction time)\r\n     * @param fragmentUrl The url of the fragment shader to be used (default: the one given at construction time)\r\n     */\r\n    public updateEffect(\r\n        defines: Nullable<string> = null,\r\n        uniforms: Nullable<string[]> = null,\r\n        samplers: Nullable<string[]> = null,\r\n        indexParameters?: any,\r\n        onCompiled?: (effect: Effect) => void,\r\n        onError?: (effect: Effect, errors: string) => void,\r\n        vertexUrl?: string,\r\n        fragmentUrl?: string\r\n    ) {\r\n        this._postProcessDefines = defines;\r\n        this._drawWrapper.effect = this._engine.createEffect(\r\n            { vertex: vertexUrl ?? this._vertexUrl, fragment: fragmentUrl ?? this._fragmentUrl },\r\n            [\"position\"],\r\n            uniforms || this._parameters,\r\n            samplers || this._samplers,\r\n            defines !== null ? defines : \"\",\r\n            undefined,\r\n            onCompiled,\r\n            onError,\r\n            indexParameters || this._indexParameters\r\n        );\r\n    }\r\n\r\n    /**\r\n     * The post process is reusable if it can be used multiple times within one frame.\r\n     * @returns If the post process is reusable\r\n     */\r\n    public isReusable(): boolean {\r\n        return this._reusable;\r\n    }\r\n\r\n    /** invalidate frameBuffer to hint the postprocess to create a depth buffer */\r\n    public markTextureDirty(): void {\r\n        this.width = -1;\r\n    }\r\n\r\n    private _createRenderTargetTexture(textureSize: { width: number; height: number }, textureOptions: RenderTargetCreationOptions, channel = 0) {\r\n        for (let i = 0; i < this._textureCache.length; i++) {\r\n            if (\r\n                this._textureCache[i].texture.width === textureSize.width &&\r\n                this._textureCache[i].texture.height === textureSize.height &&\r\n                this._textureCache[i].postProcessChannel === channel &&\r\n                this._textureCache[i].texture._generateDepthBuffer === textureOptions.generateDepthBuffer\r\n            ) {\r\n                return this._textureCache[i].texture;\r\n            }\r\n        }\r\n\r\n        const tex = this._engine.createRenderTargetTexture(textureSize, textureOptions);\r\n        this._textureCache.push({ texture: tex, postProcessChannel: channel, lastUsedRenderId: -1 });\r\n\r\n        return tex;\r\n    }\r\n\r\n    private _flushTextureCache() {\r\n        const currentRenderId = this._renderId;\r\n\r\n        for (let i = this._textureCache.length - 1; i >= 0; i--) {\r\n            if (currentRenderId - this._textureCache[i].lastUsedRenderId > 100) {\r\n                let currentlyUsed = false;\r\n                for (let j = 0; j < this._textures.length; j++) {\r\n                    if (this._textures.data[j] === this._textureCache[i].texture) {\r\n                        currentlyUsed = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!currentlyUsed) {\r\n                    this._textureCache[i].texture.dispose();\r\n                    this._textureCache.splice(i, 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _resize(width: number, height: number, camera: Camera, needMipMaps: boolean, forceDepthStencil?: boolean) {\r\n        if (this._textures.length > 0) {\r\n            this._textures.reset();\r\n        }\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        let firstPP = null;\r\n        for (let i = 0; i < camera._postProcesses.length; i++) {\r\n            if (camera._postProcesses[i] !== null) {\r\n                firstPP = camera._postProcesses[i];\r\n                break;\r\n            }\r\n        }\r\n\r\n        const textureSize = { width: this.width, height: this.height };\r\n        const textureOptions = {\r\n            generateMipMaps: needMipMaps,\r\n            generateDepthBuffer: forceDepthStencil || firstPP === this,\r\n            generateStencilBuffer: (forceDepthStencil || firstPP === this) && this._engine.isStencilEnable,\r\n            samplingMode: this.renderTargetSamplingMode,\r\n            type: this._textureType,\r\n            format: this._textureFormat,\r\n        };\r\n\r\n        this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 0));\r\n\r\n        if (this._reusable) {\r\n            this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 1));\r\n        }\r\n\r\n        this._texelSize.copyFromFloats(1.0 / this.width, 1.0 / this.height);\r\n\r\n        this.onSizeChangedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Activates the post process by intializing the textures to be used when executed. Notifies onActivateObservable.\r\n     * When this post process is used in a pipeline, this is call will bind the input texture of this post process to the output of the previous.\r\n     * @param camera The camera that will be used in the post process. This camera will be used when calling onActivateObservable.\r\n     * @param sourceTexture The source texture to be inspected to get the width and height if not specified in the post process constructor. (default: null)\r\n     * @param forceDepthStencil If true, a depth and stencil buffer will be generated. (default: false)\r\n     * @returns The render target wrapper that was bound to be written to.\r\n     */\r\n    public activate(camera: Nullable<Camera>, sourceTexture: Nullable<InternalTexture> = null, forceDepthStencil?: boolean): RenderTargetWrapper {\r\n        camera = camera || this._camera;\r\n\r\n        const scene = camera.getScene();\r\n        const engine = scene.getEngine();\r\n        const maxSize = engine.getCaps().maxTextureSize;\r\n\r\n        let requiredWidth = ((sourceTexture ? sourceTexture.width : this._engine.getRenderWidth(true)) * <number>this._options) | 0;\r\n        const requiredHeight = ((sourceTexture ? sourceTexture.height : this._engine.getRenderHeight(true)) * <number>this._options) | 0;\r\n\r\n        // If rendering to a webvr camera's left or right eye only half the width should be used to avoid resize when rendered to screen\r\n        const webVRCamera = <WebVRFreeCamera>camera.parent;\r\n        if (webVRCamera && (webVRCamera.leftCamera == camera || webVRCamera.rightCamera == camera)) {\r\n            requiredWidth /= 2;\r\n        }\r\n\r\n        let desiredWidth = (<PostProcessOptions>this._options).width || requiredWidth;\r\n        let desiredHeight = (<PostProcessOptions>this._options).height || requiredHeight;\r\n\r\n        const needMipMaps =\r\n            this.renderTargetSamplingMode !== Constants.TEXTURE_NEAREST_LINEAR &&\r\n            this.renderTargetSamplingMode !== Constants.TEXTURE_NEAREST_NEAREST &&\r\n            this.renderTargetSamplingMode !== Constants.TEXTURE_LINEAR_LINEAR;\r\n\r\n        if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {\r\n            if (this.adaptScaleToCurrentViewport) {\r\n                const currentViewport = engine.currentViewport;\r\n\r\n                if (currentViewport) {\r\n                    desiredWidth *= currentViewport.width;\r\n                    desiredHeight *= currentViewport.height;\r\n                }\r\n            }\r\n\r\n            if (needMipMaps || this.alwaysForcePOT) {\r\n                if (!(<PostProcessOptions>this._options).width) {\r\n                    desiredWidth = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredWidth, maxSize, this.scaleMode) : desiredWidth;\r\n                }\r\n\r\n                if (!(<PostProcessOptions>this._options).height) {\r\n                    desiredHeight = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredHeight, maxSize, this.scaleMode) : desiredHeight;\r\n                }\r\n            }\r\n\r\n            if (this.width !== desiredWidth || this.height !== desiredHeight) {\r\n                this._resize(desiredWidth, desiredHeight, camera, needMipMaps, forceDepthStencil);\r\n            }\r\n\r\n            this._textures.forEach((texture) => {\r\n                if (texture.samples !== this.samples) {\r\n                    this._engine.updateRenderTargetTextureSampleCount(texture, this.samples);\r\n                }\r\n            });\r\n\r\n            this._flushTextureCache();\r\n            this._renderId++;\r\n        }\r\n\r\n        let target: RenderTargetWrapper;\r\n\r\n        if (this._shareOutputWithPostProcess) {\r\n            target = this._shareOutputWithPostProcess.inputTexture;\r\n        } else if (this._forcedOutputTexture) {\r\n            target = this._forcedOutputTexture;\r\n\r\n            this.width = this._forcedOutputTexture.width;\r\n            this.height = this._forcedOutputTexture.height;\r\n        } else {\r\n            target = this.inputTexture;\r\n\r\n            let cache;\r\n            for (let i = 0; i < this._textureCache.length; i++) {\r\n                if (this._textureCache[i].texture === target) {\r\n                    cache = this._textureCache[i];\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (cache) {\r\n                cache.lastUsedRenderId = this._renderId;\r\n            }\r\n        }\r\n\r\n        // Bind the input of this post process to be used as the output of the previous post process.\r\n        if (this.enablePixelPerfectMode) {\r\n            this._scaleRatio.copyFromFloats(requiredWidth / desiredWidth, requiredHeight / desiredHeight);\r\n            this._engine.bindFramebuffer(target, 0, requiredWidth, requiredHeight, this.forceFullscreenViewport);\r\n        } else {\r\n            this._scaleRatio.copyFromFloats(1, 1);\r\n            this._engine.bindFramebuffer(target, 0, undefined, undefined, this.forceFullscreenViewport);\r\n        }\r\n\r\n        this._engine._debugInsertMarker?.(`post process ${this.name} input`);\r\n\r\n        this.onActivateObservable.notifyObservers(camera);\r\n\r\n        // Clear\r\n        if (this.autoClear && this.alphaMode === Constants.ALPHA_DISABLE) {\r\n            this._engine.clear(this.clearColor ? this.clearColor : scene.clearColor, scene._allowPostProcessClearColor, true, true);\r\n        }\r\n\r\n        if (this._reusable) {\r\n            this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2;\r\n        }\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     * If the post process is supported.\r\n     */\r\n    public get isSupported(): boolean {\r\n        return this._drawWrapper.effect!.isSupported;\r\n    }\r\n\r\n    /**\r\n     * The aspect ratio of the output texture.\r\n     */\r\n    public get aspectRatio(): number {\r\n        if (this._shareOutputWithPostProcess) {\r\n            return this._shareOutputWithPostProcess.aspectRatio;\r\n        }\r\n\r\n        if (this._forcedOutputTexture) {\r\n            return this._forcedOutputTexture.width / this._forcedOutputTexture.height;\r\n        }\r\n        return this.width / this.height;\r\n    }\r\n\r\n    /**\r\n     * Get a value indicating if the post-process is ready to be used\r\n     * @returns true if the post-process is ready (shader is compiled)\r\n     */\r\n    public isReady(): boolean {\r\n        return this._drawWrapper.effect?.isReady() ?? false;\r\n    }\r\n\r\n    /**\r\n     * Binds all textures and uniforms to the shader, this will be run on every pass.\r\n     * @returns the effect corresponding to this post process. Null if not compiled or not ready.\r\n     */\r\n    public apply(): Nullable<Effect> {\r\n        // Check\r\n        if (!this._drawWrapper.effect?.isReady()) {\r\n            return null;\r\n        }\r\n\r\n        // States\r\n        this._engine.enableEffect(this._drawWrapper);\r\n        this._engine.setState(false);\r\n        this._engine.setDepthBuffer(false);\r\n        this._engine.setDepthWrite(false);\r\n\r\n        // Alpha\r\n        this._engine.setAlphaMode(this.alphaMode);\r\n        if (this.alphaConstants) {\r\n            this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a);\r\n        }\r\n\r\n        // Bind the output texture of the preivous post process as the input to this post process.\r\n        let source: RenderTargetWrapper;\r\n        if (this._shareOutputWithPostProcess) {\r\n            source = this._shareOutputWithPostProcess.inputTexture;\r\n        } else if (this._forcedOutputTexture) {\r\n            source = this._forcedOutputTexture;\r\n        } else {\r\n            source = this.inputTexture;\r\n        }\r\n\r\n        if (!this.externalTextureSamplerBinding) {\r\n            this._drawWrapper.effect._bindTexture(\"textureSampler\", source?.texture);\r\n        }\r\n\r\n        // Parameters\r\n        this._drawWrapper.effect.setVector2(\"scale\", this._scaleRatio);\r\n        this.onApplyObservable.notifyObservers(this._drawWrapper.effect);\r\n\r\n        return this._drawWrapper.effect;\r\n    }\r\n\r\n    private _disposeTextures() {\r\n        if (this._shareOutputWithPostProcess || this._forcedOutputTexture) {\r\n            this._disposeTextureCache();\r\n            return;\r\n        }\r\n\r\n        this._disposeTextureCache();\r\n        this._textures.dispose();\r\n    }\r\n\r\n    private _disposeTextureCache() {\r\n        for (let i = this._textureCache.length - 1; i >= 0; i--) {\r\n            this._textureCache[i].texture.dispose();\r\n        }\r\n\r\n        this._textureCache.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     * @param prePassRenderer defines the prepass renderer to setup.\r\n     * @returns true if the pre pass is needed.\r\n     */\r\n    public setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean {\r\n        if (this._prePassEffectConfiguration) {\r\n            this._prePassEffectConfiguration = prePassRenderer.addEffectConfiguration(this._prePassEffectConfiguration);\r\n            this._prePassEffectConfiguration.enabled = true;\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the post process.\r\n     * @param camera The camera to dispose the post process on.\r\n     */\r\n    public dispose(camera?: Camera): void {\r\n        camera = camera || this._camera;\r\n\r\n        this._disposeTextures();\r\n\r\n        let index;\r\n        if (this._scene) {\r\n            index = this._scene.postProcesses.indexOf(this);\r\n            if (index !== -1) {\r\n                this._scene.postProcesses.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.postProcesses.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.postProcesses.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        index = this._engine.postProcesses.indexOf(this);\r\n        if (index !== -1) {\r\n            this._engine.postProcesses.splice(index, 1);\r\n        }\r\n\r\n        if (!camera) {\r\n            return;\r\n        }\r\n        camera.detachPostProcess(this);\r\n\r\n        index = camera._postProcesses.indexOf(this);\r\n        if (index === 0 && camera._postProcesses.length > 0) {\r\n            const firstPostProcess = this._camera._getFirstPostProcess();\r\n            if (firstPostProcess) {\r\n                firstPostProcess.markTextureDirty();\r\n            }\r\n        }\r\n\r\n        this.onActivateObservable.clear();\r\n        this.onAfterRenderObservable.clear();\r\n        this.onApplyObservable.clear();\r\n        this.onBeforeRenderObservable.clear();\r\n        this.onSizeChangedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Serializes the post process to a JSON object\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        const camera = this.getCamera() || (this._scene && this._scene.activeCamera);\r\n        serializationObject.customType = \"BABYLON.\" + this.getClassName();\r\n        serializationObject.cameraId = camera ? camera.id : null;\r\n        serializationObject.reusable = this._reusable;\r\n        serializationObject.textureType = this._textureType;\r\n        serializationObject.fragmentUrl = this._fragmentUrl;\r\n        serializationObject.parameters = this._parameters;\r\n        serializationObject.samplers = this._samplers;\r\n        serializationObject.options = this._options;\r\n        serializationObject.defines = this._postProcessDefines;\r\n        serializationObject.textureFormat = this._textureFormat;\r\n        serializationObject.vertexUrl = this._vertexUrl;\r\n        serializationObject.indexParameters = this._indexParameters;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Clones this post process\r\n     * @returns a new post process similar to this one\r\n     */\r\n    public clone(): Nullable<PostProcess> {\r\n        const serializationObject = this.serialize();\r\n        serializationObject._engine = this._engine;\r\n        serializationObject.cameraId = null;\r\n\r\n        const result = PostProcess.Parse(serializationObject, this._scene, \"\");\r\n\r\n        if (!result) {\r\n            return null;\r\n        }\r\n\r\n        result.onActivateObservable = this.onActivateObservable.clone();\r\n        result.onSizeChangedObservable = this.onSizeChangedObservable.clone();\r\n        result.onApplyObservable = this.onApplyObservable.clone();\r\n        result.onBeforeRenderObservable = this.onBeforeRenderObservable.clone();\r\n        result.onAfterRenderObservable = this.onAfterRenderObservable.clone();\r\n\r\n        result._prePassEffectConfiguration = this._prePassEffectConfiguration;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a material from parsed material data\r\n     * @param parsedPostProcess defines parsed post process data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures\r\n     * @returns a new post process\r\n     */\r\n    public static Parse(parsedPostProcess: any, scene: Scene, rootUrl: string): Nullable<PostProcess> {\r\n        const postProcessType = GetClass(parsedPostProcess.customType);\r\n\r\n        if (!postProcessType || !postProcessType._Parse) {\r\n            return null;\r\n        }\r\n\r\n        const camera = scene ? scene.getCameraById(parsedPostProcess.cameraId) : null;\r\n        return postProcessType._Parse(parsedPostProcess, camera, scene, rootUrl);\r\n    }\r\n\r\n    /**\r\n     * @param parsedPostProcess\r\n     * @param targetCamera\r\n     * @param scene\r\n     * @param rootUrl\r\n     * @hidden\r\n     */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<PostProcess> {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new PostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.fragmentUrl,\r\n                    parsedPostProcess.parameters,\r\n                    parsedPostProcess.samplers,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    parsedPostProcess._engine,\r\n                    parsedPostProcess.reusable,\r\n                    parsedPostProcess.defines,\r\n                    parsedPostProcess.textureType,\r\n                    parsedPostProcess.vertexUrl,\r\n                    parsedPostProcess.indexParameters,\r\n                    false,\r\n                    parsedPostProcess.textureFormat\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.PostProcess\", PostProcess);\r\n"]},"metadata":{},"sourceType":"module"}