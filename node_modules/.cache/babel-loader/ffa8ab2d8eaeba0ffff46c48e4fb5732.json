{"ast":null,"code":"import \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport { TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Mesh, _CreationDataStorage } from \"../mesh.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a Ribbon\n * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\n * * pathArray array of paths, each of which an array of successive Vector3\n * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\n * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\n * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\n * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\n * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\n * @param options.pathArray\n * @param options.closeArray\n * @param options.closePath\n * @param options.offset\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.invertUV\n * @param options.uvs\n * @param options.colors\n * @returns the VertexData of the ribbon\n */\n\nexport function CreateRibbonVertexData(options) {\n  var pathArray = options.pathArray;\n  var closeArray = options.closeArray || false;\n  var closePath = options.closePath || false;\n  var invertUV = options.invertUV || false;\n  var defaultOffset = Math.floor(pathArray[0].length / 2);\n  var offset = options.offset || defaultOffset;\n  offset = offset > defaultOffset ? defaultOffset : Math.floor(offset); // offset max allowed : defaultOffset\n\n  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  var customUV = options.uvs;\n  var customColors = options.colors;\n  var positions = [];\n  var indices = [];\n  var normals = [];\n  var uvs = [];\n  var us = []; // us[path_id] = [uDist1, uDist2, uDist3 ... ] distances between points on path path_id\n\n  var vs = []; // vs[i] = [vDist1, vDist2, vDist3, ... ] distances between points i of consecutive paths from pathArray\n\n  var uTotalDistance = []; // uTotalDistance[p] : total distance of path p\n\n  var vTotalDistance = []; //  vTotalDistance[i] : total distance between points i of first and last path from pathArray\n\n  var minlg; // minimal length among all paths from pathArray\n\n  var lg = []; // array of path lengths : nb of vertex per path\n\n  var idx = []; // array of path indexes : index of each path (first vertex) in the total vertex number\n\n  var p; // path iterator\n\n  var i; // point iterator\n\n  var j; // point iterator\n  // if single path in pathArray\n\n  if (pathArray.length < 2) {\n    var ar1 = [];\n    var ar2 = [];\n\n    for (i = 0; i < pathArray[0].length - offset; i++) {\n      ar1.push(pathArray[0][i]);\n      ar2.push(pathArray[0][i + offset]);\n    }\n\n    pathArray = [ar1, ar2];\n  } // positions and horizontal distances (u)\n\n\n  var idc = 0;\n  var closePathCorr = closePath ? 1 : 0; // the final index will be +1 if closePath\n\n  var path;\n  var l;\n  minlg = pathArray[0].length;\n  var vectlg;\n  var dist;\n\n  for (p = 0; p < pathArray.length; p++) {\n    uTotalDistance[p] = 0;\n    us[p] = [0];\n    path = pathArray[p];\n    l = path.length;\n    minlg = minlg < l ? minlg : l;\n    j = 0;\n\n    while (j < l) {\n      positions.push(path[j].x, path[j].y, path[j].z);\n\n      if (j > 0) {\n        vectlg = path[j].subtract(path[j - 1]).length();\n        dist = vectlg + uTotalDistance[p];\n        us[p].push(dist);\n        uTotalDistance[p] = dist;\n      }\n\n      j++;\n    }\n\n    if (closePath) {\n      // an extra hidden vertex is added in the \"positions\" array\n      j--;\n      positions.push(path[0].x, path[0].y, path[0].z);\n      vectlg = path[j].subtract(path[0]).length();\n      dist = vectlg + uTotalDistance[p];\n      us[p].push(dist);\n      uTotalDistance[p] = dist;\n    }\n\n    lg[p] = l + closePathCorr;\n    idx[p] = idc;\n    idc += l + closePathCorr;\n  } // vertical distances (v)\n\n\n  var path1;\n  var path2;\n  var vertex1 = null;\n  var vertex2 = null;\n\n  for (i = 0; i < minlg + closePathCorr; i++) {\n    vTotalDistance[i] = 0;\n    vs[i] = [0];\n\n    for (p = 0; p < pathArray.length - 1; p++) {\n      path1 = pathArray[p];\n      path2 = pathArray[p + 1];\n\n      if (i === minlg) {\n        // closePath\n        vertex1 = path1[0];\n        vertex2 = path2[0];\n      } else {\n        vertex1 = path1[i];\n        vertex2 = path2[i];\n      }\n\n      vectlg = vertex2.subtract(vertex1).length();\n      dist = vectlg + vTotalDistance[i];\n      vs[i].push(dist);\n      vTotalDistance[i] = dist;\n    }\n\n    if (closeArray && vertex2 && vertex1) {\n      path1 = pathArray[p];\n      path2 = pathArray[0];\n\n      if (i === minlg) {\n        // closePath\n        vertex2 = path2[0];\n      }\n\n      vectlg = vertex2.subtract(vertex1).length();\n      dist = vectlg + vTotalDistance[i];\n      vTotalDistance[i] = dist;\n    }\n  } // uvs\n\n\n  var u;\n  var v;\n\n  if (customUV) {\n    for (p = 0; p < customUV.length; p++) {\n      uvs.push(customUV[p].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - customUV[p].y : customUV[p].y);\n    }\n  } else {\n    for (p = 0; p < pathArray.length; p++) {\n      for (i = 0; i < minlg + closePathCorr; i++) {\n        u = uTotalDistance[p] != 0.0 ? us[p][i] / uTotalDistance[p] : 0.0;\n        v = vTotalDistance[i] != 0.0 ? vs[i][p] / vTotalDistance[i] : 0.0;\n\n        if (invertUV) {\n          uvs.push(v, u);\n        } else {\n          uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - v : v);\n        }\n      }\n    }\n  } // indices\n\n\n  p = 0; // path index\n\n  var pi = 0; // positions array index\n\n  var l1 = lg[p] - 1; // path1 length\n\n  var l2 = lg[p + 1] - 1; // path2 length\n\n  var min = l1 < l2 ? l1 : l2; // current path stop index\n\n  var shft = idx[1] - idx[0]; // shift\n\n  var path1nb = closeArray ? lg.length : lg.length - 1; // number of path1 to iterate\ton\n\n  while (pi <= min && p < path1nb) {\n    //  stay under min and don't go over next to last path\n    // draw two triangles between path1 (p1) and path2 (p2) : (p1.pi, p2.pi, p1.pi+1) and (p2.pi+1, p1.pi+1, p2.pi) clockwise\n    indices.push(pi, pi + shft, pi + 1);\n    indices.push(pi + shft + 1, pi + 1, pi + shft);\n    pi += 1;\n\n    if (pi === min) {\n      // if end of one of two consecutive paths reached, go to next existing path\n      p++;\n\n      if (p === lg.length - 1) {\n        // last path of pathArray reached <=> closeArray == true\n        shft = idx[0] - idx[p];\n        l1 = lg[p] - 1;\n        l2 = lg[0] - 1;\n      } else {\n        shft = idx[p + 1] - idx[p];\n        l1 = lg[p] - 1;\n        l2 = lg[p + 1] - 1;\n      }\n\n      pi = idx[p];\n      min = l1 < l2 ? l1 + pi : l2 + pi;\n    }\n  } // normals\n\n\n  VertexData.ComputeNormals(positions, indices, normals);\n\n  if (closePath) {\n    // update both the first and last vertex normals to their average value\n    var indexFirst = 0;\n    var indexLast = 0;\n\n    for (p = 0; p < pathArray.length; p++) {\n      indexFirst = idx[p] * 3;\n\n      if (p + 1 < pathArray.length) {\n        indexLast = (idx[p + 1] - 1) * 3;\n      } else {\n        indexLast = normals.length - 3;\n      }\n\n      normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\n      normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\n      normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\n      normals[indexLast] = normals[indexFirst];\n      normals[indexLast + 1] = normals[indexFirst + 1];\n      normals[indexLast + 2] = normals[indexFirst + 2];\n    }\n  } // sides\n\n\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs); // Colors\n\n\n  var colors = null;\n\n  if (customColors) {\n    colors = new Float32Array(customColors.length * 4);\n\n    for (var c = 0; c < customColors.length; c++) {\n      colors[c * 4] = customColors[c].r;\n      colors[c * 4 + 1] = customColors[c].g;\n      colors[c * 4 + 2] = customColors[c].b;\n      colors[c * 4 + 3] = customColors[c].a;\n    }\n  } // Result\n\n\n  var vertexData = new VertexData();\n  var positions32 = new Float32Array(positions);\n  var normals32 = new Float32Array(normals);\n  var uvs32 = new Float32Array(uvs);\n  vertexData.indices = indices;\n  vertexData.positions = positions32;\n  vertexData.normals = normals32;\n  vertexData.uvs = uvs32;\n\n  if (colors) {\n    vertexData.set(colors, VertexBuffer.ColorKind);\n  }\n\n  if (closePath) {\n    vertexData._idx = idx;\n  }\n\n  return vertexData;\n}\n/**\n * Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters\n * * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry\n * * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array\n * * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array\n * * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path\n * * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11\n * * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#ribbon\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\n * * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones\n * * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values\n * * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry\n * * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.pathArray\n * @param options.closeArray\n * @param options.closePath\n * @param options.offset\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.instance\n * @param options.invertUV\n * @param options.uvs\n * @param options.colors\n * @param scene defines the hosting scene\n * @returns the ribbon mesh\n * @see https://doc.babylonjs.com/how_to/ribbon_tutorial\n * @see https://doc.babylonjs.com/how_to/parametric_shapes\n */\n\nexport function CreateRibbon(name, options, scene) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  var pathArray = options.pathArray;\n  var closeArray = options.closeArray;\n  var closePath = options.closePath;\n\n  var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n\n  var instance = options.instance;\n  var updatable = options.updatable;\n\n  if (instance) {\n    // existing ribbon instance update\n    // positionFunction : ribbon case\n    // only pathArray and sideOrientation parameters are taken into account for positions update\n    var minimum_1 = TmpVectors.Vector3[0].setAll(Number.MAX_VALUE);\n    var maximum_1 = TmpVectors.Vector3[1].setAll(-Number.MAX_VALUE);\n\n    var positionFunction = function positionFunction(positions) {\n      var minlg = pathArray[0].length;\n      var mesh = instance;\n      var i = 0;\n      var ns = mesh._originalBuilderSideOrientation === Mesh.DOUBLESIDE ? 2 : 1;\n\n      for (var si = 1; si <= ns; ++si) {\n        for (var p = 0; p < pathArray.length; ++p) {\n          var path = pathArray[p];\n          var l = path.length;\n          minlg = minlg < l ? minlg : l;\n\n          for (var j = 0; j < minlg; ++j) {\n            var pathPoint = path[j];\n            positions[i] = pathPoint.x;\n            positions[i + 1] = pathPoint.y;\n            positions[i + 2] = pathPoint.z;\n            minimum_1.minimizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\n            maximum_1.maximizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\n            i += 3;\n          }\n\n          if (mesh._creationDataStorage && mesh._creationDataStorage.closePath) {\n            var pathPoint = path[0];\n            positions[i] = pathPoint.x;\n            positions[i + 1] = pathPoint.y;\n            positions[i + 2] = pathPoint.z;\n            i += 3;\n          }\n        }\n      }\n    };\n\n    var positions = instance.getVerticesData(VertexBuffer.PositionKind);\n    positionFunction(positions);\n\n    if (instance.hasBoundingInfo) {\n      instance.getBoundingInfo().reConstruct(minimum_1, maximum_1, instance._worldMatrix);\n    } else {\n      instance.buildBoundingInfo(minimum_1, maximum_1, instance._worldMatrix);\n    }\n\n    instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\n\n    if (options.colors) {\n      var colors = instance.getVerticesData(VertexBuffer.ColorKind);\n\n      for (var c = 0, colorIndex = 0; c < options.colors.length; c++, colorIndex += 4) {\n        var color = options.colors[c];\n        colors[colorIndex] = color.r;\n        colors[colorIndex + 1] = color.g;\n        colors[colorIndex + 2] = color.b;\n        colors[colorIndex + 3] = color.a;\n      }\n\n      instance.updateVerticesData(VertexBuffer.ColorKind, colors, false, false);\n    }\n\n    if (options.uvs) {\n      var uvs = instance.getVerticesData(VertexBuffer.UVKind);\n\n      for (var i = 0; i < options.uvs.length; i++) {\n        uvs[i * 2] = options.uvs[i].x;\n        uvs[i * 2 + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - options.uvs[i].y : options.uvs[i].y;\n      }\n\n      instance.updateVerticesData(VertexBuffer.UVKind, uvs, false, false);\n    }\n\n    if (!instance.areNormalsFrozen || instance.isFacetDataEnabled) {\n      var indices = instance.getIndices();\n      var normals = instance.getVerticesData(VertexBuffer.NormalKind);\n      var params = instance.isFacetDataEnabled ? instance.getFacetDataParameters() : null;\n      VertexData.ComputeNormals(positions, indices, normals, params);\n\n      if (instance._creationDataStorage && instance._creationDataStorage.closePath) {\n        var indexFirst = 0;\n        var indexLast = 0;\n\n        for (var p = 0; p < pathArray.length; p++) {\n          indexFirst = instance._creationDataStorage.idx[p] * 3;\n\n          if (p + 1 < pathArray.length) {\n            indexLast = (instance._creationDataStorage.idx[p + 1] - 1) * 3;\n          } else {\n            indexLast = normals.length - 3;\n          }\n\n          normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\n          normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\n          normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\n          normals[indexLast] = normals[indexFirst];\n          normals[indexLast + 1] = normals[indexFirst + 1];\n          normals[indexLast + 2] = normals[indexFirst + 2];\n        }\n      }\n\n      if (!instance.areNormalsFrozen) {\n        instance.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);\n      }\n    }\n\n    return instance;\n  } else {\n    // new ribbon creation\n    var ribbon = new Mesh(name, scene);\n    ribbon._originalBuilderSideOrientation = sideOrientation;\n    ribbon._creationDataStorage = new _CreationDataStorage();\n    var vertexData = CreateRibbonVertexData(options);\n\n    if (closePath) {\n      ribbon._creationDataStorage.idx = vertexData._idx;\n    }\n\n    ribbon._creationDataStorage.closePath = closePath;\n    ribbon._creationDataStorage.closeArray = closeArray;\n    vertexData.applyToMesh(ribbon, updatable);\n    return ribbon;\n  }\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateRibbon directly\n */\n\nexport var RibbonBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateRibbon: CreateRibbon\n};\nVertexData.CreateRibbon = CreateRibbonVertexData;\n\nMesh.CreateRibbon = function (name, pathArray, closeArray, closePath, offset, scene, updatable, sideOrientation, instance) {\n  if (closeArray === void 0) {\n    closeArray = false;\n  }\n\n  if (updatable === void 0) {\n    updatable = false;\n  }\n\n  return CreateRibbon(name, {\n    pathArray: pathArray,\n    closeArray: closeArray,\n    closePath: closePath,\n    offset: offset,\n    updatable: updatable,\n    sideOrientation: sideOrientation,\n    instance: instance\n  }, scene);\n};","map":{"version":3,"mappings":"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","names":["TmpVectors","Mesh","_CreationDataStorage","VertexBuffer","VertexData","CompatibilityOptions","CreateRibbonVertexData","options","pathArray","closeArray","closePath","invertUV","defaultOffset","Math","floor","length","offset","sideOrientation","DEFAULTSIDE","customUV","uvs","customColors","colors","positions","indices","normals","us","vs","uTotalDistance","vTotalDistance","minlg","lg","idx","p","i","j","ar1","ar2","push","idc","closePathCorr","path","l","vectlg","dist","x","y","z","subtract","path1","path2","vertex1","vertex2","u","v","UseOpenGLOrientationForUV","pi","l1","l2","min","shft","path1nb","ComputeNormals","indexFirst","indexLast","_ComputeSides","frontUVs","backUVs","Float32Array","c","r","g","b","a","vertexData","positions32","normals32","uvs32","set","ColorKind","_idx","CreateRibbon","name","scene","_GetDefaultSideOrientation","instance","updatable","minimum_1","Vector3","setAll","Number","MAX_VALUE","maximum_1","positionFunction","mesh","ns","_originalBuilderSideOrientation","DOUBLESIDE","si","pathPoint","minimizeInPlaceFromFloats","maximizeInPlaceFromFloats","_creationDataStorage","getVerticesData","PositionKind","hasBoundingInfo","getBoundingInfo","reConstruct","_worldMatrix","buildBoundingInfo","updateVerticesData","colorIndex","color","UVKind","areNormalsFrozen","isFacetDataEnabled","getIndices","NormalKind","params","getFacetDataParameters","ribbon","applyToMesh","RibbonBuilder"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Meshes/Builders/ribbonBuilder.ts"],"sourcesContent":["import type { Nullable, FloatArray } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector3, Vector2, Vector4 } from \"../../Maths/math.vector\";\r\nimport { TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a Ribbon\r\n * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\r\n * * pathArray array of paths, each of which an array of successive Vector3\r\n * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\r\n * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\r\n * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\r\n * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\r\n * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\r\n * @param options.pathArray\r\n * @param options.closeArray\r\n * @param options.closePath\r\n * @param options.offset\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.invertUV\r\n * @param options.uvs\r\n * @param options.colors\r\n * @returns the VertexData of the ribbon\r\n */\r\nexport function CreateRibbonVertexData(options: {\r\n    pathArray: Vector3[][];\r\n    closeArray?: boolean;\r\n    closePath?: boolean;\r\n    offset?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    invertUV?: boolean;\r\n    uvs?: Vector2[];\r\n    colors?: Color4[];\r\n}): VertexData {\r\n    let pathArray: Vector3[][] = options.pathArray;\r\n    const closeArray: boolean = options.closeArray || false;\r\n    const closePath: boolean = options.closePath || false;\r\n    const invertUV: boolean = options.invertUV || false;\r\n    const defaultOffset: number = Math.floor(pathArray[0].length / 2);\r\n    let offset: number = options.offset || defaultOffset;\r\n    offset = offset > defaultOffset ? defaultOffset : Math.floor(offset); // offset max allowed : defaultOffset\r\n    const sideOrientation: number = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const customUV = options.uvs;\r\n    const customColors = options.colors;\r\n\r\n    const positions: number[] = [];\r\n    const indices: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n\r\n    const us: number[][] = []; // us[path_id] = [uDist1, uDist2, uDist3 ... ] distances between points on path path_id\r\n    const vs: number[][] = []; // vs[i] = [vDist1, vDist2, vDist3, ... ] distances between points i of consecutive paths from pathArray\r\n    const uTotalDistance: number[] = []; // uTotalDistance[p] : total distance of path p\r\n    const vTotalDistance: number[] = []; //  vTotalDistance[i] : total distance between points i of first and last path from pathArray\r\n    let minlg: number; // minimal length among all paths from pathArray\r\n    const lg: number[] = []; // array of path lengths : nb of vertex per path\r\n    const idx: number[] = []; // array of path indexes : index of each path (first vertex) in the total vertex number\r\n    let p: number; // path iterator\r\n    let i: number; // point iterator\r\n    let j: number; // point iterator\r\n\r\n    // if single path in pathArray\r\n    if (pathArray.length < 2) {\r\n        const ar1: Vector3[] = [];\r\n        const ar2: Vector3[] = [];\r\n        for (i = 0; i < pathArray[0].length - offset; i++) {\r\n            ar1.push(pathArray[0][i]);\r\n            ar2.push(pathArray[0][i + offset]);\r\n        }\r\n        pathArray = [ar1, ar2];\r\n    }\r\n\r\n    // positions and horizontal distances (u)\r\n    let idc: number = 0;\r\n    const closePathCorr: number = closePath ? 1 : 0; // the final index will be +1 if closePath\r\n    let path: Vector3[];\r\n    let l: number;\r\n    minlg = pathArray[0].length;\r\n    let vectlg: number;\r\n    let dist: number;\r\n    for (p = 0; p < pathArray.length; p++) {\r\n        uTotalDistance[p] = 0;\r\n        us[p] = [0];\r\n        path = pathArray[p];\r\n        l = path.length;\r\n        minlg = minlg < l ? minlg : l;\r\n\r\n        j = 0;\r\n        while (j < l) {\r\n            positions.push(path[j].x, path[j].y, path[j].z);\r\n            if (j > 0) {\r\n                vectlg = path[j].subtract(path[j - 1]).length();\r\n                dist = vectlg + uTotalDistance[p];\r\n                us[p].push(dist);\r\n                uTotalDistance[p] = dist;\r\n            }\r\n            j++;\r\n        }\r\n\r\n        if (closePath) {\r\n            // an extra hidden vertex is added in the \"positions\" array\r\n            j--;\r\n            positions.push(path[0].x, path[0].y, path[0].z);\r\n            vectlg = path[j].subtract(path[0]).length();\r\n            dist = vectlg + uTotalDistance[p];\r\n            us[p].push(dist);\r\n            uTotalDistance[p] = dist;\r\n        }\r\n\r\n        lg[p] = l + closePathCorr;\r\n        idx[p] = idc;\r\n        idc += l + closePathCorr;\r\n    }\r\n\r\n    // vertical distances (v)\r\n    let path1: Vector3[];\r\n    let path2: Vector3[];\r\n    let vertex1: Nullable<Vector3> = null;\r\n    let vertex2: Nullable<Vector3> = null;\r\n    for (i = 0; i < minlg + closePathCorr; i++) {\r\n        vTotalDistance[i] = 0;\r\n        vs[i] = [0];\r\n        for (p = 0; p < pathArray.length - 1; p++) {\r\n            path1 = pathArray[p];\r\n            path2 = pathArray[p + 1];\r\n            if (i === minlg) {\r\n                // closePath\r\n                vertex1 = path1[0];\r\n                vertex2 = path2[0];\r\n            } else {\r\n                vertex1 = path1[i];\r\n                vertex2 = path2[i];\r\n            }\r\n            vectlg = vertex2.subtract(vertex1).length();\r\n            dist = vectlg + vTotalDistance[i];\r\n            vs[i].push(dist);\r\n            vTotalDistance[i] = dist;\r\n        }\r\n\r\n        if (closeArray && vertex2 && vertex1) {\r\n            path1 = pathArray[p];\r\n            path2 = pathArray[0];\r\n            if (i === minlg) {\r\n                // closePath\r\n                vertex2 = path2[0];\r\n            }\r\n            vectlg = vertex2.subtract(vertex1).length();\r\n            dist = vectlg + vTotalDistance[i];\r\n            vTotalDistance[i] = dist;\r\n        }\r\n    }\r\n\r\n    // uvs\r\n    let u: number;\r\n    let v: number;\r\n    if (customUV) {\r\n        for (p = 0; p < customUV.length; p++) {\r\n            uvs.push(customUV[p].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - customUV[p].y : customUV[p].y);\r\n        }\r\n    } else {\r\n        for (p = 0; p < pathArray.length; p++) {\r\n            for (i = 0; i < minlg + closePathCorr; i++) {\r\n                u = uTotalDistance[p] != 0.0 ? us[p][i] / uTotalDistance[p] : 0.0;\r\n                v = vTotalDistance[i] != 0.0 ? vs[i][p] / vTotalDistance[i] : 0.0;\r\n                if (invertUV) {\r\n                    uvs.push(v, u);\r\n                } else {\r\n                    uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - v : v);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // indices\r\n    p = 0; // path index\r\n    let pi: number = 0; // positions array index\r\n    let l1: number = lg[p] - 1; // path1 length\r\n    let l2: number = lg[p + 1] - 1; // path2 length\r\n    let min: number = l1 < l2 ? l1 : l2; // current path stop index\r\n    let shft: number = idx[1] - idx[0]; // shift\r\n    const path1nb: number = closeArray ? lg.length : lg.length - 1; // number of path1 to iterate\ton\r\n\r\n    while (pi <= min && p < path1nb) {\r\n        //  stay under min and don't go over next to last path\r\n        // draw two triangles between path1 (p1) and path2 (p2) : (p1.pi, p2.pi, p1.pi+1) and (p2.pi+1, p1.pi+1, p2.pi) clockwise\r\n\r\n        indices.push(pi, pi + shft, pi + 1);\r\n        indices.push(pi + shft + 1, pi + 1, pi + shft);\r\n        pi += 1;\r\n        if (pi === min) {\r\n            // if end of one of two consecutive paths reached, go to next existing path\r\n            p++;\r\n            if (p === lg.length - 1) {\r\n                // last path of pathArray reached <=> closeArray == true\r\n                shft = idx[0] - idx[p];\r\n                l1 = lg[p] - 1;\r\n                l2 = lg[0] - 1;\r\n            } else {\r\n                shft = idx[p + 1] - idx[p];\r\n                l1 = lg[p] - 1;\r\n                l2 = lg[p + 1] - 1;\r\n            }\r\n            pi = idx[p];\r\n            min = l1 < l2 ? l1 + pi : l2 + pi;\r\n        }\r\n    }\r\n\r\n    // normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    if (closePath) {\r\n        // update both the first and last vertex normals to their average value\r\n        let indexFirst: number = 0;\r\n        let indexLast: number = 0;\r\n        for (p = 0; p < pathArray.length; p++) {\r\n            indexFirst = idx[p] * 3;\r\n            if (p + 1 < pathArray.length) {\r\n                indexLast = (idx[p + 1] - 1) * 3;\r\n            } else {\r\n                indexLast = normals.length - 3;\r\n            }\r\n            normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\r\n            normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\r\n            normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\r\n            normals[indexLast] = normals[indexFirst];\r\n            normals[indexLast + 1] = normals[indexFirst + 1];\r\n            normals[indexLast + 2] = normals[indexFirst + 2];\r\n        }\r\n    }\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Colors\r\n    let colors: Nullable<Float32Array> = null;\r\n    if (customColors) {\r\n        colors = new Float32Array(customColors.length * 4);\r\n        for (let c = 0; c < customColors.length; c++) {\r\n            colors[c * 4] = customColors[c].r;\r\n            colors[c * 4 + 1] = customColors[c].g;\r\n            colors[c * 4 + 2] = customColors[c].b;\r\n            colors[c * 4 + 3] = customColors[c].a;\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    const positions32 = new Float32Array(positions);\r\n    const normals32 = new Float32Array(normals);\r\n    const uvs32 = new Float32Array(uvs);\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions32;\r\n    vertexData.normals = normals32;\r\n    vertexData.uvs = uvs32;\r\n    if (colors) {\r\n        vertexData.set(colors, VertexBuffer.ColorKind);\r\n    }\r\n\r\n    if (closePath) {\r\n        (<any>vertexData)._idx = idx;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters\r\n * * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry\r\n * * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array\r\n * * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array\r\n * * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path\r\n * * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11\r\n * * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#ribbon\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n * * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones\r\n * * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values\r\n * * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry\r\n * * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.pathArray\r\n * @param options.closeArray\r\n * @param options.closePath\r\n * @param options.offset\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.instance\r\n * @param options.invertUV\r\n * @param options.uvs\r\n * @param options.colors\r\n * @param scene defines the hosting scene\r\n * @returns the ribbon mesh\r\n * @see https://doc.babylonjs.com/how_to/ribbon_tutorial\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n */\r\nexport function CreateRibbon(\r\n    name: string,\r\n    options: {\r\n        pathArray: Vector3[][];\r\n        closeArray?: boolean;\r\n        closePath?: boolean;\r\n        offset?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        instance?: Mesh;\r\n        invertUV?: boolean;\r\n        uvs?: Vector2[];\r\n        colors?: Color4[];\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const pathArray = options.pathArray;\r\n    const closeArray = options.closeArray;\r\n    const closePath = options.closePath;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const instance = options.instance;\r\n    const updatable = options.updatable;\r\n\r\n    if (instance) {\r\n        // existing ribbon instance update\r\n        // positionFunction : ribbon case\r\n        // only pathArray and sideOrientation parameters are taken into account for positions update\r\n        const minimum = TmpVectors.Vector3[0].setAll(Number.MAX_VALUE);\r\n        const maximum = TmpVectors.Vector3[1].setAll(-Number.MAX_VALUE);\r\n        const positionFunction = (positions: FloatArray) => {\r\n            let minlg = pathArray[0].length;\r\n            const mesh = <Mesh>instance;\r\n            let i = 0;\r\n            const ns = mesh._originalBuilderSideOrientation === Mesh.DOUBLESIDE ? 2 : 1;\r\n            for (let si = 1; si <= ns; ++si) {\r\n                for (let p = 0; p < pathArray.length; ++p) {\r\n                    const path = pathArray[p];\r\n                    const l = path.length;\r\n                    minlg = minlg < l ? minlg : l;\r\n                    for (let j = 0; j < minlg; ++j) {\r\n                        const pathPoint = path[j];\r\n                        positions[i] = pathPoint.x;\r\n                        positions[i + 1] = pathPoint.y;\r\n                        positions[i + 2] = pathPoint.z;\r\n                        minimum.minimizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\r\n                        maximum.maximizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\r\n                        i += 3;\r\n                    }\r\n                    if (mesh._creationDataStorage && mesh._creationDataStorage.closePath) {\r\n                        const pathPoint = path[0];\r\n                        positions[i] = pathPoint.x;\r\n                        positions[i + 1] = pathPoint.y;\r\n                        positions[i + 2] = pathPoint.z;\r\n                        i += 3;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        const positions = <FloatArray>instance.getVerticesData(VertexBuffer.PositionKind);\r\n        positionFunction(positions);\r\n        if (instance.hasBoundingInfo) {\r\n            instance.getBoundingInfo().reConstruct(minimum, maximum, instance._worldMatrix);\r\n        } else {\r\n            instance.buildBoundingInfo(minimum, maximum, instance._worldMatrix);\r\n        }\r\n        instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n        if (options.colors) {\r\n            const colors = <FloatArray>instance.getVerticesData(VertexBuffer.ColorKind);\r\n            for (let c = 0, colorIndex = 0; c < options.colors.length; c++, colorIndex += 4) {\r\n                const color = options.colors[c];\r\n                colors[colorIndex] = color.r;\r\n                colors[colorIndex + 1] = color.g;\r\n                colors[colorIndex + 2] = color.b;\r\n                colors[colorIndex + 3] = color.a;\r\n            }\r\n            instance.updateVerticesData(VertexBuffer.ColorKind, colors, false, false);\r\n        }\r\n        if (options.uvs) {\r\n            const uvs = <FloatArray>instance.getVerticesData(VertexBuffer.UVKind);\r\n            for (let i = 0; i < options.uvs.length; i++) {\r\n                uvs[i * 2] = options.uvs[i].x;\r\n                uvs[i * 2 + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - options.uvs[i].y : options.uvs[i].y;\r\n            }\r\n            instance.updateVerticesData(VertexBuffer.UVKind, uvs, false, false);\r\n        }\r\n        if (!instance.areNormalsFrozen || instance.isFacetDataEnabled) {\r\n            const indices = instance.getIndices();\r\n            const normals = <FloatArray>instance.getVerticesData(VertexBuffer.NormalKind);\r\n            const params = instance.isFacetDataEnabled ? instance.getFacetDataParameters() : null;\r\n            VertexData.ComputeNormals(positions, indices, normals, params);\r\n\r\n            if (instance._creationDataStorage && instance._creationDataStorage.closePath) {\r\n                let indexFirst: number = 0;\r\n                let indexLast: number = 0;\r\n                for (let p = 0; p < pathArray.length; p++) {\r\n                    indexFirst = instance._creationDataStorage!.idx[p] * 3;\r\n                    if (p + 1 < pathArray.length) {\r\n                        indexLast = (instance._creationDataStorage!.idx[p + 1] - 1) * 3;\r\n                    } else {\r\n                        indexLast = normals.length - 3;\r\n                    }\r\n                    normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\r\n                    normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\r\n                    normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\r\n                    normals[indexLast] = normals[indexFirst];\r\n                    normals[indexLast + 1] = normals[indexFirst + 1];\r\n                    normals[indexLast + 2] = normals[indexFirst + 2];\r\n                }\r\n            }\r\n            if (!instance.areNormalsFrozen) {\r\n                instance.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);\r\n            }\r\n        }\r\n\r\n        return instance;\r\n    } else {\r\n        // new ribbon creation\r\n\r\n        const ribbon = new Mesh(name, scene);\r\n        ribbon._originalBuilderSideOrientation = sideOrientation;\r\n        ribbon._creationDataStorage = new _CreationDataStorage();\r\n\r\n        const vertexData = CreateRibbonVertexData(options);\r\n        if (closePath) {\r\n            ribbon._creationDataStorage.idx = (<any>vertexData)._idx;\r\n        }\r\n        ribbon._creationDataStorage.closePath = closePath;\r\n        ribbon._creationDataStorage.closeArray = closeArray;\r\n\r\n        vertexData.applyToMesh(ribbon, updatable);\r\n\r\n        return ribbon;\r\n    }\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateRibbon directly\r\n */\r\nexport const RibbonBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateRibbon,\r\n};\r\n\r\nVertexData.CreateRibbon = CreateRibbonVertexData;\r\n\r\n(Mesh as any).CreateRibbon = (\r\n    name: string,\r\n    pathArray: Vector3[][],\r\n    closeArray: boolean = false,\r\n    closePath: boolean,\r\n    offset: number,\r\n    scene?: Scene,\r\n    updatable: boolean = false,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n) => {\r\n    return CreateRibbon(\r\n        name,\r\n        {\r\n            pathArray: pathArray,\r\n            closeArray: closeArray,\r\n            closePath: closePath,\r\n            offset: offset,\r\n            updatable: updatable,\r\n            sideOrientation: sideOrientation,\r\n            instance: instance,\r\n        },\r\n        scene\r\n    );\r\n};\r\n"]},"metadata":{},"sourceType":"module"}