{"ast":null,"code":"import \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.from.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport { WebGPUEngine } from \"../../webgpuEngine.js\";\n\nWebGPUEngine.prototype.updateDynamicIndexBuffer = function (indexBuffer, indices, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var gpuBuffer = indexBuffer;\n  var view;\n\n  if (indices instanceof Uint16Array) {\n    if (indexBuffer.is32Bits) {\n      view = Uint32Array.from(indices);\n    } else {\n      view = indices;\n    }\n  } else if (indices instanceof Uint32Array) {\n    if (indexBuffer.is32Bits) {\n      view = indices;\n    } else {\n      view = Uint16Array.from(indices);\n    }\n  } else {\n    if (indexBuffer.is32Bits) {\n      view = new Uint32Array(indices);\n    } else {\n      view = new Uint16Array(indices);\n    }\n  }\n\n  this._bufferManager.setSubData(gpuBuffer, offset, view);\n};\n\nWebGPUEngine.prototype.updateDynamicVertexBuffer = function (vertexBuffer, data, byteOffset, byteLength) {\n  var dataBuffer = vertexBuffer;\n\n  if (byteOffset === undefined) {\n    byteOffset = 0;\n  }\n\n  var view;\n\n  if (byteLength === undefined) {\n    if (data instanceof Array) {\n      view = new Float32Array(data);\n    } else if (data instanceof ArrayBuffer) {\n      view = new Uint8Array(data);\n    } else {\n      view = data;\n    }\n\n    byteLength = view.byteLength;\n  } else {\n    if (data instanceof Array) {\n      view = new Float32Array(data);\n    } else if (data instanceof ArrayBuffer) {\n      view = new Uint8Array(data);\n    } else {\n      view = data;\n    }\n  }\n\n  this._bufferManager.setSubData(dataBuffer, byteOffset, view, 0, byteLength);\n};","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA,SAASA,YAAT,QAA6B,uBAA7B;;AAEAA,YAAY,CAACC,SAAb,CAAuBC,wBAAvB,GAAkD,UAAUC,WAAV,EAAmCC,OAAnC,EAA0DC,MAA1D,EAA4E;AAAlB;AAAAA;AAAkB;;AAC1H,MAAMC,SAAS,GAAGH,WAAlB;AAEA,MAAII,IAAJ;;AACA,MAAIH,OAAO,YAAYI,WAAvB,EAAoC;AAChC,QAAIL,WAAW,CAACM,QAAhB,EAA0B;AACtBF,UAAI,GAAGG,WAAW,CAACC,IAAZ,CAAiBP,OAAjB,CAAP;AACH,KAFD,MAEO;AACHG,UAAI,GAAGH,OAAP;AACH;AACJ,GAND,MAMO,IAAIA,OAAO,YAAYM,WAAvB,EAAoC;AACvC,QAAIP,WAAW,CAACM,QAAhB,EAA0B;AACtBF,UAAI,GAAGH,OAAP;AACH,KAFD,MAEO;AACHG,UAAI,GAAGC,WAAW,CAACG,IAAZ,CAAiBP,OAAjB,CAAP;AACH;AACJ,GANM,MAMA;AACH,QAAID,WAAW,CAACM,QAAhB,EAA0B;AACtBF,UAAI,GAAG,IAAIG,WAAJ,CAAgBN,OAAhB,CAAP;AACH,KAFD,MAEO;AACHG,UAAI,GAAG,IAAIC,WAAJ,CAAgBJ,OAAhB,CAAP;AACH;AACJ;;AAED,OAAKQ,cAAL,CAAoBC,UAApB,CAA+BP,SAA/B,EAA0CD,MAA1C,EAAkDE,IAAlD;AACH,CAzBD;;AA2BAP,YAAY,CAACC,SAAb,CAAuBa,yBAAvB,GAAmD,UAAUC,YAAV,EAAoCC,IAApC,EAAqDC,UAArD,EAA0EC,UAA1E,EAA6F;AAC5I,MAAMC,UAAU,GAAGJ,YAAnB;;AACA,MAAIE,UAAU,KAAKG,SAAnB,EAA8B;AAC1BH,cAAU,GAAG,CAAb;AACH;;AAED,MAAIV,IAAJ;;AACA,MAAIW,UAAU,KAAKE,SAAnB,EAA8B;AAC1B,QAAIJ,IAAI,YAAYK,KAApB,EAA2B;AACvBd,UAAI,GAAG,IAAIe,YAAJ,CAAiBN,IAAjB,CAAP;AACH,KAFD,MAEO,IAAIA,IAAI,YAAYO,WAApB,EAAiC;AACpChB,UAAI,GAAG,IAAIiB,UAAJ,CAAeR,IAAf,CAAP;AACH,KAFM,MAEA;AACHT,UAAI,GAAGS,IAAP;AACH;;AACDE,cAAU,GAAGX,IAAI,CAACW,UAAlB;AACH,GATD,MASO;AACH,QAAIF,IAAI,YAAYK,KAApB,EAA2B;AACvBd,UAAI,GAAG,IAAIe,YAAJ,CAAiBN,IAAjB,CAAP;AACH,KAFD,MAEO,IAAIA,IAAI,YAAYO,WAApB,EAAiC;AACpChB,UAAI,GAAG,IAAIiB,UAAJ,CAAeR,IAAf,CAAP;AACH,KAFM,MAEA;AACHT,UAAI,GAAGS,IAAP;AACH;AACJ;;AAED,OAAKJ,cAAL,CAAoBC,UAApB,CAA+BM,UAA/B,EAA2CF,UAA3C,EAAuDV,IAAvD,EAA6D,CAA7D,EAAgEW,UAAhE;AACH,CA3BD","names":["WebGPUEngine","prototype","updateDynamicIndexBuffer","indexBuffer","indices","offset","gpuBuffer","view","Uint16Array","is32Bits","Uint32Array","from","_bufferManager","setSubData","updateDynamicVertexBuffer","vertexBuffer","data","byteOffset","byteLength","dataBuffer","undefined","Array","Float32Array","ArrayBuffer","Uint8Array"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Engines/WebGPU/Extensions/engine.dynamicBuffer.ts"],"sourcesContent":["import type { DataBuffer } from \"../../../Buffers/dataBuffer\";\r\nimport type { WebGPUDataBuffer } from \"../../../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport type { DataArray, IndicesArray } from \"../../../types\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\n\r\nWebGPUEngine.prototype.updateDynamicIndexBuffer = function (indexBuffer: DataBuffer, indices: IndicesArray, offset: number = 0): void {\r\n    const gpuBuffer = indexBuffer as WebGPUDataBuffer;\r\n\r\n    let view: ArrayBufferView;\r\n    if (indices instanceof Uint16Array) {\r\n        if (indexBuffer.is32Bits) {\r\n            view = Uint32Array.from(indices);\r\n        } else {\r\n            view = indices;\r\n        }\r\n    } else if (indices instanceof Uint32Array) {\r\n        if (indexBuffer.is32Bits) {\r\n            view = indices;\r\n        } else {\r\n            view = Uint16Array.from(indices);\r\n        }\r\n    } else {\r\n        if (indexBuffer.is32Bits) {\r\n            view = new Uint32Array(indices);\r\n        } else {\r\n            view = new Uint16Array(indices);\r\n        }\r\n    }\r\n\r\n    this._bufferManager.setSubData(gpuBuffer, offset, view);\r\n};\r\n\r\nWebGPUEngine.prototype.updateDynamicVertexBuffer = function (vertexBuffer: DataBuffer, data: DataArray, byteOffset?: number, byteLength?: number): void {\r\n    const dataBuffer = vertexBuffer as WebGPUDataBuffer;\r\n    if (byteOffset === undefined) {\r\n        byteOffset = 0;\r\n    }\r\n\r\n    let view: ArrayBufferView;\r\n    if (byteLength === undefined) {\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n        byteLength = view.byteLength;\r\n    } else {\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n    }\r\n\r\n    this._bufferManager.setSubData(dataBuffer, byteOffset, view, 0, byteLength);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}