{"ast":null,"code":"import \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.number.to-fixed.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport { __decorate, __extends } from \"tslib\";\nimport { serialize, serializeAsTexture, SerializationHelper } from \"../../../Misc/decorators.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nimport { Vector2, Vector3, Matrix, Vector4 } from \"../../../Maths/math.vector.js\";\nimport { Scalar } from \"../../../Maths/math.scalar.js\";\nimport { Texture } from \"../../../Materials/Textures/texture.js\";\nimport { PostProcess } from \"../../../PostProcesses/postProcess.js\";\nimport { PostProcessRenderPipeline } from \"../../../PostProcesses/RenderPipeline/postProcessRenderPipeline.js\";\nimport { PostProcessRenderEffect } from \"../../../PostProcesses/RenderPipeline/postProcessRenderEffect.js\";\nimport { BlurPostProcess } from \"../../../PostProcesses/blurPostProcess.js\";\nimport { FxaaPostProcess } from \"../../../PostProcesses/fxaaPostProcess.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { MotionBlurPostProcess } from \"../../motionBlurPostProcess.js\";\nimport { ScreenSpaceReflectionPostProcess } from \"../../screenSpaceReflectionPostProcess.js\";\nimport \"../../../PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent.js\";\nimport \"../../../Shaders/standard.fragment.js\";\n/**\n * Standard rendering pipeline\n * Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.\n * @see https://doc.babylonjs.com/how_to/using_standard_rendering_pipeline\n */\n\nvar StandardRenderingPipeline =\n/** @class */\nfunction (_super) {\n  __extends(StandardRenderingPipeline, _super);\n  /**\n   * Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.\n   * @constructor\n   * @param name The rendering pipeline name\n   * @param scene The scene linked to this pipeline\n   * @param ratio The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\n   * @param originalPostProcess the custom original color post-process. Must be \"reusable\". Can be null.\n   * @param cameras The array of cameras that the rendering pipeline will be attached to\n   */\n\n\n  function StandardRenderingPipeline(name, scene, ratio, originalPostProcess, cameras) {\n    if (originalPostProcess === void 0) {\n      originalPostProcess = null;\n    }\n\n    var _this = _super.call(this, scene.getEngine(), name) || this;\n    /**\n     * Post-process used to down scale an image x4\n     */\n\n\n    _this.downSampleX4PostProcess = null;\n    /**\n     * Post-process used to calculate the illuminated surfaces controlled by a threshold\n     */\n\n    _this.brightPassPostProcess = null;\n    /**\n     * Post-process array storing all the horizontal blur post-processes used by the pipeline\n     */\n\n    _this.blurHPostProcesses = [];\n    /**\n     * Post-process array storing all the vertical blur post-processes used by the pipeline\n     */\n\n    _this.blurVPostProcesses = [];\n    /**\n     * Post-process used to add colors of 2 textures (typically brightness + real scene color)\n     */\n\n    _this.textureAdderPostProcess = null;\n    /**\n     * Post-process used to create volumetric lighting effect\n     */\n\n    _this.volumetricLightPostProcess = null;\n    /**\n     * Post-process used to smooth the previous volumetric light post-process on the X axis\n     */\n\n    _this.volumetricLightSmoothXPostProcess = null;\n    /**\n     * Post-process used to smooth the previous volumetric light post-process on the Y axis\n     */\n\n    _this.volumetricLightSmoothYPostProcess = null;\n    /**\n     * Post-process used to merge the volumetric light effect and the real scene color\n     */\n\n    _this.volumetricLightMergePostProces = null;\n    /**\n     * Post-process used to store the final volumetric light post-process (attach/detach for debug purpose)\n     */\n\n    _this.volumetricLightFinalPostProcess = null;\n    /**\n     * Base post-process used to calculate the average luminance of the final image for HDR\n     */\n\n    _this.luminancePostProcess = null;\n    /**\n     * Post-processes used to create down sample post-processes in order to get\n     * the average luminance of the final image for HDR\n     * Array of length \"StandardRenderingPipeline.LuminanceSteps\"\n     */\n\n    _this.luminanceDownSamplePostProcesses = [];\n    /**\n     * Post-process used to create a HDR effect (light adaptation)\n     */\n\n    _this.hdrPostProcess = null;\n    /**\n     * Post-process used to store the final texture adder post-process (attach/detach for debug purpose)\n     */\n\n    _this.textureAdderFinalPostProcess = null;\n    /**\n     * Post-process used to store the final lens flare post-process (attach/detach for debug purpose)\n     */\n\n    _this.lensFlareFinalPostProcess = null;\n    /**\n     * Post-process used to merge the final HDR post-process and the real scene color\n     */\n\n    _this.hdrFinalPostProcess = null;\n    /**\n     * Post-process used to create a lens flare effect\n     */\n\n    _this.lensFlarePostProcess = null;\n    /**\n     * Post-process that merges the result of the lens flare post-process and the real scene color\n     */\n\n    _this.lensFlareComposePostProcess = null;\n    /**\n     * Post-process used to create a motion blur effect\n     */\n\n    _this.motionBlurPostProcess = null;\n    /**\n     * Post-process used to create a depth of field effect\n     */\n\n    _this.depthOfFieldPostProcess = null;\n    /**\n     * The Fast Approximate Anti-Aliasing post process which attempts to remove aliasing from an image.\n     */\n\n    _this.fxaaPostProcess = null;\n    /**\n     * Post-process used to simulate realtime reflections using the screen space and geometry renderer.\n     */\n\n    _this.screenSpaceReflectionPostProcess = null; // Values\n\n    /**\n     * Represents the brightness threshold in order to configure the illuminated surfaces\n     */\n\n    _this.brightThreshold = 1.0;\n    /**\n     * Configures the blur intensity used for surexposed surfaces are highlighted surfaces (light halo)\n     */\n\n    _this.blurWidth = 512.0;\n    /**\n     * Sets if the blur for highlighted surfaces must be only horizontal\n     */\n\n    _this.horizontalBlur = false;\n    /**\n     * Texture used typically to simulate \"dirty\" on camera lens\n     */\n\n    _this.lensTexture = null;\n    /**\n     * Represents the offset coefficient based on Rayleigh principle. Typically in interval [-0.2, 0.2]\n     */\n\n    _this.volumetricLightCoefficient = 0.2;\n    /**\n     * The overall power of volumetric lights, typically in interval [0, 10] maximum\n     */\n\n    _this.volumetricLightPower = 4.0;\n    /**\n     * Used the set the blur intensity to smooth the volumetric lights\n     */\n\n    _this.volumetricLightBlurScale = 64.0;\n    /**\n     * Light (spot or directional) used to generate the volumetric lights rays\n     * The source light must have a shadow generate so the pipeline can get its\n     * depth map\n     */\n\n    _this.sourceLight = null;\n    /**\n     * For eye adaptation, represents the minimum luminance the eye can see\n     */\n\n    _this.hdrMinimumLuminance = 1.0;\n    /**\n     * For eye adaptation, represents the decrease luminance speed\n     */\n\n    _this.hdrDecreaseRate = 0.5;\n    /**\n     * For eye adaptation, represents the increase luminance speed\n     */\n\n    _this.hdrIncreaseRate = 0.5;\n    /**\n     * Lens color texture used by the lens flare effect. Mandatory if lens flare effect enabled\n     */\n\n    _this.lensColorTexture = null;\n    /**\n     * The overall strength for the lens flare effect\n     */\n\n    _this.lensFlareStrength = 20.0;\n    /**\n     * Dispersion coefficient for lens flare ghosts\n     */\n\n    _this.lensFlareGhostDispersal = 1.4;\n    /**\n     * Main lens flare halo width\n     */\n\n    _this.lensFlareHaloWidth = 0.7;\n    /**\n     * Based on the lens distortion effect, defines how much the lens flare result\n     * is distorted\n     */\n\n    _this.lensFlareDistortionStrength = 16.0;\n    /**\n     * Configures the blur intensity used for for lens flare (halo)\n     */\n\n    _this.lensFlareBlurWidth = 512.0;\n    /**\n     * Lens star texture must be used to simulate rays on the flares and is available\n     * in the documentation\n     */\n\n    _this.lensStarTexture = null;\n    /**\n     * As the \"lensTexture\" (can be the same texture or different), it is used to apply the lens\n     * flare effect by taking account of the dirt texture\n     */\n\n    _this.lensFlareDirtTexture = null;\n    /**\n     * Represents the focal length for the depth of field effect\n     */\n\n    _this.depthOfFieldDistance = 10.0;\n    /**\n     * Represents the blur intensity for the blurred part of the depth of field effect\n     */\n\n    _this.depthOfFieldBlurWidth = 64.0;\n    /**\n     * List of animations for the pipeline (IAnimatable implementation)\n     */\n\n    _this.animations = [];\n    _this._currentDepthOfFieldSource = null;\n    _this._fixedExposure = 1.0;\n    _this._currentExposure = 1.0;\n    _this._hdrAutoExposure = false;\n    _this._hdrCurrentLuminance = 1.0;\n    _this._motionStrength = 1.0;\n    _this._isObjectBasedMotionBlur = false;\n    _this._camerasToBeAttached = []; // Getters and setters\n\n    _this._bloomEnabled = false;\n    _this._depthOfFieldEnabled = false;\n    _this._vlsEnabled = false;\n    _this._lensFlareEnabled = false;\n    _this._hdrEnabled = false;\n    _this._motionBlurEnabled = false;\n    _this._fxaaEnabled = false;\n    _this._screenSpaceReflectionsEnabled = false;\n    _this._motionBlurSamples = 64.0;\n    _this._volumetricLightStepsCount = 50.0;\n    _this._samples = 1;\n    _this._cameras = cameras || scene.cameras;\n    _this._cameras = _this._cameras.slice();\n    _this._camerasToBeAttached = _this._cameras.slice(); // Initialize\n\n    _this._scene = scene;\n    _this._basePostProcess = originalPostProcess;\n    _this._ratio = ratio; // Misc\n\n    _this._floatTextureType = scene.getEngine().getCaps().textureFloatRender ? 1 : 2; // Finish\n\n    scene.postProcessRenderPipelineManager.addPipeline(_this);\n\n    _this._buildPipeline();\n\n    return _this;\n  }\n\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"exposure\", {\n    /**\n     * Gets the overall exposure used by the pipeline\n     */\n    get: function get() {\n      return this._fixedExposure;\n    },\n\n    /**\n     * Sets the overall exposure used by the pipeline\n     */\n    set: function set(value) {\n      this._fixedExposure = value;\n      this._currentExposure = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"hdrAutoExposure\", {\n    /**\n     * Gets whether or not the exposure of the overall pipeline should be automatically adjusted by the HDR post-process\n     */\n    get: function get() {\n      return this._hdrAutoExposure;\n    },\n\n    /**\n     * Sets whether or not the exposure of the overall pipeline should be automatically adjusted by the HDR post-process\n     */\n    set: function set(value) {\n      this._hdrAutoExposure = value;\n\n      if (this.hdrPostProcess) {\n        var defines = [\"#define HDR\"];\n\n        if (value) {\n          defines.push(\"#define AUTO_EXPOSURE\");\n        }\n\n        this.hdrPostProcess.updateEffect(defines.join(\"\\n\"));\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"motionStrength\", {\n    /**\n     * Gets how much the image is blurred by the movement while using the motion blur post-process\n     */\n    get: function get() {\n      return this._motionStrength;\n    },\n\n    /**\n     * Sets how much the image is blurred by the movement while using the motion blur post-process\n     */\n    set: function set(strength) {\n      this._motionStrength = strength;\n\n      if (this._isObjectBasedMotionBlur && this.motionBlurPostProcess) {\n        this.motionBlurPostProcess.motionStrength = strength;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"objectBasedMotionBlur\", {\n    /**\n     * Gets whether or not the motion blur post-process is object based or screen based.\n     */\n    get: function get() {\n      return this._isObjectBasedMotionBlur;\n    },\n\n    /**\n     * Sets whether or not the motion blur post-process should be object based or screen based\n     */\n    set: function set(value) {\n      var shouldRebuild = this._isObjectBasedMotionBlur !== value;\n      this._isObjectBasedMotionBlur = value;\n\n      if (shouldRebuild) {\n        this._buildPipeline();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"BloomEnabled\", {\n    /**\n     * @ignore\n     * Specifies if the bloom pipeline is enabled\n     */\n    get: function get() {\n      return this._bloomEnabled;\n    },\n    set: function set(enabled) {\n      if (this._bloomEnabled === enabled) {\n        return;\n      }\n\n      this._bloomEnabled = enabled;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"DepthOfFieldEnabled\", {\n    /**\n     * @ignore\n     * Specifies if the depth of field pipeline is enabled\n     */\n    get: function get() {\n      return this._depthOfFieldEnabled;\n    },\n    set: function set(enabled) {\n      if (this._depthOfFieldEnabled === enabled) {\n        return;\n      }\n\n      this._depthOfFieldEnabled = enabled;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"LensFlareEnabled\", {\n    /**\n     * @ignore\n     * Specifies if the lens flare pipeline is enabled\n     */\n    get: function get() {\n      return this._lensFlareEnabled;\n    },\n    set: function set(enabled) {\n      if (this._lensFlareEnabled === enabled) {\n        return;\n      }\n\n      this._lensFlareEnabled = enabled;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"HDREnabled\", {\n    /**\n     * @ignore\n     * Specifies if the HDR pipeline is enabled\n     */\n    get: function get() {\n      return this._hdrEnabled;\n    },\n    set: function set(enabled) {\n      if (this._hdrEnabled === enabled) {\n        return;\n      }\n\n      this._hdrEnabled = enabled;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"VLSEnabled\", {\n    /**\n     * @ignore\n     * Specifies if the volumetric lights scattering effect is enabled\n     */\n    get: function get() {\n      return this._vlsEnabled;\n    },\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    set: function set(enabled) {\n      if (this._vlsEnabled === enabled) {\n        return;\n      }\n\n      if (enabled) {\n        var geometry = this._scene.enableGeometryBufferRenderer();\n\n        if (!geometry) {\n          Logger.Warn(\"Geometry renderer is not supported, cannot create volumetric lights in Standard Rendering Pipeline\");\n          return;\n        }\n      }\n\n      this._vlsEnabled = enabled;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"MotionBlurEnabled\", {\n    /**\n     * @ignore\n     * Specifies if the motion blur effect is enabled\n     */\n    get: function get() {\n      return this._motionBlurEnabled;\n    },\n    set: function set(enabled) {\n      if (this._motionBlurEnabled === enabled) {\n        return;\n      }\n\n      this._motionBlurEnabled = enabled;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"fxaaEnabled\", {\n    /**\n     * Specifies if anti-aliasing is enabled\n     */\n    get: function get() {\n      return this._fxaaEnabled;\n    },\n    set: function set(enabled) {\n      if (this._fxaaEnabled === enabled) {\n        return;\n      }\n\n      this._fxaaEnabled = enabled;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"screenSpaceReflectionsEnabled\", {\n    /**\n     * Specifies if screen space reflections are enabled.\n     */\n    get: function get() {\n      return this._screenSpaceReflectionsEnabled;\n    },\n    set: function set(enabled) {\n      if (this._screenSpaceReflectionsEnabled === enabled) {\n        return;\n      }\n\n      this._screenSpaceReflectionsEnabled = enabled;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"volumetricLightStepsCount\", {\n    /**\n     * Specifies the number of steps used to calculate the volumetric lights\n     * Typically in interval [50, 200]\n     */\n    get: function get() {\n      return this._volumetricLightStepsCount;\n    },\n    set: function set(count) {\n      if (this.volumetricLightPostProcess) {\n        this.volumetricLightPostProcess.updateEffect(\"#define VLS\\n#define NB_STEPS \" + count.toFixed(1));\n      }\n\n      this._volumetricLightStepsCount = count;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"motionBlurSamples\", {\n    /**\n     * Specifies the number of samples used for the motion blur effect\n     * Typically in interval [16, 64]\n     */\n    get: function get() {\n      return this._motionBlurSamples;\n    },\n    set: function set(samples) {\n      if (this.motionBlurPostProcess) {\n        if (this._isObjectBasedMotionBlur) {\n          this.motionBlurPostProcess.motionBlurSamples = samples;\n        } else {\n          this.motionBlurPostProcess.updateEffect(\"#define MOTION_BLUR\\n#define MAX_MOTION_SAMPLES \" + samples.toFixed(1));\n        }\n      }\n\n      this._motionBlurSamples = samples;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"samples\", {\n    /**\n     * Specifies MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)\n     */\n    get: function get() {\n      return this._samples;\n    },\n    set: function set(sampleCount) {\n      if (this._samples === sampleCount) {\n        return;\n      }\n\n      this._samples = sampleCount;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  StandardRenderingPipeline.prototype._buildPipeline = function () {\n    var _this = this;\n\n    var ratio = this._ratio;\n    var scene = this._scene;\n\n    this._disposePostProcesses();\n\n    if (this._cameras !== null) {\n      this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras); // get back cameras to be used to reattach pipeline\n\n\n      this._cameras = this._camerasToBeAttached.slice();\n    }\n\n    this._reset(); // Create pass post-process\n\n\n    if (this._screenSpaceReflectionsEnabled) {\n      this.screenSpaceReflectionPostProcess = new ScreenSpaceReflectionPostProcess(\"HDRPass\", scene, ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, this._floatTextureType);\n      this.screenSpaceReflectionPostProcess.onApplyObservable.add(function () {\n        _this._currentDepthOfFieldSource = _this.screenSpaceReflectionPostProcess;\n      });\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRScreenSpaceReflections\", function () {\n        return _this.screenSpaceReflectionPostProcess;\n      }, true));\n    }\n\n    if (!this._basePostProcess) {\n      this.originalPostProcess = new PostProcess(\"HDRPass\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", this._floatTextureType);\n    } else {\n      this.originalPostProcess = this._basePostProcess;\n    }\n\n    this.originalPostProcess.autoClear = !this.screenSpaceReflectionPostProcess;\n    this.originalPostProcess.onApplyObservable.add(function () {\n      _this._currentDepthOfFieldSource = _this.originalPostProcess;\n    });\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRPassPostProcess\", function () {\n      return _this.originalPostProcess;\n    }, true));\n\n    if (this._bloomEnabled) {\n      // Create down sample X4 post-process\n      this._createDownSampleX4PostProcess(scene, ratio / 4); // Create bright pass post-process\n\n\n      this._createBrightPassPostProcess(scene, ratio / 4); // Create gaussian blur post-processes (down sampling blurs)\n\n\n      this._createBlurPostProcesses(scene, ratio / 4, 1); // Create texture adder post-process\n\n\n      this._createTextureAdderPostProcess(scene, ratio); // Create depth-of-field source post-process\n\n\n      this.textureAdderFinalPostProcess = new PostProcess(\"HDRDepthOfFieldSource\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", 0);\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRBaseDepthOfFieldSource\", function () {\n        return _this.textureAdderFinalPostProcess;\n      }, true));\n    }\n\n    if (this._vlsEnabled) {\n      // Create volumetric light\n      this._createVolumetricLightPostProcess(scene, ratio); // Create volumetric light final post-process\n\n\n      this.volumetricLightFinalPostProcess = new PostProcess(\"HDRVLSFinal\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", 0);\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRVLSFinal\", function () {\n        return _this.volumetricLightFinalPostProcess;\n      }, true));\n    }\n\n    if (this._lensFlareEnabled) {\n      // Create lens flare post-process\n      this._createLensFlarePostProcess(scene, ratio); // Create depth-of-field source post-process post lens-flare and disable it now\n\n\n      this.lensFlareFinalPostProcess = new PostProcess(\"HDRPostLensFlareDepthOfFieldSource\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", 0);\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRPostLensFlareDepthOfFieldSource\", function () {\n        return _this.lensFlareFinalPostProcess;\n      }, true));\n    }\n\n    if (this._hdrEnabled) {\n      // Create luminance\n      this._createLuminancePostProcesses(scene, this._floatTextureType); // Create HDR\n\n\n      this._createHdrPostProcess(scene, ratio); // Create depth-of-field source post-process post hdr and disable it now\n\n\n      this.hdrFinalPostProcess = new PostProcess(\"HDRPostHDReDepthOfFieldSource\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", 0);\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRPostHDReDepthOfFieldSource\", function () {\n        return _this.hdrFinalPostProcess;\n      }, true));\n    }\n\n    if (this._depthOfFieldEnabled) {\n      // Create gaussian blur used by depth-of-field\n      this._createBlurPostProcesses(scene, ratio / 2, 3, \"depthOfFieldBlurWidth\"); // Create depth-of-field post-process\n\n\n      this._createDepthOfFieldPostProcess(scene, ratio);\n    }\n\n    if (this._motionBlurEnabled) {\n      // Create motion blur post-process\n      this._createMotionBlurPostProcess(scene, ratio);\n    }\n\n    if (this._fxaaEnabled) {\n      // Create fxaa post-process\n      this.fxaaPostProcess = new FxaaPostProcess(\"fxaa\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, 0);\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRFxaa\", function () {\n        return _this.fxaaPostProcess;\n      }, true));\n    }\n\n    if (this._cameras !== null) {\n      this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);\n    }\n\n    if (!this._enableMSAAOnFirstPostProcess(this._samples) && this._samples > 1) {\n      Logger.Warn(\"MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0\");\n    }\n  }; // Down Sample X4 Post-Process\n\n\n  StandardRenderingPipeline.prototype._createDownSampleX4PostProcess = function (scene, ratio) {\n    var _this = this;\n\n    var downSampleX4Offsets = new Array(32);\n    this.downSampleX4PostProcess = new PostProcess(\"HDRDownSampleX4\", \"standard\", [\"dsOffsets\"], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define DOWN_SAMPLE_X4\", this._floatTextureType);\n\n    this.downSampleX4PostProcess.onApply = function (effect) {\n      var id = 0;\n      var width = _this.downSampleX4PostProcess.width;\n      var height = _this.downSampleX4PostProcess.height;\n\n      for (var i = -2; i < 2; i++) {\n        for (var j = -2; j < 2; j++) {\n          downSampleX4Offsets[id] = (i + 0.5) * (1.0 / width);\n          downSampleX4Offsets[id + 1] = (j + 0.5) * (1.0 / height);\n          id += 2;\n        }\n      }\n\n      effect.setArray2(\"dsOffsets\", downSampleX4Offsets);\n    }; // Add to pipeline\n\n\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRDownSampleX4\", function () {\n      return _this.downSampleX4PostProcess;\n    }, true));\n  }; // Brightpass Post-Process\n\n\n  StandardRenderingPipeline.prototype._createBrightPassPostProcess = function (scene, ratio) {\n    var _this = this;\n\n    var brightOffsets = new Array(8);\n    this.brightPassPostProcess = new PostProcess(\"HDRBrightPass\", \"standard\", [\"dsOffsets\", \"brightThreshold\"], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define BRIGHT_PASS\", this._floatTextureType);\n\n    this.brightPassPostProcess.onApply = function (effect) {\n      var sU = 1.0 / _this.brightPassPostProcess.width;\n      var sV = 1.0 / _this.brightPassPostProcess.height;\n      brightOffsets[0] = -0.5 * sU;\n      brightOffsets[1] = 0.5 * sV;\n      brightOffsets[2] = 0.5 * sU;\n      brightOffsets[3] = 0.5 * sV;\n      brightOffsets[4] = -0.5 * sU;\n      brightOffsets[5] = -0.5 * sV;\n      brightOffsets[6] = 0.5 * sU;\n      brightOffsets[7] = -0.5 * sV;\n      effect.setArray2(\"dsOffsets\", brightOffsets);\n      effect.setFloat(\"brightThreshold\", _this.brightThreshold);\n    }; // Add to pipeline\n\n\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRBrightPass\", function () {\n      return _this.brightPassPostProcess;\n    }, true));\n  }; // Create blur H&V post-processes\n\n\n  StandardRenderingPipeline.prototype._createBlurPostProcesses = function (scene, ratio, indice, blurWidthKey) {\n    var _this = this;\n\n    if (blurWidthKey === void 0) {\n      blurWidthKey = \"blurWidth\";\n    }\n\n    var engine = scene.getEngine();\n    var blurX = new BlurPostProcess(\"HDRBlurH\" + \"_\" + indice, new Vector2(1, 0), this[blurWidthKey], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, this._floatTextureType);\n    var blurY = new BlurPostProcess(\"HDRBlurV\" + \"_\" + indice, new Vector2(0, 1), this[blurWidthKey], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, this._floatTextureType);\n    blurX.onActivateObservable.add(function () {\n      var dw = blurX.width / engine.getRenderWidth();\n      blurX.kernel = _this[blurWidthKey] * dw;\n    });\n    blurY.onActivateObservable.add(function () {\n      var dw = blurY.height / engine.getRenderHeight();\n      blurY.kernel = _this.horizontalBlur ? 64 * dw : _this[blurWidthKey] * dw;\n    });\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRBlurH\" + indice, function () {\n      return blurX;\n    }, true));\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRBlurV\" + indice, function () {\n      return blurY;\n    }, true));\n    this.blurHPostProcesses.push(blurX);\n    this.blurVPostProcesses.push(blurY);\n  }; // Create texture adder post-process\n\n\n  StandardRenderingPipeline.prototype._createTextureAdderPostProcess = function (scene, ratio) {\n    var _this = this;\n\n    this.textureAdderPostProcess = new PostProcess(\"HDRTextureAdder\", \"standard\", [\"exposure\"], [\"otherSampler\", \"lensSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define TEXTURE_ADDER\", this._floatTextureType);\n\n    this.textureAdderPostProcess.onApply = function (effect) {\n      effect.setTextureFromPostProcess(\"otherSampler\", _this._vlsEnabled ? _this._currentDepthOfFieldSource : _this.originalPostProcess);\n      effect.setTexture(\"lensSampler\", _this.lensTexture);\n      effect.setFloat(\"exposure\", _this._currentExposure);\n      _this._currentDepthOfFieldSource = _this.textureAdderFinalPostProcess;\n    }; // Add to pipeline\n\n\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRTextureAdder\", function () {\n      return _this.textureAdderPostProcess;\n    }, true));\n  };\n\n  StandardRenderingPipeline.prototype._createVolumetricLightPostProcess = function (scene, ratio) {\n    var _this = this;\n\n    var geometryRenderer = scene.enableGeometryBufferRenderer();\n    geometryRenderer.enablePosition = true;\n    var geometry = geometryRenderer.getGBuffer(); // Base post-process\n\n    this.volumetricLightPostProcess = new PostProcess(\"HDRVLS\", \"standard\", [\"shadowViewProjection\", \"cameraPosition\", \"sunDirection\", \"sunColor\", \"scatteringCoefficient\", \"scatteringPower\", \"depthValues\"], [\"shadowMapSampler\", \"positionSampler\"], ratio / 8, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define VLS\\n#define NB_STEPS \" + this._volumetricLightStepsCount.toFixed(1));\n    var depthValues = Vector2.Zero();\n\n    this.volumetricLightPostProcess.onApply = function (effect) {\n      if (_this.sourceLight && _this.sourceLight.getShadowGenerator() && _this._scene.activeCamera) {\n        var generator = _this.sourceLight.getShadowGenerator();\n\n        effect.setTexture(\"shadowMapSampler\", generator.getShadowMap());\n        effect.setTexture(\"positionSampler\", geometry.textures[2]);\n        effect.setColor3(\"sunColor\", _this.sourceLight.diffuse);\n        effect.setVector3(\"sunDirection\", _this.sourceLight.getShadowDirection());\n        effect.setVector3(\"cameraPosition\", _this._scene.activeCamera.globalPosition);\n        effect.setMatrix(\"shadowViewProjection\", generator.getTransformMatrix());\n        effect.setFloat(\"scatteringCoefficient\", _this.volumetricLightCoefficient);\n        effect.setFloat(\"scatteringPower\", _this.volumetricLightPower);\n        depthValues.x = _this.sourceLight.getDepthMinZ(_this._scene.activeCamera);\n        depthValues.y = _this.sourceLight.getDepthMaxZ(_this._scene.activeCamera);\n        effect.setVector2(\"depthValues\", depthValues);\n      }\n    };\n\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRVLS\", function () {\n      return _this.volumetricLightPostProcess;\n    }, true)); // Smooth\n\n    this._createBlurPostProcesses(scene, ratio / 4, 0, \"volumetricLightBlurScale\"); // Merge\n\n\n    this.volumetricLightMergePostProces = new PostProcess(\"HDRVLSMerge\", \"standard\", [], [\"originalSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define VLSMERGE\");\n\n    this.volumetricLightMergePostProces.onApply = function (effect) {\n      effect.setTextureFromPostProcess(\"originalSampler\", _this._bloomEnabled ? _this.textureAdderFinalPostProcess : _this.originalPostProcess);\n      _this._currentDepthOfFieldSource = _this.volumetricLightFinalPostProcess;\n    };\n\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRVLSMerge\", function () {\n      return _this.volumetricLightMergePostProces;\n    }, true));\n  }; // Create luminance\n\n\n  StandardRenderingPipeline.prototype._createLuminancePostProcesses = function (scene, textureType) {\n    var _this = this; // Create luminance\n\n\n    var size = Math.pow(3, StandardRenderingPipeline.LuminanceSteps);\n    this.luminancePostProcess = new PostProcess(\"HDRLuminance\", \"standard\", [\"lumOffsets\"], [], {\n      width: size,\n      height: size\n    }, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define LUMINANCE\", textureType);\n    var offsets = [];\n\n    this.luminancePostProcess.onApply = function (effect) {\n      var sU = 1.0 / _this.luminancePostProcess.width;\n      var sV = 1.0 / _this.luminancePostProcess.height;\n      offsets[0] = -0.5 * sU;\n      offsets[1] = 0.5 * sV;\n      offsets[2] = 0.5 * sU;\n      offsets[3] = 0.5 * sV;\n      offsets[4] = -0.5 * sU;\n      offsets[5] = -0.5 * sV;\n      offsets[6] = 0.5 * sU;\n      offsets[7] = -0.5 * sV;\n      effect.setArray2(\"lumOffsets\", offsets);\n    }; // Add to pipeline\n\n\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRLuminance\", function () {\n      return _this.luminancePostProcess;\n    }, true)); // Create down sample luminance\n\n    for (var i = StandardRenderingPipeline.LuminanceSteps - 1; i >= 0; i--) {\n      size = Math.pow(3, i);\n      var defines = \"#define LUMINANCE_DOWN_SAMPLE\\n\";\n\n      if (i === 0) {\n        defines += \"#define FINAL_DOWN_SAMPLER\";\n      }\n\n      var postProcess = new PostProcess(\"HDRLuminanceDownSample\" + i, \"standard\", [\"dsOffsets\", \"halfDestPixelSize\"], [], {\n        width: size,\n        height: size\n      }, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, defines, textureType);\n      this.luminanceDownSamplePostProcesses.push(postProcess);\n    } // Create callbacks and add effects\n\n\n    var lastLuminance = this.luminancePostProcess;\n    this.luminanceDownSamplePostProcesses.forEach(function (pp, index) {\n      var downSampleOffsets = new Array(18);\n\n      pp.onApply = function (effect) {\n        if (!lastLuminance) {\n          return;\n        }\n\n        var id = 0;\n\n        for (var x = -1; x < 2; x++) {\n          for (var y = -1; y < 2; y++) {\n            downSampleOffsets[id] = x / lastLuminance.width;\n            downSampleOffsets[id + 1] = y / lastLuminance.height;\n            id += 2;\n          }\n        }\n\n        effect.setArray2(\"dsOffsets\", downSampleOffsets);\n        effect.setFloat(\"halfDestPixelSize\", 0.5 / lastLuminance.width);\n\n        if (index === _this.luminanceDownSamplePostProcesses.length - 1) {\n          lastLuminance = _this.luminancePostProcess;\n        } else {\n          lastLuminance = pp;\n        }\n      };\n\n      if (index === _this.luminanceDownSamplePostProcesses.length - 1) {\n        pp.onAfterRender = function () {\n          var pixel = scene.getEngine().readPixels(0, 0, 1, 1);\n          var bit_shift = new Vector4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\n          pixel.then(function (pixel) {\n            var data = new Uint8Array(pixel.buffer);\n            _this._hdrCurrentLuminance = (data[0] * bit_shift.x + data[1] * bit_shift.y + data[2] * bit_shift.z + data[3] * bit_shift.w) / 100.0;\n          });\n        };\n      }\n\n      _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRLuminanceDownSample\" + index, function () {\n        return pp;\n      }, true));\n    });\n  }; // Create HDR post-process\n\n\n  StandardRenderingPipeline.prototype._createHdrPostProcess = function (scene, ratio) {\n    var _this = this;\n\n    var defines = [\"#define HDR\"];\n\n    if (this._hdrAutoExposure) {\n      defines.push(\"#define AUTO_EXPOSURE\");\n    }\n\n    this.hdrPostProcess = new PostProcess(\"HDR\", \"standard\", [\"averageLuminance\"], [\"textureAdderSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, defines.join(\"\\n\"), 0);\n    var outputLiminance = 1;\n    var time = 0;\n    var lastTime = 0;\n\n    this.hdrPostProcess.onApply = function (effect) {\n      effect.setTextureFromPostProcess(\"textureAdderSampler\", _this._currentDepthOfFieldSource);\n      time += scene.getEngine().getDeltaTime();\n\n      if (outputLiminance < 0) {\n        outputLiminance = _this._hdrCurrentLuminance;\n      } else {\n        var dt = (lastTime - time) / 1000.0;\n\n        if (_this._hdrCurrentLuminance < outputLiminance + _this.hdrDecreaseRate * dt) {\n          outputLiminance += _this.hdrDecreaseRate * dt;\n        } else if (_this._hdrCurrentLuminance > outputLiminance - _this.hdrIncreaseRate * dt) {\n          outputLiminance -= _this.hdrIncreaseRate * dt;\n        } else {\n          outputLiminance = _this._hdrCurrentLuminance;\n        }\n      }\n\n      if (_this.hdrAutoExposure) {\n        _this._currentExposure = _this._fixedExposure / outputLiminance;\n      } else {\n        outputLiminance = Scalar.Clamp(outputLiminance, _this.hdrMinimumLuminance, 1e20);\n        effect.setFloat(\"averageLuminance\", outputLiminance);\n      }\n\n      lastTime = time;\n      _this._currentDepthOfFieldSource = _this.hdrFinalPostProcess;\n    };\n\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDR\", function () {\n      return _this.hdrPostProcess;\n    }, true));\n  }; // Create lens flare post-process\n\n\n  StandardRenderingPipeline.prototype._createLensFlarePostProcess = function (scene, ratio) {\n    var _this = this;\n\n    this.lensFlarePostProcess = new PostProcess(\"HDRLensFlare\", \"standard\", [\"strength\", \"ghostDispersal\", \"haloWidth\", \"resolution\", \"distortionStrength\"], [\"lensColorSampler\"], ratio / 2, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define LENS_FLARE\", 0);\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRLensFlare\", function () {\n      return _this.lensFlarePostProcess;\n    }, true));\n\n    this._createBlurPostProcesses(scene, ratio / 4, 2, \"lensFlareBlurWidth\");\n\n    this.lensFlareComposePostProcess = new PostProcess(\"HDRLensFlareCompose\", \"standard\", [\"lensStarMatrix\"], [\"otherSampler\", \"lensDirtSampler\", \"lensStarSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define LENS_FLARE_COMPOSE\", 0);\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRLensFlareCompose\", function () {\n      return _this.lensFlareComposePostProcess;\n    }, true));\n    var resolution = new Vector2(0, 0); // Lens flare\n\n    this.lensFlarePostProcess.externalTextureSamplerBinding = true;\n\n    this.lensFlarePostProcess.onApply = function (effect) {\n      effect.setTextureFromPostProcess(\"textureSampler\", _this._bloomEnabled ? _this.blurHPostProcesses[0] : _this.originalPostProcess);\n      effect.setTexture(\"lensColorSampler\", _this.lensColorTexture);\n      effect.setFloat(\"strength\", _this.lensFlareStrength);\n      effect.setFloat(\"ghostDispersal\", _this.lensFlareGhostDispersal);\n      effect.setFloat(\"haloWidth\", _this.lensFlareHaloWidth); // Shift\n\n      resolution.x = _this.lensFlarePostProcess.width;\n      resolution.y = _this.lensFlarePostProcess.height;\n      effect.setVector2(\"resolution\", resolution);\n      effect.setFloat(\"distortionStrength\", _this.lensFlareDistortionStrength);\n    }; // Compose\n\n\n    var scaleBias1 = Matrix.FromValues(2.0, 0.0, -1.0, 0.0, 0.0, 2.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n    var scaleBias2 = Matrix.FromValues(0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n\n    this.lensFlareComposePostProcess.onApply = function (effect) {\n      if (!_this._scene.activeCamera) {\n        return;\n      }\n\n      effect.setTextureFromPostProcess(\"otherSampler\", _this.lensFlarePostProcess);\n      effect.setTexture(\"lensDirtSampler\", _this.lensFlareDirtTexture);\n      effect.setTexture(\"lensStarSampler\", _this.lensStarTexture); // Lens start rotation matrix\n\n      var camerax = _this._scene.activeCamera.getViewMatrix().getRow(0);\n\n      var cameraz = _this._scene.activeCamera.getViewMatrix().getRow(2);\n\n      var camRot = Vector3.Dot(camerax.toVector3(), new Vector3(1.0, 0.0, 0.0)) + Vector3.Dot(cameraz.toVector3(), new Vector3(0.0, 0.0, 1.0));\n      camRot *= 4.0;\n      var starRotation = Matrix.FromValues(Math.cos(camRot) * 0.5, -Math.sin(camRot), 0.0, 0.0, Math.sin(camRot), Math.cos(camRot) * 0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n      var lensStarMatrix = scaleBias2.multiply(starRotation).multiply(scaleBias1);\n      effect.setMatrix(\"lensStarMatrix\", lensStarMatrix);\n      _this._currentDepthOfFieldSource = _this.lensFlareFinalPostProcess;\n    };\n  }; // Create depth-of-field post-process\n\n\n  StandardRenderingPipeline.prototype._createDepthOfFieldPostProcess = function (scene, ratio) {\n    var _this = this;\n\n    this.depthOfFieldPostProcess = new PostProcess(\"HDRDepthOfField\", \"standard\", [\"distance\"], [\"otherSampler\", \"depthSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define DEPTH_OF_FIELD\", 0);\n\n    this.depthOfFieldPostProcess.onApply = function (effect) {\n      effect.setTextureFromPostProcess(\"otherSampler\", _this._currentDepthOfFieldSource);\n      effect.setTexture(\"depthSampler\", _this._getDepthTexture());\n      effect.setFloat(\"distance\", _this.depthOfFieldDistance);\n    }; // Add to pipeline\n\n\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRDepthOfField\", function () {\n      return _this.depthOfFieldPostProcess;\n    }, true));\n  }; // Create motion blur post-process\n\n\n  StandardRenderingPipeline.prototype._createMotionBlurPostProcess = function (scene, ratio) {\n    var _this = this;\n\n    if (this._isObjectBasedMotionBlur) {\n      var mb = new MotionBlurPostProcess(\"HDRMotionBlur\", scene, ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, 0);\n      mb.motionStrength = this.motionStrength;\n      mb.motionBlurSamples = this.motionBlurSamples;\n      this.motionBlurPostProcess = mb;\n    } else {\n      this.motionBlurPostProcess = new PostProcess(\"HDRMotionBlur\", \"standard\", [\"inverseViewProjection\", \"prevViewProjection\", \"screenSize\", \"motionScale\", \"motionStrength\"], [\"depthSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define MOTION_BLUR\\n#define MAX_MOTION_SAMPLES \" + this.motionBlurSamples.toFixed(1), 0);\n      var motionScale_1 = 0;\n      var prevViewProjection_1 = Matrix.Identity();\n      var invViewProjection_1 = Matrix.Identity();\n      var viewProjection_1 = Matrix.Identity();\n      var screenSize_1 = Vector2.Zero();\n\n      this.motionBlurPostProcess.onApply = function (effect) {\n        viewProjection_1 = scene.getProjectionMatrix().multiply(scene.getViewMatrix());\n        viewProjection_1.invertToRef(invViewProjection_1);\n        effect.setMatrix(\"inverseViewProjection\", invViewProjection_1);\n        effect.setMatrix(\"prevViewProjection\", prevViewProjection_1);\n        prevViewProjection_1 = viewProjection_1;\n        screenSize_1.x = _this.motionBlurPostProcess.width;\n        screenSize_1.y = _this.motionBlurPostProcess.height;\n        effect.setVector2(\"screenSize\", screenSize_1);\n        motionScale_1 = scene.getEngine().getFps() / 60.0;\n        effect.setFloat(\"motionScale\", motionScale_1);\n        effect.setFloat(\"motionStrength\", _this.motionStrength);\n        effect.setTexture(\"depthSampler\", _this._getDepthTexture());\n      };\n    }\n\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRMotionBlur\", function () {\n      return _this.motionBlurPostProcess;\n    }, true));\n  };\n\n  StandardRenderingPipeline.prototype._getDepthTexture = function () {\n    if (this._scene.getEngine().getCaps().drawBuffersExtension) {\n      var renderer = this._scene.enableGeometryBufferRenderer();\n\n      return renderer.getGBuffer().textures[0];\n    }\n\n    return this._scene.enableDepthRenderer().getDepthMap();\n  };\n\n  StandardRenderingPipeline.prototype._disposePostProcesses = function () {\n    for (var i = 0; i < this._cameras.length; i++) {\n      var camera = this._cameras[i];\n\n      if (this.originalPostProcess) {\n        this.originalPostProcess.dispose(camera);\n      }\n\n      if (this.screenSpaceReflectionPostProcess) {\n        this.screenSpaceReflectionPostProcess.dispose(camera);\n      }\n\n      if (this.downSampleX4PostProcess) {\n        this.downSampleX4PostProcess.dispose(camera);\n      }\n\n      if (this.brightPassPostProcess) {\n        this.brightPassPostProcess.dispose(camera);\n      }\n\n      if (this.textureAdderPostProcess) {\n        this.textureAdderPostProcess.dispose(camera);\n      }\n\n      if (this.volumetricLightPostProcess) {\n        this.volumetricLightPostProcess.dispose(camera);\n      }\n\n      if (this.volumetricLightSmoothXPostProcess) {\n        this.volumetricLightSmoothXPostProcess.dispose(camera);\n      }\n\n      if (this.volumetricLightSmoothYPostProcess) {\n        this.volumetricLightSmoothYPostProcess.dispose(camera);\n      }\n\n      if (this.volumetricLightMergePostProces) {\n        this.volumetricLightMergePostProces.dispose(camera);\n      }\n\n      if (this.volumetricLightFinalPostProcess) {\n        this.volumetricLightFinalPostProcess.dispose(camera);\n      }\n\n      if (this.lensFlarePostProcess) {\n        this.lensFlarePostProcess.dispose(camera);\n      }\n\n      if (this.lensFlareComposePostProcess) {\n        this.lensFlareComposePostProcess.dispose(camera);\n      }\n\n      for (var j = 0; j < this.luminanceDownSamplePostProcesses.length; j++) {\n        this.luminanceDownSamplePostProcesses[j].dispose(camera);\n      }\n\n      if (this.luminancePostProcess) {\n        this.luminancePostProcess.dispose(camera);\n      }\n\n      if (this.hdrPostProcess) {\n        this.hdrPostProcess.dispose(camera);\n      }\n\n      if (this.hdrFinalPostProcess) {\n        this.hdrFinalPostProcess.dispose(camera);\n      }\n\n      if (this.depthOfFieldPostProcess) {\n        this.depthOfFieldPostProcess.dispose(camera);\n      }\n\n      if (this.motionBlurPostProcess) {\n        this.motionBlurPostProcess.dispose(camera);\n      }\n\n      if (this.fxaaPostProcess) {\n        this.fxaaPostProcess.dispose(camera);\n      }\n\n      for (var j = 0; j < this.blurHPostProcesses.length; j++) {\n        this.blurHPostProcesses[j].dispose(camera);\n      }\n\n      for (var j = 0; j < this.blurVPostProcesses.length; j++) {\n        this.blurVPostProcesses[j].dispose(camera);\n      }\n    }\n\n    this.originalPostProcess = null;\n    this.downSampleX4PostProcess = null;\n    this.brightPassPostProcess = null;\n    this.textureAdderPostProcess = null;\n    this.textureAdderFinalPostProcess = null;\n    this.volumetricLightPostProcess = null;\n    this.volumetricLightSmoothXPostProcess = null;\n    this.volumetricLightSmoothYPostProcess = null;\n    this.volumetricLightMergePostProces = null;\n    this.volumetricLightFinalPostProcess = null;\n    this.lensFlarePostProcess = null;\n    this.lensFlareComposePostProcess = null;\n    this.luminancePostProcess = null;\n    this.hdrPostProcess = null;\n    this.hdrFinalPostProcess = null;\n    this.depthOfFieldPostProcess = null;\n    this.motionBlurPostProcess = null;\n    this.fxaaPostProcess = null;\n    this.screenSpaceReflectionPostProcess = null;\n    this.luminanceDownSamplePostProcesses = [];\n    this.blurHPostProcesses = [];\n    this.blurVPostProcesses = [];\n  };\n  /**\n   * Dispose of the pipeline and stop all post processes\n   */\n\n\n  StandardRenderingPipeline.prototype.dispose = function () {\n    this._disposePostProcesses();\n\n    this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\n   * Serialize the rendering pipeline (Used when exporting)\n   * @returns the serialized object\n   */\n\n\n  StandardRenderingPipeline.prototype.serialize = function () {\n    var serializationObject = SerializationHelper.Serialize(this);\n\n    if (this.sourceLight) {\n      serializationObject.sourceLightId = this.sourceLight.id;\n    }\n\n    if (this.screenSpaceReflectionPostProcess) {\n      serializationObject.screenSpaceReflectionPostProcess = SerializationHelper.Serialize(this.screenSpaceReflectionPostProcess);\n    }\n\n    serializationObject.customType = \"StandardRenderingPipeline\";\n    return serializationObject;\n  };\n  /**\n   * Parse the serialized pipeline\n   * @param source Source pipeline.\n   * @param scene The scene to load the pipeline to.\n   * @param rootUrl The URL of the serialized pipeline.\n   * @returns An instantiated pipeline from the serialized object.\n   */\n\n\n  StandardRenderingPipeline.Parse = function (source, scene, rootUrl) {\n    var p = SerializationHelper.Parse(function () {\n      return new StandardRenderingPipeline(source._name, scene, source._ratio);\n    }, source, scene, rootUrl);\n\n    if (source.sourceLightId) {\n      p.sourceLight = scene.getLightById(source.sourceLightId);\n    }\n\n    if (source.screenSpaceReflectionPostProcess) {\n      SerializationHelper.Parse(function () {\n        return p.screenSpaceReflectionPostProcess;\n      }, source.screenSpaceReflectionPostProcess, scene, rootUrl);\n    }\n\n    return p;\n  };\n  /**\n   * Luminance steps\n   */\n\n\n  StandardRenderingPipeline.LuminanceSteps = 6;\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"brightThreshold\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"blurWidth\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"horizontalBlur\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"exposure\", null);\n\n  __decorate([serializeAsTexture(\"lensTexture\")], StandardRenderingPipeline.prototype, \"lensTexture\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"volumetricLightCoefficient\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"volumetricLightPower\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"volumetricLightBlurScale\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"hdrMinimumLuminance\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"hdrDecreaseRate\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"hdrIncreaseRate\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"hdrAutoExposure\", null);\n\n  __decorate([serializeAsTexture(\"lensColorTexture\")], StandardRenderingPipeline.prototype, \"lensColorTexture\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"lensFlareStrength\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"lensFlareGhostDispersal\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"lensFlareHaloWidth\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"lensFlareDistortionStrength\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"lensFlareBlurWidth\", void 0);\n\n  __decorate([serializeAsTexture(\"lensStarTexture\")], StandardRenderingPipeline.prototype, \"lensStarTexture\", void 0);\n\n  __decorate([serializeAsTexture(\"lensFlareDirtTexture\")], StandardRenderingPipeline.prototype, \"lensFlareDirtTexture\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"depthOfFieldDistance\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"depthOfFieldBlurWidth\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"motionStrength\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"objectBasedMotionBlur\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"_ratio\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"BloomEnabled\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"DepthOfFieldEnabled\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"LensFlareEnabled\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"HDREnabled\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"VLSEnabled\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"MotionBlurEnabled\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"fxaaEnabled\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"screenSpaceReflectionsEnabled\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"volumetricLightStepsCount\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"motionBlurSamples\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"samples\", null);\n\n  return StandardRenderingPipeline;\n}(PostProcessRenderPipeline);\n\nexport { StandardRenderingPipeline };\nRegisterClass(\"BABYLON.StandardRenderingPipeline\", StandardRenderingPipeline);","map":{"version":3,"mappings":"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","names":["serialize","serializeAsTexture","SerializationHelper","Logger","Vector2","Vector3","Matrix","Vector4","Scalar","Texture","PostProcess","PostProcessRenderPipeline","PostProcessRenderEffect","BlurPostProcess","FxaaPostProcess","RegisterClass","MotionBlurPostProcess","ScreenSpaceReflectionPostProcess","__extends","name","scene","ratio","originalPostProcess","cameras","_super","getEngine","_this","_cameras","slice","_camerasToBeAttached","_scene","_basePostProcess","_ratio","_floatTextureType","getCaps","textureFloatRender","postProcessRenderPipelineManager","addPipeline","_buildPipeline","Object","StandardRenderingPipeline","_fixedExposure","value","_currentExposure","_hdrAutoExposure","hdrPostProcess","defines","push","updateEffect","join","_motionStrength","strength","_isObjectBasedMotionBlur","motionBlurPostProcess","motionStrength","shouldRebuild","_bloomEnabled","enabled","_depthOfFieldEnabled","_lensFlareEnabled","_hdrEnabled","_vlsEnabled","geometry","enableGeometryBufferRenderer","Warn","_motionBlurEnabled","_fxaaEnabled","_screenSpaceReflectionsEnabled","_volumetricLightStepsCount","count","volumetricLightPostProcess","toFixed","_motionBlurSamples","samples","motionBlurSamples","_samples","sampleCount","_disposePostProcesses","detachCamerasFromRenderPipeline","_name","_reset","screenSpaceReflectionPostProcess","BILINEAR_SAMPLINGMODE","onApplyObservable","add","_currentDepthOfFieldSource","addEffect","autoClear","_createDownSampleX4PostProcess","_createBrightPassPostProcess","_createBlurPostProcesses","_createTextureAdderPostProcess","textureAdderFinalPostProcess","_createVolumetricLightPostProcess","volumetricLightFinalPostProcess","_createLensFlarePostProcess","lensFlareFinalPostProcess","_createLuminancePostProcesses","_createHdrPostProcess","hdrFinalPostProcess","_createDepthOfFieldPostProcess","_createMotionBlurPostProcess","fxaaPostProcess","attachCamerasToRenderPipeline","_enableMSAAOnFirstPostProcess","downSampleX4Offsets","Array","downSampleX4PostProcess","onApply","effect","id","width","height","i","j","setArray2","brightOffsets","brightPassPostProcess","sU","sV","setFloat","brightThreshold","indice","blurWidthKey","engine","blurX","blurY","onActivateObservable","dw","getRenderWidth","kernel","getRenderHeight","horizontalBlur","blurHPostProcesses","blurVPostProcesses","textureAdderPostProcess","setTextureFromPostProcess","setTexture","lensTexture","geometryRenderer","enablePosition","getGBuffer","depthValues","Zero","sourceLight","getShadowGenerator","activeCamera","generator","getShadowMap","textures","setColor3","diffuse","setVector3","getShadowDirection","globalPosition","setMatrix","getTransformMatrix","volumetricLightCoefficient","volumetricLightPower","x","getDepthMinZ","y","getDepthMaxZ","setVector2","volumetricLightMergePostProces","textureType","size","Math","pow","LuminanceSteps","luminancePostProcess","offsets","postProcess","luminanceDownSamplePostProcesses","lastLuminance","forEach","pp","index","downSampleOffsets","length","onAfterRender","pixel","readPixels","bit_shift","then","data","Uint8Array","buffer","_hdrCurrentLuminance","z","w","outputLiminance","time","lastTime","getDeltaTime","dt","hdrDecreaseRate","hdrIncreaseRate","hdrAutoExposure","Clamp","hdrMinimumLuminance","lensFlarePostProcess","lensFlareComposePostProcess","resolution","externalTextureSamplerBinding","lensColorTexture","lensFlareStrength","lensFlareGhostDispersal","lensFlareHaloWidth","lensFlareDistortionStrength","scaleBias1","FromValues","scaleBias2","lensFlareDirtTexture","lensStarTexture","camerax","getViewMatrix","getRow","cameraz","camRot","Dot","toVector3","starRotation","cos","sin","lensStarMatrix","multiply","depthOfFieldPostProcess","_getDepthTexture","depthOfFieldDistance","mb","motionScale_1","prevViewProjection_1","Identity","invViewProjection_1","viewProjection_1","screenSize_1","getProjectionMatrix","invertToRef","getFps","drawBuffersExtension","renderer","enableDepthRenderer","getDepthMap","camera","dispose","volumetricLightSmoothXPostProcess","volumetricLightSmoothYPostProcess","call","serializationObject","Serialize","sourceLightId","customType","source","rootUrl","p","Parse","getLightById","__decorate"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/PostProcesses/RenderPipeline/Pipelines/standardRenderingPipeline.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../../types\";\r\nimport { serialize, serializeAsTexture, SerializationHelper } from \"../../../Misc/decorators\";\r\nimport type { IAnimatable } from \"../../../Animations/animatable.interface\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport { Vector2, Vector3, Matrix, Vector4 } from \"../../../Maths/math.vector\";\r\nimport { Scalar } from \"../../../Maths/math.scalar\";\r\nimport type { Camera } from \"../../../Cameras/camera\";\r\nimport type { Effect } from \"../../../Materials/effect\";\r\nimport { Texture } from \"../../../Materials/Textures/texture\";\r\nimport { PostProcess } from \"../../../PostProcesses/postProcess\";\r\nimport { PostProcessRenderPipeline } from \"../../../PostProcesses/RenderPipeline/postProcessRenderPipeline\";\r\nimport { PostProcessRenderEffect } from \"../../../PostProcesses/RenderPipeline/postProcessRenderEffect\";\r\nimport { BlurPostProcess } from \"../../../PostProcesses/blurPostProcess\";\r\nimport { FxaaPostProcess } from \"../../../PostProcesses/fxaaPostProcess\";\r\nimport type { IDisposable, Scene } from \"../../../scene\";\r\nimport type { SpotLight } from \"../../../Lights/spotLight\";\r\nimport type { DirectionalLight } from \"../../../Lights/directionalLight\";\r\nimport type { GeometryBufferRenderer } from \"../../../Rendering/geometryBufferRenderer\";\r\n\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { MotionBlurPostProcess } from \"../../motionBlurPostProcess\";\r\nimport { ScreenSpaceReflectionPostProcess } from \"../../screenSpaceReflectionPostProcess\";\r\n\r\ndeclare type Animation = import(\"../../../Animations/animation\").Animation;\r\n\r\nimport \"../../../PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent\";\r\n\r\nimport \"../../../Shaders/standard.fragment\";\r\n/**\r\n * Standard rendering pipeline\r\n * Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.\r\n * @see https://doc.babylonjs.com/how_to/using_standard_rendering_pipeline\r\n */\r\nexport class StandardRenderingPipeline extends PostProcessRenderPipeline implements IDisposable, IAnimatable {\r\n    /**\r\n     * Public members\r\n     */\r\n    // Post-processes\r\n    /**\r\n     * Post-process which contains the original scene color before the pipeline applies all the effects\r\n     */\r\n    public originalPostProcess: Nullable<PostProcess>;\r\n    /**\r\n     * Post-process used to down scale an image x4\r\n     */\r\n    public downSampleX4PostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to calculate the illuminated surfaces controlled by a threshold\r\n     */\r\n    public brightPassPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process array storing all the horizontal blur post-processes used by the pipeline\r\n     */\r\n    public blurHPostProcesses: PostProcess[] = [];\r\n    /**\r\n     * Post-process array storing all the vertical blur post-processes used by the pipeline\r\n     */\r\n    public blurVPostProcesses: PostProcess[] = [];\r\n    /**\r\n     * Post-process used to add colors of 2 textures (typically brightness + real scene color)\r\n     */\r\n    public textureAdderPostProcess: Nullable<PostProcess> = null;\r\n\r\n    /**\r\n     * Post-process used to create volumetric lighting effect\r\n     */\r\n    public volumetricLightPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to smooth the previous volumetric light post-process on the X axis\r\n     */\r\n    public volumetricLightSmoothXPostProcess: Nullable<BlurPostProcess> = null;\r\n    /**\r\n     * Post-process used to smooth the previous volumetric light post-process on the Y axis\r\n     */\r\n    public volumetricLightSmoothYPostProcess: Nullable<BlurPostProcess> = null;\r\n    /**\r\n     * Post-process used to merge the volumetric light effect and the real scene color\r\n     */\r\n    public volumetricLightMergePostProces: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to store the final volumetric light post-process (attach/detach for debug purpose)\r\n     */\r\n    public volumetricLightFinalPostProcess: Nullable<PostProcess> = null;\r\n\r\n    /**\r\n     * Base post-process used to calculate the average luminance of the final image for HDR\r\n     */\r\n    public luminancePostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-processes used to create down sample post-processes in order to get\r\n     * the average luminance of the final image for HDR\r\n     * Array of length \"StandardRenderingPipeline.LuminanceSteps\"\r\n     */\r\n    public luminanceDownSamplePostProcesses: PostProcess[] = [];\r\n    /**\r\n     * Post-process used to create a HDR effect (light adaptation)\r\n     */\r\n    public hdrPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to store the final texture adder post-process (attach/detach for debug purpose)\r\n     */\r\n    public textureAdderFinalPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to store the final lens flare post-process (attach/detach for debug purpose)\r\n     */\r\n    public lensFlareFinalPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to merge the final HDR post-process and the real scene color\r\n     */\r\n    public hdrFinalPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to create a lens flare effect\r\n     */\r\n    public lensFlarePostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process that merges the result of the lens flare post-process and the real scene color\r\n     */\r\n    public lensFlareComposePostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to create a motion blur effect\r\n     */\r\n    public motionBlurPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to create a depth of field effect\r\n     */\r\n    public depthOfFieldPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * The Fast Approximate Anti-Aliasing post process which attempts to remove aliasing from an image.\r\n     */\r\n    public fxaaPostProcess: Nullable<FxaaPostProcess> = null;\r\n    /**\r\n     * Post-process used to simulate realtime reflections using the screen space and geometry renderer.\r\n     */\r\n    public screenSpaceReflectionPostProcess: Nullable<ScreenSpaceReflectionPostProcess> = null;\r\n\r\n    // Values\r\n\r\n    /**\r\n     * Represents the brightness threshold in order to configure the illuminated surfaces\r\n     */\r\n    @serialize()\r\n    public brightThreshold: number = 1.0;\r\n\r\n    /**\r\n     * Configures the blur intensity used for surexposed surfaces are highlighted surfaces (light halo)\r\n     */\r\n    @serialize()\r\n    public blurWidth: number = 512.0;\r\n    /**\r\n     * Sets if the blur for highlighted surfaces must be only horizontal\r\n     */\r\n    @serialize()\r\n    public horizontalBlur: boolean = false;\r\n\r\n    /**\r\n     * Gets the overall exposure used by the pipeline\r\n     */\r\n    @serialize()\r\n    public get exposure(): number {\r\n        return this._fixedExposure;\r\n    }\r\n    /**\r\n     * Sets the overall exposure used by the pipeline\r\n     */\r\n    public set exposure(value: number) {\r\n        this._fixedExposure = value;\r\n        this._currentExposure = value;\r\n    }\r\n\r\n    /**\r\n     * Texture used typically to simulate \"dirty\" on camera lens\r\n     */\r\n    @serializeAsTexture(\"lensTexture\")\r\n    public lensTexture: Nullable<Texture> = null;\r\n\r\n    /**\r\n     * Represents the offset coefficient based on Rayleigh principle. Typically in interval [-0.2, 0.2]\r\n     */\r\n    @serialize()\r\n    public volumetricLightCoefficient: number = 0.2;\r\n    /**\r\n     * The overall power of volumetric lights, typically in interval [0, 10] maximum\r\n     */\r\n    @serialize()\r\n    public volumetricLightPower: number = 4.0;\r\n    /**\r\n     * Used the set the blur intensity to smooth the volumetric lights\r\n     */\r\n    @serialize()\r\n    public volumetricLightBlurScale: number = 64.0;\r\n    /**\r\n     * Light (spot or directional) used to generate the volumetric lights rays\r\n     * The source light must have a shadow generate so the pipeline can get its\r\n     * depth map\r\n     */\r\n    public sourceLight: Nullable<SpotLight | DirectionalLight> = null;\r\n\r\n    /**\r\n     * For eye adaptation, represents the minimum luminance the eye can see\r\n     */\r\n    @serialize()\r\n    public hdrMinimumLuminance: number = 1.0;\r\n    /**\r\n     * For eye adaptation, represents the decrease luminance speed\r\n     */\r\n    @serialize()\r\n    public hdrDecreaseRate: number = 0.5;\r\n    /**\r\n     * For eye adaptation, represents the increase luminance speed\r\n     */\r\n    @serialize()\r\n    public hdrIncreaseRate: number = 0.5;\r\n    /**\r\n     * Gets whether or not the exposure of the overall pipeline should be automatically adjusted by the HDR post-process\r\n     */\r\n    @serialize()\r\n    public get hdrAutoExposure(): boolean {\r\n        return this._hdrAutoExposure;\r\n    }\r\n    /**\r\n     * Sets whether or not the exposure of the overall pipeline should be automatically adjusted by the HDR post-process\r\n     */\r\n    public set hdrAutoExposure(value: boolean) {\r\n        this._hdrAutoExposure = value;\r\n        if (this.hdrPostProcess) {\r\n            const defines = [\"#define HDR\"];\r\n            if (value) {\r\n                defines.push(\"#define AUTO_EXPOSURE\");\r\n            }\r\n            this.hdrPostProcess.updateEffect(defines.join(\"\\n\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Lens color texture used by the lens flare effect. Mandatory if lens flare effect enabled\r\n     */\r\n    @serializeAsTexture(\"lensColorTexture\")\r\n    public lensColorTexture: Nullable<Texture> = null;\r\n    /**\r\n     * The overall strength for the lens flare effect\r\n     */\r\n    @serialize()\r\n    public lensFlareStrength: number = 20.0;\r\n    /**\r\n     * Dispersion coefficient for lens flare ghosts\r\n     */\r\n    @serialize()\r\n    public lensFlareGhostDispersal: number = 1.4;\r\n    /**\r\n     * Main lens flare halo width\r\n     */\r\n    @serialize()\r\n    public lensFlareHaloWidth: number = 0.7;\r\n    /**\r\n     * Based on the lens distortion effect, defines how much the lens flare result\r\n     * is distorted\r\n     */\r\n    @serialize()\r\n    public lensFlareDistortionStrength: number = 16.0;\r\n    /**\r\n     * Configures the blur intensity used for for lens flare (halo)\r\n     */\r\n    @serialize()\r\n    public lensFlareBlurWidth: number = 512.0;\r\n    /**\r\n     * Lens star texture must be used to simulate rays on the flares and is available\r\n     * in the documentation\r\n     */\r\n    @serializeAsTexture(\"lensStarTexture\")\r\n    public lensStarTexture: Nullable<Texture> = null;\r\n    /**\r\n     * As the \"lensTexture\" (can be the same texture or different), it is used to apply the lens\r\n     * flare effect by taking account of the dirt texture\r\n     */\r\n    @serializeAsTexture(\"lensFlareDirtTexture\")\r\n    public lensFlareDirtTexture: Nullable<Texture> = null;\r\n\r\n    /**\r\n     * Represents the focal length for the depth of field effect\r\n     */\r\n    @serialize()\r\n    public depthOfFieldDistance: number = 10.0;\r\n    /**\r\n     * Represents the blur intensity for the blurred part of the depth of field effect\r\n     */\r\n    @serialize()\r\n    public depthOfFieldBlurWidth: number = 64.0;\r\n\r\n    /**\r\n     * Gets how much the image is blurred by the movement while using the motion blur post-process\r\n     */\r\n    @serialize()\r\n    public get motionStrength(): number {\r\n        return this._motionStrength;\r\n    }\r\n    /**\r\n     * Sets how much the image is blurred by the movement while using the motion blur post-process\r\n     */\r\n    public set motionStrength(strength: number) {\r\n        this._motionStrength = strength;\r\n\r\n        if (this._isObjectBasedMotionBlur && this.motionBlurPostProcess) {\r\n            (this.motionBlurPostProcess as MotionBlurPostProcess).motionStrength = strength;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets whether or not the motion blur post-process is object based or screen based.\r\n     */\r\n    @serialize()\r\n    public get objectBasedMotionBlur(): boolean {\r\n        return this._isObjectBasedMotionBlur;\r\n    }\r\n    /**\r\n     * Sets whether or not the motion blur post-process should be object based or screen based\r\n     */\r\n    public set objectBasedMotionBlur(value: boolean) {\r\n        const shouldRebuild = this._isObjectBasedMotionBlur !== value;\r\n        this._isObjectBasedMotionBlur = value;\r\n\r\n        if (shouldRebuild) {\r\n            this._buildPipeline();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * List of animations for the pipeline (IAnimatable implementation)\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    /**\r\n     * Private members\r\n     */\r\n    private _scene: Scene;\r\n    private _currentDepthOfFieldSource: Nullable<PostProcess> = null;\r\n    private _basePostProcess: Nullable<PostProcess>;\r\n\r\n    private _fixedExposure: number = 1.0;\r\n    private _currentExposure: number = 1.0;\r\n    private _hdrAutoExposure: boolean = false;\r\n    private _hdrCurrentLuminance: number = 1.0;\r\n    private _motionStrength: number = 1.0;\r\n    private _isObjectBasedMotionBlur: boolean = false;\r\n\r\n    private _floatTextureType: number;\r\n\r\n    private _camerasToBeAttached: Array<Camera> = [];\r\n\r\n    @serialize()\r\n    private _ratio: number;\r\n\r\n    // Getters and setters\r\n    private _bloomEnabled: boolean = false;\r\n    private _depthOfFieldEnabled: boolean = false;\r\n    private _vlsEnabled: boolean = false;\r\n    private _lensFlareEnabled: boolean = false;\r\n    private _hdrEnabled: boolean = false;\r\n    private _motionBlurEnabled: boolean = false;\r\n    private _fxaaEnabled: boolean = false;\r\n    private _screenSpaceReflectionsEnabled: boolean = false;\r\n\r\n    private _motionBlurSamples: number = 64.0;\r\n    private _volumetricLightStepsCount: number = 50.0;\r\n    private _samples: number = 1;\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the bloom pipeline is enabled\r\n     */\r\n    @serialize()\r\n    public get BloomEnabled(): boolean {\r\n        return this._bloomEnabled;\r\n    }\r\n\r\n    public set BloomEnabled(enabled: boolean) {\r\n        if (this._bloomEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._bloomEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the depth of field pipeline is enabled\r\n     */\r\n    @serialize()\r\n    public get DepthOfFieldEnabled(): boolean {\r\n        return this._depthOfFieldEnabled;\r\n    }\r\n\r\n    public set DepthOfFieldEnabled(enabled: boolean) {\r\n        if (this._depthOfFieldEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._depthOfFieldEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the lens flare pipeline is enabled\r\n     */\r\n    @serialize()\r\n    public get LensFlareEnabled(): boolean {\r\n        return this._lensFlareEnabled;\r\n    }\r\n\r\n    public set LensFlareEnabled(enabled: boolean) {\r\n        if (this._lensFlareEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._lensFlareEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the HDR pipeline is enabled\r\n     */\r\n    @serialize()\r\n    public get HDREnabled(): boolean {\r\n        return this._hdrEnabled;\r\n    }\r\n\r\n    public set HDREnabled(enabled: boolean) {\r\n        if (this._hdrEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._hdrEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the volumetric lights scattering effect is enabled\r\n     */\r\n    @serialize()\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get VLSEnabled(): boolean {\r\n        return this._vlsEnabled;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public set VLSEnabled(enabled) {\r\n        if (this._vlsEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        if (enabled) {\r\n            const geometry = this._scene.enableGeometryBufferRenderer();\r\n            if (!geometry) {\r\n                Logger.Warn(\"Geometry renderer is not supported, cannot create volumetric lights in Standard Rendering Pipeline\");\r\n                return;\r\n            }\r\n        }\r\n\r\n        this._vlsEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the motion blur effect is enabled\r\n     */\r\n    @serialize()\r\n    public get MotionBlurEnabled(): boolean {\r\n        return this._motionBlurEnabled;\r\n    }\r\n\r\n    public set MotionBlurEnabled(enabled: boolean) {\r\n        if (this._motionBlurEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._motionBlurEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Specifies if anti-aliasing is enabled\r\n     */\r\n    @serialize()\r\n    public get fxaaEnabled(): boolean {\r\n        return this._fxaaEnabled;\r\n    }\r\n\r\n    public set fxaaEnabled(enabled: boolean) {\r\n        if (this._fxaaEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._fxaaEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Specifies if screen space reflections are enabled.\r\n     */\r\n    @serialize()\r\n    public get screenSpaceReflectionsEnabled(): boolean {\r\n        return this._screenSpaceReflectionsEnabled;\r\n    }\r\n\r\n    public set screenSpaceReflectionsEnabled(enabled: boolean) {\r\n        if (this._screenSpaceReflectionsEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._screenSpaceReflectionsEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Specifies the number of steps used to calculate the volumetric lights\r\n     * Typically in interval [50, 200]\r\n     */\r\n    @serialize()\r\n    public get volumetricLightStepsCount(): number {\r\n        return this._volumetricLightStepsCount;\r\n    }\r\n\r\n    public set volumetricLightStepsCount(count: number) {\r\n        if (this.volumetricLightPostProcess) {\r\n            this.volumetricLightPostProcess.updateEffect(\"#define VLS\\n#define NB_STEPS \" + count.toFixed(1));\r\n        }\r\n\r\n        this._volumetricLightStepsCount = count;\r\n    }\r\n\r\n    /**\r\n     * Specifies the number of samples used for the motion blur effect\r\n     * Typically in interval [16, 64]\r\n     */\r\n    @serialize()\r\n    public get motionBlurSamples(): number {\r\n        return this._motionBlurSamples;\r\n    }\r\n\r\n    public set motionBlurSamples(samples: number) {\r\n        if (this.motionBlurPostProcess) {\r\n            if (this._isObjectBasedMotionBlur) {\r\n                (this.motionBlurPostProcess as MotionBlurPostProcess).motionBlurSamples = samples;\r\n            } else {\r\n                this.motionBlurPostProcess.updateEffect(\"#define MOTION_BLUR\\n#define MAX_MOTION_SAMPLES \" + samples.toFixed(1));\r\n            }\r\n        }\r\n\r\n        this._motionBlurSamples = samples;\r\n    }\r\n\r\n    /**\r\n     * Specifies MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)\r\n     */\r\n    @serialize()\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    public set samples(sampleCount: number) {\r\n        if (this._samples === sampleCount) {\r\n            return;\r\n        }\r\n\r\n        this._samples = sampleCount;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.\r\n     * @constructor\r\n     * @param name The rendering pipeline name\r\n     * @param scene The scene linked to this pipeline\r\n     * @param ratio The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\r\n     * @param originalPostProcess the custom original color post-process. Must be \"reusable\". Can be null.\r\n     * @param cameras The array of cameras that the rendering pipeline will be attached to\r\n     */\r\n    constructor(name: string, scene: Scene, ratio: number, originalPostProcess: Nullable<PostProcess> = null, cameras?: Camera[]) {\r\n        super(scene.getEngine(), name);\r\n        this._cameras = cameras || scene.cameras;\r\n        this._cameras = this._cameras.slice();\r\n        this._camerasToBeAttached = this._cameras.slice();\r\n\r\n        // Initialize\r\n        this._scene = scene;\r\n        this._basePostProcess = originalPostProcess;\r\n        this._ratio = ratio;\r\n\r\n        // Misc\r\n        this._floatTextureType = scene.getEngine().getCaps().textureFloatRender ? Constants.TEXTURETYPE_FLOAT : Constants.TEXTURETYPE_HALF_FLOAT;\r\n\r\n        // Finish\r\n        scene.postProcessRenderPipelineManager.addPipeline(this);\r\n        this._buildPipeline();\r\n    }\r\n\r\n    private _buildPipeline(): void {\r\n        const ratio = this._ratio;\r\n        const scene = this._scene;\r\n\r\n        this._disposePostProcesses();\r\n        if (this._cameras !== null) {\r\n            this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\r\n            // get back cameras to be used to reattach pipeline\r\n            this._cameras = this._camerasToBeAttached.slice();\r\n        }\r\n        this._reset();\r\n\r\n        // Create pass post-process\r\n        if (this._screenSpaceReflectionsEnabled) {\r\n            this.screenSpaceReflectionPostProcess = new ScreenSpaceReflectionPostProcess(\r\n                \"HDRPass\",\r\n                scene,\r\n                ratio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                this._floatTextureType\r\n            );\r\n            this.screenSpaceReflectionPostProcess.onApplyObservable.add(() => {\r\n                this._currentDepthOfFieldSource = this.screenSpaceReflectionPostProcess;\r\n            });\r\n            this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRScreenSpaceReflections\", () => this.screenSpaceReflectionPostProcess, true));\r\n        }\r\n\r\n        if (!this._basePostProcess) {\r\n            this.originalPostProcess = new PostProcess(\r\n                \"HDRPass\",\r\n                \"standard\",\r\n                [],\r\n                [],\r\n                ratio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                \"#define PASS_POST_PROCESS\",\r\n                this._floatTextureType\r\n            );\r\n        } else {\r\n            this.originalPostProcess = this._basePostProcess;\r\n        }\r\n\r\n        this.originalPostProcess.autoClear = !this.screenSpaceReflectionPostProcess;\r\n        this.originalPostProcess.onApplyObservable.add(() => {\r\n            this._currentDepthOfFieldSource = this.originalPostProcess;\r\n        });\r\n\r\n        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRPassPostProcess\", () => this.originalPostProcess, true));\r\n\r\n        if (this._bloomEnabled) {\r\n            // Create down sample X4 post-process\r\n            this._createDownSampleX4PostProcess(scene, ratio / 4);\r\n\r\n            // Create bright pass post-process\r\n            this._createBrightPassPostProcess(scene, ratio / 4);\r\n\r\n            // Create gaussian blur post-processes (down sampling blurs)\r\n            this._createBlurPostProcesses(scene, ratio / 4, 1);\r\n\r\n            // Create texture adder post-process\r\n            this._createTextureAdderPostProcess(scene, ratio);\r\n\r\n            // Create depth-of-field source post-process\r\n            this.textureAdderFinalPostProcess = new PostProcess(\r\n                \"HDRDepthOfFieldSource\",\r\n                \"standard\",\r\n                [],\r\n                [],\r\n                ratio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                \"#define PASS_POST_PROCESS\",\r\n                Constants.TEXTURETYPE_UNSIGNED_INT\r\n            );\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    scene.getEngine(),\r\n                    \"HDRBaseDepthOfFieldSource\",\r\n                    () => {\r\n                        return this.textureAdderFinalPostProcess;\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n        }\r\n\r\n        if (this._vlsEnabled) {\r\n            // Create volumetric light\r\n            this._createVolumetricLightPostProcess(scene, ratio);\r\n\r\n            // Create volumetric light final post-process\r\n            this.volumetricLightFinalPostProcess = new PostProcess(\r\n                \"HDRVLSFinal\",\r\n                \"standard\",\r\n                [],\r\n                [],\r\n                ratio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                \"#define PASS_POST_PROCESS\",\r\n                Constants.TEXTURETYPE_UNSIGNED_INT\r\n            );\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    scene.getEngine(),\r\n                    \"HDRVLSFinal\",\r\n                    () => {\r\n                        return this.volumetricLightFinalPostProcess;\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n        }\r\n\r\n        if (this._lensFlareEnabled) {\r\n            // Create lens flare post-process\r\n            this._createLensFlarePostProcess(scene, ratio);\r\n\r\n            // Create depth-of-field source post-process post lens-flare and disable it now\r\n            this.lensFlareFinalPostProcess = new PostProcess(\r\n                \"HDRPostLensFlareDepthOfFieldSource\",\r\n                \"standard\",\r\n                [],\r\n                [],\r\n                ratio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                \"#define PASS_POST_PROCESS\",\r\n                Constants.TEXTURETYPE_UNSIGNED_INT\r\n            );\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    scene.getEngine(),\r\n                    \"HDRPostLensFlareDepthOfFieldSource\",\r\n                    () => {\r\n                        return this.lensFlareFinalPostProcess;\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n        }\r\n\r\n        if (this._hdrEnabled) {\r\n            // Create luminance\r\n            this._createLuminancePostProcesses(scene, this._floatTextureType);\r\n\r\n            // Create HDR\r\n            this._createHdrPostProcess(scene, ratio);\r\n\r\n            // Create depth-of-field source post-process post hdr and disable it now\r\n            this.hdrFinalPostProcess = new PostProcess(\r\n                \"HDRPostHDReDepthOfFieldSource\",\r\n                \"standard\",\r\n                [],\r\n                [],\r\n                ratio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                \"#define PASS_POST_PROCESS\",\r\n                Constants.TEXTURETYPE_UNSIGNED_INT\r\n            );\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    scene.getEngine(),\r\n                    \"HDRPostHDReDepthOfFieldSource\",\r\n                    () => {\r\n                        return this.hdrFinalPostProcess;\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n        }\r\n\r\n        if (this._depthOfFieldEnabled) {\r\n            // Create gaussian blur used by depth-of-field\r\n            this._createBlurPostProcesses(scene, ratio / 2, 3, \"depthOfFieldBlurWidth\");\r\n\r\n            // Create depth-of-field post-process\r\n            this._createDepthOfFieldPostProcess(scene, ratio);\r\n        }\r\n\r\n        if (this._motionBlurEnabled) {\r\n            // Create motion blur post-process\r\n            this._createMotionBlurPostProcess(scene, ratio);\r\n        }\r\n\r\n        if (this._fxaaEnabled) {\r\n            // Create fxaa post-process\r\n            this.fxaaPostProcess = new FxaaPostProcess(\"fxaa\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, Constants.TEXTURETYPE_UNSIGNED_INT);\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    scene.getEngine(),\r\n                    \"HDRFxaa\",\r\n                    () => {\r\n                        return this.fxaaPostProcess;\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n        }\r\n\r\n        if (this._cameras !== null) {\r\n            this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);\r\n        }\r\n\r\n        if (!this._enableMSAAOnFirstPostProcess(this._samples) && this._samples > 1) {\r\n            Logger.Warn(\"MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0\");\r\n        }\r\n    }\r\n\r\n    // Down Sample X4 Post-Process\r\n    private _createDownSampleX4PostProcess(scene: Scene, ratio: number): void {\r\n        const downSampleX4Offsets = new Array<number>(32);\r\n        this.downSampleX4PostProcess = new PostProcess(\r\n            \"HDRDownSampleX4\",\r\n            \"standard\",\r\n            [\"dsOffsets\"],\r\n            [],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define DOWN_SAMPLE_X4\",\r\n            this._floatTextureType\r\n        );\r\n\r\n        this.downSampleX4PostProcess.onApply = (effect: Effect) => {\r\n            let id = 0;\r\n            const width = (<PostProcess>this.downSampleX4PostProcess).width;\r\n            const height = (<PostProcess>this.downSampleX4PostProcess).height;\r\n\r\n            for (let i = -2; i < 2; i++) {\r\n                for (let j = -2; j < 2; j++) {\r\n                    downSampleX4Offsets[id] = (i + 0.5) * (1.0 / width);\r\n                    downSampleX4Offsets[id + 1] = (j + 0.5) * (1.0 / height);\r\n                    id += 2;\r\n                }\r\n            }\r\n\r\n            effect.setArray2(\"dsOffsets\", downSampleX4Offsets);\r\n        };\r\n\r\n        // Add to pipeline\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRDownSampleX4\",\r\n                () => {\r\n                    return this.downSampleX4PostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n    }\r\n\r\n    // Brightpass Post-Process\r\n    private _createBrightPassPostProcess(scene: Scene, ratio: number): void {\r\n        const brightOffsets = new Array<number>(8);\r\n        this.brightPassPostProcess = new PostProcess(\r\n            \"HDRBrightPass\",\r\n            \"standard\",\r\n            [\"dsOffsets\", \"brightThreshold\"],\r\n            [],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define BRIGHT_PASS\",\r\n            this._floatTextureType\r\n        );\r\n\r\n        this.brightPassPostProcess.onApply = (effect: Effect) => {\r\n            const sU = 1.0 / (<PostProcess>this.brightPassPostProcess).width;\r\n            const sV = 1.0 / (<PostProcess>this.brightPassPostProcess).height;\r\n\r\n            brightOffsets[0] = -0.5 * sU;\r\n            brightOffsets[1] = 0.5 * sV;\r\n            brightOffsets[2] = 0.5 * sU;\r\n            brightOffsets[3] = 0.5 * sV;\r\n            brightOffsets[4] = -0.5 * sU;\r\n            brightOffsets[5] = -0.5 * sV;\r\n            brightOffsets[6] = 0.5 * sU;\r\n            brightOffsets[7] = -0.5 * sV;\r\n\r\n            effect.setArray2(\"dsOffsets\", brightOffsets);\r\n            effect.setFloat(\"brightThreshold\", this.brightThreshold);\r\n        };\r\n\r\n        // Add to pipeline\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRBrightPass\",\r\n                () => {\r\n                    return this.brightPassPostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n    }\r\n\r\n    // Create blur H&V post-processes\r\n    private _createBlurPostProcesses(scene: Scene, ratio: number, indice: number, blurWidthKey: string = \"blurWidth\"): void {\r\n        const engine = scene.getEngine();\r\n\r\n        const blurX = new BlurPostProcess(\r\n            \"HDRBlurH\" + \"_\" + indice,\r\n            new Vector2(1, 0),\r\n            (<any>this)[blurWidthKey],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            this._floatTextureType\r\n        );\r\n        const blurY = new BlurPostProcess(\r\n            \"HDRBlurV\" + \"_\" + indice,\r\n            new Vector2(0, 1),\r\n            (<any>this)[blurWidthKey],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            this._floatTextureType\r\n        );\r\n\r\n        blurX.onActivateObservable.add(() => {\r\n            const dw = blurX.width / engine.getRenderWidth();\r\n            blurX.kernel = (<any>this)[blurWidthKey] * dw;\r\n        });\r\n\r\n        blurY.onActivateObservable.add(() => {\r\n            const dw = blurY.height / engine.getRenderHeight();\r\n            blurY.kernel = this.horizontalBlur ? 64 * dw : (<any>this)[blurWidthKey] * dw;\r\n        });\r\n\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRBlurH\" + indice,\r\n                () => {\r\n                    return blurX;\r\n                },\r\n                true\r\n            )\r\n        );\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRBlurV\" + indice,\r\n                () => {\r\n                    return blurY;\r\n                },\r\n                true\r\n            )\r\n        );\r\n\r\n        this.blurHPostProcesses.push(blurX);\r\n        this.blurVPostProcesses.push(blurY);\r\n    }\r\n\r\n    // Create texture adder post-process\r\n    private _createTextureAdderPostProcess(scene: Scene, ratio: number): void {\r\n        this.textureAdderPostProcess = new PostProcess(\r\n            \"HDRTextureAdder\",\r\n            \"standard\",\r\n            [\"exposure\"],\r\n            [\"otherSampler\", \"lensSampler\"],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define TEXTURE_ADDER\",\r\n            this._floatTextureType\r\n        );\r\n        this.textureAdderPostProcess.onApply = (effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"otherSampler\", this._vlsEnabled ? this._currentDepthOfFieldSource : this.originalPostProcess);\r\n            effect.setTexture(\"lensSampler\", this.lensTexture);\r\n\r\n            effect.setFloat(\"exposure\", this._currentExposure);\r\n\r\n            this._currentDepthOfFieldSource = this.textureAdderFinalPostProcess;\r\n        };\r\n\r\n        // Add to pipeline\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRTextureAdder\",\r\n                () => {\r\n                    return this.textureAdderPostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n    }\r\n\r\n    private _createVolumetricLightPostProcess(scene: Scene, ratio: number): void {\r\n        const geometryRenderer = <GeometryBufferRenderer>scene.enableGeometryBufferRenderer();\r\n        geometryRenderer.enablePosition = true;\r\n\r\n        const geometry = geometryRenderer.getGBuffer();\r\n\r\n        // Base post-process\r\n        this.volumetricLightPostProcess = new PostProcess(\r\n            \"HDRVLS\",\r\n            \"standard\",\r\n            [\"shadowViewProjection\", \"cameraPosition\", \"sunDirection\", \"sunColor\", \"scatteringCoefficient\", \"scatteringPower\", \"depthValues\"],\r\n            [\"shadowMapSampler\", \"positionSampler\"],\r\n            ratio / 8,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define VLS\\n#define NB_STEPS \" + this._volumetricLightStepsCount.toFixed(1)\r\n        );\r\n\r\n        const depthValues = Vector2.Zero();\r\n\r\n        this.volumetricLightPostProcess.onApply = (effect: Effect) => {\r\n            if (this.sourceLight && this.sourceLight.getShadowGenerator() && this._scene.activeCamera) {\r\n                const generator = this.sourceLight.getShadowGenerator()!;\r\n\r\n                effect.setTexture(\"shadowMapSampler\", generator.getShadowMap());\r\n                effect.setTexture(\"positionSampler\", geometry.textures[2]);\r\n\r\n                effect.setColor3(\"sunColor\", this.sourceLight.diffuse);\r\n                effect.setVector3(\"sunDirection\", this.sourceLight.getShadowDirection());\r\n\r\n                effect.setVector3(\"cameraPosition\", this._scene.activeCamera.globalPosition);\r\n                effect.setMatrix(\"shadowViewProjection\", generator.getTransformMatrix());\r\n\r\n                effect.setFloat(\"scatteringCoefficient\", this.volumetricLightCoefficient);\r\n                effect.setFloat(\"scatteringPower\", this.volumetricLightPower);\r\n\r\n                depthValues.x = this.sourceLight.getDepthMinZ(this._scene.activeCamera);\r\n                depthValues.y = this.sourceLight.getDepthMaxZ(this._scene.activeCamera);\r\n                effect.setVector2(\"depthValues\", depthValues);\r\n            }\r\n        };\r\n\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRVLS\",\r\n                () => {\r\n                    return this.volumetricLightPostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n\r\n        // Smooth\r\n        this._createBlurPostProcesses(scene, ratio / 4, 0, \"volumetricLightBlurScale\");\r\n\r\n        // Merge\r\n        this.volumetricLightMergePostProces = new PostProcess(\r\n            \"HDRVLSMerge\",\r\n            \"standard\",\r\n            [],\r\n            [\"originalSampler\"],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define VLSMERGE\"\r\n        );\r\n\r\n        this.volumetricLightMergePostProces.onApply = (effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"originalSampler\", this._bloomEnabled ? this.textureAdderFinalPostProcess : this.originalPostProcess);\r\n\r\n            this._currentDepthOfFieldSource = this.volumetricLightFinalPostProcess;\r\n        };\r\n\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRVLSMerge\",\r\n                () => {\r\n                    return this.volumetricLightMergePostProces;\r\n                },\r\n                true\r\n            )\r\n        );\r\n    }\r\n\r\n    // Create luminance\r\n    private _createLuminancePostProcesses(scene: Scene, textureType: number): void {\r\n        // Create luminance\r\n        let size = Math.pow(3, StandardRenderingPipeline.LuminanceSteps);\r\n        this.luminancePostProcess = new PostProcess(\r\n            \"HDRLuminance\",\r\n            \"standard\",\r\n            [\"lumOffsets\"],\r\n            [],\r\n            { width: size, height: size },\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define LUMINANCE\",\r\n            textureType\r\n        );\r\n\r\n        const offsets: number[] = [];\r\n        this.luminancePostProcess.onApply = (effect: Effect) => {\r\n            const sU = 1.0 / (<PostProcess>this.luminancePostProcess).width;\r\n            const sV = 1.0 / (<PostProcess>this.luminancePostProcess).height;\r\n\r\n            offsets[0] = -0.5 * sU;\r\n            offsets[1] = 0.5 * sV;\r\n            offsets[2] = 0.5 * sU;\r\n            offsets[3] = 0.5 * sV;\r\n            offsets[4] = -0.5 * sU;\r\n            offsets[5] = -0.5 * sV;\r\n            offsets[6] = 0.5 * sU;\r\n            offsets[7] = -0.5 * sV;\r\n\r\n            effect.setArray2(\"lumOffsets\", offsets);\r\n        };\r\n\r\n        // Add to pipeline\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRLuminance\",\r\n                () => {\r\n                    return this.luminancePostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n\r\n        // Create down sample luminance\r\n        for (let i = StandardRenderingPipeline.LuminanceSteps - 1; i >= 0; i--) {\r\n            size = Math.pow(3, i);\r\n\r\n            let defines = \"#define LUMINANCE_DOWN_SAMPLE\\n\";\r\n            if (i === 0) {\r\n                defines += \"#define FINAL_DOWN_SAMPLER\";\r\n            }\r\n\r\n            const postProcess = new PostProcess(\r\n                \"HDRLuminanceDownSample\" + i,\r\n                \"standard\",\r\n                [\"dsOffsets\", \"halfDestPixelSize\"],\r\n                [],\r\n                { width: size, height: size },\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                defines,\r\n                textureType\r\n            );\r\n            this.luminanceDownSamplePostProcesses.push(postProcess);\r\n        }\r\n\r\n        // Create callbacks and add effects\r\n        let lastLuminance: Nullable<PostProcess> = this.luminancePostProcess;\r\n\r\n        this.luminanceDownSamplePostProcesses.forEach((pp, index) => {\r\n            const downSampleOffsets = new Array<number>(18);\r\n\r\n            pp.onApply = (effect: Effect) => {\r\n                if (!lastLuminance) {\r\n                    return;\r\n                }\r\n\r\n                let id = 0;\r\n                for (let x = -1; x < 2; x++) {\r\n                    for (let y = -1; y < 2; y++) {\r\n                        downSampleOffsets[id] = x / lastLuminance.width;\r\n                        downSampleOffsets[id + 1] = y / lastLuminance.height;\r\n                        id += 2;\r\n                    }\r\n                }\r\n\r\n                effect.setArray2(\"dsOffsets\", downSampleOffsets);\r\n                effect.setFloat(\"halfDestPixelSize\", 0.5 / lastLuminance.width);\r\n\r\n                if (index === this.luminanceDownSamplePostProcesses.length - 1) {\r\n                    lastLuminance = this.luminancePostProcess;\r\n                } else {\r\n                    lastLuminance = pp;\r\n                }\r\n            };\r\n\r\n            if (index === this.luminanceDownSamplePostProcesses.length - 1) {\r\n                pp.onAfterRender = () => {\r\n                    const pixel = scene.getEngine().readPixels(0, 0, 1, 1);\r\n                    const bit_shift = new Vector4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\r\n                    pixel.then((pixel) => {\r\n                        const data = new Uint8Array(pixel.buffer);\r\n                        this._hdrCurrentLuminance = (data[0] * bit_shift.x + data[1] * bit_shift.y + data[2] * bit_shift.z + data[3] * bit_shift.w) / 100.0;\r\n                    });\r\n                };\r\n            }\r\n\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    scene.getEngine(),\r\n                    \"HDRLuminanceDownSample\" + index,\r\n                    () => {\r\n                        return pp;\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n        });\r\n    }\r\n\r\n    // Create HDR post-process\r\n    private _createHdrPostProcess(scene: Scene, ratio: number): void {\r\n        const defines = [\"#define HDR\"];\r\n        if (this._hdrAutoExposure) {\r\n            defines.push(\"#define AUTO_EXPOSURE\");\r\n        }\r\n        this.hdrPostProcess = new PostProcess(\r\n            \"HDR\",\r\n            \"standard\",\r\n            [\"averageLuminance\"],\r\n            [\"textureAdderSampler\"],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            defines.join(\"\\n\"),\r\n            Constants.TEXTURETYPE_UNSIGNED_INT\r\n        );\r\n\r\n        let outputLiminance = 1;\r\n        let time = 0;\r\n        let lastTime = 0;\r\n\r\n        this.hdrPostProcess.onApply = (effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"textureAdderSampler\", this._currentDepthOfFieldSource);\r\n\r\n            time += scene.getEngine().getDeltaTime();\r\n\r\n            if (outputLiminance < 0) {\r\n                outputLiminance = this._hdrCurrentLuminance;\r\n            } else {\r\n                const dt = (lastTime - time) / 1000.0;\r\n\r\n                if (this._hdrCurrentLuminance < outputLiminance + this.hdrDecreaseRate * dt) {\r\n                    outputLiminance += this.hdrDecreaseRate * dt;\r\n                } else if (this._hdrCurrentLuminance > outputLiminance - this.hdrIncreaseRate * dt) {\r\n                    outputLiminance -= this.hdrIncreaseRate * dt;\r\n                } else {\r\n                    outputLiminance = this._hdrCurrentLuminance;\r\n                }\r\n            }\r\n\r\n            if (this.hdrAutoExposure) {\r\n                this._currentExposure = this._fixedExposure / outputLiminance;\r\n            } else {\r\n                outputLiminance = Scalar.Clamp(outputLiminance, this.hdrMinimumLuminance, 1e20);\r\n                effect.setFloat(\"averageLuminance\", outputLiminance);\r\n            }\r\n\r\n            lastTime = time;\r\n\r\n            this._currentDepthOfFieldSource = this.hdrFinalPostProcess;\r\n        };\r\n\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDR\",\r\n                () => {\r\n                    return this.hdrPostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n    }\r\n\r\n    // Create lens flare post-process\r\n    private _createLensFlarePostProcess(scene: Scene, ratio: number): void {\r\n        this.lensFlarePostProcess = new PostProcess(\r\n            \"HDRLensFlare\",\r\n            \"standard\",\r\n            [\"strength\", \"ghostDispersal\", \"haloWidth\", \"resolution\", \"distortionStrength\"],\r\n            [\"lensColorSampler\"],\r\n            ratio / 2,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define LENS_FLARE\",\r\n            Constants.TEXTURETYPE_UNSIGNED_INT\r\n        );\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRLensFlare\",\r\n                () => {\r\n                    return this.lensFlarePostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n\r\n        this._createBlurPostProcesses(scene, ratio / 4, 2, \"lensFlareBlurWidth\");\r\n\r\n        this.lensFlareComposePostProcess = new PostProcess(\r\n            \"HDRLensFlareCompose\",\r\n            \"standard\",\r\n            [\"lensStarMatrix\"],\r\n            [\"otherSampler\", \"lensDirtSampler\", \"lensStarSampler\"],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define LENS_FLARE_COMPOSE\",\r\n            Constants.TEXTURETYPE_UNSIGNED_INT\r\n        );\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRLensFlareCompose\",\r\n                () => {\r\n                    return this.lensFlareComposePostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n\r\n        const resolution = new Vector2(0, 0);\r\n\r\n        // Lens flare\r\n        this.lensFlarePostProcess.externalTextureSamplerBinding = true;\r\n        this.lensFlarePostProcess.onApply = (effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"textureSampler\", this._bloomEnabled ? this.blurHPostProcesses[0] : this.originalPostProcess);\r\n            effect.setTexture(\"lensColorSampler\", this.lensColorTexture);\r\n            effect.setFloat(\"strength\", this.lensFlareStrength);\r\n            effect.setFloat(\"ghostDispersal\", this.lensFlareGhostDispersal);\r\n            effect.setFloat(\"haloWidth\", this.lensFlareHaloWidth);\r\n\r\n            // Shift\r\n            resolution.x = (<PostProcess>this.lensFlarePostProcess).width;\r\n            resolution.y = (<PostProcess>this.lensFlarePostProcess).height;\r\n            effect.setVector2(\"resolution\", resolution);\r\n\r\n            effect.setFloat(\"distortionStrength\", this.lensFlareDistortionStrength);\r\n        };\r\n\r\n        // Compose\r\n        const scaleBias1 = Matrix.FromValues(2.0, 0.0, -1.0, 0.0, 0.0, 2.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\r\n\r\n        const scaleBias2 = Matrix.FromValues(0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\r\n\r\n        this.lensFlareComposePostProcess.onApply = (effect: Effect) => {\r\n            if (!this._scene.activeCamera) {\r\n                return;\r\n            }\r\n\r\n            effect.setTextureFromPostProcess(\"otherSampler\", this.lensFlarePostProcess);\r\n            effect.setTexture(\"lensDirtSampler\", this.lensFlareDirtTexture);\r\n            effect.setTexture(\"lensStarSampler\", this.lensStarTexture);\r\n\r\n            // Lens start rotation matrix\r\n            const camerax = <Vector4>this._scene.activeCamera.getViewMatrix().getRow(0);\r\n            const cameraz = <Vector4>this._scene.activeCamera.getViewMatrix().getRow(2);\r\n            let camRot = Vector3.Dot(camerax.toVector3(), new Vector3(1.0, 0.0, 0.0)) + Vector3.Dot(cameraz.toVector3(), new Vector3(0.0, 0.0, 1.0));\r\n            camRot *= 4.0;\r\n\r\n            const starRotation = Matrix.FromValues(\r\n                Math.cos(camRot) * 0.5,\r\n                -Math.sin(camRot),\r\n                0.0,\r\n                0.0,\r\n                Math.sin(camRot),\r\n                Math.cos(camRot) * 0.5,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                1.0,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                1.0\r\n            );\r\n\r\n            const lensStarMatrix = scaleBias2.multiply(starRotation).multiply(scaleBias1);\r\n\r\n            effect.setMatrix(\"lensStarMatrix\", lensStarMatrix);\r\n\r\n            this._currentDepthOfFieldSource = this.lensFlareFinalPostProcess;\r\n        };\r\n    }\r\n\r\n    // Create depth-of-field post-process\r\n    private _createDepthOfFieldPostProcess(scene: Scene, ratio: number): void {\r\n        this.depthOfFieldPostProcess = new PostProcess(\r\n            \"HDRDepthOfField\",\r\n            \"standard\",\r\n            [\"distance\"],\r\n            [\"otherSampler\", \"depthSampler\"],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define DEPTH_OF_FIELD\",\r\n            Constants.TEXTURETYPE_UNSIGNED_INT\r\n        );\r\n        this.depthOfFieldPostProcess.onApply = (effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"otherSampler\", this._currentDepthOfFieldSource);\r\n            effect.setTexture(\"depthSampler\", this._getDepthTexture());\r\n\r\n            effect.setFloat(\"distance\", this.depthOfFieldDistance);\r\n        };\r\n\r\n        // Add to pipeline\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRDepthOfField\",\r\n                () => {\r\n                    return this.depthOfFieldPostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n    }\r\n\r\n    // Create motion blur post-process\r\n    private _createMotionBlurPostProcess(scene: Scene, ratio: number): void {\r\n        if (this._isObjectBasedMotionBlur) {\r\n            const mb = new MotionBlurPostProcess(\"HDRMotionBlur\", scene, ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, Constants.TEXTURETYPE_UNSIGNED_INT);\r\n            mb.motionStrength = this.motionStrength;\r\n            mb.motionBlurSamples = this.motionBlurSamples;\r\n            this.motionBlurPostProcess = mb;\r\n        } else {\r\n            this.motionBlurPostProcess = new PostProcess(\r\n                \"HDRMotionBlur\",\r\n                \"standard\",\r\n                [\"inverseViewProjection\", \"prevViewProjection\", \"screenSize\", \"motionScale\", \"motionStrength\"],\r\n                [\"depthSampler\"],\r\n                ratio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                \"#define MOTION_BLUR\\n#define MAX_MOTION_SAMPLES \" + this.motionBlurSamples.toFixed(1),\r\n                Constants.TEXTURETYPE_UNSIGNED_INT\r\n            );\r\n\r\n            let motionScale: number = 0;\r\n            let prevViewProjection = Matrix.Identity();\r\n            const invViewProjection = Matrix.Identity();\r\n            let viewProjection = Matrix.Identity();\r\n            const screenSize = Vector2.Zero();\r\n\r\n            this.motionBlurPostProcess.onApply = (effect: Effect) => {\r\n                viewProjection = scene.getProjectionMatrix().multiply(scene.getViewMatrix());\r\n\r\n                viewProjection.invertToRef(invViewProjection);\r\n                effect.setMatrix(\"inverseViewProjection\", invViewProjection);\r\n\r\n                effect.setMatrix(\"prevViewProjection\", prevViewProjection);\r\n                prevViewProjection = viewProjection;\r\n\r\n                screenSize.x = (<PostProcess>this.motionBlurPostProcess).width;\r\n                screenSize.y = (<PostProcess>this.motionBlurPostProcess).height;\r\n                effect.setVector2(\"screenSize\", screenSize);\r\n\r\n                motionScale = scene.getEngine().getFps() / 60.0;\r\n                effect.setFloat(\"motionScale\", motionScale);\r\n                effect.setFloat(\"motionStrength\", this.motionStrength);\r\n\r\n                effect.setTexture(\"depthSampler\", this._getDepthTexture());\r\n            };\r\n        }\r\n\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRMotionBlur\",\r\n                () => {\r\n                    return this.motionBlurPostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n    }\r\n\r\n    private _getDepthTexture(): Texture {\r\n        if (this._scene.getEngine().getCaps().drawBuffersExtension) {\r\n            const renderer = <GeometryBufferRenderer>this._scene.enableGeometryBufferRenderer();\r\n            return renderer.getGBuffer().textures[0];\r\n        }\r\n\r\n        return this._scene.enableDepthRenderer().getDepthMap();\r\n    }\r\n\r\n    private _disposePostProcesses(): void {\r\n        for (let i = 0; i < this._cameras.length; i++) {\r\n            const camera = this._cameras[i];\r\n\r\n            if (this.originalPostProcess) {\r\n                this.originalPostProcess.dispose(camera);\r\n            }\r\n            if (this.screenSpaceReflectionPostProcess) {\r\n                this.screenSpaceReflectionPostProcess.dispose(camera);\r\n            }\r\n\r\n            if (this.downSampleX4PostProcess) {\r\n                this.downSampleX4PostProcess.dispose(camera);\r\n            }\r\n            if (this.brightPassPostProcess) {\r\n                this.brightPassPostProcess.dispose(camera);\r\n            }\r\n            if (this.textureAdderPostProcess) {\r\n                this.textureAdderPostProcess.dispose(camera);\r\n            }\r\n\r\n            if (this.volumetricLightPostProcess) {\r\n                this.volumetricLightPostProcess.dispose(camera);\r\n            }\r\n            if (this.volumetricLightSmoothXPostProcess) {\r\n                this.volumetricLightSmoothXPostProcess.dispose(camera);\r\n            }\r\n            if (this.volumetricLightSmoothYPostProcess) {\r\n                this.volumetricLightSmoothYPostProcess.dispose(camera);\r\n            }\r\n            if (this.volumetricLightMergePostProces) {\r\n                this.volumetricLightMergePostProces.dispose(camera);\r\n            }\r\n            if (this.volumetricLightFinalPostProcess) {\r\n                this.volumetricLightFinalPostProcess.dispose(camera);\r\n            }\r\n\r\n            if (this.lensFlarePostProcess) {\r\n                this.lensFlarePostProcess.dispose(camera);\r\n            }\r\n            if (this.lensFlareComposePostProcess) {\r\n                this.lensFlareComposePostProcess.dispose(camera);\r\n            }\r\n\r\n            for (let j = 0; j < this.luminanceDownSamplePostProcesses.length; j++) {\r\n                this.luminanceDownSamplePostProcesses[j].dispose(camera);\r\n            }\r\n\r\n            if (this.luminancePostProcess) {\r\n                this.luminancePostProcess.dispose(camera);\r\n            }\r\n            if (this.hdrPostProcess) {\r\n                this.hdrPostProcess.dispose(camera);\r\n            }\r\n            if (this.hdrFinalPostProcess) {\r\n                this.hdrFinalPostProcess.dispose(camera);\r\n            }\r\n\r\n            if (this.depthOfFieldPostProcess) {\r\n                this.depthOfFieldPostProcess.dispose(camera);\r\n            }\r\n\r\n            if (this.motionBlurPostProcess) {\r\n                this.motionBlurPostProcess.dispose(camera);\r\n            }\r\n\r\n            if (this.fxaaPostProcess) {\r\n                this.fxaaPostProcess.dispose(camera);\r\n            }\r\n\r\n            for (let j = 0; j < this.blurHPostProcesses.length; j++) {\r\n                this.blurHPostProcesses[j].dispose(camera);\r\n            }\r\n\r\n            for (let j = 0; j < this.blurVPostProcesses.length; j++) {\r\n                this.blurVPostProcesses[j].dispose(camera);\r\n            }\r\n        }\r\n\r\n        this.originalPostProcess = null;\r\n        this.downSampleX4PostProcess = null;\r\n        this.brightPassPostProcess = null;\r\n        this.textureAdderPostProcess = null;\r\n        this.textureAdderFinalPostProcess = null;\r\n        this.volumetricLightPostProcess = null;\r\n        this.volumetricLightSmoothXPostProcess = null;\r\n        this.volumetricLightSmoothYPostProcess = null;\r\n        this.volumetricLightMergePostProces = null;\r\n        this.volumetricLightFinalPostProcess = null;\r\n        this.lensFlarePostProcess = null;\r\n        this.lensFlareComposePostProcess = null;\r\n        this.luminancePostProcess = null;\r\n        this.hdrPostProcess = null;\r\n        this.hdrFinalPostProcess = null;\r\n        this.depthOfFieldPostProcess = null;\r\n        this.motionBlurPostProcess = null;\r\n        this.fxaaPostProcess = null;\r\n        this.screenSpaceReflectionPostProcess = null;\r\n\r\n        this.luminanceDownSamplePostProcesses = [];\r\n        this.blurHPostProcesses = [];\r\n        this.blurVPostProcesses = [];\r\n    }\r\n\r\n    /**\r\n     * Dispose of the pipeline and stop all post processes\r\n     */\r\n    public dispose(): void {\r\n        this._disposePostProcesses();\r\n\r\n        this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Serialize the rendering pipeline (Used when exporting)\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        if (this.sourceLight) {\r\n            serializationObject.sourceLightId = this.sourceLight.id;\r\n        }\r\n\r\n        if (this.screenSpaceReflectionPostProcess) {\r\n            serializationObject.screenSpaceReflectionPostProcess = SerializationHelper.Serialize(this.screenSpaceReflectionPostProcess);\r\n        }\r\n\r\n        serializationObject.customType = \"StandardRenderingPipeline\";\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse the serialized pipeline\r\n     * @param source Source pipeline.\r\n     * @param scene The scene to load the pipeline to.\r\n     * @param rootUrl The URL of the serialized pipeline.\r\n     * @returns An instantiated pipeline from the serialized object.\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): StandardRenderingPipeline {\r\n        const p = SerializationHelper.Parse(() => new StandardRenderingPipeline(source._name, scene, source._ratio), source, scene, rootUrl);\r\n\r\n        if (source.sourceLightId) {\r\n            p.sourceLight = <SpotLight | DirectionalLight>scene.getLightById(source.sourceLightId);\r\n        }\r\n\r\n        if (source.screenSpaceReflectionPostProcess) {\r\n            SerializationHelper.Parse(() => p.screenSpaceReflectionPostProcess, source.screenSpaceReflectionPostProcess, scene, rootUrl);\r\n        }\r\n\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Luminance steps\r\n     */\r\n    public static LuminanceSteps: number = 6;\r\n}\r\n\r\nRegisterClass(\"BABYLON.StandardRenderingPipeline\", StandardRenderingPipeline);\r\n"]},"metadata":{},"sourceType":"module"}