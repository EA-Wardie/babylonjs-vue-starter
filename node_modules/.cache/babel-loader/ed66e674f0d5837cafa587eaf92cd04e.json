{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/web.timers.js\";\nimport \"core-js/modules/es.date.now.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport { PointerInfoPre, PointerInfo, PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { AbstractActionManager } from \"../Actions/abstractActionManager.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { Vector2, Matrix } from \"../Maths/math.vector.js\";\nimport { ActionEvent } from \"../Actions/actionEvent.js\";\nimport { KeyboardEventTypes, KeyboardInfoPre, KeyboardInfo } from \"../Events/keyboardEvents.js\";\nimport { DeviceType, PointerInput } from \"../DeviceInput/InputDevices/deviceEnums.js\";\nimport { DeviceSourceManager } from \"../DeviceInput/InputDevices/deviceSourceManager.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n/** @hidden */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\nvar _ClickInfo =\n/** @class */\nfunction () {\n  function _ClickInfo() {\n    this._singleClick = false;\n    this._doubleClick = false;\n    this._hasSwiped = false;\n    this._ignore = false;\n  }\n\n  Object.defineProperty(_ClickInfo.prototype, \"singleClick\", {\n    get: function get() {\n      return this._singleClick;\n    },\n    set: function set(b) {\n      this._singleClick = b;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(_ClickInfo.prototype, \"doubleClick\", {\n    get: function get() {\n      return this._doubleClick;\n    },\n    set: function set(b) {\n      this._doubleClick = b;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(_ClickInfo.prototype, \"hasSwiped\", {\n    get: function get() {\n      return this._hasSwiped;\n    },\n    set: function set(b) {\n      this._hasSwiped = b;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(_ClickInfo.prototype, \"ignore\", {\n    get: function get() {\n      return this._ignore;\n    },\n    set: function set(b) {\n      this._ignore = b;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return _ClickInfo;\n}();\n/**\n * Class used to manage all inputs for the scene.\n */\n\n\nvar InputManager =\n/** @class */\nfunction () {\n  /**\n   * Creates a new InputManager\n   * @param scene - defines the hosting scene\n   */\n  function InputManager(scene) {\n    /** This is a defensive check to not allow control attachment prior to an already active one. If already attached, previous control is unattached before attaching the new one. */\n    this._alreadyAttached = false;\n    this._meshPickProceed = false;\n    this._currentPickResult = null;\n    this._previousPickResult = null;\n    this._totalPointersPressed = 0;\n    this._doubleClickOccured = false;\n    this._pointerX = 0;\n    this._pointerY = 0;\n    this._startingPointerPosition = new Vector2(0, 0);\n    this._previousStartingPointerPosition = new Vector2(0, 0);\n    this._startingPointerTime = 0;\n    this._previousStartingPointerTime = 0;\n    this._pointerCaptures = {};\n    this._meshUnderPointerId = {};\n    this._deviceSourceManager = null;\n    this._scene = scene || EngineStore.LastCreatedScene;\n\n    if (!this._scene) {\n      return;\n    }\n  }\n\n  Object.defineProperty(InputManager.prototype, \"meshUnderPointer\", {\n    /**\n     * Gets the mesh that is currently under the pointer\n     * @returns Mesh that the pointer is pointer is hovering over\n     */\n    get: function get() {\n      return this._pointerOverMesh;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * When using more than one pointer (for example in XR) you can get the mesh under the specific pointer\n   * @param pointerId - the pointer id to use\n   * @returns The mesh under this pointer id or null if not found\n   */\n\n  InputManager.prototype.getMeshUnderPointerByPointerId = function (pointerId) {\n    return this._meshUnderPointerId[pointerId] || null;\n  };\n\n  Object.defineProperty(InputManager.prototype, \"unTranslatedPointer\", {\n    /**\n     * Gets the pointer coordinates in 2D without any translation (ie. straight out of the pointer event)\n     * @returns Vector with X/Y values directly from pointer event\n     */\n    get: function get() {\n      return new Vector2(this._unTranslatedPointerX, this._unTranslatedPointerY);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InputManager.prototype, \"pointerX\", {\n    /**\n     * Gets or sets the current on-screen X position of the pointer\n     * @returns Translated X with respect to screen\n     */\n    get: function get() {\n      return this._pointerX;\n    },\n    set: function set(value) {\n      this._pointerX = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InputManager.prototype, \"pointerY\", {\n    /**\n     * Gets or sets the current on-screen Y position of the pointer\n     * @returns Translated Y with respect to screen\n     */\n    get: function get() {\n      return this._pointerY;\n    },\n    set: function set(value) {\n      this._pointerY = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  InputManager.prototype._updatePointerPosition = function (evt) {\n    var canvasRect = this._scene.getEngine().getInputElementClientRect();\n\n    if (!canvasRect) {\n      return;\n    }\n\n    this._pointerX = evt.clientX - canvasRect.left;\n    this._pointerY = evt.clientY - canvasRect.top;\n    this._unTranslatedPointerX = this._pointerX;\n    this._unTranslatedPointerY = this._pointerY;\n  };\n\n  InputManager.prototype._processPointerMove = function (pickResult, evt) {\n    var scene = this._scene;\n    var engine = scene.getEngine();\n    var canvas = engine.getInputElement();\n\n    if (canvas) {\n      canvas.tabIndex = engine.canvasTabIndex; // Restore pointer\n\n      if (!scene.doNotHandleCursors) {\n        canvas.style.cursor = scene.defaultCursor;\n      }\n    }\n\n    var isMeshPicked = pickResult && pickResult.hit && pickResult.pickedMesh ? true : false;\n\n    if (isMeshPicked) {\n      scene.setPointerOverMesh(pickResult.pickedMesh, evt.pointerId, pickResult);\n\n      if (this._pointerOverMesh && this._pointerOverMesh.actionManager && this._pointerOverMesh.actionManager.hasPointerTriggers) {\n        if (!scene.doNotHandleCursors && canvas) {\n          if (this._pointerOverMesh.actionManager.hoverCursor) {\n            canvas.style.cursor = this._pointerOverMesh.actionManager.hoverCursor;\n          } else {\n            canvas.style.cursor = scene.hoverCursor;\n          }\n        }\n      }\n    } else {\n      scene.setPointerOverMesh(null, evt.pointerId, pickResult);\n    }\n\n    for (var _i = 0, _a = scene._pointerMoveStage; _i < _a.length; _i++) {\n      var step = _a[_i];\n      pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, isMeshPicked, canvas);\n    }\n\n    if (pickResult) {\n      var type = evt.type === \"wheel\" || evt.type === \"mousewheel\" || evt.type === \"DOMMouseScroll\" ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE;\n\n      if (scene.onPointerMove) {\n        scene.onPointerMove(evt, pickResult, type);\n      }\n\n      if (scene.onPointerObservable.hasObservers()) {\n        var pi = new PointerInfo(type, evt, pickResult);\n\n        this._setRayOnPointerInfo(pi);\n\n        scene.onPointerObservable.notifyObservers(pi, type);\n      }\n    }\n  }; // Pointers handling\n\n\n  InputManager.prototype._setRayOnPointerInfo = function (pointerInfo) {\n    var scene = this._scene;\n\n    if (pointerInfo.pickInfo && !pointerInfo.pickInfo._pickingUnavailable) {\n      if (!pointerInfo.pickInfo.ray) {\n        pointerInfo.pickInfo.ray = scene.createPickingRay(pointerInfo.event.offsetX, pointerInfo.event.offsetY, Matrix.Identity(), scene.activeCamera);\n      }\n    }\n  };\n\n  InputManager.prototype._checkPrePointerObservable = function (pickResult, evt, type) {\n    var scene = this._scene;\n    var pi = new PointerInfoPre(type, evt, this._unTranslatedPointerX, this._unTranslatedPointerY);\n\n    if (pickResult) {\n      pi.ray = pickResult.ray;\n\n      if (pickResult.originMesh) {\n        pi.nearInteractionPickingInfo = pickResult;\n      }\n    }\n\n    scene.onPrePointerObservable.notifyObservers(pi, type);\n\n    if (pi.skipOnPointerObservable) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /**\n   * Use this method to simulate a pointer move on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult - pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   */\n\n\n  InputManager.prototype.simulatePointerMove = function (pickResult, pointerEventInit) {\n    var evt = new PointerEvent(\"pointermove\", pointerEventInit);\n    evt.inputIndex = PointerInput.Move;\n\n    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERMOVE)) {\n      return;\n    }\n\n    this._processPointerMove(pickResult, evt);\n  };\n  /**\n   * Use this method to simulate a pointer down on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult - pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   */\n\n\n  InputManager.prototype.simulatePointerDown = function (pickResult, pointerEventInit) {\n    var evt = new PointerEvent(\"pointerdown\", pointerEventInit);\n    evt.inputIndex = evt.button + 2;\n\n    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERDOWN)) {\n      return;\n    }\n\n    this._processPointerDown(pickResult, evt);\n  };\n\n  InputManager.prototype._processPointerDown = function (pickResult, evt) {\n    var _this = this;\n\n    var scene = this._scene;\n\n    if (pickResult && pickResult.hit && pickResult.pickedMesh) {\n      this._pickedDownMesh = pickResult.pickedMesh;\n\n      var actionManager_1 = pickResult.pickedMesh._getActionManagerForTrigger();\n\n      if (actionManager_1) {\n        if (actionManager_1.hasPickTriggers) {\n          actionManager_1.processTrigger(5, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n\n          switch (evt.button) {\n            case 0:\n              actionManager_1.processTrigger(2, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n              break;\n\n            case 1:\n              actionManager_1.processTrigger(4, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n              break;\n\n            case 2:\n              actionManager_1.processTrigger(3, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n              break;\n          }\n        }\n\n        if (actionManager_1.hasSpecificTrigger(8)) {\n          window.setTimeout(function () {\n            var pickResult = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, function (mesh) {\n              return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.actionManager && mesh.actionManager.hasSpecificTrigger(8) && mesh === _this._pickedDownMesh;\n            }, false, scene.cameraToUseForPointers);\n\n            if (pickResult && pickResult.hit && pickResult.pickedMesh && actionManager_1) {\n              if (_this._totalPointersPressed !== 0 && Date.now() - _this._startingPointerTime > InputManager.LongPressDelay && !_this._isPointerSwiping()) {\n                _this._startingPointerTime = 0;\n                actionManager_1.processTrigger(8, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n              }\n            }\n          }, InputManager.LongPressDelay);\n        }\n      }\n    } else {\n      for (var _i = 0, _a = scene._pointerDownStage; _i < _a.length; _i++) {\n        var step = _a[_i];\n        pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt);\n      }\n    }\n\n    if (pickResult) {\n      var type = PointerEventTypes.POINTERDOWN;\n\n      if (scene.onPointerDown) {\n        scene.onPointerDown(evt, pickResult, type);\n      }\n\n      if (scene.onPointerObservable.hasObservers()) {\n        var pi = new PointerInfo(type, evt, pickResult);\n\n        this._setRayOnPointerInfo(pi);\n\n        scene.onPointerObservable.notifyObservers(pi, type);\n      }\n    }\n  };\n  /**\n   * @hidden\n   * @returns Boolean if delta for pointer exceeds drag movement threshold\n   */\n\n\n  InputManager.prototype._isPointerSwiping = function () {\n    return Math.abs(this._startingPointerPosition.x - this._pointerX) > InputManager.DragMovementThreshold || Math.abs(this._startingPointerPosition.y - this._pointerY) > InputManager.DragMovementThreshold;\n  };\n  /**\n   * Use this method to simulate a pointer up on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult - pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   * @param doubleTap - indicates that the pointer up event should be considered as part of a double click (false by default)\n   */\n\n\n  InputManager.prototype.simulatePointerUp = function (pickResult, pointerEventInit, doubleTap) {\n    var evt = new PointerEvent(\"pointerup\", pointerEventInit);\n    evt.inputIndex = PointerInput.Move;\n    var clickInfo = new _ClickInfo();\n\n    if (doubleTap) {\n      clickInfo.doubleClick = true;\n    } else {\n      clickInfo.singleClick = true;\n    }\n\n    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERUP)) {\n      return;\n    }\n\n    this._processPointerUp(pickResult, evt, clickInfo);\n  };\n\n  InputManager.prototype._processPointerUp = function (pickResult, evt, clickInfo) {\n    var scene = this._scene;\n\n    if (pickResult && pickResult && pickResult.pickedMesh) {\n      this._pickedUpMesh = pickResult.pickedMesh;\n\n      if (this._pickedDownMesh === this._pickedUpMesh) {\n        if (scene.onPointerPick) {\n          scene.onPointerPick(evt, pickResult);\n        }\n\n        if (clickInfo.singleClick && !clickInfo.ignore && scene.onPointerObservable.hasObservers()) {\n          var type_1 = PointerEventTypes.POINTERPICK;\n          var pi = new PointerInfo(type_1, evt, pickResult);\n\n          this._setRayOnPointerInfo(pi);\n\n          scene.onPointerObservable.notifyObservers(pi, type_1);\n        }\n      }\n\n      var actionManager = pickResult.pickedMesh._getActionManagerForTrigger();\n\n      if (actionManager && !clickInfo.ignore) {\n        actionManager.processTrigger(7, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\n\n        if (!clickInfo.hasSwiped && clickInfo.singleClick) {\n          actionManager.processTrigger(1, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\n        }\n\n        var doubleClickActionManager = pickResult.pickedMesh._getActionManagerForTrigger(6);\n\n        if (clickInfo.doubleClick && doubleClickActionManager) {\n          doubleClickActionManager.processTrigger(6, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\n        }\n      }\n    } else {\n      if (!clickInfo.ignore) {\n        for (var _i = 0, _a = scene._pointerUpStage; _i < _a.length; _i++) {\n          var step = _a[_i];\n          pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt);\n        }\n      }\n    }\n\n    if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {\n      var pickedDownActionManager = this._pickedDownMesh._getActionManagerForTrigger(16);\n\n      if (pickedDownActionManager) {\n        pickedDownActionManager.processTrigger(16, ActionEvent.CreateNew(this._pickedDownMesh, evt));\n      }\n    }\n\n    var type = 0;\n\n    if (scene.onPointerObservable.hasObservers()) {\n      if (!clickInfo.ignore && !clickInfo.hasSwiped) {\n        if (clickInfo.singleClick && scene.onPointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {\n          type = PointerEventTypes.POINTERTAP;\n        } else if (clickInfo.doubleClick && scene.onPointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {\n          type = PointerEventTypes.POINTERDOUBLETAP;\n        }\n\n        if (type) {\n          var pi = new PointerInfo(type, evt, pickResult);\n\n          this._setRayOnPointerInfo(pi);\n\n          scene.onPointerObservable.notifyObservers(pi, type);\n        }\n      }\n\n      if (!clickInfo.ignore) {\n        type = PointerEventTypes.POINTERUP;\n        var pi = new PointerInfo(type, evt, pickResult);\n\n        this._setRayOnPointerInfo(pi);\n\n        scene.onPointerObservable.notifyObservers(pi, type);\n      }\n    }\n\n    if (scene.onPointerUp && !clickInfo.ignore) {\n      scene.onPointerUp(evt, pickResult, type);\n    }\n  };\n  /**\n   * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\n   * @param pointerId - defines the pointer id to use in a multi-touch scenario (0 by default)\n   * @returns true if the pointer was captured\n   */\n\n\n  InputManager.prototype.isPointerCaptured = function (pointerId) {\n    if (pointerId === void 0) {\n      pointerId = 0;\n    }\n\n    return this._pointerCaptures[pointerId];\n  };\n  /**\n   * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\n   * @param attachUp - defines if you want to attach events to pointerup\n   * @param attachDown - defines if you want to attach events to pointerdown\n   * @param attachMove - defines if you want to attach events to pointermove\n   * @param elementToAttachTo - defines the target DOM element to attach to (will use the canvas by default)\n   */\n\n\n  InputManager.prototype.attachControl = function (attachUp, attachDown, attachMove, elementToAttachTo) {\n    var _this = this;\n\n    if (attachUp === void 0) {\n      attachUp = true;\n    }\n\n    if (attachDown === void 0) {\n      attachDown = true;\n    }\n\n    if (attachMove === void 0) {\n      attachMove = true;\n    }\n\n    if (elementToAttachTo === void 0) {\n      elementToAttachTo = null;\n    }\n\n    var scene = this._scene;\n    var engine = scene.getEngine();\n\n    if (!elementToAttachTo) {\n      elementToAttachTo = engine.getInputElement();\n    }\n\n    if (this._alreadyAttached) {\n      this.detachControl();\n    }\n\n    if (elementToAttachTo) {\n      this._alreadyAttachedTo = elementToAttachTo;\n    }\n\n    this._deviceSourceManager = new DeviceSourceManager(engine);\n\n    this._initActionManager = function (act) {\n      if (!_this._meshPickProceed) {\n        var pickResult = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, scene.pointerDownPredicate, false, scene.cameraToUseForPointers);\n        _this._currentPickResult = pickResult;\n\n        if (pickResult) {\n          act = pickResult.hit && pickResult.pickedMesh ? pickResult.pickedMesh._getActionManagerForTrigger() : null;\n        }\n\n        _this._meshPickProceed = true;\n      }\n\n      return act;\n    };\n\n    this._delayedSimpleClick = function (btn, clickInfo, cb) {\n      // double click delay is over and that no double click has been raised since, or the 2 consecutive keys pressed are different\n      if (Date.now() - _this._previousStartingPointerTime > InputManager.DoubleClickDelay && !_this._doubleClickOccured || btn !== _this._previousButtonPressed) {\n        _this._doubleClickOccured = false;\n        clickInfo.singleClick = true;\n        clickInfo.ignore = false;\n        cb(clickInfo, _this._currentPickResult);\n      }\n    };\n\n    this._initClickEvent = function (obs1, obs2, evt, cb) {\n      var clickInfo = new _ClickInfo();\n      _this._currentPickResult = null;\n      var act = null;\n      var checkPicking = obs1.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs2.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs1.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\n\n      if (!checkPicking && AbstractActionManager) {\n        act = _this._initActionManager(act, clickInfo);\n\n        if (act) {\n          checkPicking = act.hasPickTriggers;\n        }\n      }\n\n      var needToIgnoreNext = false;\n\n      if (checkPicking) {\n        var btn = evt.button;\n        clickInfo.hasSwiped = _this._isPointerSwiping();\n\n        if (!clickInfo.hasSwiped) {\n          var checkSingleClickImmediately = !InputManager.ExclusiveDoubleClickMode;\n\n          if (!checkSingleClickImmediately) {\n            checkSingleClickImmediately = !obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) && !obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\n\n            if (checkSingleClickImmediately && !AbstractActionManager.HasSpecificTrigger(6)) {\n              act = _this._initActionManager(act, clickInfo);\n\n              if (act) {\n                checkSingleClickImmediately = !act.hasSpecificTrigger(6);\n              }\n            }\n          }\n\n          if (checkSingleClickImmediately) {\n            // single click detected if double click delay is over or two different successive keys pressed without exclusive double click or no double click required\n            if (Date.now() - _this._previousStartingPointerTime > InputManager.DoubleClickDelay || btn !== _this._previousButtonPressed) {\n              clickInfo.singleClick = true;\n              cb(clickInfo, _this._currentPickResult);\n              needToIgnoreNext = true;\n            }\n          } // at least one double click is required to be check and exclusive double click is enabled\n          else {\n            // wait that no double click has been raised during the double click delay\n            _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;\n            _this._delayedSimpleClickTimeout = window.setTimeout(_this._delayedSimpleClick.bind(_this, btn, clickInfo, cb), InputManager.DoubleClickDelay);\n          }\n\n          var checkDoubleClick = obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\n\n          if (!checkDoubleClick && AbstractActionManager.HasSpecificTrigger(6)) {\n            act = _this._initActionManager(act, clickInfo);\n\n            if (act) {\n              checkDoubleClick = act.hasSpecificTrigger(6);\n            }\n          }\n\n          if (checkDoubleClick) {\n            // two successive keys pressed are equal, double click delay is not over and double click has not just occurred\n            if (btn === _this._previousButtonPressed && Date.now() - _this._previousStartingPointerTime < InputManager.DoubleClickDelay && !_this._doubleClickOccured) {\n              // pointer has not moved for 2 clicks, it's a double click\n              if (!clickInfo.hasSwiped && !_this._isPointerSwiping()) {\n                _this._previousStartingPointerTime = 0;\n                _this._doubleClickOccured = true;\n                clickInfo.doubleClick = true;\n                clickInfo.ignore = false;\n\n                if (InputManager.ExclusiveDoubleClickMode && _this._previousDelayedSimpleClickTimeout) {\n                  clearTimeout(_this._previousDelayedSimpleClickTimeout);\n                }\n\n                _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;\n                cb(clickInfo, _this._currentPickResult);\n              } // if the two successive clicks are too far, it's just two simple clicks\n              else {\n                _this._doubleClickOccured = false;\n                _this._previousStartingPointerTime = _this._startingPointerTime;\n                _this._previousStartingPointerPosition.x = _this._startingPointerPosition.x;\n                _this._previousStartingPointerPosition.y = _this._startingPointerPosition.y;\n                _this._previousButtonPressed = btn;\n\n                if (InputManager.ExclusiveDoubleClickMode) {\n                  if (_this._previousDelayedSimpleClickTimeout) {\n                    clearTimeout(_this._previousDelayedSimpleClickTimeout);\n                  }\n\n                  _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;\n                  cb(clickInfo, _this._previousPickResult);\n                } else {\n                  cb(clickInfo, _this._currentPickResult);\n                }\n              }\n\n              needToIgnoreNext = true;\n            } // just the first click of the double has been raised\n            else {\n              _this._doubleClickOccured = false;\n              _this._previousStartingPointerTime = _this._startingPointerTime;\n              _this._previousStartingPointerPosition.x = _this._startingPointerPosition.x;\n              _this._previousStartingPointerPosition.y = _this._startingPointerPosition.y;\n              _this._previousButtonPressed = btn;\n            }\n          }\n        }\n      }\n\n      if (!needToIgnoreNext) {\n        cb(clickInfo, _this._currentPickResult);\n      }\n    };\n\n    this._onPointerMove = function (evt) {\n      // preserve compatibility with Safari when pointerId is not present\n      if (evt.pointerId === undefined) {\n        evt.pointerId = 0;\n      }\n\n      _this._updatePointerPosition(evt); // PreObservable support\n\n\n      if (_this._checkPrePointerObservable(null, evt, evt.type === \"wheel\" || evt.type === \"mousewheel\" || evt.type === \"DOMMouseScroll\" ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE)) {\n        return;\n      }\n\n      if (!scene.cameraToUseForPointers && !scene.activeCamera) {\n        return;\n      }\n\n      if (scene.skipPointerMovePicking) {\n        _this._processPointerMove(new PickingInfo(), evt);\n\n        return;\n      }\n\n      if (!scene.pointerMovePredicate) {\n        scene.pointerMovePredicate = function (mesh) {\n          return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (mesh.enablePointerMoveEvents || scene.constantlyUpdateMeshUnderPointer || mesh._getActionManagerForTrigger() !== null) && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\n        };\n      } // Meshes\n\n\n      var pickResult = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, scene.pointerMovePredicate, false, scene.cameraToUseForPointers, scene.pointerMoveTrianglePredicate);\n\n      _this._processPointerMove(pickResult, evt);\n    };\n\n    this._onPointerDown = function (evt) {\n      _this._totalPointersPressed++;\n      _this._pickedDownMesh = null;\n      _this._meshPickProceed = false; // preserve compatibility with Safari when pointerId is not present\n\n      if (evt.pointerId === undefined) {\n        evt.pointerId = 0;\n      }\n\n      _this._updatePointerPosition(evt);\n\n      if (scene.preventDefaultOnPointerDown && elementToAttachTo) {\n        evt.preventDefault();\n        elementToAttachTo.focus();\n      }\n\n      _this._startingPointerPosition.x = _this._pointerX;\n      _this._startingPointerPosition.y = _this._pointerY;\n      _this._startingPointerTime = Date.now(); // PreObservable support\n\n      if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOWN)) {\n        return;\n      }\n\n      if (!scene.cameraToUseForPointers && !scene.activeCamera) {\n        return;\n      }\n\n      _this._pointerCaptures[evt.pointerId] = true;\n\n      if (!scene.pointerDownPredicate) {\n        scene.pointerDownPredicate = function (mesh) {\n          return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\n        };\n      } // Meshes\n\n\n      _this._pickedDownMesh = null;\n      var pickResult;\n\n      if (scene.skipPointerDownPicking) {\n        pickResult = new PickingInfo();\n      } else {\n        pickResult = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, scene.pointerDownPredicate, false, scene.cameraToUseForPointers);\n      }\n\n      _this._processPointerDown(pickResult, evt);\n    };\n\n    this._onPointerUp = function (evt) {\n      if (_this._totalPointersPressed === 0) {\n        // We are attaching the pointer up to windows because of a bug in FF\n        return; // So we need to test it the pointer down was pressed before.\n      }\n\n      _this._totalPointersPressed--;\n      _this._pickedUpMesh = null;\n      _this._meshPickProceed = false; // preserve compatibility with Safari when pointerId is not present\n\n      if (evt.pointerId === undefined) {\n        evt.pointerId = 0;\n      }\n\n      _this._updatePointerPosition(evt);\n\n      if (scene.preventDefaultOnPointerUp && elementToAttachTo) {\n        evt.preventDefault();\n        elementToAttachTo.focus();\n      }\n\n      _this._initClickEvent(scene.onPrePointerObservable, scene.onPointerObservable, evt, function (clickInfo, pickResult) {\n        // PreObservable support\n        if (scene.onPrePointerObservable.hasObservers()) {\n          if (!clickInfo.ignore) {\n            if (!clickInfo.hasSwiped) {\n              if (clickInfo.singleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {\n                if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERTAP)) {\n                  return;\n                }\n              }\n\n              if (clickInfo.doubleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {\n                if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOUBLETAP)) {\n                  return;\n                }\n              }\n            }\n\n            if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERUP)) {\n              return;\n            }\n          }\n        }\n\n        if (!_this._pointerCaptures[evt.pointerId] && evt.buttons > 0) {\n          return;\n        }\n\n        _this._pointerCaptures[evt.pointerId] = false;\n\n        if (!scene.cameraToUseForPointers && !scene.activeCamera) {\n          return;\n        }\n\n        if (!scene.pointerUpPredicate) {\n          scene.pointerUpPredicate = function (mesh) {\n            return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\n          };\n        } // Meshes\n\n\n        if (!_this._meshPickProceed && (AbstractActionManager && AbstractActionManager.HasTriggers || scene.onPointerObservable.hasObservers())) {\n          _this._initActionManager(null, clickInfo);\n        }\n\n        if (!pickResult) {\n          pickResult = _this._currentPickResult;\n        }\n\n        _this._processPointerUp(pickResult, evt, clickInfo);\n\n        _this._previousPickResult = _this._currentPickResult;\n      });\n    };\n\n    this._onKeyDown = function (evt) {\n      var type = KeyboardEventTypes.KEYDOWN;\n\n      if (scene.onPreKeyboardObservable.hasObservers()) {\n        var pi = new KeyboardInfoPre(type, evt);\n        scene.onPreKeyboardObservable.notifyObservers(pi, type);\n\n        if (pi.skipOnKeyboardObservable) {\n          return;\n        }\n      }\n\n      if (scene.onKeyboardObservable.hasObservers()) {\n        var pi = new KeyboardInfo(type, evt);\n        scene.onKeyboardObservable.notifyObservers(pi, type);\n      }\n\n      if (scene.actionManager) {\n        scene.actionManager.processTrigger(14, ActionEvent.CreateNewFromScene(scene, evt));\n      }\n    };\n\n    this._onKeyUp = function (evt) {\n      var type = KeyboardEventTypes.KEYUP;\n\n      if (scene.onPreKeyboardObservable.hasObservers()) {\n        var pi = new KeyboardInfoPre(type, evt);\n        scene.onPreKeyboardObservable.notifyObservers(pi, type);\n\n        if (pi.skipOnKeyboardObservable) {\n          return;\n        }\n      }\n\n      if (scene.onKeyboardObservable.hasObservers()) {\n        var pi = new KeyboardInfo(type, evt);\n        scene.onKeyboardObservable.notifyObservers(pi, type);\n      }\n\n      if (scene.actionManager) {\n        scene.actionManager.processTrigger(15, ActionEvent.CreateNewFromScene(scene, evt));\n      }\n    }; // If a device connects that we can handle, wire up the observable\n\n\n    this._deviceSourceManager.onDeviceConnectedObservable.add(function (deviceSource) {\n      if (deviceSource.deviceType === DeviceType.Mouse) {\n        deviceSource.onInputChangedObservable.add(function (eventData) {\n          if (eventData.inputIndex === PointerInput.LeftClick || eventData.inputIndex === PointerInput.MiddleClick || eventData.inputIndex === PointerInput.RightClick) {\n            if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {\n              _this._onPointerDown(eventData);\n            } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {\n              _this._onPointerUp(eventData);\n            }\n          } else if (attachMove) {\n            if (eventData.inputIndex === PointerInput.Move) {\n              _this._onPointerMove(eventData);\n            } else if (eventData.inputIndex === PointerInput.MouseWheelX || eventData.inputIndex === PointerInput.MouseWheelY || eventData.inputIndex === PointerInput.MouseWheelZ) {\n              _this._onPointerMove(eventData);\n            }\n          }\n        });\n      } else if (deviceSource.deviceType === DeviceType.Touch) {\n        deviceSource.onInputChangedObservable.add(function (eventData) {\n          if (eventData.inputIndex === PointerInput.LeftClick) {\n            if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {\n              _this._onPointerDown(eventData);\n            } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {\n              _this._onPointerUp(eventData);\n            }\n          }\n\n          if (attachMove && eventData.inputIndex === PointerInput.Move) {\n            _this._onPointerMove(eventData);\n          }\n        });\n      } else if (deviceSource.deviceType === DeviceType.Keyboard) {\n        deviceSource.onInputChangedObservable.add(function (eventData) {\n          if (eventData.type === \"keydown\") {\n            _this._onKeyDown(eventData);\n          } else if (eventData.type === \"keyup\") {\n            _this._onKeyUp(eventData);\n          }\n        });\n      }\n    });\n\n    this._alreadyAttached = true;\n  };\n  /**\n   * Detaches all event handlers\n   */\n\n\n  InputManager.prototype.detachControl = function () {\n    if (this._alreadyAttached) {\n      this._deviceSourceManager.dispose();\n\n      this._deviceSourceManager = null; // Cursor\n\n      if (this._alreadyAttachedTo && !this._scene.doNotHandleCursors) {\n        this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor;\n      }\n\n      this._alreadyAttached = false;\n      this._alreadyAttachedTo = null;\n    }\n  };\n  /**\n   * Force the value of meshUnderPointer\n   * @param mesh - defines the mesh to use\n   * @param pointerId - optional pointer id when using more than one pointer. Defaults to 0\n   * @param pickResult - optional pickingInfo data used to find mesh\n   */\n\n\n  InputManager.prototype.setPointerOverMesh = function (mesh, pointerId, pickResult) {\n    if (pointerId === void 0) {\n      pointerId = 0;\n    }\n\n    if (this._meshUnderPointerId[pointerId] === mesh) {\n      return;\n    }\n\n    var underPointerMesh = this._meshUnderPointerId[pointerId];\n    var actionManager;\n\n    if (underPointerMesh) {\n      actionManager = underPointerMesh._getActionManagerForTrigger(10);\n\n      if (actionManager) {\n        actionManager.processTrigger(10, ActionEvent.CreateNew(underPointerMesh, undefined, {\n          pointerId: pointerId\n        }));\n      }\n    }\n\n    if (mesh) {\n      this._meshUnderPointerId[pointerId] = mesh;\n      this._pointerOverMesh = mesh;\n      actionManager = mesh._getActionManagerForTrigger(9);\n\n      if (actionManager) {\n        actionManager.processTrigger(9, ActionEvent.CreateNew(mesh, undefined, {\n          pointerId: pointerId,\n          pickResult: pickResult\n        }));\n      }\n    } else {\n      delete this._meshUnderPointerId[pointerId];\n      this._pointerOverMesh = null;\n    }\n  };\n  /**\n   * Gets the mesh under the pointer\n   * @returns a Mesh or null if no mesh is under the pointer\n   */\n\n\n  InputManager.prototype.getPointerOverMesh = function () {\n    return this._pointerOverMesh;\n  };\n  /**\n   * @param mesh - Mesh to invalidate\n   * @hidden\n   */\n\n\n  InputManager.prototype._invalidateMesh = function (mesh) {\n    if (this._pointerOverMesh === mesh) {\n      this._pointerOverMesh = null;\n    }\n\n    if (this._pickedDownMesh === mesh) {\n      this._pickedDownMesh = null;\n    }\n\n    if (this._pickedUpMesh === mesh) {\n      this._pickedUpMesh = null;\n    }\n\n    for (var pointerId in this._meshUnderPointerId) {\n      if (this._meshUnderPointerId[pointerId] === mesh) {\n        delete this._meshUnderPointerId[pointerId];\n      }\n    }\n  };\n  /** The distance in pixel that you have to move to prevent some events */\n\n\n  InputManager.DragMovementThreshold = 10; // in pixels\n\n  /** Time in milliseconds to wait to raise long press events if button is still pressed */\n\n  InputManager.LongPressDelay = 500; // in milliseconds\n\n  /** Time in milliseconds with two consecutive clicks will be considered as a double click */\n\n  InputManager.DoubleClickDelay = 300; // in milliseconds\n\n  /** If you need to check double click without raising a single click at first click, enable this flag */\n\n  InputManager.ExclusiveDoubleClickMode = false;\n  return InputManager;\n}();\n\nexport { InputManager };","map":{"version":3,"mappings":"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","names":["PointerInfoPre","PointerInfo","PointerEventTypes","AbstractActionManager","PickingInfo","Vector2","Matrix","ActionEvent","KeyboardEventTypes","KeyboardInfoPre","KeyboardInfo","DeviceType","PointerInput","DeviceSourceManager","EngineStore","Object","_ClickInfo","_singleClick","b","_doubleClick","_hasSwiped","_ignore","scene","_scene","LastCreatedScene","InputManager","_pointerOverMesh","pointerId","_meshUnderPointerId","_unTranslatedPointerX","_unTranslatedPointerY","_pointerX","value","_pointerY","evt","canvasRect","getEngine","getInputElementClientRect","clientX","left","clientY","top","pickResult","engine","canvas","getInputElement","tabIndex","canvasTabIndex","doNotHandleCursors","style","cursor","defaultCursor","isMeshPicked","hit","pickedMesh","setPointerOverMesh","actionManager","hasPointerTriggers","hoverCursor","_pointerMoveStage","_i","step","action","type","POINTERWHEEL","POINTERMOVE","onPointerMove","onPointerObservable","hasObservers","pi","_setRayOnPointerInfo","notifyObservers","pointerInfo","pickInfo","_pickingUnavailable","ray","createPickingRay","event","offsetX","offsetY","Identity","activeCamera","originMesh","nearInteractionPickingInfo","onPrePointerObservable","skipOnPointerObservable","pointerEventInit","PointerEvent","inputIndex","Move","_checkPrePointerObservable","_processPointerMove","button","POINTERDOWN","_processPointerDown","_pickedDownMesh","actionManager_1","_getActionManagerForTrigger","hasPickTriggers","processTrigger","hasSpecificTrigger","window","setTimeout","pick","_this","mesh","isPickable","isVisible","isReady","cameraToUseForPointers","_totalPointersPressed","Date","now","_startingPointerTime","LongPressDelay","_isPointerSwiping","_pointerDownStage","onPointerDown","Math","abs","_startingPointerPosition","x","DragMovementThreshold","y","doubleTap","clickInfo","doubleClick","singleClick","POINTERUP","_processPointerUp","_pickedUpMesh","onPointerPick","ignore","type_1","POINTERPICK","hasSwiped","doubleClickActionManager","_pointerUpStage","pickedDownActionManager","hasSpecificMask","POINTERTAP","POINTERDOUBLETAP","onPointerUp","_pointerCaptures","attachUp","attachDown","attachMove","elementToAttachTo","_alreadyAttached","detachControl","_alreadyAttachedTo","_deviceSourceManager","_initActionManager","act","_meshPickProceed","pointerDownPredicate","_currentPickResult","_delayedSimpleClick","btn","cb","_previousStartingPointerTime","DoubleClickDelay","_doubleClickOccured","_previousButtonPressed","_initClickEvent","obs1","obs2","checkPicking","needToIgnoreNext","checkSingleClickImmediately","ExclusiveDoubleClickMode","HasSpecificTrigger","_previousDelayedSimpleClickTimeout","_delayedSimpleClickTimeout","bind","checkDoubleClick","clearTimeout","_previousStartingPointerPosition","_previousPickResult","_onPointerMove","undefined","_updatePointerPosition","skipPointerMovePicking","pointerMovePredicate","isEnabled","enablePointerMoveEvents","constantlyUpdateMeshUnderPointer","layerMask","pointerMoveTrianglePredicate","_onPointerDown","preventDefaultOnPointerDown","preventDefault","focus","skipPointerDownPicking","_onPointerUp","preventDefaultOnPointerUp","buttons","pointerUpPredicate","HasTriggers","_onKeyDown","KEYDOWN","onPreKeyboardObservable","skipOnKeyboardObservable","onKeyboardObservable","_onKeyUp","KEYUP","onDeviceConnectedObservable","add","deviceSource","deviceType","Mouse","onInputChangedObservable","eventData","LeftClick","MiddleClick","RightClick","getInput","MouseWheelX","MouseWheelY","MouseWheelZ","Touch","Keyboard","dispose","underPointerMesh"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Inputs/scene.inputManager.ts"],"sourcesContent":["import type { Observable } from \"../Misc/observable\";\r\nimport { PointerInfoPre, PointerInfo, PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport type { Nullable } from \"../types\";\r\nimport { AbstractActionManager } from \"../Actions/abstractActionManager\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { Vector2, Matrix } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { ActionEvent } from \"../Actions/actionEvent\";\r\nimport { KeyboardEventTypes, KeyboardInfoPre, KeyboardInfo } from \"../Events/keyboardEvents\";\r\nimport { DeviceType, PointerInput } from \"../DeviceInput/InputDevices/deviceEnums\";\r\nimport type { IKeyboardEvent, IMouseEvent, IPointerEvent } from \"../Events/deviceInputEvents\";\r\nimport { DeviceSourceManager } from \"../DeviceInput/InputDevices/deviceSourceManager\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\ndeclare type Scene = import(\"../scene\").Scene;\r\n\r\n/** @hidden */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nclass _ClickInfo {\r\n    private _singleClick = false;\r\n    private _doubleClick = false;\r\n    private _hasSwiped = false;\r\n    private _ignore = false;\r\n\r\n    public get singleClick(): boolean {\r\n        return this._singleClick;\r\n    }\r\n    public get doubleClick(): boolean {\r\n        return this._doubleClick;\r\n    }\r\n    public get hasSwiped(): boolean {\r\n        return this._hasSwiped;\r\n    }\r\n    public get ignore(): boolean {\r\n        return this._ignore;\r\n    }\r\n\r\n    public set singleClick(b: boolean) {\r\n        this._singleClick = b;\r\n    }\r\n    public set doubleClick(b: boolean) {\r\n        this._doubleClick = b;\r\n    }\r\n    public set hasSwiped(b: boolean) {\r\n        this._hasSwiped = b;\r\n    }\r\n    public set ignore(b: boolean) {\r\n        this._ignore = b;\r\n    }\r\n}\r\n\r\n/**\r\n * Class used to manage all inputs for the scene.\r\n */\r\nexport class InputManager {\r\n    /** The distance in pixel that you have to move to prevent some events */\r\n    public static DragMovementThreshold = 10; // in pixels\r\n    /** Time in milliseconds to wait to raise long press events if button is still pressed */\r\n    public static LongPressDelay = 500; // in milliseconds\r\n    /** Time in milliseconds with two consecutive clicks will be considered as a double click */\r\n    public static DoubleClickDelay = 300; // in milliseconds\r\n    /** If you need to check double click without raising a single click at first click, enable this flag */\r\n    public static ExclusiveDoubleClickMode = false;\r\n\r\n    /** This is a defensive check to not allow control attachment prior to an already active one. If already attached, previous control is unattached before attaching the new one. */\r\n    private _alreadyAttached = false;\r\n    private _alreadyAttachedTo: Nullable<HTMLElement>;\r\n\r\n    // Pointers\r\n    private _onPointerMove: (evt: IMouseEvent) => void;\r\n    private _onPointerDown: (evt: IPointerEvent) => void;\r\n    private _onPointerUp: (evt: IPointerEvent) => void;\r\n\r\n    private _initClickEvent: (\r\n        obs1: Observable<PointerInfoPre>,\r\n        obs2: Observable<PointerInfo>,\r\n        evt: IPointerEvent,\r\n        cb: (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => void\r\n    ) => void;\r\n    private _initActionManager: (act: Nullable<AbstractActionManager>, clickInfo: _ClickInfo) => Nullable<AbstractActionManager>;\r\n    private _delayedSimpleClick: (btn: number, clickInfo: _ClickInfo, cb: (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => void) => void;\r\n    private _delayedSimpleClickTimeout: number;\r\n    private _previousDelayedSimpleClickTimeout: number;\r\n    private _meshPickProceed = false;\r\n\r\n    private _previousButtonPressed: number;\r\n    private _currentPickResult: Nullable<PickingInfo> = null;\r\n    private _previousPickResult: Nullable<PickingInfo> = null;\r\n    private _totalPointersPressed = 0;\r\n    private _doubleClickOccured = false;\r\n\r\n    private _pointerOverMesh: Nullable<AbstractMesh>;\r\n\r\n    private _pickedDownMesh: Nullable<AbstractMesh>;\r\n    private _pickedUpMesh: Nullable<AbstractMesh>;\r\n\r\n    private _pointerX: number = 0;\r\n    private _pointerY: number = 0;\r\n    private _unTranslatedPointerX: number;\r\n    private _unTranslatedPointerY: number;\r\n    private _startingPointerPosition = new Vector2(0, 0);\r\n    private _previousStartingPointerPosition = new Vector2(0, 0);\r\n    private _startingPointerTime = 0;\r\n    private _previousStartingPointerTime = 0;\r\n    private _pointerCaptures: { [pointerId: number]: boolean } = {};\r\n    private _meshUnderPointerId: { [pointerId: number]: Nullable<AbstractMesh> } = {};\r\n\r\n    // Keyboard\r\n    private _onKeyDown: (evt: IKeyboardEvent) => void;\r\n    private _onKeyUp: (evt: IKeyboardEvent) => void;\r\n\r\n    private _scene: Scene;\r\n    private _deviceSourceManager: Nullable<DeviceSourceManager> = null;\r\n\r\n    /**\r\n     * Creates a new InputManager\r\n     * @param scene - defines the hosting scene\r\n     */\r\n    constructor(scene?: Scene) {\r\n        this._scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!this._scene) {\r\n            return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the mesh that is currently under the pointer\r\n     * @returns Mesh that the pointer is pointer is hovering over\r\n     */\r\n    public get meshUnderPointer(): Nullable<AbstractMesh> {\r\n        return this._pointerOverMesh;\r\n    }\r\n\r\n    /**\r\n     * When using more than one pointer (for example in XR) you can get the mesh under the specific pointer\r\n     * @param pointerId - the pointer id to use\r\n     * @returns The mesh under this pointer id or null if not found\r\n     */\r\n    public getMeshUnderPointerByPointerId(pointerId: number): Nullable<AbstractMesh> {\r\n        return this._meshUnderPointerId[pointerId] || null;\r\n    }\r\n\r\n    /**\r\n     * Gets the pointer coordinates in 2D without any translation (ie. straight out of the pointer event)\r\n     * @returns Vector with X/Y values directly from pointer event\r\n     */\r\n    public get unTranslatedPointer(): Vector2 {\r\n        return new Vector2(this._unTranslatedPointerX, this._unTranslatedPointerY);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current on-screen X position of the pointer\r\n     * @returns Translated X with respect to screen\r\n     */\r\n    public get pointerX(): number {\r\n        return this._pointerX;\r\n    }\r\n\r\n    public set pointerX(value: number) {\r\n        this._pointerX = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current on-screen Y position of the pointer\r\n     * @returns Translated Y with respect to screen\r\n     */\r\n    public get pointerY(): number {\r\n        return this._pointerY;\r\n    }\r\n\r\n    public set pointerY(value: number) {\r\n        this._pointerY = value;\r\n    }\r\n\r\n    private _updatePointerPosition(evt: IPointerEvent): void {\r\n        const canvasRect = this._scene.getEngine().getInputElementClientRect();\r\n\r\n        if (!canvasRect) {\r\n            return;\r\n        }\r\n\r\n        this._pointerX = evt.clientX - canvasRect.left;\r\n        this._pointerY = evt.clientY - canvasRect.top;\r\n\r\n        this._unTranslatedPointerX = this._pointerX;\r\n        this._unTranslatedPointerY = this._pointerY;\r\n    }\r\n\r\n    private _processPointerMove(pickResult: Nullable<PickingInfo>, evt: IPointerEvent) {\r\n        const scene = this._scene;\r\n        const engine = scene.getEngine();\r\n        const canvas = engine.getInputElement();\r\n\r\n        if (canvas) {\r\n            canvas.tabIndex = engine.canvasTabIndex;\r\n\r\n            // Restore pointer\r\n            if (!scene.doNotHandleCursors) {\r\n                canvas.style.cursor = scene.defaultCursor;\r\n            }\r\n        }\r\n\r\n        const isMeshPicked = pickResult && pickResult.hit && pickResult.pickedMesh ? true : false;\r\n        if (isMeshPicked) {\r\n            scene.setPointerOverMesh(pickResult!.pickedMesh, evt.pointerId, pickResult);\r\n\r\n            if (this._pointerOverMesh && this._pointerOverMesh.actionManager && this._pointerOverMesh.actionManager.hasPointerTriggers) {\r\n                if (!scene.doNotHandleCursors && canvas) {\r\n                    if (this._pointerOverMesh.actionManager.hoverCursor) {\r\n                        canvas.style.cursor = this._pointerOverMesh.actionManager.hoverCursor;\r\n                    } else {\r\n                        canvas.style.cursor = scene.hoverCursor;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            scene.setPointerOverMesh(null, evt.pointerId, pickResult);\r\n        }\r\n\r\n        for (const step of scene._pointerMoveStage) {\r\n            pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, isMeshPicked, canvas);\r\n        }\r\n\r\n        if (pickResult) {\r\n            const type = evt.type === \"wheel\" || evt.type === \"mousewheel\" || evt.type === \"DOMMouseScroll\" ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE;\r\n\r\n            if (scene.onPointerMove) {\r\n                scene.onPointerMove(evt, pickResult, type);\r\n            }\r\n\r\n            if (scene.onPointerObservable.hasObservers()) {\r\n                const pi = new PointerInfo(type, evt, pickResult);\r\n                this._setRayOnPointerInfo(pi);\r\n                scene.onPointerObservable.notifyObservers(pi, type);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Pointers handling\r\n    private _setRayOnPointerInfo(pointerInfo: PointerInfo) {\r\n        const scene = this._scene;\r\n        if (pointerInfo.pickInfo && !pointerInfo.pickInfo._pickingUnavailable) {\r\n            if (!pointerInfo.pickInfo.ray) {\r\n                pointerInfo.pickInfo.ray = scene.createPickingRay(pointerInfo.event.offsetX, pointerInfo.event.offsetY, Matrix.Identity(), scene.activeCamera);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _checkPrePointerObservable(pickResult: Nullable<PickingInfo>, evt: IPointerEvent, type: number) {\r\n        const scene = this._scene;\r\n        const pi = new PointerInfoPre(type, evt, this._unTranslatedPointerX, this._unTranslatedPointerY);\r\n        if (pickResult) {\r\n            pi.ray = pickResult.ray;\r\n            if (pickResult.originMesh) {\r\n                pi.nearInteractionPickingInfo = pickResult;\r\n            }\r\n        }\r\n\r\n        scene.onPrePointerObservable.notifyObservers(pi, type);\r\n        if (pi.skipOnPointerObservable) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Use this method to simulate a pointer move on a mesh\r\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n     * @param pickResult - pickingInfo of the object wished to simulate pointer event on\r\n     * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n     */\r\n    public simulatePointerMove(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): void {\r\n        const evt = new PointerEvent(\"pointermove\", pointerEventInit);\r\n        evt.inputIndex = PointerInput.Move;\r\n\r\n        if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERMOVE)) {\r\n            return;\r\n        }\r\n        this._processPointerMove(pickResult, evt);\r\n    }\r\n\r\n    /**\r\n     * Use this method to simulate a pointer down on a mesh\r\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n     * @param pickResult - pickingInfo of the object wished to simulate pointer event on\r\n     * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n     */\r\n    public simulatePointerDown(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): void {\r\n        const evt = new PointerEvent(\"pointerdown\", pointerEventInit);\r\n        evt.inputIndex = evt.button + 2;\r\n\r\n        if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERDOWN)) {\r\n            return;\r\n        }\r\n\r\n        this._processPointerDown(pickResult, evt);\r\n    }\r\n\r\n    private _processPointerDown(pickResult: Nullable<PickingInfo>, evt: IPointerEvent): void {\r\n        const scene = this._scene;\r\n        if (pickResult && pickResult.hit && pickResult.pickedMesh) {\r\n            this._pickedDownMesh = pickResult.pickedMesh;\r\n            const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();\r\n            if (actionManager) {\r\n                if (actionManager.hasPickTriggers) {\r\n                    actionManager.processTrigger(Constants.ACTION_OnPickDownTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\r\n                    switch (evt.button) {\r\n                        case 0:\r\n                            actionManager.processTrigger(Constants.ACTION_OnLeftPickTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\r\n                            break;\r\n                        case 1:\r\n                            actionManager.processTrigger(Constants.ACTION_OnCenterPickTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\r\n                            break;\r\n                        case 2:\r\n                            actionManager.processTrigger(Constants.ACTION_OnRightPickTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\r\n                            break;\r\n                    }\r\n                }\r\n\r\n                if (actionManager.hasSpecificTrigger(Constants.ACTION_OnLongPressTrigger)) {\r\n                    window.setTimeout(() => {\r\n                        const pickResult = scene.pick(\r\n                            this._unTranslatedPointerX,\r\n                            this._unTranslatedPointerY,\r\n                            (mesh: AbstractMesh): boolean =>\r\n                                <boolean>(\r\n                                    (mesh.isPickable &&\r\n                                        mesh.isVisible &&\r\n                                        mesh.isReady() &&\r\n                                        mesh.actionManager &&\r\n                                        mesh.actionManager.hasSpecificTrigger(Constants.ACTION_OnLongPressTrigger) &&\r\n                                        mesh === this._pickedDownMesh)\r\n                                ),\r\n                            false,\r\n                            scene.cameraToUseForPointers\r\n                        );\r\n\r\n                        if (pickResult && pickResult.hit && pickResult.pickedMesh && actionManager) {\r\n                            if (this._totalPointersPressed !== 0 && Date.now() - this._startingPointerTime > InputManager.LongPressDelay && !this._isPointerSwiping()) {\r\n                                this._startingPointerTime = 0;\r\n                                actionManager.processTrigger(Constants.ACTION_OnLongPressTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\r\n                            }\r\n                        }\r\n                    }, InputManager.LongPressDelay);\r\n                }\r\n            }\r\n        } else {\r\n            for (const step of scene._pointerDownStage) {\r\n                pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt);\r\n            }\r\n        }\r\n\r\n        if (pickResult) {\r\n            const type = PointerEventTypes.POINTERDOWN;\r\n\r\n            if (scene.onPointerDown) {\r\n                scene.onPointerDown(evt, pickResult, type);\r\n            }\r\n\r\n            if (scene.onPointerObservable.hasObservers()) {\r\n                const pi = new PointerInfo(type, evt, pickResult);\r\n                this._setRayOnPointerInfo(pi);\r\n                scene.onPointerObservable.notifyObservers(pi, type);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * @returns Boolean if delta for pointer exceeds drag movement threshold\r\n     */\r\n    public _isPointerSwiping(): boolean {\r\n        return (\r\n            Math.abs(this._startingPointerPosition.x - this._pointerX) > InputManager.DragMovementThreshold ||\r\n            Math.abs(this._startingPointerPosition.y - this._pointerY) > InputManager.DragMovementThreshold\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Use this method to simulate a pointer up on a mesh\r\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n     * @param pickResult - pickingInfo of the object wished to simulate pointer event on\r\n     * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n     * @param doubleTap - indicates that the pointer up event should be considered as part of a double click (false by default)\r\n     */\r\n    public simulatePointerUp(pickResult: PickingInfo, pointerEventInit?: PointerEventInit, doubleTap?: boolean): void {\r\n        const evt = new PointerEvent(\"pointerup\", pointerEventInit);\r\n        evt.inputIndex = PointerInput.Move;\r\n        const clickInfo = new _ClickInfo();\r\n\r\n        if (doubleTap) {\r\n            clickInfo.doubleClick = true;\r\n        } else {\r\n            clickInfo.singleClick = true;\r\n        }\r\n\r\n        if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERUP)) {\r\n            return;\r\n        }\r\n\r\n        this._processPointerUp(pickResult, evt, clickInfo);\r\n    }\r\n\r\n    private _processPointerUp(pickResult: Nullable<PickingInfo>, evt: IPointerEvent, clickInfo: _ClickInfo): void {\r\n        const scene = this._scene;\r\n        if (pickResult && pickResult && pickResult.pickedMesh) {\r\n            this._pickedUpMesh = pickResult.pickedMesh;\r\n            if (this._pickedDownMesh === this._pickedUpMesh) {\r\n                if (scene.onPointerPick) {\r\n                    scene.onPointerPick(evt, pickResult);\r\n                }\r\n                if (clickInfo.singleClick && !clickInfo.ignore && scene.onPointerObservable.hasObservers()) {\r\n                    const type = PointerEventTypes.POINTERPICK;\r\n                    const pi = new PointerInfo(type, evt, pickResult);\r\n                    this._setRayOnPointerInfo(pi);\r\n                    scene.onPointerObservable.notifyObservers(pi, type);\r\n                }\r\n            }\r\n            const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();\r\n            if (actionManager && !clickInfo.ignore) {\r\n                actionManager.processTrigger(Constants.ACTION_OnPickUpTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\r\n\r\n                if (!clickInfo.hasSwiped && clickInfo.singleClick) {\r\n                    actionManager.processTrigger(Constants.ACTION_OnPickTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\r\n                }\r\n\r\n                const doubleClickActionManager = pickResult.pickedMesh._getActionManagerForTrigger(Constants.ACTION_OnDoublePickTrigger);\r\n                if (clickInfo.doubleClick && doubleClickActionManager) {\r\n                    doubleClickActionManager.processTrigger(Constants.ACTION_OnDoublePickTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\r\n                }\r\n            }\r\n        } else {\r\n            if (!clickInfo.ignore) {\r\n                for (const step of scene._pointerUpStage) {\r\n                    pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {\r\n            const pickedDownActionManager = this._pickedDownMesh._getActionManagerForTrigger(Constants.ACTION_OnPickOutTrigger);\r\n            if (pickedDownActionManager) {\r\n                pickedDownActionManager.processTrigger(Constants.ACTION_OnPickOutTrigger, ActionEvent.CreateNew(this._pickedDownMesh, evt));\r\n            }\r\n        }\r\n\r\n        let type = 0;\r\n        if (scene.onPointerObservable.hasObservers()) {\r\n            if (!clickInfo.ignore && !clickInfo.hasSwiped) {\r\n                if (clickInfo.singleClick && scene.onPointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {\r\n                    type = PointerEventTypes.POINTERTAP;\r\n                } else if (clickInfo.doubleClick && scene.onPointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {\r\n                    type = PointerEventTypes.POINTERDOUBLETAP;\r\n                }\r\n                if (type) {\r\n                    const pi = new PointerInfo(type, evt, pickResult);\r\n                    this._setRayOnPointerInfo(pi);\r\n                    scene.onPointerObservable.notifyObservers(pi, type);\r\n                }\r\n            }\r\n\r\n            if (!clickInfo.ignore) {\r\n                type = PointerEventTypes.POINTERUP;\r\n\r\n                const pi = new PointerInfo(type, evt, pickResult);\r\n                this._setRayOnPointerInfo(pi);\r\n                scene.onPointerObservable.notifyObservers(pi, type);\r\n            }\r\n        }\r\n\r\n        if (scene.onPointerUp && !clickInfo.ignore) {\r\n            scene.onPointerUp(evt, pickResult, type);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\r\n     * @param pointerId - defines the pointer id to use in a multi-touch scenario (0 by default)\r\n     * @returns true if the pointer was captured\r\n     */\r\n    public isPointerCaptured(pointerId = 0): boolean {\r\n        return this._pointerCaptures[pointerId];\r\n    }\r\n\r\n    /**\r\n     * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\r\n     * @param attachUp - defines if you want to attach events to pointerup\r\n     * @param attachDown - defines if you want to attach events to pointerdown\r\n     * @param attachMove - defines if you want to attach events to pointermove\r\n     * @param elementToAttachTo - defines the target DOM element to attach to (will use the canvas by default)\r\n     */\r\n    public attachControl(attachUp = true, attachDown = true, attachMove = true, elementToAttachTo: Nullable<HTMLElement> = null): void {\r\n        const scene = this._scene;\r\n        const engine = scene.getEngine();\r\n\r\n        if (!elementToAttachTo) {\r\n            elementToAttachTo = engine.getInputElement();\r\n        }\r\n\r\n        if (this._alreadyAttached) {\r\n            this.detachControl();\r\n        }\r\n\r\n        if (elementToAttachTo) {\r\n            this._alreadyAttachedTo = elementToAttachTo;\r\n        }\r\n        this._deviceSourceManager = new DeviceSourceManager(engine);\r\n\r\n        this._initActionManager = (act: Nullable<AbstractActionManager>): Nullable<AbstractActionManager> => {\r\n            if (!this._meshPickProceed) {\r\n                const pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerDownPredicate, false, scene.cameraToUseForPointers);\r\n                this._currentPickResult = pickResult;\r\n                if (pickResult) {\r\n                    act = pickResult.hit && pickResult.pickedMesh ? pickResult.pickedMesh._getActionManagerForTrigger() : null;\r\n                }\r\n                this._meshPickProceed = true;\r\n            }\r\n            return act;\r\n        };\r\n\r\n        this._delayedSimpleClick = (btn: number, clickInfo: _ClickInfo, cb: (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => void) => {\r\n            // double click delay is over and that no double click has been raised since, or the 2 consecutive keys pressed are different\r\n            if ((Date.now() - this._previousStartingPointerTime > InputManager.DoubleClickDelay && !this._doubleClickOccured) || btn !== this._previousButtonPressed) {\r\n                this._doubleClickOccured = false;\r\n                clickInfo.singleClick = true;\r\n                clickInfo.ignore = false;\r\n                cb(clickInfo, this._currentPickResult);\r\n            }\r\n        };\r\n\r\n        this._initClickEvent = (\r\n            obs1: Observable<PointerInfoPre>,\r\n            obs2: Observable<PointerInfo>,\r\n            evt: IPointerEvent,\r\n            cb: (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => void\r\n        ): void => {\r\n            const clickInfo = new _ClickInfo();\r\n            this._currentPickResult = null;\r\n            let act: Nullable<AbstractActionManager> = null;\r\n\r\n            let checkPicking =\r\n                obs1.hasSpecificMask(PointerEventTypes.POINTERPICK) ||\r\n                obs2.hasSpecificMask(PointerEventTypes.POINTERPICK) ||\r\n                obs1.hasSpecificMask(PointerEventTypes.POINTERTAP) ||\r\n                obs2.hasSpecificMask(PointerEventTypes.POINTERTAP) ||\r\n                obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) ||\r\n                obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\r\n            if (!checkPicking && AbstractActionManager) {\r\n                act = this._initActionManager(act, clickInfo);\r\n                if (act) {\r\n                    checkPicking = act.hasPickTriggers;\r\n                }\r\n            }\r\n\r\n            let needToIgnoreNext = false;\r\n\r\n            if (checkPicking) {\r\n                const btn = evt.button;\r\n                clickInfo.hasSwiped = this._isPointerSwiping();\r\n\r\n                if (!clickInfo.hasSwiped) {\r\n                    let checkSingleClickImmediately = !InputManager.ExclusiveDoubleClickMode;\r\n\r\n                    if (!checkSingleClickImmediately) {\r\n                        checkSingleClickImmediately = !obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) && !obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\r\n\r\n                        if (checkSingleClickImmediately && !AbstractActionManager.HasSpecificTrigger(Constants.ACTION_OnDoublePickTrigger)) {\r\n                            act = this._initActionManager(act, clickInfo);\r\n                            if (act) {\r\n                                checkSingleClickImmediately = !act.hasSpecificTrigger(Constants.ACTION_OnDoublePickTrigger);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (checkSingleClickImmediately) {\r\n                        // single click detected if double click delay is over or two different successive keys pressed without exclusive double click or no double click required\r\n                        if (Date.now() - this._previousStartingPointerTime > InputManager.DoubleClickDelay || btn !== this._previousButtonPressed) {\r\n                            clickInfo.singleClick = true;\r\n                            cb(clickInfo, this._currentPickResult);\r\n                            needToIgnoreNext = true;\r\n                        }\r\n                    }\r\n                    // at least one double click is required to be check and exclusive double click is enabled\r\n                    else {\r\n                        // wait that no double click has been raised during the double click delay\r\n                        this._previousDelayedSimpleClickTimeout = this._delayedSimpleClickTimeout;\r\n                        this._delayedSimpleClickTimeout = window.setTimeout(this._delayedSimpleClick.bind(this, btn, clickInfo, cb), InputManager.DoubleClickDelay);\r\n                    }\r\n\r\n                    let checkDoubleClick = obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\r\n                    if (!checkDoubleClick && AbstractActionManager.HasSpecificTrigger(Constants.ACTION_OnDoublePickTrigger)) {\r\n                        act = this._initActionManager(act, clickInfo);\r\n                        if (act) {\r\n                            checkDoubleClick = act.hasSpecificTrigger(Constants.ACTION_OnDoublePickTrigger);\r\n                        }\r\n                    }\r\n                    if (checkDoubleClick) {\r\n                        // two successive keys pressed are equal, double click delay is not over and double click has not just occurred\r\n                        if (btn === this._previousButtonPressed && Date.now() - this._previousStartingPointerTime < InputManager.DoubleClickDelay && !this._doubleClickOccured) {\r\n                            // pointer has not moved for 2 clicks, it's a double click\r\n                            if (!clickInfo.hasSwiped && !this._isPointerSwiping()) {\r\n                                this._previousStartingPointerTime = 0;\r\n                                this._doubleClickOccured = true;\r\n                                clickInfo.doubleClick = true;\r\n                                clickInfo.ignore = false;\r\n                                if (InputManager.ExclusiveDoubleClickMode && this._previousDelayedSimpleClickTimeout) {\r\n                                    clearTimeout(this._previousDelayedSimpleClickTimeout);\r\n                                }\r\n                                this._previousDelayedSimpleClickTimeout = this._delayedSimpleClickTimeout;\r\n                                cb(clickInfo, this._currentPickResult);\r\n                            }\r\n                            // if the two successive clicks are too far, it's just two simple clicks\r\n                            else {\r\n                                this._doubleClickOccured = false;\r\n                                this._previousStartingPointerTime = this._startingPointerTime;\r\n                                this._previousStartingPointerPosition.x = this._startingPointerPosition.x;\r\n                                this._previousStartingPointerPosition.y = this._startingPointerPosition.y;\r\n                                this._previousButtonPressed = btn;\r\n                                if (InputManager.ExclusiveDoubleClickMode) {\r\n                                    if (this._previousDelayedSimpleClickTimeout) {\r\n                                        clearTimeout(this._previousDelayedSimpleClickTimeout);\r\n                                    }\r\n                                    this._previousDelayedSimpleClickTimeout = this._delayedSimpleClickTimeout;\r\n\r\n                                    cb(clickInfo, this._previousPickResult);\r\n                                } else {\r\n                                    cb(clickInfo, this._currentPickResult);\r\n                                }\r\n                            }\r\n                            needToIgnoreNext = true;\r\n                        }\r\n                        // just the first click of the double has been raised\r\n                        else {\r\n                            this._doubleClickOccured = false;\r\n                            this._previousStartingPointerTime = this._startingPointerTime;\r\n                            this._previousStartingPointerPosition.x = this._startingPointerPosition.x;\r\n                            this._previousStartingPointerPosition.y = this._startingPointerPosition.y;\r\n                            this._previousButtonPressed = btn!;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!needToIgnoreNext) {\r\n                cb(clickInfo, this._currentPickResult);\r\n            }\r\n        };\r\n\r\n        this._onPointerMove = (evt: IMouseEvent) => {\r\n            // preserve compatibility with Safari when pointerId is not present\r\n            if ((evt as IPointerEvent).pointerId === undefined) {\r\n                (evt as IPointerEvent as any).pointerId = 0;\r\n            }\r\n\r\n            this._updatePointerPosition(evt as IPointerEvent);\r\n\r\n            // PreObservable support\r\n            if (\r\n                this._checkPrePointerObservable(\r\n                    null,\r\n                    evt as IPointerEvent,\r\n                    evt.type === \"wheel\" || evt.type === \"mousewheel\" || evt.type === \"DOMMouseScroll\" ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE\r\n                )\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            if (!scene.cameraToUseForPointers && !scene.activeCamera) {\r\n                return;\r\n            }\r\n\r\n            if (scene.skipPointerMovePicking) {\r\n                this._processPointerMove(new PickingInfo(), evt as IPointerEvent);\r\n                return;\r\n            }\r\n\r\n            if (!scene.pointerMovePredicate) {\r\n                scene.pointerMovePredicate = (mesh: AbstractMesh): boolean =>\r\n                    mesh.isPickable &&\r\n                    mesh.isVisible &&\r\n                    mesh.isReady() &&\r\n                    mesh.isEnabled() &&\r\n                    (mesh.enablePointerMoveEvents || scene.constantlyUpdateMeshUnderPointer || mesh._getActionManagerForTrigger() !== null) &&\r\n                    (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\r\n            }\r\n\r\n            // Meshes\r\n            const pickResult = scene.pick(\r\n                this._unTranslatedPointerX,\r\n                this._unTranslatedPointerY,\r\n                scene.pointerMovePredicate,\r\n                false,\r\n                scene.cameraToUseForPointers,\r\n                scene.pointerMoveTrianglePredicate\r\n            );\r\n\r\n            this._processPointerMove(pickResult, evt as IPointerEvent);\r\n        };\r\n\r\n        this._onPointerDown = (evt: IPointerEvent) => {\r\n            this._totalPointersPressed++;\r\n            this._pickedDownMesh = null;\r\n            this._meshPickProceed = false;\r\n\r\n            // preserve compatibility with Safari when pointerId is not present\r\n            if (evt.pointerId === undefined) {\r\n                (evt as any).pointerId = 0;\r\n            }\r\n\r\n            this._updatePointerPosition(evt);\r\n\r\n            if (scene.preventDefaultOnPointerDown && elementToAttachTo) {\r\n                evt.preventDefault();\r\n                elementToAttachTo.focus();\r\n            }\r\n\r\n            this._startingPointerPosition.x = this._pointerX;\r\n            this._startingPointerPosition.y = this._pointerY;\r\n            this._startingPointerTime = Date.now();\r\n\r\n            // PreObservable support\r\n            if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOWN)) {\r\n                return;\r\n            }\r\n\r\n            if (!scene.cameraToUseForPointers && !scene.activeCamera) {\r\n                return;\r\n            }\r\n\r\n            this._pointerCaptures[evt.pointerId] = true;\r\n\r\n            if (!scene.pointerDownPredicate) {\r\n                scene.pointerDownPredicate = (mesh: AbstractMesh): boolean => {\r\n                    return (\r\n                        mesh.isPickable &&\r\n                        mesh.isVisible &&\r\n                        mesh.isReady() &&\r\n                        mesh.isEnabled() &&\r\n                        (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0)\r\n                    );\r\n                };\r\n            }\r\n\r\n            // Meshes\r\n            this._pickedDownMesh = null;\r\n            let pickResult;\r\n            if (scene.skipPointerDownPicking) {\r\n                pickResult = new PickingInfo();\r\n            } else {\r\n                pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerDownPredicate, false, scene.cameraToUseForPointers);\r\n            }\r\n\r\n            this._processPointerDown(pickResult, evt);\r\n        };\r\n\r\n        this._onPointerUp = (evt: IPointerEvent) => {\r\n            if (this._totalPointersPressed === 0) {\r\n                // We are attaching the pointer up to windows because of a bug in FF\r\n                return; // So we need to test it the pointer down was pressed before.\r\n            }\r\n\r\n            this._totalPointersPressed--;\r\n            this._pickedUpMesh = null;\r\n            this._meshPickProceed = false;\r\n\r\n            // preserve compatibility with Safari when pointerId is not present\r\n            if (evt.pointerId === undefined) {\r\n                (evt as any).pointerId = 0;\r\n            }\r\n\r\n            this._updatePointerPosition(evt);\r\n\r\n            if (scene.preventDefaultOnPointerUp && elementToAttachTo) {\r\n                evt.preventDefault();\r\n                elementToAttachTo.focus();\r\n            }\r\n\r\n            this._initClickEvent(scene.onPrePointerObservable, scene.onPointerObservable, evt, (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => {\r\n                // PreObservable support\r\n                if (scene.onPrePointerObservable.hasObservers()) {\r\n                    if (!clickInfo.ignore) {\r\n                        if (!clickInfo.hasSwiped) {\r\n                            if (clickInfo.singleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {\r\n                                if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERTAP)) {\r\n                                    return;\r\n                                }\r\n                            }\r\n                            if (clickInfo.doubleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {\r\n                                if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOUBLETAP)) {\r\n                                    return;\r\n                                }\r\n                            }\r\n                        }\r\n                        if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERUP)) {\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!this._pointerCaptures[evt.pointerId] && evt.buttons > 0) {\r\n                    return;\r\n                }\r\n\r\n                this._pointerCaptures[evt.pointerId] = false;\r\n                if (!scene.cameraToUseForPointers && !scene.activeCamera) {\r\n                    return;\r\n                }\r\n\r\n                if (!scene.pointerUpPredicate) {\r\n                    scene.pointerUpPredicate = (mesh: AbstractMesh): boolean => {\r\n                        return (\r\n                            mesh.isPickable &&\r\n                            mesh.isVisible &&\r\n                            mesh.isReady() &&\r\n                            mesh.isEnabled() &&\r\n                            (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0)\r\n                        );\r\n                    };\r\n                }\r\n\r\n                // Meshes\r\n                if (!this._meshPickProceed && ((AbstractActionManager && AbstractActionManager.HasTriggers) || scene.onPointerObservable.hasObservers())) {\r\n                    this._initActionManager(null, clickInfo);\r\n                }\r\n                if (!pickResult) {\r\n                    pickResult = this._currentPickResult;\r\n                }\r\n\r\n                this._processPointerUp(pickResult, evt, clickInfo);\r\n\r\n                this._previousPickResult = this._currentPickResult;\r\n            });\r\n        };\r\n\r\n        this._onKeyDown = (evt: IKeyboardEvent) => {\r\n            const type = KeyboardEventTypes.KEYDOWN;\r\n            if (scene.onPreKeyboardObservable.hasObservers()) {\r\n                const pi = new KeyboardInfoPre(type, evt);\r\n                scene.onPreKeyboardObservable.notifyObservers(pi, type);\r\n                if (pi.skipOnKeyboardObservable) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (scene.onKeyboardObservable.hasObservers()) {\r\n                const pi = new KeyboardInfo(type, evt);\r\n                scene.onKeyboardObservable.notifyObservers(pi, type);\r\n            }\r\n\r\n            if (scene.actionManager) {\r\n                scene.actionManager.processTrigger(Constants.ACTION_OnKeyDownTrigger, ActionEvent.CreateNewFromScene(scene, evt));\r\n            }\r\n        };\r\n\r\n        this._onKeyUp = (evt: IKeyboardEvent) => {\r\n            const type = KeyboardEventTypes.KEYUP;\r\n            if (scene.onPreKeyboardObservable.hasObservers()) {\r\n                const pi = new KeyboardInfoPre(type, evt);\r\n                scene.onPreKeyboardObservable.notifyObservers(pi, type);\r\n                if (pi.skipOnKeyboardObservable) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (scene.onKeyboardObservable.hasObservers()) {\r\n                const pi = new KeyboardInfo(type, evt);\r\n                scene.onKeyboardObservable.notifyObservers(pi, type);\r\n            }\r\n\r\n            if (scene.actionManager) {\r\n                scene.actionManager.processTrigger(Constants.ACTION_OnKeyUpTrigger, ActionEvent.CreateNewFromScene(scene, evt));\r\n            }\r\n        };\r\n\r\n        // If a device connects that we can handle, wire up the observable\r\n        this._deviceSourceManager.onDeviceConnectedObservable.add((deviceSource) => {\r\n            if (deviceSource.deviceType === DeviceType.Mouse) {\r\n                deviceSource.onInputChangedObservable.add((eventData) => {\r\n                    if (eventData.inputIndex === PointerInput.LeftClick || eventData.inputIndex === PointerInput.MiddleClick || eventData.inputIndex === PointerInput.RightClick) {\r\n                        if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {\r\n                            this._onPointerDown(eventData);\r\n                        } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {\r\n                            this._onPointerUp(eventData);\r\n                        }\r\n                    } else if (attachMove) {\r\n                        if (eventData.inputIndex === PointerInput.Move) {\r\n                            this._onPointerMove(eventData);\r\n                        } else if (\r\n                            eventData.inputIndex === PointerInput.MouseWheelX ||\r\n                            eventData.inputIndex === PointerInput.MouseWheelY ||\r\n                            eventData.inputIndex === PointerInput.MouseWheelZ\r\n                        ) {\r\n                            this._onPointerMove(eventData);\r\n                        }\r\n                    }\r\n                });\r\n            } else if (deviceSource.deviceType === DeviceType.Touch) {\r\n                deviceSource.onInputChangedObservable.add((eventData) => {\r\n                    if (eventData.inputIndex === PointerInput.LeftClick) {\r\n                        if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {\r\n                            this._onPointerDown(eventData);\r\n                        } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {\r\n                            this._onPointerUp(eventData);\r\n                        }\r\n                    }\r\n\r\n                    if (attachMove && eventData.inputIndex === PointerInput.Move) {\r\n                        this._onPointerMove(eventData);\r\n                    }\r\n                });\r\n            } else if (deviceSource.deviceType === DeviceType.Keyboard) {\r\n                deviceSource.onInputChangedObservable.add((eventData) => {\r\n                    if (eventData.type === \"keydown\") {\r\n                        this._onKeyDown(eventData);\r\n                    } else if (eventData.type === \"keyup\") {\r\n                        this._onKeyUp(eventData);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n        this._alreadyAttached = true;\r\n    }\r\n\r\n    /**\r\n     * Detaches all event handlers\r\n     */\r\n    public detachControl() {\r\n        if (this._alreadyAttached) {\r\n            this._deviceSourceManager!.dispose();\r\n            this._deviceSourceManager = null;\r\n\r\n            // Cursor\r\n            if (this._alreadyAttachedTo && !this._scene.doNotHandleCursors) {\r\n                this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor;\r\n            }\r\n\r\n            this._alreadyAttached = false;\r\n            this._alreadyAttachedTo = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force the value of meshUnderPointer\r\n     * @param mesh - defines the mesh to use\r\n     * @param pointerId - optional pointer id when using more than one pointer. Defaults to 0\r\n     * @param pickResult - optional pickingInfo data used to find mesh\r\n     */\r\n    public setPointerOverMesh(mesh: Nullable<AbstractMesh>, pointerId: number = 0, pickResult?: Nullable<PickingInfo>): void {\r\n        if (this._meshUnderPointerId[pointerId] === mesh) {\r\n            return;\r\n        }\r\n\r\n        const underPointerMesh = this._meshUnderPointerId[pointerId];\r\n\r\n        let actionManager: Nullable<AbstractActionManager>;\r\n        if (underPointerMesh) {\r\n            actionManager = underPointerMesh._getActionManagerForTrigger(Constants.ACTION_OnPointerOutTrigger);\r\n            if (actionManager) {\r\n                actionManager.processTrigger(Constants.ACTION_OnPointerOutTrigger, ActionEvent.CreateNew(underPointerMesh, undefined, { pointerId }));\r\n            }\r\n        }\r\n\r\n        if (mesh) {\r\n            this._meshUnderPointerId[pointerId] = mesh;\r\n            this._pointerOverMesh = mesh;\r\n\r\n            actionManager = mesh._getActionManagerForTrigger(Constants.ACTION_OnPointerOverTrigger);\r\n            if (actionManager) {\r\n                actionManager.processTrigger(Constants.ACTION_OnPointerOverTrigger, ActionEvent.CreateNew(mesh, undefined, { pointerId, pickResult }));\r\n            }\r\n        } else {\r\n            delete this._meshUnderPointerId[pointerId];\r\n            this._pointerOverMesh = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the mesh under the pointer\r\n     * @returns a Mesh or null if no mesh is under the pointer\r\n     */\r\n    public getPointerOverMesh(): Nullable<AbstractMesh> {\r\n        return this._pointerOverMesh;\r\n    }\r\n\r\n    /**\r\n     * @param mesh - Mesh to invalidate\r\n     * @hidden\r\n     */\r\n    public _invalidateMesh(mesh: AbstractMesh) {\r\n        if (this._pointerOverMesh === mesh) {\r\n            this._pointerOverMesh = null;\r\n        }\r\n        if (this._pickedDownMesh === mesh) {\r\n            this._pickedDownMesh = null;\r\n        }\r\n        if (this._pickedUpMesh === mesh) {\r\n            this._pickedUpMesh = null;\r\n        }\r\n        for (const pointerId in this._meshUnderPointerId) {\r\n            if (this._meshUnderPointerId[pointerId] === mesh) {\r\n                delete this._meshUnderPointerId[pointerId];\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}