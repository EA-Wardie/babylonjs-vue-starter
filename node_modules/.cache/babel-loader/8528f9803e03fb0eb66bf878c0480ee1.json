{"ast":null,"code":"import \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport { Scalar } from \"./math.scalar.js\";\nimport { Vector2, Vector3, Quaternion, Matrix } from \"./math.vector.js\";\nimport { Epsilon } from \"./math.constants.js\";\n/**\n * Defines potential orientation for back face culling\n */\n\nexport var Orientation;\n\n(function (Orientation) {\n  /**\n   * Clockwise\n   */\n  Orientation[Orientation[\"CW\"] = 0] = \"CW\";\n  /** Counter clockwise */\n\n  Orientation[Orientation[\"CCW\"] = 1] = \"CCW\";\n})(Orientation || (Orientation = {}));\n/** Class used to represent a Bezier curve */\n\n\nvar BezierCurve =\n/** @class */\nfunction () {\n  function BezierCurve() {}\n  /**\n   * Returns the cubic Bezier interpolated value (float) at \"t\" (float) from the given x1, y1, x2, y2 floats\n   * @param t defines the time\n   * @param x1 defines the left coordinate on X axis\n   * @param y1 defines the left coordinate on Y axis\n   * @param x2 defines the right coordinate on X axis\n   * @param y2 defines the right coordinate on Y axis\n   * @returns the interpolated value\n   */\n\n\n  BezierCurve.Interpolate = function (t, x1, y1, x2, y2) {\n    // Extract X (which is equal to time here)\n    var f0 = 1 - 3 * x2 + 3 * x1;\n    var f1 = 3 * x2 - 6 * x1;\n    var f2 = 3 * x1;\n    var refinedT = t;\n\n    for (var i = 0; i < 5; i++) {\n      var refinedT2 = refinedT * refinedT;\n      var refinedT3 = refinedT2 * refinedT;\n      var x = f0 * refinedT3 + f1 * refinedT2 + f2 * refinedT;\n      var slope = 1.0 / (3.0 * f0 * refinedT2 + 2.0 * f1 * refinedT + f2);\n      refinedT -= (x - t) * slope;\n      refinedT = Math.min(1, Math.max(0, refinedT));\n    } // Resolve cubic bezier for the given x\n\n\n    return 3 * Math.pow(1 - refinedT, 2) * refinedT * y1 + 3 * (1 - refinedT) * Math.pow(refinedT, 2) * y2 + Math.pow(refinedT, 3);\n  };\n\n  return BezierCurve;\n}();\n\nexport { BezierCurve };\n/**\n * Defines angle representation\n */\n\nvar Angle =\n/** @class */\nfunction () {\n  /**\n   * Creates an Angle object of \"radians\" radians (float).\n   * @param radians the angle in radians\n   */\n  function Angle(radians) {\n    this._radians = radians;\n\n    if (this._radians < 0.0) {\n      this._radians += 2.0 * Math.PI;\n    }\n  }\n  /**\n   * Get value in degrees\n   * @returns the Angle value in degrees (float)\n   */\n\n\n  Angle.prototype.degrees = function () {\n    return this._radians * 180.0 / Math.PI;\n  };\n  /**\n   * Get value in radians\n   * @returns the Angle value in radians (float)\n   */\n\n\n  Angle.prototype.radians = function () {\n    return this._radians;\n  };\n  /**\n   * Gets a new Angle object valued with the gradient angle, in radians, of the line joining two points\n   * @param a defines first point as the origin\n   * @param b defines point\n   * @returns a new Angle\n   */\n\n\n  Angle.BetweenTwoPoints = function (a, b) {\n    var delta = b.subtract(a);\n    var theta = Math.atan2(delta.y, delta.x);\n    return new Angle(theta);\n  };\n  /**\n   * Gets a new Angle object from the given float in radians\n   * @param radians defines the angle value in radians\n   * @returns a new Angle\n   */\n\n\n  Angle.FromRadians = function (radians) {\n    return new Angle(radians);\n  };\n  /**\n   * Gets a new Angle object from the given float in degrees\n   * @param degrees defines the angle value in degrees\n   * @returns a new Angle\n   */\n\n\n  Angle.FromDegrees = function (degrees) {\n    return new Angle(degrees * Math.PI / 180.0);\n  };\n\n  return Angle;\n}();\n\nexport { Angle };\n/**\n * This represents an arc in a 2d space.\n */\n\nvar Arc2 =\n/** @class */\nfunction () {\n  /**\n   * Creates an Arc object from the three given points : start, middle and end.\n   * @param startPoint Defines the start point of the arc\n   * @param midPoint Defines the middle point of the arc\n   * @param endPoint Defines the end point of the arc\n   */\n  function Arc2(\n  /** Defines the start point of the arc */\n  startPoint,\n  /** Defines the mid point of the arc */\n  midPoint,\n  /** Defines the end point of the arc */\n  endPoint) {\n    this.startPoint = startPoint;\n    this.midPoint = midPoint;\n    this.endPoint = endPoint;\n    var temp = Math.pow(midPoint.x, 2) + Math.pow(midPoint.y, 2);\n    var startToMid = (Math.pow(startPoint.x, 2) + Math.pow(startPoint.y, 2) - temp) / 2;\n    var midToEnd = (temp - Math.pow(endPoint.x, 2) - Math.pow(endPoint.y, 2)) / 2;\n    var det = (startPoint.x - midPoint.x) * (midPoint.y - endPoint.y) - (midPoint.x - endPoint.x) * (startPoint.y - midPoint.y);\n    this.centerPoint = new Vector2((startToMid * (midPoint.y - endPoint.y) - midToEnd * (startPoint.y - midPoint.y)) / det, ((startPoint.x - midPoint.x) * midToEnd - (midPoint.x - endPoint.x) * startToMid) / det);\n    this.radius = this.centerPoint.subtract(this.startPoint).length();\n    this.startAngle = Angle.BetweenTwoPoints(this.centerPoint, this.startPoint);\n    var a1 = this.startAngle.degrees();\n    var a2 = Angle.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees();\n    var a3 = Angle.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees(); // angles correction\n\n    if (a2 - a1 > +180.0) {\n      a2 -= 360.0;\n    }\n\n    if (a2 - a1 < -180.0) {\n      a2 += 360.0;\n    }\n\n    if (a3 - a2 > +180.0) {\n      a3 -= 360.0;\n    }\n\n    if (a3 - a2 < -180.0) {\n      a3 += 360.0;\n    }\n\n    this.orientation = a2 - a1 < 0 ? Orientation.CW : Orientation.CCW;\n    this.angle = Angle.FromDegrees(this.orientation === Orientation.CW ? a1 - a3 : a3 - a1);\n  }\n\n  return Arc2;\n}();\n\nexport { Arc2 };\n/**\n * Represents a 2D path made up of multiple 2D points\n */\n\nvar Path2 =\n/** @class */\nfunction () {\n  /**\n   * Creates a Path2 object from the starting 2D coordinates x and y.\n   * @param x the starting points x value\n   * @param y the starting points y value\n   */\n  function Path2(x, y) {\n    this._points = new Array();\n    this._length = 0.0;\n    /**\n     * If the path start and end point are the same\n     */\n\n    this.closed = false;\n\n    this._points.push(new Vector2(x, y));\n  }\n  /**\n   * Adds a new segment until the given coordinates (x, y) to the current Path2.\n   * @param x the added points x value\n   * @param y the added points y value\n   * @returns the updated Path2.\n   */\n\n\n  Path2.prototype.addLineTo = function (x, y) {\n    if (this.closed) {\n      return this;\n    }\n\n    var newPoint = new Vector2(x, y);\n    var previousPoint = this._points[this._points.length - 1];\n\n    this._points.push(newPoint);\n\n    this._length += newPoint.subtract(previousPoint).length();\n    return this;\n  };\n  /**\n   * Adds _numberOfSegments_ segments according to the arc definition (middle point coordinates, end point coordinates, the arc start point being the current Path2 last point) to the current Path2.\n   * @param midX middle point x value\n   * @param midY middle point y value\n   * @param endX end point x value\n   * @param endY end point y value\n   * @param numberOfSegments (default: 36)\n   * @returns the updated Path2.\n   */\n\n\n  Path2.prototype.addArcTo = function (midX, midY, endX, endY, numberOfSegments) {\n    if (numberOfSegments === void 0) {\n      numberOfSegments = 36;\n    }\n\n    if (this.closed) {\n      return this;\n    }\n\n    var startPoint = this._points[this._points.length - 1];\n    var midPoint = new Vector2(midX, midY);\n    var endPoint = new Vector2(endX, endY);\n    var arc = new Arc2(startPoint, midPoint, endPoint);\n    var increment = arc.angle.radians() / numberOfSegments;\n\n    if (arc.orientation === Orientation.CW) {\n      increment *= -1;\n    }\n\n    var currentAngle = arc.startAngle.radians() + increment;\n\n    for (var i = 0; i < numberOfSegments; i++) {\n      var x = Math.cos(currentAngle) * arc.radius + arc.centerPoint.x;\n      var y = Math.sin(currentAngle) * arc.radius + arc.centerPoint.y;\n      this.addLineTo(x, y);\n      currentAngle += increment;\n    }\n\n    return this;\n  };\n  /**\n   * Closes the Path2.\n   * @returns the Path2.\n   */\n\n\n  Path2.prototype.close = function () {\n    this.closed = true;\n    return this;\n  };\n  /**\n   * Gets the sum of the distance between each sequential point in the path\n   * @returns the Path2 total length (float).\n   */\n\n\n  Path2.prototype.length = function () {\n    var result = this._length;\n\n    if (this.closed) {\n      var lastPoint = this._points[this._points.length - 1];\n      var firstPoint = this._points[0];\n      result += firstPoint.subtract(lastPoint).length();\n    }\n\n    return result;\n  };\n  /**\n   * Gets the points which construct the path\n   * @returns the Path2 internal array of points.\n   */\n\n\n  Path2.prototype.getPoints = function () {\n    return this._points;\n  };\n  /**\n   * Retreives the point at the distance aways from the starting point\n   * @param normalizedLengthPosition the length along the path to retrieve the point from\n   * @returns a new Vector2 located at a percentage of the Path2 total length on this path.\n   */\n\n\n  Path2.prototype.getPointAtLengthPosition = function (normalizedLengthPosition) {\n    if (normalizedLengthPosition < 0 || normalizedLengthPosition > 1) {\n      return Vector2.Zero();\n    }\n\n    var lengthPosition = normalizedLengthPosition * this.length();\n    var previousOffset = 0;\n\n    for (var i = 0; i < this._points.length; i++) {\n      var j = (i + 1) % this._points.length;\n      var a = this._points[i];\n      var b = this._points[j];\n      var bToA = b.subtract(a);\n      var nextOffset = bToA.length() + previousOffset;\n\n      if (lengthPosition >= previousOffset && lengthPosition <= nextOffset) {\n        var dir = bToA.normalize();\n        var localOffset = lengthPosition - previousOffset;\n        return new Vector2(a.x + dir.x * localOffset, a.y + dir.y * localOffset);\n      }\n\n      previousOffset = nextOffset;\n    }\n\n    return Vector2.Zero();\n  };\n  /**\n   * Creates a new path starting from an x and y position\n   * @param x starting x value\n   * @param y starting y value\n   * @returns a new Path2 starting at the coordinates (x, y).\n   */\n\n\n  Path2.StartingAt = function (x, y) {\n    return new Path2(x, y);\n  };\n\n  return Path2;\n}();\n\nexport { Path2 };\n/**\n * Represents a 3D path made up of multiple 3D points\n * @see https://doc.babylonjs.com/divingDeeper/mesh/path3D\n */\n\nvar Path3D =\n/** @class */\nfunction () {\n  /**\n   * new Path3D(path, normal, raw)\n   * Creates a Path3D. A Path3D is a logical math object, so not a mesh.\n   * please read the description in the tutorial : https://doc.babylonjs.com/how_to/how_to_use_path3d\n   * @param path an array of Vector3, the curve axis of the Path3D\n   * @param firstNormal (options) Vector3, the first wanted normal to the curve. Ex (0, 1, 0) for a vertical normal.\n   * @param raw (optional, default false) : boolean, if true the returned Path3D isn't normalized. Useful to depict path acceleration or speed.\n   * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path.\n   */\n  function Path3D(\n  /**\n   * an array of Vector3, the curve axis of the Path3D\n   */\n  path, firstNormal, raw, alignTangentsWithPath) {\n    if (firstNormal === void 0) {\n      firstNormal = null;\n    }\n\n    if (alignTangentsWithPath === void 0) {\n      alignTangentsWithPath = false;\n    }\n\n    this.path = path;\n    this._curve = new Array();\n    this._distances = new Array();\n    this._tangents = new Array();\n    this._normals = new Array();\n    this._binormals = new Array(); // holds interpolated point data\n\n    this._pointAtData = {\n      id: 0,\n      point: Vector3.Zero(),\n      previousPointArrayIndex: 0,\n      position: 0,\n      subPosition: 0,\n      interpolateReady: false,\n      interpolationMatrix: Matrix.Identity()\n    };\n\n    for (var p = 0; p < path.length; p++) {\n      this._curve[p] = path[p].clone(); // hard copy\n    }\n\n    this._raw = raw || false;\n    this._alignTangentsWithPath = alignTangentsWithPath;\n\n    this._compute(firstNormal, alignTangentsWithPath);\n  }\n  /**\n   * Returns the Path3D array of successive Vector3 designing its curve.\n   * @returns the Path3D array of successive Vector3 designing its curve.\n   */\n\n\n  Path3D.prototype.getCurve = function () {\n    return this._curve;\n  };\n  /**\n   * Returns the Path3D array of successive Vector3 designing its curve.\n   * @returns the Path3D array of successive Vector3 designing its curve.\n   */\n\n\n  Path3D.prototype.getPoints = function () {\n    return this._curve;\n  };\n  /**\n   * @returns the computed length (float) of the path.\n   */\n\n\n  Path3D.prototype.length = function () {\n    return this._distances[this._distances.length - 1];\n  };\n  /**\n   * Returns an array populated with tangent vectors on each Path3D curve point.\n   * @returns an array populated with tangent vectors on each Path3D curve point.\n   */\n\n\n  Path3D.prototype.getTangents = function () {\n    return this._tangents;\n  };\n  /**\n   * Returns an array populated with normal vectors on each Path3D curve point.\n   * @returns an array populated with normal vectors on each Path3D curve point.\n   */\n\n\n  Path3D.prototype.getNormals = function () {\n    return this._normals;\n  };\n  /**\n   * Returns an array populated with binormal vectors on each Path3D curve point.\n   * @returns an array populated with binormal vectors on each Path3D curve point.\n   */\n\n\n  Path3D.prototype.getBinormals = function () {\n    return this._binormals;\n  };\n  /**\n   * Returns an array populated with distances (float) of the i-th point from the first curve point.\n   * @returns an array populated with distances (float) of the i-th point from the first curve point.\n   */\n\n\n  Path3D.prototype.getDistances = function () {\n    return this._distances;\n  };\n  /**\n   * Returns an interpolated point along this path\n   * @param position the position of the point along this path, from 0.0 to 1.0\n   * @returns a new Vector3 as the point\n   */\n\n\n  Path3D.prototype.getPointAt = function (position) {\n    return this._updatePointAtData(position).point;\n  };\n  /**\n   * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.\n   * @param position the position of the point along this path, from 0.0 to 1.0\n   * @param interpolated (optional, default false) : boolean, if true returns an interpolated tangent instead of the tangent of the previous path point.\n   * @returns a tangent vector corresponding to the interpolated Path3D curve point, if not interpolated, the tangent is taken from the precomputed tangents array.\n   */\n\n\n  Path3D.prototype.getTangentAt = function (position, interpolated) {\n    if (interpolated === void 0) {\n      interpolated = false;\n    }\n\n    this._updatePointAtData(position, interpolated);\n\n    return interpolated ? Vector3.TransformCoordinates(Vector3.Forward(), this._pointAtData.interpolationMatrix) : this._tangents[this._pointAtData.previousPointArrayIndex];\n  };\n  /**\n   * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.\n   * @param position the position of the point along this path, from 0.0 to 1.0\n   * @param interpolated (optional, default false) : boolean, if true returns an interpolated normal instead of the normal of the previous path point.\n   * @returns a normal vector corresponding to the interpolated Path3D curve point, if not interpolated, the normal is taken from the precomputed normals array.\n   */\n\n\n  Path3D.prototype.getNormalAt = function (position, interpolated) {\n    if (interpolated === void 0) {\n      interpolated = false;\n    }\n\n    this._updatePointAtData(position, interpolated);\n\n    return interpolated ? Vector3.TransformCoordinates(Vector3.Right(), this._pointAtData.interpolationMatrix) : this._normals[this._pointAtData.previousPointArrayIndex];\n  };\n  /**\n   * Returns the binormal vector of an interpolated Path3D curve point at the specified position along this path.\n   * @param position the position of the point along this path, from 0.0 to 1.0\n   * @param interpolated (optional, default false) : boolean, if true returns an interpolated binormal instead of the binormal of the previous path point.\n   * @returns a binormal vector corresponding to the interpolated Path3D curve point, if not interpolated, the binormal is taken from the precomputed binormals array.\n   */\n\n\n  Path3D.prototype.getBinormalAt = function (position, interpolated) {\n    if (interpolated === void 0) {\n      interpolated = false;\n    }\n\n    this._updatePointAtData(position, interpolated);\n\n    return interpolated ? Vector3.TransformCoordinates(Vector3.UpReadOnly, this._pointAtData.interpolationMatrix) : this._binormals[this._pointAtData.previousPointArrayIndex];\n  };\n  /**\n   * Returns the distance (float) of an interpolated Path3D curve point at the specified position along this path.\n   * @param position the position of the point along this path, from 0.0 to 1.0\n   * @returns the distance of the interpolated Path3D curve point at the specified position along this path.\n   */\n\n\n  Path3D.prototype.getDistanceAt = function (position) {\n    return this.length() * position;\n  };\n  /**\n   * Returns the array index of the previous point of an interpolated point along this path\n   * @param position the position of the point to interpolate along this path, from 0.0 to 1.0\n   * @returns the array index\n   */\n\n\n  Path3D.prototype.getPreviousPointIndexAt = function (position) {\n    this._updatePointAtData(position);\n\n    return this._pointAtData.previousPointArrayIndex;\n  };\n  /**\n   * Returns the position of an interpolated point relative to the two path points it lies between, from 0.0 (point A) to 1.0 (point B)\n   * @param position the position of the point to interpolate along this path, from 0.0 to 1.0\n   * @returns the sub position\n   */\n\n\n  Path3D.prototype.getSubPositionAt = function (position) {\n    this._updatePointAtData(position);\n\n    return this._pointAtData.subPosition;\n  };\n  /**\n   * Returns the position of the closest virtual point on this path to an arbitrary Vector3, from 0.0 to 1.0\n   * @param target the vector of which to get the closest position to\n   * @returns the position of the closest virtual point on this path to the target vector\n   */\n\n\n  Path3D.prototype.getClosestPositionTo = function (target) {\n    var smallestDistance = Number.MAX_VALUE;\n    var closestPosition = 0.0;\n\n    for (var i = 0; i < this._curve.length - 1; i++) {\n      var point = this._curve[i + 0];\n\n      var tangent = this._curve[i + 1].subtract(point).normalize();\n\n      var subLength = this._distances[i + 1] - this._distances[i + 0];\n      var subPosition = Math.min(Math.max(Vector3.Dot(tangent, target.subtract(point).normalize()), 0.0) * Vector3.Distance(point, target) / subLength, 1.0);\n      var distance = Vector3.Distance(point.add(tangent.scale(subPosition * subLength)), target);\n\n      if (distance < smallestDistance) {\n        smallestDistance = distance;\n        closestPosition = (this._distances[i + 0] + subLength * subPosition) / this.length();\n      }\n    }\n\n    return closestPosition;\n  };\n  /**\n   * Returns a sub path (slice) of this path\n   * @param start the position of the fist path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values\n   * @param end the position of the last path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values\n   * @returns a sub path (slice) of this path\n   */\n\n\n  Path3D.prototype.slice = function (start, end) {\n    if (start === void 0) {\n      start = 0.0;\n    }\n\n    if (end === void 0) {\n      end = 1.0;\n    }\n\n    if (start < 0.0) {\n      start = 1 - start * -1.0 % 1.0;\n    }\n\n    if (end < 0.0) {\n      end = 1 - end * -1.0 % 1.0;\n    }\n\n    if (start > end) {\n      var _start = start;\n      start = end;\n      end = _start;\n    }\n\n    var curvePoints = this.getCurve();\n    var startPoint = this.getPointAt(start);\n    var startIndex = this.getPreviousPointIndexAt(start);\n    var endPoint = this.getPointAt(end);\n    var endIndex = this.getPreviousPointIndexAt(end) + 1;\n    var slicePoints = [];\n\n    if (start !== 0.0) {\n      startIndex++;\n      slicePoints.push(startPoint);\n    }\n\n    slicePoints.push.apply(slicePoints, curvePoints.slice(startIndex, endIndex));\n\n    if (end !== 1.0 || start === 1.0) {\n      slicePoints.push(endPoint);\n    }\n\n    return new Path3D(slicePoints, this.getNormalAt(start), this._raw, this._alignTangentsWithPath);\n  };\n  /**\n   * Forces the Path3D tangent, normal, binormal and distance recomputation.\n   * @param path path which all values are copied into the curves points\n   * @param firstNormal which should be projected onto the curve\n   * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path\n   * @returns the same object updated.\n   */\n\n\n  Path3D.prototype.update = function (path, firstNormal, alignTangentsWithPath) {\n    if (firstNormal === void 0) {\n      firstNormal = null;\n    }\n\n    if (alignTangentsWithPath === void 0) {\n      alignTangentsWithPath = false;\n    }\n\n    for (var p = 0; p < path.length; p++) {\n      this._curve[p].x = path[p].x;\n      this._curve[p].y = path[p].y;\n      this._curve[p].z = path[p].z;\n    }\n\n    this._compute(firstNormal, alignTangentsWithPath);\n\n    return this;\n  }; // private function compute() : computes tangents, normals and binormals\n\n\n  Path3D.prototype._compute = function (firstNormal, alignTangentsWithPath) {\n    if (alignTangentsWithPath === void 0) {\n      alignTangentsWithPath = false;\n    }\n\n    var l = this._curve.length;\n\n    if (l < 2) {\n      return;\n    } // first and last tangents\n\n\n    this._tangents[0] = this._getFirstNonNullVector(0);\n\n    if (!this._raw) {\n      this._tangents[0].normalize();\n    }\n\n    this._tangents[l - 1] = this._curve[l - 1].subtract(this._curve[l - 2]);\n\n    if (!this._raw) {\n      this._tangents[l - 1].normalize();\n    } // normals and binormals at first point : arbitrary vector with _normalVector()\n\n\n    var tg0 = this._tangents[0];\n\n    var pp0 = this._normalVector(tg0, firstNormal);\n\n    this._normals[0] = pp0;\n\n    if (!this._raw) {\n      this._normals[0].normalize();\n    }\n\n    this._binormals[0] = Vector3.Cross(tg0, this._normals[0]);\n\n    if (!this._raw) {\n      this._binormals[0].normalize();\n    }\n\n    this._distances[0] = 0.0; // normals and binormals : next points\n\n    var prev; // previous vector (segment)\n\n    var cur; // current vector (segment)\n\n    var curTang; // current tangent\n    // previous normal\n\n    var prevNor; // previous normal\n\n    var prevBinor; // previous binormal\n\n    for (var i = 1; i < l; i++) {\n      // tangents\n      prev = this._getLastNonNullVector(i);\n\n      if (i < l - 1) {\n        cur = this._getFirstNonNullVector(i);\n        this._tangents[i] = alignTangentsWithPath ? cur : prev.add(cur);\n\n        this._tangents[i].normalize();\n      }\n\n      this._distances[i] = this._distances[i - 1] + this._curve[i].subtract(this._curve[i - 1]).length(); // normals and binormals\n      // http://www.cs.cmu.edu/afs/andrew/scs/cs/15-462/web/old/asst2camera.html\n\n      curTang = this._tangents[i];\n      prevBinor = this._binormals[i - 1];\n      this._normals[i] = Vector3.Cross(prevBinor, curTang);\n\n      if (!this._raw) {\n        if (this._normals[i].length() === 0) {\n          prevNor = this._normals[i - 1];\n          this._normals[i] = prevNor.clone();\n        } else {\n          this._normals[i].normalize();\n        }\n      }\n\n      this._binormals[i] = Vector3.Cross(curTang, this._normals[i]);\n\n      if (!this._raw) {\n        this._binormals[i].normalize();\n      }\n    }\n\n    this._pointAtData.id = NaN;\n  }; // private function getFirstNonNullVector(index)\n  // returns the first non null vector from index : curve[index + N].subtract(curve[index])\n\n\n  Path3D.prototype._getFirstNonNullVector = function (index) {\n    var i = 1;\n\n    var nNVector = this._curve[index + i].subtract(this._curve[index]);\n\n    while (nNVector.length() === 0 && index + i + 1 < this._curve.length) {\n      i++;\n      nNVector = this._curve[index + i].subtract(this._curve[index]);\n    }\n\n    return nNVector;\n  }; // private function getLastNonNullVector(index)\n  // returns the last non null vector from index : curve[index].subtract(curve[index - N])\n\n\n  Path3D.prototype._getLastNonNullVector = function (index) {\n    var i = 1;\n\n    var nLVector = this._curve[index].subtract(this._curve[index - i]);\n\n    while (nLVector.length() === 0 && index > i + 1) {\n      i++;\n      nLVector = this._curve[index].subtract(this._curve[index - i]);\n    }\n\n    return nLVector;\n  }; // private function normalVector(v0, vt, va) :\n  // returns an arbitrary point in the plane defined by the point v0 and the vector vt orthogonal to this plane\n  // if va is passed, it returns the va projection on the plane orthogonal to vt at the point v0\n\n\n  Path3D.prototype._normalVector = function (vt, va) {\n    var normal0;\n    var tgl = vt.length();\n\n    if (tgl === 0.0) {\n      tgl = 1.0;\n    }\n\n    if (va === undefined || va === null) {\n      var point = void 0;\n\n      if (!Scalar.WithinEpsilon(Math.abs(vt.y) / tgl, 1.0, Epsilon)) {\n        // search for a point in the plane\n        point = new Vector3(0.0, -1.0, 0.0);\n      } else if (!Scalar.WithinEpsilon(Math.abs(vt.x) / tgl, 1.0, Epsilon)) {\n        point = new Vector3(1.0, 0.0, 0.0);\n      } else if (!Scalar.WithinEpsilon(Math.abs(vt.z) / tgl, 1.0, Epsilon)) {\n        point = new Vector3(0.0, 0.0, 1.0);\n      } else {\n        point = Vector3.Zero();\n      }\n\n      normal0 = Vector3.Cross(vt, point);\n    } else {\n      normal0 = Vector3.Cross(vt, va);\n      Vector3.CrossToRef(normal0, vt, normal0);\n    }\n\n    normal0.normalize();\n    return normal0;\n  };\n  /**\n   * Updates the point at data for an interpolated point along this curve\n   * @param position the position of the point along this curve, from 0.0 to 1.0\n   * @param interpolateTNB\n   * @interpolateTNB whether to compute the interpolated tangent, normal and binormal\n   * @returns the (updated) point at data\n   */\n\n\n  Path3D.prototype._updatePointAtData = function (position, interpolateTNB) {\n    if (interpolateTNB === void 0) {\n      interpolateTNB = false;\n    } // set an id for caching the result\n\n\n    if (this._pointAtData.id === position) {\n      if (!this._pointAtData.interpolateReady) {\n        this._updateInterpolationMatrix();\n      }\n\n      return this._pointAtData;\n    } else {\n      this._pointAtData.id = position;\n    }\n\n    var curvePoints = this.getPoints(); // clamp position between 0.0 and 1.0\n\n    if (position <= 0.0) {\n      return this._setPointAtData(0.0, 0.0, curvePoints[0], 0, interpolateTNB);\n    } else if (position >= 1.0) {\n      return this._setPointAtData(1.0, 1.0, curvePoints[curvePoints.length - 1], curvePoints.length - 1, interpolateTNB);\n    }\n\n    var previousPoint = curvePoints[0];\n    var currentPoint;\n    var currentLength = 0.0;\n    var targetLength = position * this.length();\n\n    for (var i = 1; i < curvePoints.length; i++) {\n      currentPoint = curvePoints[i];\n      var distance = Vector3.Distance(previousPoint, currentPoint);\n      currentLength += distance;\n\n      if (currentLength === targetLength) {\n        return this._setPointAtData(position, 1.0, currentPoint, i, interpolateTNB);\n      } else if (currentLength > targetLength) {\n        var toLength = currentLength - targetLength;\n        var diff = toLength / distance;\n        var dir = previousPoint.subtract(currentPoint);\n        var point = currentPoint.add(dir.scaleInPlace(diff));\n        return this._setPointAtData(position, 1 - diff, point, i - 1, interpolateTNB);\n      }\n\n      previousPoint = currentPoint;\n    }\n\n    return this._pointAtData;\n  };\n  /**\n   * Updates the point at data from the specified parameters\n   * @param position where along the path the interpolated point is, from 0.0 to 1.0\n   * @param subPosition\n   * @param point the interpolated point\n   * @param parentIndex the index of an existing curve point that is on, or else positionally the first behind, the interpolated point\n   * @param interpolateTNB\n   */\n\n\n  Path3D.prototype._setPointAtData = function (position, subPosition, point, parentIndex, interpolateTNB) {\n    this._pointAtData.point = point;\n    this._pointAtData.position = position;\n    this._pointAtData.subPosition = subPosition;\n    this._pointAtData.previousPointArrayIndex = parentIndex;\n    this._pointAtData.interpolateReady = interpolateTNB;\n\n    if (interpolateTNB) {\n      this._updateInterpolationMatrix();\n    }\n\n    return this._pointAtData;\n  };\n  /**\n   * Updates the point at interpolation matrix for the tangents, normals and binormals\n   */\n\n\n  Path3D.prototype._updateInterpolationMatrix = function () {\n    this._pointAtData.interpolationMatrix = Matrix.Identity();\n    var parentIndex = this._pointAtData.previousPointArrayIndex;\n\n    if (parentIndex !== this._tangents.length - 1) {\n      var index = parentIndex + 1;\n\n      var tangentFrom = this._tangents[parentIndex].clone();\n\n      var normalFrom = this._normals[parentIndex].clone();\n\n      var binormalFrom = this._binormals[parentIndex].clone();\n\n      var tangentTo = this._tangents[index].clone();\n\n      var normalTo = this._normals[index].clone();\n\n      var binormalTo = this._binormals[index].clone();\n\n      var quatFrom = Quaternion.RotationQuaternionFromAxis(normalFrom, binormalFrom, tangentFrom);\n      var quatTo = Quaternion.RotationQuaternionFromAxis(normalTo, binormalTo, tangentTo);\n      var quatAt = Quaternion.Slerp(quatFrom, quatTo, this._pointAtData.subPosition);\n      quatAt.toRotationMatrix(this._pointAtData.interpolationMatrix);\n    }\n  };\n\n  return Path3D;\n}();\n\nexport { Path3D };\n/**\n * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\n * A Curve3 is designed from a series of successive Vector3.\n * @see https://doc.babylonjs.com/how_to/how_to_use_curve3\n */\n\nvar Curve3 =\n/** @class */\nfunction () {\n  /**\n   * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\n   * A Curve3 is designed from a series of successive Vector3.\n   * Tuto : https://doc.babylonjs.com/how_to/how_to_use_curve3#curve3-object\n   * @param points points which make up the curve\n   */\n  function Curve3(points) {\n    this._length = 0.0;\n    this._points = points;\n    this._length = this._computeLength(points);\n  }\n  /**\n   * Returns a Curve3 object along a Quadratic Bezier curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#quadratic-bezier-curve\n   * @param v0 (Vector3) the origin point of the Quadratic Bezier\n   * @param v1 (Vector3) the control point\n   * @param v2 (Vector3) the end point of the Quadratic Bezier\n   * @param nbPoints (integer) the wanted number of points in the curve\n   * @returns the created Curve3\n   */\n\n\n  Curve3.CreateQuadraticBezier = function (v0, v1, v2, nbPoints) {\n    nbPoints = nbPoints > 2 ? nbPoints : 3;\n    var bez = new Array();\n\n    var equation = function equation(t, val0, val1, val2) {\n      var res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;\n      return res;\n    };\n\n    for (var i = 0; i <= nbPoints; i++) {\n      bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x), equation(i / nbPoints, v0.y, v1.y, v2.y), equation(i / nbPoints, v0.z, v1.z, v2.z)));\n    }\n\n    return new Curve3(bez);\n  };\n  /**\n   * Returns a Curve3 object along a Cubic Bezier curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#cubic-bezier-curve\n   * @param v0 (Vector3) the origin point of the Cubic Bezier\n   * @param v1 (Vector3) the first control point\n   * @param v2 (Vector3) the second control point\n   * @param v3 (Vector3) the end point of the Cubic Bezier\n   * @param nbPoints (integer) the wanted number of points in the curve\n   * @returns the created Curve3\n   */\n\n\n  Curve3.CreateCubicBezier = function (v0, v1, v2, v3, nbPoints) {\n    nbPoints = nbPoints > 3 ? nbPoints : 4;\n    var bez = new Array();\n\n    var equation = function equation(t, val0, val1, val2, val3) {\n      var res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;\n      return res;\n    };\n\n    for (var i = 0; i <= nbPoints; i++) {\n      bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x, v3.x), equation(i / nbPoints, v0.y, v1.y, v2.y, v3.y), equation(i / nbPoints, v0.z, v1.z, v2.z, v3.z)));\n    }\n\n    return new Curve3(bez);\n  };\n  /**\n   * Returns a Curve3 object along a Hermite Spline curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#hermite-spline\n   * @param p1 (Vector3) the origin point of the Hermite Spline\n   * @param t1 (Vector3) the tangent vector at the origin point\n   * @param p2 (Vector3) the end point of the Hermite Spline\n   * @param t2 (Vector3) the tangent vector at the end point\n   * @param nbPoints (integer) the wanted number of points in the curve\n   * @returns the created Curve3\n   */\n\n\n  Curve3.CreateHermiteSpline = function (p1, t1, p2, t2, nbPoints) {\n    var hermite = new Array();\n    var step = 1.0 / nbPoints;\n\n    for (var i = 0; i <= nbPoints; i++) {\n      hermite.push(Vector3.Hermite(p1, t1, p2, t2, i * step));\n    }\n\n    return new Curve3(hermite);\n  };\n  /**\n   * Returns a Curve3 object along a CatmullRom Spline curve :\n   * @param points (array of Vector3) the points the spline must pass through. At least, four points required\n   * @param nbPoints (integer) the wanted number of points between each curve control points\n   * @param closed (boolean) optional with default false, when true forms a closed loop from the points\n   * @returns the created Curve3\n   */\n\n\n  Curve3.CreateCatmullRomSpline = function (points, nbPoints, closed) {\n    var catmullRom = new Array();\n    var step = 1.0 / nbPoints;\n    var amount = 0.0;\n\n    if (closed) {\n      var pointsCount = points.length;\n\n      for (var i = 0; i < pointsCount; i++) {\n        amount = 0;\n\n        for (var c = 0; c < nbPoints; c++) {\n          catmullRom.push(Vector3.CatmullRom(points[i % pointsCount], points[(i + 1) % pointsCount], points[(i + 2) % pointsCount], points[(i + 3) % pointsCount], amount));\n          amount += step;\n        }\n      }\n\n      catmullRom.push(catmullRom[0]);\n    } else {\n      var totalPoints = new Array();\n      totalPoints.push(points[0].clone());\n      Array.prototype.push.apply(totalPoints, points);\n      totalPoints.push(points[points.length - 1].clone());\n      var i = 0;\n\n      for (; i < totalPoints.length - 3; i++) {\n        amount = 0;\n\n        for (var c = 0; c < nbPoints; c++) {\n          catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\n          amount += step;\n        }\n      }\n\n      i--;\n      catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\n    }\n\n    return new Curve3(catmullRom);\n  };\n  /**\n   * Returns a Curve3 object along an arc through three vector3 points:\n   * The three points should not be colinear. When they are the Curve3 is empty.\n   * @param first (Vector3) the first point the arc must pass through.\n   * @param second (Vector3) the second point the arc must pass through.\n   * @param third (Vector3) the third point the arc must pass through.\n   * @param steps (number) the larger the number of steps the more detailed the arc.\n   * @param closed (boolean) optional with default false, when true forms the chord from the first and third point\n   * @param fullCircle Circle (boolean) optional with default false, when true forms the complete circle through the three points\n   * @returns the created Curve3\n   */\n\n\n  Curve3.ArcThru3Points = function (first, second, third, steps, closed, fullCircle) {\n    if (steps === void 0) {\n      steps = 32;\n    }\n\n    if (closed === void 0) {\n      closed = false;\n    }\n\n    if (fullCircle === void 0) {\n      fullCircle = false;\n    }\n\n    var arc = new Array();\n    var vec1 = second.subtract(first);\n    var vec2 = third.subtract(second);\n    var vec3 = first.subtract(third);\n    var zAxis = Vector3.Cross(vec1, vec2);\n    var len4 = zAxis.length();\n\n    if (len4 < Math.pow(10, -8)) {\n      return new Curve3(arc); // colinear points arc is empty\n    }\n\n    var len1_sq = vec1.lengthSquared();\n    var len2_sq = vec2.lengthSquared();\n    var len3_sq = vec3.lengthSquared();\n    var len4_sq = zAxis.lengthSquared();\n    var len1 = vec1.length();\n    var len2 = vec2.length();\n    var len3 = vec3.length();\n    var radius = 0.5 * len1 * len2 * len3 / len4;\n    var dot1 = Vector3.Dot(vec1, vec3);\n    var dot2 = Vector3.Dot(vec1, vec2);\n    var dot3 = Vector3.Dot(vec2, vec3);\n    var a = -0.5 * len2_sq * dot1 / len4_sq;\n    var b = -0.5 * len3_sq * dot2 / len4_sq;\n    var c = -0.5 * len1_sq * dot3 / len4_sq;\n    var center = first.scale(a).add(second.scale(b)).add(third.scale(c));\n    var radiusVec = first.subtract(center);\n    var xAxis = radiusVec.normalize();\n    var yAxis = Vector3.Cross(zAxis, xAxis).normalize();\n\n    if (fullCircle) {\n      var dStep = 2 * Math.PI / steps;\n\n      for (var theta = 0; theta <= 2 * Math.PI; theta += dStep) {\n        arc.push(center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta)))));\n      }\n\n      arc.push(first);\n    } else {\n      var dStep = 1 / steps;\n      var theta = 0;\n      var point = Vector3.Zero();\n\n      do {\n        point = center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta))));\n        arc.push(point);\n        theta += dStep;\n      } while (!point.equalsWithEpsilon(third, radius * dStep * 1.1));\n\n      arc.push(third);\n\n      if (closed) {\n        arc.push(first);\n      }\n    }\n\n    return new Curve3(arc);\n  };\n  /**\n   * @returns the Curve3 stored array of successive Vector3\n   */\n\n\n  Curve3.prototype.getPoints = function () {\n    return this._points;\n  };\n  /**\n   * @returns the computed length (float) of the curve.\n   */\n\n\n  Curve3.prototype.length = function () {\n    return this._length;\n  };\n  /**\n   * Returns a new instance of Curve3 object : var curve = curveA.continue(curveB);\n   * This new Curve3 is built by translating and sticking the curveB at the end of the curveA.\n   * curveA and curveB keep unchanged.\n   * @param curve the curve to continue from this curve\n   * @returns the newly constructed curve\n   */\n\n\n  Curve3.prototype[\"continue\"] = function (curve) {\n    var lastPoint = this._points[this._points.length - 1];\n\n    var continuedPoints = this._points.slice();\n\n    var curvePoints = curve.getPoints();\n\n    for (var i = 1; i < curvePoints.length; i++) {\n      continuedPoints.push(curvePoints[i].subtract(curvePoints[0]).add(lastPoint));\n    }\n\n    var continuedCurve = new Curve3(continuedPoints);\n    return continuedCurve;\n  };\n\n  Curve3.prototype._computeLength = function (path) {\n    var l = 0;\n\n    for (var i = 1; i < path.length; i++) {\n      l += path[i].subtract(path[i - 1]).length();\n    }\n\n    return l;\n  };\n\n  return Curve3;\n}();\n\nexport { Curve3 };","map":{"version":3,"mappings":"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","names":["Scalar","Vector2","Vector3","Quaternion","Matrix","Epsilon","Orientation","BezierCurve","t","x1","y1","x2","y2","f0","f1","f2","refinedT","i","refinedT2","refinedT3","x","slope","Math","min","max","pow","radians","_radians","PI","Angle","a","b","delta","subtract","theta","atan2","y","degrees","startPoint","midPoint","endPoint","temp","startToMid","midToEnd","det","centerPoint","radius","length","startAngle","BetweenTwoPoints","a1","a2","a3","orientation","CW","CCW","angle","FromDegrees","Array","_points","push","Path2","closed","newPoint","previousPoint","_length","midX","midY","endX","endY","numberOfSegments","arc","Arc2","increment","currentAngle","cos","sin","addLineTo","result","lastPoint","firstPoint","normalizedLengthPosition","Zero","lengthPosition","previousOffset","j","bToA","nextOffset","dir","normalize","localOffset","path","firstNormal","raw","alignTangentsWithPath","id","point","previousPointArrayIndex","position","subPosition","interpolateReady","interpolationMatrix","Identity","p","_curve","clone","_raw","_alignTangentsWithPath","_compute","Path3D","_distances","_tangents","_normals","_binormals","_updatePointAtData","interpolated","TransformCoordinates","Forward","_pointAtData","Right","UpReadOnly","target","smallestDistance","Number","MAX_VALUE","closestPosition","tangent","subLength","Dot","Distance","distance","add","scale","start","end","_start","curvePoints","getCurve","getPointAt","startIndex","getPreviousPointIndexAt","endIndex","slicePoints","apply","slice","getNormalAt","z","l","_getFirstNonNullVector","tg0","pp0","_normalVector","Cross","prev","cur","curTang","prevNor","prevBinor","_getLastNonNullVector","NaN","index","nNVector","nLVector","vt","va","normal0","tgl","undefined","WithinEpsilon","abs","CrossToRef","interpolateTNB","_updateInterpolationMatrix","getPoints","_setPointAtData","currentPoint","currentLength","targetLength","toLength","diff","scaleInPlace","parentIndex","tangentFrom","normalFrom","binormalFrom","tangentTo","normalTo","binormalTo","quatFrom","RotationQuaternionFromAxis","quatTo","quatAt","Slerp","toRotationMatrix","points","_computeLength","Curve3","v0","v1","v2","nbPoints","bez","equation","val0","val1","val2","res","v3","val3","p1","t1","p2","t2","hermite","step","Hermite","catmullRom","amount","pointsCount","c","CatmullRom","totalPoints","prototype","first","second","third","steps","fullCircle","vec1","vec2","vec3","zAxis","len4","len1_sq","lengthSquared","len2_sq","len3_sq","len4_sq","len1","len2","len3","dot1","dot2","dot3","center","radiusVec","xAxis","yAxis","dStep","equalsWithEpsilon","curve","continuedPoints","continuedCurve"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Maths/math.path.ts"],"sourcesContent":["import type { DeepImmutable, Nullable } from \"../types\";\r\nimport { Scalar } from \"./math.scalar\";\r\nimport { Vector2, Vector3, Quaternion, Matrix } from \"./math.vector\";\r\nimport { Epsilon } from \"./math.constants\";\r\n\r\n/**\r\n * Defines potential orientation for back face culling\r\n */\r\nexport enum Orientation {\r\n    /**\r\n     * Clockwise\r\n     */\r\n    CW = 0,\r\n    /** Counter clockwise */\r\n    CCW = 1,\r\n}\r\n\r\n/** Class used to represent a Bezier curve */\r\nexport class BezierCurve {\r\n    /**\r\n     * Returns the cubic Bezier interpolated value (float) at \"t\" (float) from the given x1, y1, x2, y2 floats\r\n     * @param t defines the time\r\n     * @param x1 defines the left coordinate on X axis\r\n     * @param y1 defines the left coordinate on Y axis\r\n     * @param x2 defines the right coordinate on X axis\r\n     * @param y2 defines the right coordinate on Y axis\r\n     * @returns the interpolated value\r\n     */\r\n    public static Interpolate(t: number, x1: number, y1: number, x2: number, y2: number): number {\r\n        // Extract X (which is equal to time here)\r\n        const f0 = 1 - 3 * x2 + 3 * x1;\r\n        const f1 = 3 * x2 - 6 * x1;\r\n        const f2 = 3 * x1;\r\n\r\n        let refinedT = t;\r\n        for (let i = 0; i < 5; i++) {\r\n            const refinedT2 = refinedT * refinedT;\r\n            const refinedT3 = refinedT2 * refinedT;\r\n\r\n            const x = f0 * refinedT3 + f1 * refinedT2 + f2 * refinedT;\r\n            const slope = 1.0 / (3.0 * f0 * refinedT2 + 2.0 * f1 * refinedT + f2);\r\n            refinedT -= (x - t) * slope;\r\n            refinedT = Math.min(1, Math.max(0, refinedT));\r\n        }\r\n\r\n        // Resolve cubic bezier for the given x\r\n        return 3 * Math.pow(1 - refinedT, 2) * refinedT * y1 + 3 * (1 - refinedT) * Math.pow(refinedT, 2) * y2 + Math.pow(refinedT, 3);\r\n    }\r\n}\r\n\r\n/**\r\n * Defines angle representation\r\n */\r\nexport class Angle {\r\n    private _radians: number;\r\n\r\n    /**\r\n     * Creates an Angle object of \"radians\" radians (float).\r\n     * @param radians the angle in radians\r\n     */\r\n    constructor(radians: number) {\r\n        this._radians = radians;\r\n        if (this._radians < 0.0) {\r\n            this._radians += 2.0 * Math.PI;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get value in degrees\r\n     * @returns the Angle value in degrees (float)\r\n     */\r\n    public degrees() {\r\n        return (this._radians * 180.0) / Math.PI;\r\n    }\r\n\r\n    /**\r\n     * Get value in radians\r\n     * @returns the Angle value in radians (float)\r\n     */\r\n    public radians() {\r\n        return this._radians;\r\n    }\r\n\r\n    /**\r\n     * Gets a new Angle object valued with the gradient angle, in radians, of the line joining two points\r\n     * @param a defines first point as the origin\r\n     * @param b defines point\r\n     * @returns a new Angle\r\n     */\r\n    public static BetweenTwoPoints(a: DeepImmutable<Vector2>, b: DeepImmutable<Vector2>): Angle {\r\n        const delta = b.subtract(a);\r\n        const theta = Math.atan2(delta.y, delta.x);\r\n        return new Angle(theta);\r\n    }\r\n\r\n    /**\r\n     * Gets a new Angle object from the given float in radians\r\n     * @param radians defines the angle value in radians\r\n     * @returns a new Angle\r\n     */\r\n    public static FromRadians(radians: number): Angle {\r\n        return new Angle(radians);\r\n    }\r\n    /**\r\n     * Gets a new Angle object from the given float in degrees\r\n     * @param degrees defines the angle value in degrees\r\n     * @returns a new Angle\r\n     */\r\n    public static FromDegrees(degrees: number): Angle {\r\n        return new Angle((degrees * Math.PI) / 180.0);\r\n    }\r\n}\r\n\r\n/**\r\n * This represents an arc in a 2d space.\r\n */\r\nexport class Arc2 {\r\n    /**\r\n     * Defines the center point of the arc.\r\n     */\r\n    public centerPoint: Vector2;\r\n    /**\r\n     * Defines the radius of the arc.\r\n     */\r\n    public radius: number;\r\n    /**\r\n     * Defines the angle of the arc (from mid point to end point).\r\n     */\r\n    public angle: Angle;\r\n    /**\r\n     * Defines the start angle of the arc (from start point to middle point).\r\n     */\r\n    public startAngle: Angle;\r\n    /**\r\n     * Defines the orientation of the arc (clock wise/counter clock wise).\r\n     */\r\n    public orientation: Orientation;\r\n\r\n    /**\r\n     * Creates an Arc object from the three given points : start, middle and end.\r\n     * @param startPoint Defines the start point of the arc\r\n     * @param midPoint Defines the middle point of the arc\r\n     * @param endPoint Defines the end point of the arc\r\n     */\r\n    constructor(\r\n        /** Defines the start point of the arc */\r\n        public startPoint: Vector2,\r\n        /** Defines the mid point of the arc */\r\n        public midPoint: Vector2,\r\n        /** Defines the end point of the arc */\r\n        public endPoint: Vector2\r\n    ) {\r\n        const temp = Math.pow(midPoint.x, 2) + Math.pow(midPoint.y, 2);\r\n        const startToMid = (Math.pow(startPoint.x, 2) + Math.pow(startPoint.y, 2) - temp) / 2;\r\n        const midToEnd = (temp - Math.pow(endPoint.x, 2) - Math.pow(endPoint.y, 2)) / 2;\r\n        const det = (startPoint.x - midPoint.x) * (midPoint.y - endPoint.y) - (midPoint.x - endPoint.x) * (startPoint.y - midPoint.y);\r\n\r\n        this.centerPoint = new Vector2(\r\n            (startToMid * (midPoint.y - endPoint.y) - midToEnd * (startPoint.y - midPoint.y)) / det,\r\n            ((startPoint.x - midPoint.x) * midToEnd - (midPoint.x - endPoint.x) * startToMid) / det\r\n        );\r\n\r\n        this.radius = this.centerPoint.subtract(this.startPoint).length();\r\n\r\n        this.startAngle = Angle.BetweenTwoPoints(this.centerPoint, this.startPoint);\r\n\r\n        const a1 = this.startAngle.degrees();\r\n        let a2 = Angle.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees();\r\n        let a3 = Angle.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees();\r\n\r\n        // angles correction\r\n        if (a2 - a1 > +180.0) {\r\n            a2 -= 360.0;\r\n        }\r\n        if (a2 - a1 < -180.0) {\r\n            a2 += 360.0;\r\n        }\r\n        if (a3 - a2 > +180.0) {\r\n            a3 -= 360.0;\r\n        }\r\n        if (a3 - a2 < -180.0) {\r\n            a3 += 360.0;\r\n        }\r\n\r\n        this.orientation = a2 - a1 < 0 ? Orientation.CW : Orientation.CCW;\r\n        this.angle = Angle.FromDegrees(this.orientation === Orientation.CW ? a1 - a3 : a3 - a1);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a 2D path made up of multiple 2D points\r\n */\r\nexport class Path2 {\r\n    private _points = new Array<Vector2>();\r\n    private _length = 0.0;\r\n\r\n    /**\r\n     * If the path start and end point are the same\r\n     */\r\n    public closed = false;\r\n\r\n    /**\r\n     * Creates a Path2 object from the starting 2D coordinates x and y.\r\n     * @param x the starting points x value\r\n     * @param y the starting points y value\r\n     */\r\n    constructor(x: number, y: number) {\r\n        this._points.push(new Vector2(x, y));\r\n    }\r\n\r\n    /**\r\n     * Adds a new segment until the given coordinates (x, y) to the current Path2.\r\n     * @param x the added points x value\r\n     * @param y the added points y value\r\n     * @returns the updated Path2.\r\n     */\r\n    public addLineTo(x: number, y: number): Path2 {\r\n        if (this.closed) {\r\n            return this;\r\n        }\r\n        const newPoint = new Vector2(x, y);\r\n        const previousPoint = this._points[this._points.length - 1];\r\n        this._points.push(newPoint);\r\n        this._length += newPoint.subtract(previousPoint).length();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds _numberOfSegments_ segments according to the arc definition (middle point coordinates, end point coordinates, the arc start point being the current Path2 last point) to the current Path2.\r\n     * @param midX middle point x value\r\n     * @param midY middle point y value\r\n     * @param endX end point x value\r\n     * @param endY end point y value\r\n     * @param numberOfSegments (default: 36)\r\n     * @returns the updated Path2.\r\n     */\r\n    public addArcTo(midX: number, midY: number, endX: number, endY: number, numberOfSegments = 36): Path2 {\r\n        if (this.closed) {\r\n            return this;\r\n        }\r\n        const startPoint = this._points[this._points.length - 1];\r\n        const midPoint = new Vector2(midX, midY);\r\n        const endPoint = new Vector2(endX, endY);\r\n\r\n        const arc = new Arc2(startPoint, midPoint, endPoint);\r\n\r\n        let increment = arc.angle.radians() / numberOfSegments;\r\n        if (arc.orientation === Orientation.CW) {\r\n            increment *= -1;\r\n        }\r\n        let currentAngle = arc.startAngle.radians() + increment;\r\n\r\n        for (let i = 0; i < numberOfSegments; i++) {\r\n            const x = Math.cos(currentAngle) * arc.radius + arc.centerPoint.x;\r\n            const y = Math.sin(currentAngle) * arc.radius + arc.centerPoint.y;\r\n            this.addLineTo(x, y);\r\n            currentAngle += increment;\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Closes the Path2.\r\n     * @returns the Path2.\r\n     */\r\n    public close(): Path2 {\r\n        this.closed = true;\r\n        return this;\r\n    }\r\n    /**\r\n     * Gets the sum of the distance between each sequential point in the path\r\n     * @returns the Path2 total length (float).\r\n     */\r\n    public length(): number {\r\n        let result = this._length;\r\n\r\n        if (this.closed) {\r\n            const lastPoint = this._points[this._points.length - 1];\r\n            const firstPoint = this._points[0];\r\n            result += firstPoint.subtract(lastPoint).length();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Gets the points which construct the path\r\n     * @returns the Path2 internal array of points.\r\n     */\r\n    public getPoints(): Vector2[] {\r\n        return this._points;\r\n    }\r\n\r\n    /**\r\n     * Retreives the point at the distance aways from the starting point\r\n     * @param normalizedLengthPosition the length along the path to retrieve the point from\r\n     * @returns a new Vector2 located at a percentage of the Path2 total length on this path.\r\n     */\r\n    public getPointAtLengthPosition(normalizedLengthPosition: number): Vector2 {\r\n        if (normalizedLengthPosition < 0 || normalizedLengthPosition > 1) {\r\n            return Vector2.Zero();\r\n        }\r\n\r\n        const lengthPosition = normalizedLengthPosition * this.length();\r\n\r\n        let previousOffset = 0;\r\n        for (let i = 0; i < this._points.length; i++) {\r\n            const j = (i + 1) % this._points.length;\r\n\r\n            const a = this._points[i];\r\n            const b = this._points[j];\r\n            const bToA = b.subtract(a);\r\n\r\n            const nextOffset = bToA.length() + previousOffset;\r\n            if (lengthPosition >= previousOffset && lengthPosition <= nextOffset) {\r\n                const dir = bToA.normalize();\r\n                const localOffset = lengthPosition - previousOffset;\r\n\r\n                return new Vector2(a.x + dir.x * localOffset, a.y + dir.y * localOffset);\r\n            }\r\n            previousOffset = nextOffset;\r\n        }\r\n\r\n        return Vector2.Zero();\r\n    }\r\n\r\n    /**\r\n     * Creates a new path starting from an x and y position\r\n     * @param x starting x value\r\n     * @param y starting y value\r\n     * @returns a new Path2 starting at the coordinates (x, y).\r\n     */\r\n    public static StartingAt(x: number, y: number): Path2 {\r\n        return new Path2(x, y);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a 3D path made up of multiple 3D points\r\n * @see https://doc.babylonjs.com/divingDeeper/mesh/path3D\r\n */\r\nexport class Path3D {\r\n    private _curve = new Array<Vector3>();\r\n    private _distances = new Array<number>();\r\n    private _tangents = new Array<Vector3>();\r\n    private _normals = new Array<Vector3>();\r\n    private _binormals = new Array<Vector3>();\r\n    private _raw: boolean;\r\n    private _alignTangentsWithPath: boolean;\r\n\r\n    // holds interpolated point data\r\n    private readonly _pointAtData = {\r\n        id: 0,\r\n        point: Vector3.Zero(),\r\n        previousPointArrayIndex: 0,\r\n\r\n        position: 0,\r\n        subPosition: 0,\r\n\r\n        interpolateReady: false,\r\n        interpolationMatrix: Matrix.Identity(),\r\n    };\r\n\r\n    /**\r\n     * new Path3D(path, normal, raw)\r\n     * Creates a Path3D. A Path3D is a logical math object, so not a mesh.\r\n     * please read the description in the tutorial : https://doc.babylonjs.com/how_to/how_to_use_path3d\r\n     * @param path an array of Vector3, the curve axis of the Path3D\r\n     * @param firstNormal (options) Vector3, the first wanted normal to the curve. Ex (0, 1, 0) for a vertical normal.\r\n     * @param raw (optional, default false) : boolean, if true the returned Path3D isn't normalized. Useful to depict path acceleration or speed.\r\n     * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path.\r\n     */\r\n    constructor(\r\n        /**\r\n         * an array of Vector3, the curve axis of the Path3D\r\n         */\r\n        public path: Vector3[],\r\n        firstNormal: Nullable<Vector3> = null,\r\n        raw?: boolean,\r\n        alignTangentsWithPath = false\r\n    ) {\r\n        for (let p = 0; p < path.length; p++) {\r\n            this._curve[p] = path[p].clone(); // hard copy\r\n        }\r\n        this._raw = raw || false;\r\n        this._alignTangentsWithPath = alignTangentsWithPath;\r\n        this._compute(firstNormal, alignTangentsWithPath);\r\n    }\r\n\r\n    /**\r\n     * Returns the Path3D array of successive Vector3 designing its curve.\r\n     * @returns the Path3D array of successive Vector3 designing its curve.\r\n     */\r\n    public getCurve(): Vector3[] {\r\n        return this._curve;\r\n    }\r\n\r\n    /**\r\n     * Returns the Path3D array of successive Vector3 designing its curve.\r\n     * @returns the Path3D array of successive Vector3 designing its curve.\r\n     */\r\n    public getPoints(): Vector3[] {\r\n        return this._curve;\r\n    }\r\n\r\n    /**\r\n     * @returns the computed length (float) of the path.\r\n     */\r\n    public length() {\r\n        return this._distances[this._distances.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Returns an array populated with tangent vectors on each Path3D curve point.\r\n     * @returns an array populated with tangent vectors on each Path3D curve point.\r\n     */\r\n    public getTangents(): Vector3[] {\r\n        return this._tangents;\r\n    }\r\n\r\n    /**\r\n     * Returns an array populated with normal vectors on each Path3D curve point.\r\n     * @returns an array populated with normal vectors on each Path3D curve point.\r\n     */\r\n    public getNormals(): Vector3[] {\r\n        return this._normals;\r\n    }\r\n\r\n    /**\r\n     * Returns an array populated with binormal vectors on each Path3D curve point.\r\n     * @returns an array populated with binormal vectors on each Path3D curve point.\r\n     */\r\n    public getBinormals(): Vector3[] {\r\n        return this._binormals;\r\n    }\r\n\r\n    /**\r\n     * Returns an array populated with distances (float) of the i-th point from the first curve point.\r\n     * @returns an array populated with distances (float) of the i-th point from the first curve point.\r\n     */\r\n    public getDistances(): number[] {\r\n        return this._distances;\r\n    }\r\n\r\n    /**\r\n     * Returns an interpolated point along this path\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @returns a new Vector3 as the point\r\n     */\r\n    public getPointAt(position: number): Vector3 {\r\n        return this._updatePointAtData(position).point;\r\n    }\r\n\r\n    /**\r\n     * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @param interpolated (optional, default false) : boolean, if true returns an interpolated tangent instead of the tangent of the previous path point.\r\n     * @returns a tangent vector corresponding to the interpolated Path3D curve point, if not interpolated, the tangent is taken from the precomputed tangents array.\r\n     */\r\n    public getTangentAt(position: number, interpolated = false): Vector3 {\r\n        this._updatePointAtData(position, interpolated);\r\n        return interpolated ? Vector3.TransformCoordinates(Vector3.Forward(), this._pointAtData.interpolationMatrix) : this._tangents[this._pointAtData.previousPointArrayIndex];\r\n    }\r\n\r\n    /**\r\n     * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @param interpolated (optional, default false) : boolean, if true returns an interpolated normal instead of the normal of the previous path point.\r\n     * @returns a normal vector corresponding to the interpolated Path3D curve point, if not interpolated, the normal is taken from the precomputed normals array.\r\n     */\r\n    public getNormalAt(position: number, interpolated = false): Vector3 {\r\n        this._updatePointAtData(position, interpolated);\r\n        return interpolated ? Vector3.TransformCoordinates(Vector3.Right(), this._pointAtData.interpolationMatrix) : this._normals[this._pointAtData.previousPointArrayIndex];\r\n    }\r\n\r\n    /**\r\n     * Returns the binormal vector of an interpolated Path3D curve point at the specified position along this path.\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @param interpolated (optional, default false) : boolean, if true returns an interpolated binormal instead of the binormal of the previous path point.\r\n     * @returns a binormal vector corresponding to the interpolated Path3D curve point, if not interpolated, the binormal is taken from the precomputed binormals array.\r\n     */\r\n    public getBinormalAt(position: number, interpolated = false): Vector3 {\r\n        this._updatePointAtData(position, interpolated);\r\n        return interpolated ? Vector3.TransformCoordinates(Vector3.UpReadOnly, this._pointAtData.interpolationMatrix) : this._binormals[this._pointAtData.previousPointArrayIndex];\r\n    }\r\n\r\n    /**\r\n     * Returns the distance (float) of an interpolated Path3D curve point at the specified position along this path.\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @returns the distance of the interpolated Path3D curve point at the specified position along this path.\r\n     */\r\n    public getDistanceAt(position: number): number {\r\n        return this.length() * position;\r\n    }\r\n\r\n    /**\r\n     * Returns the array index of the previous point of an interpolated point along this path\r\n     * @param position the position of the point to interpolate along this path, from 0.0 to 1.0\r\n     * @returns the array index\r\n     */\r\n    public getPreviousPointIndexAt(position: number) {\r\n        this._updatePointAtData(position);\r\n        return this._pointAtData.previousPointArrayIndex;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of an interpolated point relative to the two path points it lies between, from 0.0 (point A) to 1.0 (point B)\r\n     * @param position the position of the point to interpolate along this path, from 0.0 to 1.0\r\n     * @returns the sub position\r\n     */\r\n    public getSubPositionAt(position: number) {\r\n        this._updatePointAtData(position);\r\n        return this._pointAtData.subPosition;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the closest virtual point on this path to an arbitrary Vector3, from 0.0 to 1.0\r\n     * @param target the vector of which to get the closest position to\r\n     * @returns the position of the closest virtual point on this path to the target vector\r\n     */\r\n    public getClosestPositionTo(target: Vector3) {\r\n        let smallestDistance = Number.MAX_VALUE;\r\n        let closestPosition = 0.0;\r\n        for (let i = 0; i < this._curve.length - 1; i++) {\r\n            const point = this._curve[i + 0];\r\n            const tangent = this._curve[i + 1].subtract(point).normalize();\r\n            const subLength = this._distances[i + 1] - this._distances[i + 0];\r\n            const subPosition = Math.min((Math.max(Vector3.Dot(tangent, target.subtract(point).normalize()), 0.0) * Vector3.Distance(point, target)) / subLength, 1.0);\r\n            const distance = Vector3.Distance(point.add(tangent.scale(subPosition * subLength)), target);\r\n\r\n            if (distance < smallestDistance) {\r\n                smallestDistance = distance;\r\n                closestPosition = (this._distances[i + 0] + subLength * subPosition) / this.length();\r\n            }\r\n        }\r\n        return closestPosition;\r\n    }\r\n\r\n    /**\r\n     * Returns a sub path (slice) of this path\r\n     * @param start the position of the fist path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values\r\n     * @param end the position of the last path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values\r\n     * @returns a sub path (slice) of this path\r\n     */\r\n    public slice(start: number = 0.0, end: number = 1.0) {\r\n        if (start < 0.0) {\r\n            start = 1 - ((start * -1.0) % 1.0);\r\n        }\r\n        if (end < 0.0) {\r\n            end = 1 - ((end * -1.0) % 1.0);\r\n        }\r\n        if (start > end) {\r\n            const _start = start;\r\n            start = end;\r\n            end = _start;\r\n        }\r\n        const curvePoints = this.getCurve();\r\n\r\n        const startPoint = this.getPointAt(start);\r\n        let startIndex = this.getPreviousPointIndexAt(start);\r\n\r\n        const endPoint = this.getPointAt(end);\r\n        const endIndex = this.getPreviousPointIndexAt(end) + 1;\r\n\r\n        const slicePoints: Vector3[] = [];\r\n        if (start !== 0.0) {\r\n            startIndex++;\r\n            slicePoints.push(startPoint);\r\n        }\r\n\r\n        slicePoints.push(...curvePoints.slice(startIndex, endIndex));\r\n        if (end !== 1.0 || start === 1.0) {\r\n            slicePoints.push(endPoint);\r\n        }\r\n        return new Path3D(slicePoints, this.getNormalAt(start), this._raw, this._alignTangentsWithPath);\r\n    }\r\n\r\n    /**\r\n     * Forces the Path3D tangent, normal, binormal and distance recomputation.\r\n     * @param path path which all values are copied into the curves points\r\n     * @param firstNormal which should be projected onto the curve\r\n     * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path\r\n     * @returns the same object updated.\r\n     */\r\n    public update(path: Vector3[], firstNormal: Nullable<Vector3> = null, alignTangentsWithPath = false): Path3D {\r\n        for (let p = 0; p < path.length; p++) {\r\n            this._curve[p].x = path[p].x;\r\n            this._curve[p].y = path[p].y;\r\n            this._curve[p].z = path[p].z;\r\n        }\r\n        this._compute(firstNormal, alignTangentsWithPath);\r\n        return this;\r\n    }\r\n\r\n    // private function compute() : computes tangents, normals and binormals\r\n    private _compute(firstNormal: Nullable<Vector3>, alignTangentsWithPath = false): void {\r\n        const l = this._curve.length;\r\n\r\n        if (l < 2) {\r\n            return;\r\n        }\r\n\r\n        // first and last tangents\r\n        this._tangents[0] = this._getFirstNonNullVector(0);\r\n        if (!this._raw) {\r\n            this._tangents[0].normalize();\r\n        }\r\n        this._tangents[l - 1] = this._curve[l - 1].subtract(this._curve[l - 2]);\r\n        if (!this._raw) {\r\n            this._tangents[l - 1].normalize();\r\n        }\r\n\r\n        // normals and binormals at first point : arbitrary vector with _normalVector()\r\n        const tg0 = this._tangents[0];\r\n        const pp0 = this._normalVector(tg0, firstNormal);\r\n        this._normals[0] = pp0;\r\n        if (!this._raw) {\r\n            this._normals[0].normalize();\r\n        }\r\n        this._binormals[0] = Vector3.Cross(tg0, this._normals[0]);\r\n        if (!this._raw) {\r\n            this._binormals[0].normalize();\r\n        }\r\n        this._distances[0] = 0.0;\r\n\r\n        // normals and binormals : next points\r\n        let prev: Vector3; // previous vector (segment)\r\n        let cur: Vector3; // current vector (segment)\r\n        let curTang: Vector3; // current tangent\r\n        // previous normal\r\n        let prevNor: Vector3; // previous normal\r\n        let prevBinor: Vector3; // previous binormal\r\n\r\n        for (let i = 1; i < l; i++) {\r\n            // tangents\r\n            prev = this._getLastNonNullVector(i);\r\n            if (i < l - 1) {\r\n                cur = this._getFirstNonNullVector(i);\r\n                this._tangents[i] = alignTangentsWithPath ? cur : prev.add(cur);\r\n                this._tangents[i].normalize();\r\n            }\r\n            this._distances[i] = this._distances[i - 1] + this._curve[i].subtract(this._curve[i - 1]).length();\r\n\r\n            // normals and binormals\r\n            // http://www.cs.cmu.edu/afs/andrew/scs/cs/15-462/web/old/asst2camera.html\r\n            curTang = this._tangents[i];\r\n            prevBinor = this._binormals[i - 1];\r\n            this._normals[i] = Vector3.Cross(prevBinor, curTang);\r\n            if (!this._raw) {\r\n                if (this._normals[i].length() === 0) {\r\n                    prevNor = this._normals[i - 1];\r\n                    this._normals[i] = prevNor.clone();\r\n                } else {\r\n                    this._normals[i].normalize();\r\n                }\r\n            }\r\n            this._binormals[i] = Vector3.Cross(curTang, this._normals[i]);\r\n            if (!this._raw) {\r\n                this._binormals[i].normalize();\r\n            }\r\n        }\r\n        this._pointAtData.id = NaN;\r\n    }\r\n\r\n    // private function getFirstNonNullVector(index)\r\n    // returns the first non null vector from index : curve[index + N].subtract(curve[index])\r\n    private _getFirstNonNullVector(index: number): Vector3 {\r\n        let i = 1;\r\n        let nNVector: Vector3 = this._curve[index + i].subtract(this._curve[index]);\r\n        while (nNVector.length() === 0 && index + i + 1 < this._curve.length) {\r\n            i++;\r\n            nNVector = this._curve[index + i].subtract(this._curve[index]);\r\n        }\r\n        return nNVector;\r\n    }\r\n\r\n    // private function getLastNonNullVector(index)\r\n    // returns the last non null vector from index : curve[index].subtract(curve[index - N])\r\n    private _getLastNonNullVector(index: number): Vector3 {\r\n        let i = 1;\r\n        let nLVector: Vector3 = this._curve[index].subtract(this._curve[index - i]);\r\n        while (nLVector.length() === 0 && index > i + 1) {\r\n            i++;\r\n            nLVector = this._curve[index].subtract(this._curve[index - i]);\r\n        }\r\n        return nLVector;\r\n    }\r\n\r\n    // private function normalVector(v0, vt, va) :\r\n    // returns an arbitrary point in the plane defined by the point v0 and the vector vt orthogonal to this plane\r\n    // if va is passed, it returns the va projection on the plane orthogonal to vt at the point v0\r\n    private _normalVector(vt: Vector3, va: Nullable<Vector3>): Vector3 {\r\n        let normal0: Vector3;\r\n        let tgl = vt.length();\r\n        if (tgl === 0.0) {\r\n            tgl = 1.0;\r\n        }\r\n\r\n        if (va === undefined || va === null) {\r\n            let point: Vector3;\r\n            if (!Scalar.WithinEpsilon(Math.abs(vt.y) / tgl, 1.0, Epsilon)) {\r\n                // search for a point in the plane\r\n                point = new Vector3(0.0, -1.0, 0.0);\r\n            } else if (!Scalar.WithinEpsilon(Math.abs(vt.x) / tgl, 1.0, Epsilon)) {\r\n                point = new Vector3(1.0, 0.0, 0.0);\r\n            } else if (!Scalar.WithinEpsilon(Math.abs(vt.z) / tgl, 1.0, Epsilon)) {\r\n                point = new Vector3(0.0, 0.0, 1.0);\r\n            } else {\r\n                point = Vector3.Zero();\r\n            }\r\n            normal0 = Vector3.Cross(vt, point);\r\n        } else {\r\n            normal0 = Vector3.Cross(vt, va);\r\n            Vector3.CrossToRef(normal0, vt, normal0);\r\n        }\r\n        normal0.normalize();\r\n        return normal0;\r\n    }\r\n\r\n    /**\r\n     * Updates the point at data for an interpolated point along this curve\r\n     * @param position the position of the point along this curve, from 0.0 to 1.0\r\n     * @param interpolateTNB\r\n     * @interpolateTNB whether to compute the interpolated tangent, normal and binormal\r\n     * @returns the (updated) point at data\r\n     */\r\n    private _updatePointAtData(position: number, interpolateTNB: boolean = false) {\r\n        // set an id for caching the result\r\n        if (this._pointAtData.id === position) {\r\n            if (!this._pointAtData.interpolateReady) {\r\n                this._updateInterpolationMatrix();\r\n            }\r\n            return this._pointAtData;\r\n        } else {\r\n            this._pointAtData.id = position;\r\n        }\r\n        const curvePoints = this.getPoints();\r\n\r\n        // clamp position between 0.0 and 1.0\r\n        if (position <= 0.0) {\r\n            return this._setPointAtData(0.0, 0.0, curvePoints[0], 0, interpolateTNB);\r\n        } else if (position >= 1.0) {\r\n            return this._setPointAtData(1.0, 1.0, curvePoints[curvePoints.length - 1], curvePoints.length - 1, interpolateTNB);\r\n        }\r\n\r\n        let previousPoint: Vector3 = curvePoints[0];\r\n        let currentPoint: Vector3;\r\n        let currentLength = 0.0;\r\n        const targetLength = position * this.length();\r\n\r\n        for (let i = 1; i < curvePoints.length; i++) {\r\n            currentPoint = curvePoints[i];\r\n            const distance = Vector3.Distance(previousPoint, currentPoint);\r\n            currentLength += distance;\r\n            if (currentLength === targetLength) {\r\n                return this._setPointAtData(position, 1.0, currentPoint, i, interpolateTNB);\r\n            } else if (currentLength > targetLength) {\r\n                const toLength = currentLength - targetLength;\r\n                const diff = toLength / distance;\r\n                const dir = previousPoint.subtract(currentPoint);\r\n                const point = currentPoint.add(dir.scaleInPlace(diff));\r\n                return this._setPointAtData(position, 1 - diff, point, i - 1, interpolateTNB);\r\n            }\r\n            previousPoint = currentPoint;\r\n        }\r\n        return this._pointAtData;\r\n    }\r\n\r\n    /**\r\n     * Updates the point at data from the specified parameters\r\n     * @param position where along the path the interpolated point is, from 0.0 to 1.0\r\n     * @param subPosition\r\n     * @param point the interpolated point\r\n     * @param parentIndex the index of an existing curve point that is on, or else positionally the first behind, the interpolated point\r\n     * @param interpolateTNB\r\n     */\r\n    private _setPointAtData(position: number, subPosition: number, point: Vector3, parentIndex: number, interpolateTNB: boolean) {\r\n        this._pointAtData.point = point;\r\n        this._pointAtData.position = position;\r\n        this._pointAtData.subPosition = subPosition;\r\n        this._pointAtData.previousPointArrayIndex = parentIndex;\r\n        this._pointAtData.interpolateReady = interpolateTNB;\r\n\r\n        if (interpolateTNB) {\r\n            this._updateInterpolationMatrix();\r\n        }\r\n        return this._pointAtData;\r\n    }\r\n\r\n    /**\r\n     * Updates the point at interpolation matrix for the tangents, normals and binormals\r\n     */\r\n    private _updateInterpolationMatrix() {\r\n        this._pointAtData.interpolationMatrix = Matrix.Identity();\r\n        const parentIndex = this._pointAtData.previousPointArrayIndex;\r\n\r\n        if (parentIndex !== this._tangents.length - 1) {\r\n            const index = parentIndex + 1;\r\n\r\n            const tangentFrom = this._tangents[parentIndex].clone();\r\n            const normalFrom = this._normals[parentIndex].clone();\r\n            const binormalFrom = this._binormals[parentIndex].clone();\r\n\r\n            const tangentTo = this._tangents[index].clone();\r\n            const normalTo = this._normals[index].clone();\r\n            const binormalTo = this._binormals[index].clone();\r\n\r\n            const quatFrom = Quaternion.RotationQuaternionFromAxis(normalFrom, binormalFrom, tangentFrom);\r\n            const quatTo = Quaternion.RotationQuaternionFromAxis(normalTo, binormalTo, tangentTo);\r\n            const quatAt = Quaternion.Slerp(quatFrom, quatTo, this._pointAtData.subPosition);\r\n\r\n            quatAt.toRotationMatrix(this._pointAtData.interpolationMatrix);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\r\n * A Curve3 is designed from a series of successive Vector3.\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_curve3\r\n */\r\nexport class Curve3 {\r\n    private _points: Vector3[];\r\n    private _length: number = 0.0;\r\n\r\n    /**\r\n     * Returns a Curve3 object along a Quadratic Bezier curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#quadratic-bezier-curve\r\n     * @param v0 (Vector3) the origin point of the Quadratic Bezier\r\n     * @param v1 (Vector3) the control point\r\n     * @param v2 (Vector3) the end point of the Quadratic Bezier\r\n     * @param nbPoints (integer) the wanted number of points in the curve\r\n     * @returns the created Curve3\r\n     */\r\n    public static CreateQuadraticBezier(v0: DeepImmutable<Vector3>, v1: DeepImmutable<Vector3>, v2: DeepImmutable<Vector3>, nbPoints: number): Curve3 {\r\n        nbPoints = nbPoints > 2 ? nbPoints : 3;\r\n        const bez = new Array<Vector3>();\r\n        const equation = (t: number, val0: number, val1: number, val2: number) => {\r\n            const res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;\r\n            return res;\r\n        };\r\n        for (let i = 0; i <= nbPoints; i++) {\r\n            bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x), equation(i / nbPoints, v0.y, v1.y, v2.y), equation(i / nbPoints, v0.z, v1.z, v2.z)));\r\n        }\r\n        return new Curve3(bez);\r\n    }\r\n\r\n    /**\r\n     * Returns a Curve3 object along a Cubic Bezier curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#cubic-bezier-curve\r\n     * @param v0 (Vector3) the origin point of the Cubic Bezier\r\n     * @param v1 (Vector3) the first control point\r\n     * @param v2 (Vector3) the second control point\r\n     * @param v3 (Vector3) the end point of the Cubic Bezier\r\n     * @param nbPoints (integer) the wanted number of points in the curve\r\n     * @returns the created Curve3\r\n     */\r\n    public static CreateCubicBezier(v0: DeepImmutable<Vector3>, v1: DeepImmutable<Vector3>, v2: DeepImmutable<Vector3>, v3: DeepImmutable<Vector3>, nbPoints: number): Curve3 {\r\n        nbPoints = nbPoints > 3 ? nbPoints : 4;\r\n        const bez = new Array<Vector3>();\r\n        const equation = (t: number, val0: number, val1: number, val2: number, val3: number) => {\r\n            const res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;\r\n            return res;\r\n        };\r\n        for (let i = 0; i <= nbPoints; i++) {\r\n            bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x, v3.x), equation(i / nbPoints, v0.y, v1.y, v2.y, v3.y), equation(i / nbPoints, v0.z, v1.z, v2.z, v3.z)));\r\n        }\r\n        return new Curve3(bez);\r\n    }\r\n\r\n    /**\r\n     * Returns a Curve3 object along a Hermite Spline curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#hermite-spline\r\n     * @param p1 (Vector3) the origin point of the Hermite Spline\r\n     * @param t1 (Vector3) the tangent vector at the origin point\r\n     * @param p2 (Vector3) the end point of the Hermite Spline\r\n     * @param t2 (Vector3) the tangent vector at the end point\r\n     * @param nbPoints (integer) the wanted number of points in the curve\r\n     * @returns the created Curve3\r\n     */\r\n    public static CreateHermiteSpline(p1: DeepImmutable<Vector3>, t1: DeepImmutable<Vector3>, p2: DeepImmutable<Vector3>, t2: DeepImmutable<Vector3>, nbPoints: number): Curve3 {\r\n        const hermite = new Array<Vector3>();\r\n        const step = 1.0 / nbPoints;\r\n        for (let i = 0; i <= nbPoints; i++) {\r\n            hermite.push(Vector3.Hermite(p1, t1, p2, t2, i * step));\r\n        }\r\n        return new Curve3(hermite);\r\n    }\r\n\r\n    /**\r\n     * Returns a Curve3 object along a CatmullRom Spline curve :\r\n     * @param points (array of Vector3) the points the spline must pass through. At least, four points required\r\n     * @param nbPoints (integer) the wanted number of points between each curve control points\r\n     * @param closed (boolean) optional with default false, when true forms a closed loop from the points\r\n     * @returns the created Curve3\r\n     */\r\n    public static CreateCatmullRomSpline(points: DeepImmutable<Vector3[]>, nbPoints: number, closed?: boolean): Curve3 {\r\n        const catmullRom = new Array<Vector3>();\r\n        const step = 1.0 / nbPoints;\r\n        let amount = 0.0;\r\n        if (closed) {\r\n            const pointsCount = points.length;\r\n            for (let i = 0; i < pointsCount; i++) {\r\n                amount = 0;\r\n                for (let c = 0; c < nbPoints; c++) {\r\n                    catmullRom.push(\r\n                        Vector3.CatmullRom(points[i % pointsCount], points[(i + 1) % pointsCount], points[(i + 2) % pointsCount], points[(i + 3) % pointsCount], amount)\r\n                    );\r\n                    amount += step;\r\n                }\r\n            }\r\n            catmullRom.push(catmullRom[0]);\r\n        } else {\r\n            const totalPoints = new Array<Vector3>();\r\n            totalPoints.push(points[0].clone());\r\n            Array.prototype.push.apply(totalPoints, points);\r\n            totalPoints.push(points[points.length - 1].clone());\r\n            let i = 0;\r\n            for (; i < totalPoints.length - 3; i++) {\r\n                amount = 0;\r\n                for (let c = 0; c < nbPoints; c++) {\r\n                    catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\r\n                    amount += step;\r\n                }\r\n            }\r\n            i--;\r\n            catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\r\n        }\r\n        return new Curve3(catmullRom);\r\n    }\r\n\r\n    /**\r\n     * Returns a Curve3 object along an arc through three vector3 points:\r\n     * The three points should not be colinear. When they are the Curve3 is empty.\r\n     * @param first (Vector3) the first point the arc must pass through.\r\n     * @param second (Vector3) the second point the arc must pass through.\r\n     * @param third (Vector3) the third point the arc must pass through.\r\n     * @param steps (number) the larger the number of steps the more detailed the arc.\r\n     * @param closed (boolean) optional with default false, when true forms the chord from the first and third point\r\n     * @param fullCircle Circle (boolean) optional with default false, when true forms the complete circle through the three points\r\n     * @returns the created Curve3\r\n     */\r\n    public static ArcThru3Points(first: Vector3, second: Vector3, third: Vector3, steps: number = 32, closed: boolean = false, fullCircle: boolean = false): Curve3 {\r\n        const arc = new Array<Vector3>();\r\n        const vec1 = second.subtract(first);\r\n        const vec2 = third.subtract(second);\r\n        const vec3 = first.subtract(third);\r\n        const zAxis = Vector3.Cross(vec1, vec2);\r\n        const len4 = zAxis.length();\r\n        if (len4 < Math.pow(10, -8)) {\r\n            return new Curve3(arc); // colinear points arc is empty\r\n        }\r\n        const len1_sq = vec1.lengthSquared();\r\n        const len2_sq = vec2.lengthSquared();\r\n        const len3_sq = vec3.lengthSquared();\r\n        const len4_sq = zAxis.lengthSquared();\r\n        const len1 = vec1.length();\r\n        const len2 = vec2.length();\r\n        const len3 = vec3.length();\r\n        const radius = (0.5 * len1 * len2 * len3) / len4;\r\n        const dot1 = Vector3.Dot(vec1, vec3);\r\n        const dot2 = Vector3.Dot(vec1, vec2);\r\n        const dot3 = Vector3.Dot(vec2, vec3);\r\n        const a = (-0.5 * len2_sq * dot1) / len4_sq;\r\n        const b = (-0.5 * len3_sq * dot2) / len4_sq;\r\n        const c = (-0.5 * len1_sq * dot3) / len4_sq;\r\n        const center = first.scale(a).add(second.scale(b)).add(third.scale(c));\r\n        const radiusVec = first.subtract(center);\r\n        const xAxis = radiusVec.normalize();\r\n        const yAxis = Vector3.Cross(zAxis, xAxis).normalize();\r\n        if (fullCircle) {\r\n            const dStep = (2 * Math.PI) / steps;\r\n            for (let theta = 0; theta <= 2 * Math.PI; theta += dStep) {\r\n                arc.push(center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta)))));\r\n            }\r\n            arc.push(first);\r\n        } else {\r\n            const dStep = 1 / steps;\r\n            let theta = 0;\r\n            let point = Vector3.Zero();\r\n            do {\r\n                point = center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta))));\r\n                arc.push(point);\r\n                theta += dStep;\r\n            } while (!point.equalsWithEpsilon(third, radius * dStep * 1.1));\r\n            arc.push(third);\r\n            if (closed) {\r\n                arc.push(first);\r\n            }\r\n        }\r\n        return new Curve3(arc);\r\n    }\r\n\r\n    /**\r\n     * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\r\n     * A Curve3 is designed from a series of successive Vector3.\r\n     * Tuto : https://doc.babylonjs.com/how_to/how_to_use_curve3#curve3-object\r\n     * @param points points which make up the curve\r\n     */\r\n    constructor(points: Vector3[]) {\r\n        this._points = points;\r\n        this._length = this._computeLength(points);\r\n    }\r\n\r\n    /**\r\n     * @returns the Curve3 stored array of successive Vector3\r\n     */\r\n    public getPoints() {\r\n        return this._points;\r\n    }\r\n\r\n    /**\r\n     * @returns the computed length (float) of the curve.\r\n     */\r\n    public length() {\r\n        return this._length;\r\n    }\r\n\r\n    /**\r\n     * Returns a new instance of Curve3 object : var curve = curveA.continue(curveB);\r\n     * This new Curve3 is built by translating and sticking the curveB at the end of the curveA.\r\n     * curveA and curveB keep unchanged.\r\n     * @param curve the curve to continue from this curve\r\n     * @returns the newly constructed curve\r\n     */\r\n    public continue(curve: DeepImmutable<Curve3>): Curve3 {\r\n        const lastPoint = this._points[this._points.length - 1];\r\n        const continuedPoints = this._points.slice();\r\n        const curvePoints = curve.getPoints();\r\n        for (let i = 1; i < curvePoints.length; i++) {\r\n            continuedPoints.push(curvePoints[i].subtract(curvePoints[0]).add(lastPoint));\r\n        }\r\n        const continuedCurve = new Curve3(continuedPoints);\r\n        return continuedCurve;\r\n    }\r\n\r\n    private _computeLength(path: DeepImmutable<Vector3[]>): number {\r\n        let l = 0;\r\n        for (let i = 1; i < path.length; i++) {\r\n            l += path[i].subtract(path[i - 1]).length();\r\n        }\r\n        return l;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}