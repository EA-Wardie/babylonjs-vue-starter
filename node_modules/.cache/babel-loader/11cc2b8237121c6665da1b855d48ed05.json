{"ast":null,"code":"import \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport { __spreadArray } from \"tslib\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\"; // This implementation was based on the original MIT-licensed TRACE repository\n// from https://github.com/septagon/TRACE.\n\n/**\n * Generic implementation of Levenshtein distance.\n */\n\nvar Levenshtein;\n\n(function (Levenshtein) {\n  /**\n   * Alphabet from which to construct sequences to be compared using Levenshtein\n   * distance.\n   */\n  var Alphabet =\n  /** @class */\n  function () {\n    /**\n     * Create a new Alphabet.\n     * @param characters characters of the alphabet\n     * @param charToInsertionCost function mapping characters to insertion costs\n     * @param charToDeletionCost function mapping characters to deletion costs\n     * @param charsToSubstitutionCost function mapping character pairs to substitution costs\n     */\n    function Alphabet(characters, charToInsertionCost, charToDeletionCost, charsToSubstitutionCost) {\n      if (charToInsertionCost === void 0) {\n        charToInsertionCost = null;\n      }\n\n      if (charToDeletionCost === void 0) {\n        charToDeletionCost = null;\n      }\n\n      if (charsToSubstitutionCost === void 0) {\n        charsToSubstitutionCost = null;\n      }\n\n      charToInsertionCost = charToInsertionCost !== null && charToInsertionCost !== void 0 ? charToInsertionCost : function () {\n        return 1;\n      };\n      charToDeletionCost = charToDeletionCost !== null && charToDeletionCost !== void 0 ? charToDeletionCost : function () {\n        return 1;\n      };\n      charsToSubstitutionCost = charsToSubstitutionCost !== null && charsToSubstitutionCost !== void 0 ? charsToSubstitutionCost : function (a, b) {\n        return a === b ? 0 : 1;\n      };\n      this._characterToIdx = new Map();\n      this._insertionCosts = new Array(characters.length);\n      this._deletionCosts = new Array(characters.length);\n      this._substitutionCosts = new Array(characters.length);\n      var c;\n\n      for (var outerIdx = 0; outerIdx < characters.length; ++outerIdx) {\n        c = characters[outerIdx];\n\n        this._characterToIdx.set(c, outerIdx);\n\n        this._insertionCosts[outerIdx] = charToInsertionCost(c);\n        this._deletionCosts[outerIdx] = charToDeletionCost(c);\n        this._substitutionCosts[outerIdx] = new Array(characters.length);\n\n        for (var innerIdx = outerIdx; innerIdx < characters.length; ++innerIdx) {\n          this._substitutionCosts[outerIdx][innerIdx] = charsToSubstitutionCost(c, characters[innerIdx]);\n        }\n      }\n    }\n    /**\n     * Serialize the Alphabet to JSON string.\n     * @returns JSON serialization\n     */\n\n\n    Alphabet.prototype.serialize = function () {\n      var jsonObject = {};\n      var characters = new Array(this._characterToIdx.size);\n\n      this._characterToIdx.forEach(function (v, k) {\n        characters[v] = k;\n      });\n\n      jsonObject[\"characters\"] = characters;\n      jsonObject[\"insertionCosts\"] = this._insertionCosts;\n      jsonObject[\"deletionCosts\"] = this._deletionCosts;\n      jsonObject[\"substitutionCosts\"] = this._substitutionCosts;\n      return JSON.stringify(jsonObject);\n    };\n    /**\n     * Parse an Alphabet from a JSON serialization.\n     * @param json JSON string to deserialize\n     * @returns deserialized Alphabet\n     */\n\n\n    Alphabet.Deserialize = function (json) {\n      var jsonObject = JSON.parse(json);\n      var alphabet = new Alphabet(jsonObject[\"characters\"]);\n      alphabet._insertionCosts = jsonObject[\"insertionCosts\"];\n      alphabet._deletionCosts = jsonObject[\"deletionCosts\"];\n      alphabet._substitutionCosts = jsonObject[\"substitutionCosts\"];\n      return alphabet;\n    };\n    /**\n     * Get the index (internally-assigned number) for a character.\n     * @param char character\n     * @returns index\n     */\n\n\n    Alphabet.prototype.getCharacterIdx = function (_char) {\n      return this._characterToIdx.get(_char);\n    };\n    /**\n     * Get the insertion cost of a character from its index.\n     * @param idx character index\n     * @returns insertion cost\n     */\n\n\n    Alphabet.prototype.getInsertionCost = function (idx) {\n      return this._insertionCosts[idx];\n    };\n    /**\n     * Get the deletion cost of a character from its index.\n     * @param idx character index\n     * @returns deletion cost\n     */\n\n\n    Alphabet.prototype.getDeletionCost = function (idx) {\n      return this._deletionCosts[idx];\n    };\n    /**\n     * Gets the cost to substitute two characters. NOTE: this cost is\n     * required to be bi-directional, meaning it cannot matter which of\n     * the provided characters is being removed and which is being inserted.\n     * @param idx1 the first character index\n     * @param idx2 the second character index\n     * @returns substitution cost\n     */\n\n\n    Alphabet.prototype.getSubstitutionCost = function (idx1, idx2) {\n      var min = Math.min(idx1, idx2);\n      var max = Math.max(idx1, idx2);\n      return this._substitutionCosts[min][max];\n    };\n\n    return Alphabet;\n  }();\n\n  Levenshtein.Alphabet = Alphabet;\n  /**\n   * Character sequence intended to be compared against other Sequences created\n   * with the same Alphabet in order to compute Levenshtein distance.\n   */\n\n  var Sequence =\n  /** @class */\n  function () {\n    /**\n     * Create a new Sequence.\n     * @param characters characters in the new Sequence\n     * @param alphabet Alphabet, which must include all used characters\n     */\n    function Sequence(characters, alphabet) {\n      var _this = this;\n\n      if (characters.length > Sequence._MAX_SEQUENCE_LENGTH) {\n        throw new Error(\"Sequences longer than \" + Sequence._MAX_SEQUENCE_LENGTH + \" not supported.\");\n      }\n\n      this._alphabet = alphabet;\n      this._characters = characters.map(function (c) {\n        return _this._alphabet.getCharacterIdx(c);\n      });\n    }\n    /**\n     * Serialize to JSON string. JSON representation does NOT include the Alphabet\n     * from which this Sequence was created; Alphabet must be independently\n     * serialized.\n     * @returns JSON string\n     */\n\n\n    Sequence.prototype.serialize = function () {\n      return JSON.stringify(this._characters);\n    };\n    /**\n     * Deserialize from JSON string and Alphabet. This should be the same Alphabet\n     * from which the Sequence was originally created, which must be serialized and\n     * deserialized independently so that it can be passed in here.\n     * @param json JSON string representation of Sequence\n     * @param alphabet Alphabet from which Sequence was originally created\n     * @returns Sequence\n     */\n\n\n    Sequence.Deserialize = function (json, alphabet) {\n      var sequence = new Sequence([], alphabet);\n      sequence._characters = JSON.parse(json);\n      return sequence;\n    };\n    /**\n     * Get the distance between this Sequence and another.\n     * @param other sequence to compare to\n     * @returns Levenshtein distance\n     */\n\n\n    Sequence.prototype.distance = function (other) {\n      return Sequence._Distance(this, other);\n    };\n    /**\n     * Compute the Levenshtein distance between two Sequences.\n     * @param a first Sequence\n     * @param b second Sequence\n     * @returns Levenshtein distance\n     */\n\n\n    Sequence._Distance = function (a, b) {\n      var alphabet = a._alphabet;\n\n      if (alphabet !== b._alphabet) {\n        throw new Error(\"Cannot Levenshtein compare Sequences built from different alphabets.\");\n      }\n\n      var aChars = a._characters;\n      var bChars = b._characters;\n      var aLength = aChars.length;\n      var bLength = bChars.length;\n      var costMatrix = Sequence._CostMatrix;\n      costMatrix[0][0] = 0;\n\n      for (var idx = 0; idx < aLength; ++idx) {\n        costMatrix[idx + 1][0] = costMatrix[idx][0] + alphabet.getInsertionCost(aChars[idx]);\n      }\n\n      for (var idx = 0; idx < bLength; ++idx) {\n        costMatrix[0][idx + 1] = costMatrix[0][idx] + alphabet.getInsertionCost(bChars[idx]);\n      }\n\n      for (var aIdx = 0; aIdx < aLength; ++aIdx) {\n        for (var bIdx = 0; bIdx < bLength; ++bIdx) {\n          Sequence._InsertionCost = costMatrix[aIdx + 1][bIdx] + alphabet.getInsertionCost(bChars[bIdx]);\n          Sequence._DeletionCost = costMatrix[aIdx][bIdx + 1] + alphabet.getDeletionCost(aChars[aIdx]);\n          Sequence._SubstitutionCost = costMatrix[aIdx][bIdx] + alphabet.getSubstitutionCost(aChars[aIdx], bChars[bIdx]);\n          costMatrix[aIdx + 1][bIdx + 1] = Math.min(Sequence._InsertionCost, Sequence._DeletionCost, Sequence._SubstitutionCost);\n        }\n      }\n\n      return costMatrix[aLength][bLength];\n    }; // Scratch values\n\n\n    Sequence._MAX_SEQUENCE_LENGTH = 256;\n    Sequence._CostMatrix = __spreadArray([], Array(Sequence._MAX_SEQUENCE_LENGTH + 1), true).map(function () {\n      return new Array(Sequence._MAX_SEQUENCE_LENGTH + 1);\n    });\n    return Sequence;\n  }();\n\n  Levenshtein.Sequence = Sequence;\n})(Levenshtein || (Levenshtein = {}));\n/**\n * A 3D trajectory consisting of an order list of vectors describing a\n * path of motion through 3D space.\n */\n\n\nvar Trajectory =\n/** @class */\nfunction () {\n  /**\n   * Create a new empty Trajectory.\n   * @param segmentLength radius of discretization for Trajectory points\n   */\n  function Trajectory(segmentLength) {\n    if (segmentLength === void 0) {\n      segmentLength = 0.01;\n    }\n\n    this._points = [];\n    this._segmentLength = segmentLength;\n  }\n  /**\n   * Serialize to JSON.\n   * @returns serialized JSON string\n   */\n\n\n  Trajectory.prototype.serialize = function () {\n    return JSON.stringify(this);\n  };\n  /**\n   * Deserialize from JSON.\n   * @param json serialized JSON string\n   * @returns deserialized Trajectory\n   */\n\n\n  Trajectory.Deserialize = function (json) {\n    var jsonObject = JSON.parse(json);\n    var trajectory = new Trajectory(jsonObject[\"_segmentLength\"]);\n    trajectory._points = jsonObject[\"_points\"].map(function (pt) {\n      return new Vector3(pt[\"_x\"], pt[\"_y\"], pt[\"_z\"]);\n    });\n    return trajectory;\n  };\n  /**\n   * Get the length of the Trajectory.\n   * @returns length of the Trajectory\n   */\n\n\n  Trajectory.prototype.getLength = function () {\n    return this._points.length * this._segmentLength;\n  };\n  /**\n   * Append a new point to the Trajectory.\n   * NOTE: This implementation has many allocations.\n   * @param point point to append to the Trajectory\n   */\n\n\n  Trajectory.prototype.add = function (point) {\n    var _this = this;\n\n    var numPoints = this._points.length;\n\n    if (numPoints === 0) {\n      this._points.push(point.clone());\n    } else {\n      var getT = function getT() {\n        return _this._segmentLength / Vector3.Distance(_this._points[numPoints - 1], point);\n      };\n\n      for (var t = getT(); t <= 1.0; t = getT()) {\n        var newPoint = this._points[numPoints - 1].scale(1.0 - t);\n\n        point.scaleAndAddToRef(t, newPoint);\n\n        this._points.push(newPoint);\n\n        ++numPoints;\n      }\n    }\n  };\n  /**\n   * Create a new Trajectory with a segment length chosen to make it\n   * probable that the new Trajectory will have a specified number of\n   * segments. This operation is imprecise.\n   * @param targetResolution number of segments desired\n   * @returns new Trajectory with approximately the requested number of segments\n   */\n\n\n  Trajectory.prototype.resampleAtTargetResolution = function (targetResolution) {\n    var resampled = new Trajectory(this.getLength() / targetResolution);\n\n    this._points.forEach(function (pt) {\n      resampled.add(pt);\n    });\n\n    return resampled;\n  };\n  /**\n   * Convert Trajectory segments into tokenized representation. This\n   * representation is an array of numbers where each nth number is the\n   * index of the token which is most similar to the nth segment of the\n   * Trajectory.\n   * @param tokens list of vectors which serve as discrete tokens\n   * @returns list of indices of most similar token per segment\n   */\n\n\n  Trajectory.prototype.tokenize = function (tokens) {\n    var tokenization = [];\n    var segmentDir = new Vector3();\n\n    for (var idx = 2; idx < this._points.length; ++idx) {\n      if (Trajectory._TransformSegmentDirToRef(this._points[idx - 2], this._points[idx - 1], this._points[idx], segmentDir)) {\n        tokenization.push(Trajectory._TokenizeSegment(segmentDir, tokens));\n      }\n    }\n\n    return tokenization;\n  };\n  /**\n   * Transform the rotation (i.e., direction) of a segment to isolate\n   * the relative transformation represented by the segment. This operation\n   * may or may not succeed due to singularities in the equations that define\n   * motion relativity in this context.\n   * @param priorVec the origin of the prior segment\n   * @param fromVec the origin of the current segment\n   * @param toVec the destination of the current segment\n   * @param result reference to output variable\n   * @returns whether or not transformation was successful\n   */\n\n\n  Trajectory._TransformSegmentDirToRef = function (priorVec, fromVec, toVec, result) {\n    var DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD = 0.98;\n    fromVec.subtractToRef(priorVec, Trajectory._ForwardDir);\n\n    Trajectory._ForwardDir.normalize();\n\n    fromVec.scaleToRef(-1, Trajectory._InverseFromVec);\n\n    Trajectory._InverseFromVec.normalize();\n\n    if (Math.abs(Vector3.Dot(Trajectory._ForwardDir, Trajectory._InverseFromVec)) > DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD) {\n      return false;\n    }\n\n    Vector3.CrossToRef(Trajectory._ForwardDir, Trajectory._InverseFromVec, Trajectory._UpDir);\n\n    Trajectory._UpDir.normalize();\n\n    Matrix.LookAtLHToRef(priorVec, fromVec, Trajectory._UpDir, Trajectory._LookMatrix);\n    toVec.subtractToRef(fromVec, Trajectory._FromToVec);\n\n    Trajectory._FromToVec.normalize();\n\n    Vector3.TransformNormalToRef(Trajectory._FromToVec, Trajectory._LookMatrix, result);\n    return true;\n  };\n  /**\n   * Determine which token vector is most similar to the\n   * segment vector.\n   * @param segment segment vector\n   * @param tokens token vector list\n   * @returns index of the most similar token to the segment\n   */\n\n\n  Trajectory._TokenizeSegment = function (segment, tokens) {\n    Trajectory._BestMatch = 0;\n    Trajectory._Score = Vector3.Dot(segment, tokens[0]);\n    Trajectory._BestScore = Trajectory._Score;\n\n    for (var idx = 1; idx < tokens.length; ++idx) {\n      Trajectory._Score = Vector3.Dot(segment, tokens[idx]);\n\n      if (Trajectory._Score > Trajectory._BestScore) {\n        Trajectory._BestMatch = idx;\n        Trajectory._BestScore = Trajectory._Score;\n      }\n    }\n\n    return Trajectory._BestMatch;\n  };\n\n  Trajectory._ForwardDir = new Vector3();\n  Trajectory._InverseFromVec = new Vector3();\n  Trajectory._UpDir = new Vector3();\n  Trajectory._FromToVec = new Vector3();\n  Trajectory._LookMatrix = new Matrix();\n  return Trajectory;\n}();\n\nexport { Trajectory };\n/**\n * Collection of vectors intended to be used as the basis of Trajectory\n * tokenization for Levenshtein distance comparison. Canonically, a\n * Vector3Alphabet will resemble a \"spikeball\" of vectors distributed\n * roughly evenly over the surface of the unit sphere.\n */\n\nvar Vector3Alphabet =\n/** @class */\nfunction () {\n  function Vector3Alphabet(size) {\n    this.chars = new Array(size);\n  }\n  /**\n   * Helper method to create new \"spikeball\" Vector3Alphabets. Uses a naive\n   * optimize-from-random strategy to space points around the unit sphere\n   * surface as a simple alternative to really doing the math to tile the\n   * sphere.\n   * @param alphabetSize size of the desired alphabet\n   * @param iterations number of iterations over which to optimize the \"spikeball\"\n   * @param startingStepSize distance factor to move points in early optimization iterations\n   * @param endingStepSize distance factor to move points in late optimization iterations\n   * @param fixedValues alphabet \"characters\" that are required and cannot be moved by optimization\n   * @returns a new randomly generated and optimized Vector3Alphabet of the specified size\n   */\n\n\n  Vector3Alphabet.Generate = function (alphabetSize, iterations, startingStepSize, endingStepSize, fixedValues) {\n    if (alphabetSize === void 0) {\n      alphabetSize = 64;\n    }\n\n    if (iterations === void 0) {\n      iterations = 256;\n    }\n\n    if (startingStepSize === void 0) {\n      startingStepSize = 0.1;\n    }\n\n    if (endingStepSize === void 0) {\n      endingStepSize = 0.001;\n    }\n\n    if (fixedValues === void 0) {\n      fixedValues = [];\n    }\n\n    var EPSILON = 0.001;\n    var EPSILON_SQUARED = EPSILON * EPSILON;\n    var alphabet = new Vector3Alphabet(alphabetSize);\n\n    for (var idx = 0; idx < alphabetSize; ++idx) {\n      alphabet.chars[idx] = new Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);\n      alphabet.chars[idx].normalize();\n    }\n\n    for (var idx = 0; idx < fixedValues.length; ++idx) {\n      alphabet.chars[idx].copyFrom(fixedValues[idx]);\n    }\n\n    var stepSize;\n    var distSq;\n    var force = new Vector3();\n    var scratch = new Vector3();\n\n    var lerp = function lerp(l, r, t) {\n      return (1.0 - t) * l + t * r;\n    };\n\n    for (var iteration = 0; iteration < iterations; ++iteration) {\n      stepSize = lerp(startingStepSize, endingStepSize, iteration / (iterations - 1));\n\n      var _loop_1 = function _loop_1(idx) {\n        force.copyFromFloats(0, 0, 0);\n        alphabet.chars.forEach(function (pt) {\n          alphabet.chars[idx].subtractToRef(pt, scratch);\n          distSq = scratch.lengthSquared();\n\n          if (distSq > EPSILON_SQUARED) {\n            scratch.scaleAndAddToRef(1 / (scratch.lengthSquared() * distSq), force);\n          }\n        });\n        force.scaleInPlace(stepSize);\n        alphabet.chars[idx].addInPlace(force);\n        alphabet.chars[idx].normalize();\n      };\n\n      for (var idx = fixedValues.length; idx < alphabet.chars.length; ++idx) {\n        _loop_1(idx);\n      }\n    }\n\n    return alphabet;\n  };\n  /**\n   * Serialize to JSON.\n   * @returns JSON serialization\n   */\n\n\n  Vector3Alphabet.prototype.serialize = function () {\n    return JSON.stringify(this.chars);\n  };\n  /**\n   * Deserialize from JSON.\n   * @param json JSON serialization\n   * @returns deserialized Vector3Alphabet\n   */\n\n\n  Vector3Alphabet.Deserialize = function (json) {\n    var jsonObject = JSON.parse(json);\n    var alphabet = new Vector3Alphabet(jsonObject.length);\n\n    for (var idx = 0; idx < jsonObject.length; ++idx) {\n      alphabet.chars[idx] = new Vector3(jsonObject[idx][\"_x\"], jsonObject[idx][\"_y\"], jsonObject[idx][\"_z\"]);\n    }\n\n    return alphabet;\n  };\n\n  return Vector3Alphabet;\n}();\n/**\n * Class which formalizes the manner in which a Vector3Alphabet is used to tokenize and\n * describe a Trajectory. This class houses the functionality which determines what\n * attributes of Trajectories are and are not considered important, such as scale.\n */\n\n\nvar TrajectoryDescriptor =\n/** @class */\nfunction () {\n  function TrajectoryDescriptor() {\n    this._sequences = [];\n  }\n  /**\n   * Serialize to JSON.\n   * @returns JSON serialization\n   */\n\n\n  TrajectoryDescriptor.prototype.serialize = function () {\n    return JSON.stringify(this._sequences.map(function (sequence) {\n      return sequence.serialize();\n    }));\n  };\n  /**\n   * Deserialize from JSON string and Alphabet. This should be the same Alphabet\n   * from which the descriptor was originally created, which must be serialized and\n   * deserialized independently so that it can be passed in here.\n   * @param json JSON serialization\n   * @param alphabet Alphabet from which descriptor was originally created\n   * @returns deserialized TrajectoryDescriptor\n   */\n\n\n  TrajectoryDescriptor.Deserialize = function (json, alphabet) {\n    var descriptor = new TrajectoryDescriptor();\n    descriptor._sequences = JSON.parse(json).map(function (s) {\n      return Levenshtein.Sequence.Deserialize(s, alphabet);\n    });\n    return descriptor;\n  };\n  /**\n   * Create a new TrajectoryDescriptor to describe a provided Trajectory according\n   * to the provided alphabets.\n   * @param trajectory Trajectory to be described\n   * @param vector3Alphabet Vector3Alphabet to be used to tokenize the Trajectory\n   * @param levenshteinAlphabet Levenshtein.Alphabet to be used as basis for comparison with other descriptors\n   * @returns TrajectoryDescriptor describing provided Trajectory\n   */\n\n\n  TrajectoryDescriptor.CreateFromTrajectory = function (trajectory, vector3Alphabet, levenshteinAlphabet) {\n    return TrajectoryDescriptor.CreateFromTokenizationPyramid(TrajectoryDescriptor._GetTokenizationPyramid(trajectory, vector3Alphabet), levenshteinAlphabet);\n  };\n  /**\n   * Create a new TrajectoryDescriptor from a pre-existing pyramid of tokens.\n   * NOTE: This function exists to support an outdated serialization mechanism and should\n   * be deleted if it is no longer useful.\n   * @param pyramid tokenization pyramid\n   * @param levenshteinAlphabet Levenshtein.Alphabet to be uses as basis for comparison with other descriptors\n   * @returns TrajectoryDescriptor describing the Trajectory from which the pyramid was built\n   */\n\n\n  TrajectoryDescriptor.CreateFromTokenizationPyramid = function (pyramid, levenshteinAlphabet) {\n    var descriptor = new TrajectoryDescriptor();\n    descriptor._sequences = pyramid.map(function (tokens) {\n      return new Levenshtein.Sequence(tokens, levenshteinAlphabet);\n    });\n    return descriptor;\n  };\n  /**\n   * Create the tokenization pyramid for the provided Trajectory according to the given\n   * Vector3Alphabet.\n   * @param trajectory Trajectory to be tokenized\n   * @param alphabet Vector3Alphabet containing tokens\n   * @param targetResolution finest resolution of descriptor\n   * @returns tokenization pyramid for Trajectory\n   */\n\n\n  TrajectoryDescriptor._GetTokenizationPyramid = function (trajectory, alphabet, targetResolution) {\n    if (targetResolution === void 0) {\n      targetResolution = TrajectoryDescriptor._FINEST_DESCRIPTOR_RESOLUTION;\n    }\n\n    var pyramid = [];\n\n    for (var res = targetResolution; res > 4; res = Math.floor(res / 2)) {\n      pyramid.push(trajectory.resampleAtTargetResolution(res).tokenize(alphabet.chars));\n    }\n\n    return pyramid;\n  };\n  /**\n   * Calculate a distance metric between this TrajectoryDescriptor and another. This is\n   * essentially a similarity score and does not directly represent Euclidean distance,\n   * edit distance, or any other formal distance metric.\n   * @param other TrajectoryDescriptor from which to determine distance\n   * @returns distance, a nonnegative similarity score where larger values indicate dissimilarity\n   */\n\n\n  TrajectoryDescriptor.prototype.distance = function (other) {\n    var totalDistance = 0;\n    var weight;\n\n    for (var idx = 0; idx < this._sequences.length; ++idx) {\n      weight = Math.pow(2, idx);\n      totalDistance += weight * this._sequences[idx].distance(other._sequences[idx]);\n    }\n\n    return totalDistance;\n  };\n\n  TrajectoryDescriptor._FINEST_DESCRIPTOR_RESOLUTION = 32;\n  return TrajectoryDescriptor;\n}();\n/**\n * A set of TrajectoryDescriptors defined to be \"the same.\" This is essentially a helper\n * class to facilitate methods of Trajectory clustering.\n */\n\n\nvar TrajectoryClass =\n/** @class */\nfunction () {\n  /**\n   * Create a new DescribedTrajectory.\n   * @param descriptors currently-known TrajectoryDescriptors, if any\n   */\n  function TrajectoryClass(descriptors) {\n    if (descriptors === void 0) {\n      descriptors = [];\n    }\n\n    this._descriptors = descriptors;\n    this._centroidIdx = -1;\n    this._averageDistance = 0;\n\n    this._refreshDescription();\n  }\n  /**\n   * Serialize to JSON.\n   * @returns JSON serialization\n   */\n\n\n  TrajectoryClass.prototype.serialize = function () {\n    var jsonObject = {};\n    jsonObject.descriptors = this._descriptors.map(function (desc) {\n      return desc.serialize();\n    });\n    jsonObject.centroidIdx = this._centroidIdx;\n    jsonObject.averageDistance = this._averageDistance;\n    return JSON.stringify(jsonObject);\n  };\n  /**\n   * Deserialize from JSON string and Alphabet. This should be the same Alphabet\n   * from which the descriptors were originally created, which must be serialized and\n   * deserialized independently so that it can be passed in here.\n   * @param json JSON string representation\n   * @param alphabet Alphabet from which TrajectoryDescriptors were originally created\n   * @returns deserialized TrajectoryDescriptor\n   */\n\n\n  TrajectoryClass.Deserialize = function (json, alphabet) {\n    var jsonObject = JSON.parse(json);\n    var described = new TrajectoryClass();\n    described._descriptors = jsonObject.descriptors.map(function (s) {\n      return TrajectoryDescriptor.Deserialize(s, alphabet);\n    });\n    described._centroidIdx = jsonObject.centroidIdx;\n    described._averageDistance = jsonObject.averageDistance;\n    return described;\n  };\n  /**\n   * Add a new TrajectoryDescriptor to the list of descriptors known to describe\n   * this same DescribedTrajectory.\n   * @param descriptor descriptor to be added\n   */\n\n\n  TrajectoryClass.prototype.add = function (descriptor) {\n    this._descriptors.push(descriptor);\n\n    this._refreshDescription();\n  };\n  /**\n   * Compute the cost, which is inversely related to the likelihood that the provided\n   * TrajectoryDescriptor describes a Trajectory that is considered to be the same as\n   * the class represented by this DescribedTrajectory.\n   * @param descriptor the descriptor to be costed\n   * @returns cost of the match, which is a nonnegative similarity metric where larger values indicate dissimilarity\n   */\n\n\n  TrajectoryClass.prototype.getMatchCost = function (descriptor) {\n    return descriptor.distance(this._descriptors[this._centroidIdx]) / this._averageDistance;\n  };\n  /**\n   * Compute the minimum distance between the queried TrajectoryDescriptor and a\n   * descriptor which is a member of this collection. This is an alternative way of\n   * conceptualizing match cost from getMatchCost(), and it serves a different function.\n   * @param descriptor the descriptor to find the minimum distance to\n   * @returns minimum descriptor distance to a member descriptor of this DescribedTrajectory\n   */\n\n\n  TrajectoryClass.prototype.getMatchMinimumDistance = function (descriptor) {\n    return Math.min.apply(Math, this._descriptors.map(function (desc) {\n      return desc.distance(descriptor);\n    }));\n  };\n  /**\n   * Refreshes the internal representation of this DescribedTrajectory.\n   */\n\n\n  TrajectoryClass.prototype._refreshDescription = function () {\n    var _this = this;\n\n    this._centroidIdx = -1;\n    var sum;\n\n    var distances = this._descriptors.map(function (a) {\n      sum = 0;\n\n      _this._descriptors.forEach(function (b) {\n        sum += a.distance(b);\n      });\n\n      return sum;\n    });\n\n    for (var idx = 0; idx < distances.length; ++idx) {\n      if (this._centroidIdx < 0 || distances[idx] < distances[this._centroidIdx]) {\n        this._centroidIdx = idx;\n      }\n    }\n\n    this._averageDistance = 0;\n\n    this._descriptors.forEach(function (desc) {\n      _this._averageDistance += desc.distance(_this._descriptors[_this._centroidIdx]);\n    });\n\n    if (this._descriptors.length > 0) {\n      this._averageDistance = Math.max(this._averageDistance / this._descriptors.length, TrajectoryClass._MIN_AVERAGE_DISTANCE);\n    }\n  };\n\n  TrajectoryClass._MIN_AVERAGE_DISTANCE = 1;\n  return TrajectoryClass;\n}();\n/**\n * Class representing a set of known, named trajectories to which Trajectories can be\n * added and using which Trajectories can be recognized.\n */\n\n\nvar TrajectoryClassifier =\n/** @class */\nfunction () {\n  function TrajectoryClassifier() {\n    this._maximumAllowableMatchCost = 4;\n    this._nameToDescribedTrajectory = new Map();\n  }\n  /**\n   * Serialize to JSON.\n   * @returns JSON serialization\n   */\n\n\n  TrajectoryClassifier.prototype.serialize = function () {\n    var jsonObject = {};\n    jsonObject.maximumAllowableMatchCost = this._maximumAllowableMatchCost;\n    jsonObject.vector3Alphabet = this._vector3Alphabet.serialize();\n    jsonObject.levenshteinAlphabet = this._levenshteinAlphabet.serialize();\n    jsonObject.nameToDescribedTrajectory = [];\n\n    this._nameToDescribedTrajectory.forEach(function (described, name) {\n      jsonObject.nameToDescribedTrajectory.push(name);\n      jsonObject.nameToDescribedTrajectory.push(described.serialize());\n    });\n\n    return JSON.stringify(jsonObject);\n  };\n  /**\n   * Deserialize from JSON.\n   * @param json JSON serialization\n   * @returns deserialized TrajectorySet\n   */\n\n\n  TrajectoryClassifier.Deserialize = function (json) {\n    var jsonObject = JSON.parse(json);\n    var classifier = new TrajectoryClassifier();\n    classifier._maximumAllowableMatchCost = jsonObject.maximumAllowableMatchCost;\n    classifier._vector3Alphabet = Vector3Alphabet.Deserialize(jsonObject.vector3Alphabet);\n    classifier._levenshteinAlphabet = Levenshtein.Alphabet.Deserialize(jsonObject.levenshteinAlphabet);\n\n    for (var idx = 0; idx < jsonObject.nameToDescribedTrajectory.length; idx += 2) {\n      classifier._nameToDescribedTrajectory.set(jsonObject.nameToDescribedTrajectory[idx], TrajectoryClass.Deserialize(jsonObject.nameToDescribedTrajectory[idx + 1], classifier._levenshteinAlphabet));\n    }\n\n    return classifier;\n  };\n  /**\n   * Initialize a new empty TrajectorySet with auto-generated Alphabets.\n   * VERY naive, need to be generating these things from known\n   * sets. Better version later, probably eliminating this one.\n   * @returns auto-generated TrajectorySet\n   */\n\n\n  TrajectoryClassifier.Generate = function () {\n    var vecs = Vector3Alphabet.Generate(64, 256, 0.1, 0.001, [Vector3.Forward()]);\n    var charIdxs = new Array(vecs.chars.length);\n\n    for (var idx = 0; idx < charIdxs.length; ++idx) {\n      charIdxs[idx] = idx;\n    }\n\n    var alphabet = new Levenshtein.Alphabet(charIdxs, function (idx) {\n      return idx === 0 ? 0 : 1;\n    }, function (idx) {\n      return idx === 0 ? 0 : 1;\n    }, function (a, b) {\n      return Math.min(1 - Vector3.Dot(vecs.chars[a], vecs.chars[b]), 1);\n    });\n    var trajectorySet = new TrajectoryClassifier();\n    trajectorySet._vector3Alphabet = vecs;\n    trajectorySet._levenshteinAlphabet = alphabet;\n    return trajectorySet;\n  };\n  /**\n   * Add a new Trajectory to the set with a given name.\n   * @param trajectory new Trajectory to be added\n   * @param classification name to which to add the Trajectory\n   */\n\n\n  TrajectoryClassifier.prototype.addTrajectoryToClassification = function (trajectory, classification) {\n    if (!this._nameToDescribedTrajectory.has(classification)) {\n      this._nameToDescribedTrajectory.set(classification, new TrajectoryClass());\n    }\n\n    this._nameToDescribedTrajectory.get(classification).add(TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet));\n  };\n  /**\n   * Remove a known named trajectory and all Trajectories associated with it.\n   * @param classification name to remove\n   * @returns whether anything was removed\n   */\n\n\n  TrajectoryClassifier.prototype.deleteClassification = function (classification) {\n    return this._nameToDescribedTrajectory[\"delete\"](classification);\n  };\n  /**\n   * Attempt to recognize a Trajectory from among all the classifications\n   * already known to the classifier.\n   * @param trajectory Trajectory to be recognized\n   * @returns classification of Trajectory if recognized, null otherwise\n   */\n\n\n  TrajectoryClassifier.prototype.classifyTrajectory = function (trajectory) {\n    var _this = this;\n\n    var descriptor = TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet);\n    var allowableMatches = [];\n\n    this._nameToDescribedTrajectory.forEach(function (trajectoryClass, classification) {\n      if (trajectoryClass.getMatchCost(descriptor) < _this._maximumAllowableMatchCost) {\n        allowableMatches.push(classification);\n      }\n    });\n\n    if (allowableMatches.length === 0) {\n      return null;\n    }\n\n    var bestIdx = 0;\n\n    var bestMatch = this._nameToDescribedTrajectory.get(allowableMatches[bestIdx]).getMatchMinimumDistance(descriptor);\n\n    var match;\n\n    for (var idx = 0; idx < allowableMatches.length; ++idx) {\n      match = this._nameToDescribedTrajectory.get(allowableMatches[idx]).getMatchMinimumDistance(descriptor);\n\n      if (match < bestMatch) {\n        bestMatch = match;\n        bestIdx = idx;\n      }\n    }\n\n    return allowableMatches[bestIdx];\n  };\n\n  return TrajectoryClassifier;\n}();\n\nexport { TrajectoryClassifier };","map":{"version":3,"mappings":"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","names":["Matrix","Vector3","Levenshtein","characters","charToInsertionCost","charToDeletionCost","charsToSubstitutionCost","a","b","_characterToIdx","Map","_insertionCosts","Array","length","_deletionCosts","_substitutionCosts","c","outerIdx","set","innerIdx","Alphabet","jsonObject","size","forEach","v","k","JSON","stringify","json","parse","alphabet","char","get","idx","idx1","idx2","min","Math","max","Sequence","_MAX_SEQUENCE_LENGTH","Error","_alphabet","_characters","map","getCharacterIdx","sequence","other","_Distance","aChars","bChars","aLength","bLength","costMatrix","_CostMatrix","getInsertionCost","aIdx","bIdx","_InsertionCost","_DeletionCost","getDeletionCost","_SubstitutionCost","getSubstitutionCost","__spreadArray","segmentLength","_points","_segmentLength","Trajectory","trajectory","pt","point","numPoints","push","clone","getT","Distance","_this","t","newPoint","scale","scaleAndAddToRef","targetResolution","resampled","getLength","add","tokens","tokenization","segmentDir","_TransformSegmentDirToRef","_TokenizeSegment","priorVec","fromVec","toVec","result","DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD","subtractToRef","_ForwardDir","normalize","scaleToRef","_InverseFromVec","abs","Dot","CrossToRef","_UpDir","LookAtLHToRef","_LookMatrix","_FromToVec","TransformNormalToRef","segment","_BestMatch","_Score","_BestScore","chars","Vector3Alphabet","alphabetSize","iterations","startingStepSize","endingStepSize","fixedValues","EPSILON","EPSILON_SQUARED","random","copyFrom","stepSize","distSq","force","scratch","lerp","l","r","iteration","copyFromFloats","lengthSquared","scaleInPlace","addInPlace","_sequences","TrajectoryDescriptor","serialize","descriptor","s","Deserialize","vector3Alphabet","levenshteinAlphabet","CreateFromTokenizationPyramid","_GetTokenizationPyramid","pyramid","_FINEST_DESCRIPTOR_RESOLUTION","res","floor","resampleAtTargetResolution","tokenize","totalDistance","weight","pow","distance","descriptors","_descriptors","_centroidIdx","_averageDistance","_refreshDescription","TrajectoryClass","desc","centroidIdx","averageDistance","described","apply","sum","distances","_MIN_AVERAGE_DISTANCE","_nameToDescribedTrajectory","TrajectoryClassifier","maximumAllowableMatchCost","_maximumAllowableMatchCost","_vector3Alphabet","_levenshteinAlphabet","nameToDescribedTrajectory","name","classifier","vecs","Generate","Forward","charIdxs","trajectorySet","classification","has","CreateFromTrajectory","allowableMatches","trajectoryClass","getMatchCost","bestIdx","bestMatch","getMatchMinimumDistance","match"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/trajectoryClassifier.ts"],"sourcesContent":["import type { DeepImmutable, Nullable } from \"../types\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\n\r\n// This implementation was based on the original MIT-licensed TRACE repository\r\n// from https://github.com/septagon/TRACE.\r\n\r\n/**\r\n * Generic implementation of Levenshtein distance.\r\n */\r\nnamespace Levenshtein {\r\n    /**\r\n     * Alphabet from which to construct sequences to be compared using Levenshtein\r\n     * distance.\r\n     */\r\n    export class Alphabet<T> {\r\n        private _characterToIdx: Map<T, number>;\r\n        private _insertionCosts: number[];\r\n        private _deletionCosts: number[];\r\n        private _substitutionCosts: number[][];\r\n\r\n        /**\r\n         * Serialize the Alphabet to JSON string.\r\n         * @returns JSON serialization\r\n         */\r\n        public serialize(): string {\r\n            const jsonObject: any = {};\r\n\r\n            const characters = new Array<T>(this._characterToIdx.size);\r\n            this._characterToIdx.forEach((v, k) => {\r\n                characters[v] = k;\r\n            });\r\n            jsonObject[\"characters\"] = characters;\r\n\r\n            jsonObject[\"insertionCosts\"] = this._insertionCosts;\r\n            jsonObject[\"deletionCosts\"] = this._deletionCosts;\r\n            jsonObject[\"substitutionCosts\"] = this._substitutionCosts;\r\n\r\n            return JSON.stringify(jsonObject);\r\n        }\r\n\r\n        /**\r\n         * Parse an Alphabet from a JSON serialization.\r\n         * @param json JSON string to deserialize\r\n         * @returns deserialized Alphabet\r\n         */\r\n        public static Deserialize<T>(json: string): Alphabet<T> {\r\n            const jsonObject = JSON.parse(json);\r\n            const alphabet = new Alphabet(jsonObject[\"characters\"] as T[]);\r\n            alphabet._insertionCosts = jsonObject[\"insertionCosts\"];\r\n            alphabet._deletionCosts = jsonObject[\"deletionCosts\"];\r\n            alphabet._substitutionCosts = jsonObject[\"substitutionCosts\"];\r\n            return alphabet;\r\n        }\r\n\r\n        /**\r\n         * Create a new Alphabet.\r\n         * @param characters characters of the alphabet\r\n         * @param charToInsertionCost function mapping characters to insertion costs\r\n         * @param charToDeletionCost function mapping characters to deletion costs\r\n         * @param charsToSubstitutionCost function mapping character pairs to substitution costs\r\n         */\r\n        public constructor(\r\n            characters: Array<T>,\r\n            charToInsertionCost: Nullable<(char: T) => number> = null,\r\n            charToDeletionCost: Nullable<(char: T) => number> = null,\r\n            charsToSubstitutionCost: Nullable<(outChar: T, inChar: T) => number> = null\r\n        ) {\r\n            charToInsertionCost = charToInsertionCost ?? (() => 1);\r\n            charToDeletionCost = charToDeletionCost ?? (() => 1);\r\n            charsToSubstitutionCost = charsToSubstitutionCost ?? ((a: T, b: T) => (a === b ? 0 : 1));\r\n\r\n            this._characterToIdx = new Map<T, number>();\r\n            this._insertionCosts = new Array<number>(characters.length);\r\n            this._deletionCosts = new Array<number>(characters.length);\r\n            this._substitutionCosts = new Array<Array<number>>(characters.length);\r\n\r\n            let c: T;\r\n            for (let outerIdx = 0; outerIdx < characters.length; ++outerIdx) {\r\n                c = characters[outerIdx];\r\n                this._characterToIdx.set(c, outerIdx);\r\n                this._insertionCosts[outerIdx] = charToInsertionCost(c);\r\n                this._deletionCosts[outerIdx] = charToDeletionCost(c);\r\n\r\n                this._substitutionCosts[outerIdx] = new Array<number>(characters.length);\r\n                for (let innerIdx = outerIdx; innerIdx < characters.length; ++innerIdx) {\r\n                    this._substitutionCosts[outerIdx][innerIdx] = charsToSubstitutionCost(c, characters[innerIdx]);\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Get the index (internally-assigned number) for a character.\r\n         * @param char character\r\n         * @returns index\r\n         */\r\n        public getCharacterIdx(char: T): number {\r\n            return this._characterToIdx.get(char)!;\r\n        }\r\n\r\n        /**\r\n         * Get the insertion cost of a character from its index.\r\n         * @param idx character index\r\n         * @returns insertion cost\r\n         */\r\n        public getInsertionCost(idx: number): number {\r\n            return this._insertionCosts[idx];\r\n        }\r\n\r\n        /**\r\n         * Get the deletion cost of a character from its index.\r\n         * @param idx character index\r\n         * @returns deletion cost\r\n         */\r\n        public getDeletionCost(idx: number): number {\r\n            return this._deletionCosts[idx];\r\n        }\r\n\r\n        /**\r\n         * Gets the cost to substitute two characters. NOTE: this cost is\r\n         * required to be bi-directional, meaning it cannot matter which of\r\n         * the provided characters is being removed and which is being inserted.\r\n         * @param idx1 the first character index\r\n         * @param idx2 the second character index\r\n         * @returns substitution cost\r\n         */\r\n        public getSubstitutionCost(idx1: number, idx2: number): number {\r\n            const min = Math.min(idx1, idx2);\r\n            const max = Math.max(idx1, idx2);\r\n\r\n            return this._substitutionCosts[min][max];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Character sequence intended to be compared against other Sequences created\r\n     * with the same Alphabet in order to compute Levenshtein distance.\r\n     */\r\n    export class Sequence<T> {\r\n        private _alphabet: Alphabet<T>;\r\n        private _characters: number[];\r\n\r\n        // Scratch values\r\n        private static readonly _MAX_SEQUENCE_LENGTH = 256;\r\n        private static _CostMatrix = [...Array(Sequence._MAX_SEQUENCE_LENGTH + 1)].map(() => new Array<number>(Sequence._MAX_SEQUENCE_LENGTH + 1));\r\n        private static _InsertionCost: number;\r\n        private static _DeletionCost: number;\r\n        private static _SubstitutionCost: number;\r\n\r\n        /**\r\n         * Serialize to JSON string. JSON representation does NOT include the Alphabet\r\n         * from which this Sequence was created; Alphabet must be independently\r\n         * serialized.\r\n         * @returns JSON string\r\n         */\r\n        public serialize(): string {\r\n            return JSON.stringify(this._characters);\r\n        }\r\n\r\n        /**\r\n         * Deserialize from JSON string and Alphabet. This should be the same Alphabet\r\n         * from which the Sequence was originally created, which must be serialized and\r\n         * deserialized independently so that it can be passed in here.\r\n         * @param json JSON string representation of Sequence\r\n         * @param alphabet Alphabet from which Sequence was originally created\r\n         * @returns Sequence\r\n         */\r\n        public static Deserialize<T>(json: string, alphabet: Alphabet<T>): Sequence<T> {\r\n            const sequence = new Sequence([], alphabet);\r\n            sequence._characters = JSON.parse(json);\r\n            return sequence;\r\n        }\r\n\r\n        /**\r\n         * Create a new Sequence.\r\n         * @param characters characters in the new Sequence\r\n         * @param alphabet Alphabet, which must include all used characters\r\n         */\r\n        public constructor(characters: T[], alphabet: Alphabet<T>) {\r\n            if (characters.length > Sequence._MAX_SEQUENCE_LENGTH) {\r\n                throw new Error(\"Sequences longer than \" + Sequence._MAX_SEQUENCE_LENGTH + \" not supported.\");\r\n            }\r\n            this._alphabet = alphabet;\r\n            this._characters = characters.map((c) => this._alphabet.getCharacterIdx(c));\r\n        }\r\n\r\n        /**\r\n         * Get the distance between this Sequence and another.\r\n         * @param other sequence to compare to\r\n         * @returns Levenshtein distance\r\n         */\r\n        public distance(other: Sequence<T>): number {\r\n            return Sequence._Distance<T>(this, other);\r\n        }\r\n\r\n        /**\r\n         * Compute the Levenshtein distance between two Sequences.\r\n         * @param a first Sequence\r\n         * @param b second Sequence\r\n         * @returns Levenshtein distance\r\n         */\r\n        private static _Distance<T>(a: Sequence<T>, b: Sequence<T>): number {\r\n            const alphabet = a._alphabet;\r\n            if (alphabet !== b._alphabet) {\r\n                throw new Error(\"Cannot Levenshtein compare Sequences built from different alphabets.\");\r\n            }\r\n            const aChars = a._characters;\r\n            const bChars = b._characters;\r\n            const aLength = aChars.length;\r\n            const bLength = bChars.length;\r\n\r\n            const costMatrix = Sequence._CostMatrix;\r\n            costMatrix[0][0] = 0;\r\n            for (let idx = 0; idx < aLength; ++idx) {\r\n                costMatrix[idx + 1][0] = costMatrix[idx][0] + alphabet.getInsertionCost(aChars[idx]);\r\n            }\r\n            for (let idx = 0; idx < bLength; ++idx) {\r\n                costMatrix[0][idx + 1] = costMatrix[0][idx] + alphabet.getInsertionCost(bChars[idx]);\r\n            }\r\n\r\n            for (let aIdx = 0; aIdx < aLength; ++aIdx) {\r\n                for (let bIdx = 0; bIdx < bLength; ++bIdx) {\r\n                    Sequence._InsertionCost = costMatrix[aIdx + 1][bIdx] + alphabet.getInsertionCost(bChars[bIdx]);\r\n                    Sequence._DeletionCost = costMatrix[aIdx][bIdx + 1] + alphabet.getDeletionCost(aChars[aIdx]);\r\n                    Sequence._SubstitutionCost = costMatrix[aIdx][bIdx] + alphabet.getSubstitutionCost(aChars[aIdx], bChars[bIdx]);\r\n\r\n                    costMatrix[aIdx + 1][bIdx + 1] = Math.min(Sequence._InsertionCost, Sequence._DeletionCost, Sequence._SubstitutionCost);\r\n                }\r\n            }\r\n\r\n            return costMatrix[aLength][bLength];\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * A 3D trajectory consisting of an order list of vectors describing a\r\n * path of motion through 3D space.\r\n */\r\nexport class Trajectory {\r\n    private _points: Vector3[];\r\n    private readonly _segmentLength: number;\r\n\r\n    /**\r\n     * Serialize to JSON.\r\n     * @returns serialized JSON string\r\n     */\r\n    public serialize(): string {\r\n        return JSON.stringify(this);\r\n    }\r\n\r\n    /**\r\n     * Deserialize from JSON.\r\n     * @param json serialized JSON string\r\n     * @returns deserialized Trajectory\r\n     */\r\n    public static Deserialize(json: string): Trajectory {\r\n        const jsonObject = JSON.parse(json);\r\n        const trajectory = new Trajectory(jsonObject[\"_segmentLength\"]);\r\n        trajectory._points = jsonObject[\"_points\"].map((pt: any) => {\r\n            return new Vector3(pt[\"_x\"], pt[\"_y\"], pt[\"_z\"]);\r\n        });\r\n        return trajectory;\r\n    }\r\n\r\n    /**\r\n     * Create a new empty Trajectory.\r\n     * @param segmentLength radius of discretization for Trajectory points\r\n     */\r\n    public constructor(segmentLength: number = 0.01) {\r\n        this._points = [];\r\n        this._segmentLength = segmentLength;\r\n    }\r\n\r\n    /**\r\n     * Get the length of the Trajectory.\r\n     * @returns length of the Trajectory\r\n     */\r\n    public getLength(): number {\r\n        return this._points.length * this._segmentLength;\r\n    }\r\n\r\n    /**\r\n     * Append a new point to the Trajectory.\r\n     * NOTE: This implementation has many allocations.\r\n     * @param point point to append to the Trajectory\r\n     */\r\n    public add(point: DeepImmutable<Vector3>): void {\r\n        let numPoints = this._points.length;\r\n        if (numPoints === 0) {\r\n            this._points.push(point.clone());\r\n        } else {\r\n            const getT = () => this._segmentLength / Vector3.Distance(this._points[numPoints - 1], point);\r\n            for (let t = getT(); t <= 1.0; t = getT()) {\r\n                const newPoint = this._points[numPoints - 1].scale(1.0 - t);\r\n                point.scaleAndAddToRef(t, newPoint);\r\n                this._points.push(newPoint);\r\n                ++numPoints;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new Trajectory with a segment length chosen to make it\r\n     * probable that the new Trajectory will have a specified number of\r\n     * segments. This operation is imprecise.\r\n     * @param targetResolution number of segments desired\r\n     * @returns new Trajectory with approximately the requested number of segments\r\n     */\r\n    public resampleAtTargetResolution(targetResolution: number): Trajectory {\r\n        const resampled = new Trajectory(this.getLength() / targetResolution);\r\n        this._points.forEach((pt) => {\r\n            resampled.add(pt);\r\n        });\r\n        return resampled;\r\n    }\r\n\r\n    /**\r\n     * Convert Trajectory segments into tokenized representation. This\r\n     * representation is an array of numbers where each nth number is the\r\n     * index of the token which is most similar to the nth segment of the\r\n     * Trajectory.\r\n     * @param tokens list of vectors which serve as discrete tokens\r\n     * @returns list of indices of most similar token per segment\r\n     */\r\n    public tokenize(tokens: DeepImmutable<Vector3[]>): number[] {\r\n        const tokenization: number[] = [];\r\n\r\n        const segmentDir = new Vector3();\r\n        for (let idx = 2; idx < this._points.length; ++idx) {\r\n            if (Trajectory._TransformSegmentDirToRef(this._points[idx - 2], this._points[idx - 1], this._points[idx], segmentDir)) {\r\n                tokenization.push(Trajectory._TokenizeSegment(segmentDir, tokens));\r\n            }\r\n        }\r\n\r\n        return tokenization;\r\n    }\r\n\r\n    private static _ForwardDir = new Vector3();\r\n    private static _InverseFromVec = new Vector3();\r\n    private static _UpDir = new Vector3();\r\n    private static _FromToVec = new Vector3();\r\n    private static _LookMatrix = new Matrix();\r\n\r\n    /**\r\n     * Transform the rotation (i.e., direction) of a segment to isolate\r\n     * the relative transformation represented by the segment. This operation\r\n     * may or may not succeed due to singularities in the equations that define\r\n     * motion relativity in this context.\r\n     * @param priorVec the origin of the prior segment\r\n     * @param fromVec the origin of the current segment\r\n     * @param toVec the destination of the current segment\r\n     * @param result reference to output variable\r\n     * @returns whether or not transformation was successful\r\n     */\r\n    private static _TransformSegmentDirToRef(priorVec: DeepImmutable<Vector3>, fromVec: DeepImmutable<Vector3>, toVec: DeepImmutable<Vector3>, result: Vector3): boolean {\r\n        const DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD = 0.98;\r\n\r\n        fromVec.subtractToRef(priorVec, Trajectory._ForwardDir);\r\n        Trajectory._ForwardDir.normalize();\r\n        fromVec.scaleToRef(-1, Trajectory._InverseFromVec);\r\n        Trajectory._InverseFromVec.normalize();\r\n\r\n        if (Math.abs(Vector3.Dot(Trajectory._ForwardDir, Trajectory._InverseFromVec)) > DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD) {\r\n            return false;\r\n        }\r\n\r\n        Vector3.CrossToRef(Trajectory._ForwardDir, Trajectory._InverseFromVec, Trajectory._UpDir);\r\n        Trajectory._UpDir.normalize();\r\n        Matrix.LookAtLHToRef(priorVec, fromVec, Trajectory._UpDir, Trajectory._LookMatrix);\r\n        toVec.subtractToRef(fromVec, Trajectory._FromToVec);\r\n        Trajectory._FromToVec.normalize();\r\n        Vector3.TransformNormalToRef(Trajectory._FromToVec, Trajectory._LookMatrix, result);\r\n        return true;\r\n    }\r\n\r\n    private static _BestMatch: number;\r\n    private static _Score: number;\r\n    private static _BestScore: number;\r\n\r\n    /**\r\n     * Determine which token vector is most similar to the\r\n     * segment vector.\r\n     * @param segment segment vector\r\n     * @param tokens token vector list\r\n     * @returns index of the most similar token to the segment\r\n     */\r\n    private static _TokenizeSegment(segment: DeepImmutable<Vector3>, tokens: DeepImmutable<Vector3[]>): number {\r\n        Trajectory._BestMatch = 0;\r\n        Trajectory._Score = Vector3.Dot(segment, tokens[0]);\r\n        Trajectory._BestScore = Trajectory._Score;\r\n        for (let idx = 1; idx < tokens.length; ++idx) {\r\n            Trajectory._Score = Vector3.Dot(segment, tokens[idx]);\r\n            if (Trajectory._Score > Trajectory._BestScore) {\r\n                Trajectory._BestMatch = idx;\r\n                Trajectory._BestScore = Trajectory._Score;\r\n            }\r\n        }\r\n\r\n        return Trajectory._BestMatch;\r\n    }\r\n}\r\n\r\n/**\r\n * Collection of vectors intended to be used as the basis of Trajectory\r\n * tokenization for Levenshtein distance comparison. Canonically, a\r\n * Vector3Alphabet will resemble a \"spikeball\" of vectors distributed\r\n * roughly evenly over the surface of the unit sphere.\r\n */\r\nclass Vector3Alphabet {\r\n    /**\r\n     * Characters in the alphabet.\r\n     * NOTE: There is no reason for this property to exist and this class should just extend\r\n     * Array<Vector3>, except that doing so produces bizarre build-time errors indicating that\r\n     * the ES5 library itself fails its own TypeDoc validation.\r\n     */\r\n    public chars: Vector3[];\r\n\r\n    /**\r\n     * Helper method to create new \"spikeball\" Vector3Alphabets. Uses a naive\r\n     * optimize-from-random strategy to space points around the unit sphere\r\n     * surface as a simple alternative to really doing the math to tile the\r\n     * sphere.\r\n     * @param alphabetSize size of the desired alphabet\r\n     * @param iterations number of iterations over which to optimize the \"spikeball\"\r\n     * @param startingStepSize distance factor to move points in early optimization iterations\r\n     * @param endingStepSize distance factor to move points in late optimization iterations\r\n     * @param fixedValues alphabet \"characters\" that are required and cannot be moved by optimization\r\n     * @returns a new randomly generated and optimized Vector3Alphabet of the specified size\r\n     */\r\n    public static Generate(\r\n        alphabetSize: number = 64,\r\n        iterations: number = 256,\r\n        startingStepSize: number = 0.1,\r\n        endingStepSize: number = 0.001,\r\n        fixedValues: DeepImmutable<Vector3[]> = []\r\n    ): Vector3Alphabet {\r\n        const EPSILON = 0.001;\r\n        const EPSILON_SQUARED = EPSILON * EPSILON;\r\n\r\n        const alphabet = new Vector3Alphabet(alphabetSize);\r\n        for (let idx = 0; idx < alphabetSize; ++idx) {\r\n            alphabet.chars[idx] = new Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);\r\n            alphabet.chars[idx].normalize();\r\n        }\r\n\r\n        for (let idx = 0; idx < fixedValues.length; ++idx) {\r\n            alphabet.chars[idx].copyFrom(fixedValues[idx]);\r\n        }\r\n\r\n        let stepSize: number;\r\n        let distSq: number;\r\n        const force = new Vector3();\r\n        const scratch = new Vector3();\r\n        const lerp = (l: number, r: number, t: number) => (1.0 - t) * l + t * r;\r\n        for (let iteration = 0; iteration < iterations; ++iteration) {\r\n            stepSize = lerp(startingStepSize, endingStepSize, iteration / (iterations - 1));\r\n            for (let idx = fixedValues.length; idx < alphabet.chars.length; ++idx) {\r\n                force.copyFromFloats(0, 0, 0);\r\n                alphabet.chars.forEach((pt) => {\r\n                    alphabet.chars[idx].subtractToRef(pt, scratch);\r\n                    distSq = scratch.lengthSquared();\r\n                    if (distSq > EPSILON_SQUARED) {\r\n                        scratch.scaleAndAddToRef(1 / (scratch.lengthSquared() * distSq), force);\r\n                    }\r\n                });\r\n                force.scaleInPlace(stepSize);\r\n                alphabet.chars[idx].addInPlace(force);\r\n                alphabet.chars[idx].normalize();\r\n            }\r\n        }\r\n\r\n        return alphabet;\r\n    }\r\n\r\n    /**\r\n     * Serialize to JSON.\r\n     * @returns JSON serialization\r\n     */\r\n    public serialize(): string {\r\n        return JSON.stringify(this.chars);\r\n    }\r\n\r\n    /**\r\n     * Deserialize from JSON.\r\n     * @param json JSON serialization\r\n     * @returns deserialized Vector3Alphabet\r\n     */\r\n    public static Deserialize(json: string): Vector3Alphabet {\r\n        const jsonObject = JSON.parse(json);\r\n        const alphabet = new Vector3Alphabet(jsonObject.length);\r\n        for (let idx = 0; idx < jsonObject.length; ++idx) {\r\n            alphabet.chars[idx] = new Vector3(jsonObject[idx][\"_x\"], jsonObject[idx][\"_y\"], jsonObject[idx][\"_z\"]);\r\n        }\r\n        return alphabet;\r\n    }\r\n\r\n    private constructor(size: number) {\r\n        this.chars = new Array(size);\r\n    }\r\n}\r\n\r\n/**\r\n * Class which formalizes the manner in which a Vector3Alphabet is used to tokenize and\r\n * describe a Trajectory. This class houses the functionality which determines what\r\n * attributes of Trajectories are and are not considered important, such as scale.\r\n */\r\nclass TrajectoryDescriptor {\r\n    private static readonly _FINEST_DESCRIPTOR_RESOLUTION = 32;\r\n\r\n    private _sequences: Levenshtein.Sequence<number>[];\r\n\r\n    /**\r\n     * Serialize to JSON.\r\n     * @returns JSON serialization\r\n     */\r\n    public serialize(): string {\r\n        return JSON.stringify(this._sequences.map((sequence) => sequence.serialize()));\r\n    }\r\n\r\n    /**\r\n     * Deserialize from JSON string and Alphabet. This should be the same Alphabet\r\n     * from which the descriptor was originally created, which must be serialized and\r\n     * deserialized independently so that it can be passed in here.\r\n     * @param json JSON serialization\r\n     * @param alphabet Alphabet from which descriptor was originally created\r\n     * @returns deserialized TrajectoryDescriptor\r\n     */\r\n    public static Deserialize(json: string, alphabet: Levenshtein.Alphabet<number>): TrajectoryDescriptor {\r\n        const descriptor = new TrajectoryDescriptor();\r\n        descriptor._sequences = (JSON.parse(json) as string[]).map((s) => Levenshtein.Sequence.Deserialize(s, alphabet));\r\n        return descriptor;\r\n    }\r\n\r\n    /**\r\n     * Create a new TrajectoryDescriptor to describe a provided Trajectory according\r\n     * to the provided alphabets.\r\n     * @param trajectory Trajectory to be described\r\n     * @param vector3Alphabet Vector3Alphabet to be used to tokenize the Trajectory\r\n     * @param levenshteinAlphabet Levenshtein.Alphabet to be used as basis for comparison with other descriptors\r\n     * @returns TrajectoryDescriptor describing provided Trajectory\r\n     */\r\n    public static CreateFromTrajectory(trajectory: Trajectory, vector3Alphabet: Vector3Alphabet, levenshteinAlphabet: Levenshtein.Alphabet<number>): TrajectoryDescriptor {\r\n        return TrajectoryDescriptor.CreateFromTokenizationPyramid(TrajectoryDescriptor._GetTokenizationPyramid(trajectory, vector3Alphabet), levenshteinAlphabet);\r\n    }\r\n\r\n    /**\r\n     * Create a new TrajectoryDescriptor from a pre-existing pyramid of tokens.\r\n     * NOTE: This function exists to support an outdated serialization mechanism and should\r\n     * be deleted if it is no longer useful.\r\n     * @param pyramid tokenization pyramid\r\n     * @param levenshteinAlphabet Levenshtein.Alphabet to be uses as basis for comparison with other descriptors\r\n     * @returns TrajectoryDescriptor describing the Trajectory from which the pyramid was built\r\n     */\r\n    public static CreateFromTokenizationPyramid(pyramid: number[][], levenshteinAlphabet: Levenshtein.Alphabet<number>): TrajectoryDescriptor {\r\n        const descriptor = new TrajectoryDescriptor();\r\n        descriptor._sequences = pyramid.map((tokens) => new Levenshtein.Sequence<number>(tokens, levenshteinAlphabet));\r\n        return descriptor;\r\n    }\r\n\r\n    private constructor() {\r\n        this._sequences = [];\r\n    }\r\n\r\n    /**\r\n     * Create the tokenization pyramid for the provided Trajectory according to the given\r\n     * Vector3Alphabet.\r\n     * @param trajectory Trajectory to be tokenized\r\n     * @param alphabet Vector3Alphabet containing tokens\r\n     * @param targetResolution finest resolution of descriptor\r\n     * @returns tokenization pyramid for Trajectory\r\n     */\r\n    private static _GetTokenizationPyramid(\r\n        trajectory: Trajectory,\r\n        alphabet: Vector3Alphabet,\r\n        targetResolution: number = TrajectoryDescriptor._FINEST_DESCRIPTOR_RESOLUTION\r\n    ): number[][] {\r\n        const pyramid: number[][] = [];\r\n        for (let res = targetResolution; res > 4; res = Math.floor(res / 2)) {\r\n            pyramid.push(trajectory.resampleAtTargetResolution(res).tokenize(alphabet.chars));\r\n        }\r\n        return pyramid;\r\n    }\r\n\r\n    /**\r\n     * Calculate a distance metric between this TrajectoryDescriptor and another. This is\r\n     * essentially a similarity score and does not directly represent Euclidean distance,\r\n     * edit distance, or any other formal distance metric.\r\n     * @param other TrajectoryDescriptor from which to determine distance\r\n     * @returns distance, a nonnegative similarity score where larger values indicate dissimilarity\r\n     */\r\n    public distance(other: TrajectoryDescriptor): number {\r\n        let totalDistance = 0;\r\n        let weight: number;\r\n        for (let idx = 0; idx < this._sequences.length; ++idx) {\r\n            weight = Math.pow(2, idx);\r\n            totalDistance += weight * this._sequences[idx].distance(other._sequences[idx]);\r\n        }\r\n        return totalDistance;\r\n    }\r\n}\r\n\r\n/**\r\n * A set of TrajectoryDescriptors defined to be \"the same.\" This is essentially a helper\r\n * class to facilitate methods of Trajectory clustering.\r\n */\r\nclass TrajectoryClass {\r\n    private static readonly _MIN_AVERAGE_DISTANCE = 1;\r\n\r\n    private _descriptors: TrajectoryDescriptor[];\r\n    private _centroidIdx: number;\r\n    private _averageDistance: number;\r\n\r\n    /**\r\n     * Serialize to JSON.\r\n     * @returns JSON serialization\r\n     */\r\n    public serialize(): string {\r\n        const jsonObject: any = {};\r\n        jsonObject.descriptors = this._descriptors.map((desc) => desc.serialize());\r\n        jsonObject.centroidIdx = this._centroidIdx;\r\n        jsonObject.averageDistance = this._averageDistance;\r\n        return JSON.stringify(jsonObject);\r\n    }\r\n\r\n    /**\r\n     * Deserialize from JSON string and Alphabet. This should be the same Alphabet\r\n     * from which the descriptors were originally created, which must be serialized and\r\n     * deserialized independently so that it can be passed in here.\r\n     * @param json JSON string representation\r\n     * @param alphabet Alphabet from which TrajectoryDescriptors were originally created\r\n     * @returns deserialized TrajectoryDescriptor\r\n     */\r\n    public static Deserialize(json: string, alphabet: Levenshtein.Alphabet<number>): TrajectoryClass {\r\n        const jsonObject = JSON.parse(json);\r\n        const described = new TrajectoryClass();\r\n        described._descriptors = jsonObject.descriptors.map((s: string) => TrajectoryDescriptor.Deserialize(s, alphabet));\r\n        described._centroidIdx = jsonObject.centroidIdx;\r\n        described._averageDistance = jsonObject.averageDistance;\r\n        return described;\r\n    }\r\n\r\n    /**\r\n     * Create a new DescribedTrajectory.\r\n     * @param descriptors currently-known TrajectoryDescriptors, if any\r\n     */\r\n    public constructor(descriptors: TrajectoryDescriptor[] = []) {\r\n        this._descriptors = descriptors;\r\n        this._centroidIdx = -1;\r\n        this._averageDistance = 0;\r\n\r\n        this._refreshDescription();\r\n    }\r\n\r\n    /**\r\n     * Add a new TrajectoryDescriptor to the list of descriptors known to describe\r\n     * this same DescribedTrajectory.\r\n     * @param descriptor descriptor to be added\r\n     */\r\n    public add(descriptor: TrajectoryDescriptor): void {\r\n        this._descriptors.push(descriptor);\r\n        this._refreshDescription();\r\n    }\r\n\r\n    /**\r\n     * Compute the cost, which is inversely related to the likelihood that the provided\r\n     * TrajectoryDescriptor describes a Trajectory that is considered to be the same as\r\n     * the class represented by this DescribedTrajectory.\r\n     * @param descriptor the descriptor to be costed\r\n     * @returns cost of the match, which is a nonnegative similarity metric where larger values indicate dissimilarity\r\n     */\r\n    public getMatchCost(descriptor: TrajectoryDescriptor): number {\r\n        return descriptor.distance(this._descriptors[this._centroidIdx]) / this._averageDistance;\r\n    }\r\n\r\n    /**\r\n     * Compute the minimum distance between the queried TrajectoryDescriptor and a\r\n     * descriptor which is a member of this collection. This is an alternative way of\r\n     * conceptualizing match cost from getMatchCost(), and it serves a different function.\r\n     * @param descriptor the descriptor to find the minimum distance to\r\n     * @returns minimum descriptor distance to a member descriptor of this DescribedTrajectory\r\n     */\r\n    public getMatchMinimumDistance(descriptor: TrajectoryDescriptor): number {\r\n        return Math.min(...this._descriptors.map((desc) => desc.distance(descriptor)));\r\n    }\r\n\r\n    /**\r\n     * Refreshes the internal representation of this DescribedTrajectory.\r\n     */\r\n    private _refreshDescription(): void {\r\n        this._centroidIdx = -1;\r\n        let sum: number;\r\n        const distances = this._descriptors.map((a) => {\r\n            sum = 0;\r\n            this._descriptors.forEach((b) => {\r\n                sum += a.distance(b);\r\n            });\r\n            return sum;\r\n        });\r\n        for (let idx = 0; idx < distances.length; ++idx) {\r\n            if (this._centroidIdx < 0 || distances[idx] < distances[this._centroidIdx]) {\r\n                this._centroidIdx = idx;\r\n            }\r\n        }\r\n\r\n        this._averageDistance = 0;\r\n        this._descriptors.forEach((desc) => {\r\n            this._averageDistance += desc.distance(this._descriptors[this._centroidIdx]);\r\n        });\r\n        if (this._descriptors.length > 0) {\r\n            this._averageDistance = Math.max(this._averageDistance / this._descriptors.length, TrajectoryClass._MIN_AVERAGE_DISTANCE);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Class representing a set of known, named trajectories to which Trajectories can be\r\n * added and using which Trajectories can be recognized.\r\n */\r\nexport class TrajectoryClassifier {\r\n    private _maximumAllowableMatchCost: number = 4;\r\n    private _vector3Alphabet: Vector3Alphabet;\r\n    private _levenshteinAlphabet: Levenshtein.Alphabet<number>;\r\n    private _nameToDescribedTrajectory: Map<string, TrajectoryClass>;\r\n\r\n    /**\r\n     * Serialize to JSON.\r\n     * @returns JSON serialization\r\n     */\r\n    public serialize(): string {\r\n        const jsonObject: any = {};\r\n        jsonObject.maximumAllowableMatchCost = this._maximumAllowableMatchCost;\r\n        jsonObject.vector3Alphabet = this._vector3Alphabet.serialize();\r\n        jsonObject.levenshteinAlphabet = this._levenshteinAlphabet.serialize();\r\n        jsonObject.nameToDescribedTrajectory = [];\r\n        this._nameToDescribedTrajectory.forEach((described, name) => {\r\n            jsonObject.nameToDescribedTrajectory.push(name);\r\n            jsonObject.nameToDescribedTrajectory.push(described.serialize());\r\n        });\r\n        return JSON.stringify(jsonObject);\r\n    }\r\n\r\n    /**\r\n     * Deserialize from JSON.\r\n     * @param json JSON serialization\r\n     * @returns deserialized TrajectorySet\r\n     */\r\n    public static Deserialize(json: string): TrajectoryClassifier {\r\n        const jsonObject = JSON.parse(json);\r\n        const classifier = new TrajectoryClassifier();\r\n        classifier._maximumAllowableMatchCost = jsonObject.maximumAllowableMatchCost;\r\n        classifier._vector3Alphabet = Vector3Alphabet.Deserialize(jsonObject.vector3Alphabet);\r\n        classifier._levenshteinAlphabet = Levenshtein.Alphabet.Deserialize<number>(jsonObject.levenshteinAlphabet);\r\n        for (let idx = 0; idx < jsonObject.nameToDescribedTrajectory.length; idx += 2) {\r\n            classifier._nameToDescribedTrajectory.set(\r\n                jsonObject.nameToDescribedTrajectory[idx],\r\n                TrajectoryClass.Deserialize(jsonObject.nameToDescribedTrajectory[idx + 1], classifier._levenshteinAlphabet)\r\n            );\r\n        }\r\n        return classifier;\r\n    }\r\n\r\n    /**\r\n     * Initialize a new empty TrajectorySet with auto-generated Alphabets.\r\n     * VERY naive, need to be generating these things from known\r\n     * sets. Better version later, probably eliminating this one.\r\n     * @returns auto-generated TrajectorySet\r\n     */\r\n    public static Generate(): TrajectoryClassifier {\r\n        const vecs = Vector3Alphabet.Generate(64, 256, 0.1, 0.001, [Vector3.Forward()]);\r\n\r\n        const charIdxs = new Array(vecs.chars.length);\r\n        for (let idx = 0; idx < charIdxs.length; ++idx) {\r\n            charIdxs[idx] = idx;\r\n        }\r\n\r\n        const alphabet = new Levenshtein.Alphabet<number>(\r\n            charIdxs,\r\n            (idx) => (idx === 0 ? 0 : 1),\r\n            (idx) => (idx === 0 ? 0 : 1),\r\n            (a, b) => Math.min(1 - Vector3.Dot(vecs.chars[a], vecs.chars[b]), 1)\r\n        );\r\n\r\n        const trajectorySet = new TrajectoryClassifier();\r\n        trajectorySet._vector3Alphabet = vecs;\r\n        trajectorySet._levenshteinAlphabet = alphabet;\r\n        return trajectorySet;\r\n    }\r\n\r\n    private constructor() {\r\n        this._nameToDescribedTrajectory = new Map<string, TrajectoryClass>();\r\n    }\r\n\r\n    /**\r\n     * Add a new Trajectory to the set with a given name.\r\n     * @param trajectory new Trajectory to be added\r\n     * @param classification name to which to add the Trajectory\r\n     */\r\n    public addTrajectoryToClassification(trajectory: Trajectory, classification: string): void {\r\n        if (!this._nameToDescribedTrajectory.has(classification)) {\r\n            this._nameToDescribedTrajectory.set(classification, new TrajectoryClass());\r\n        }\r\n\r\n        this._nameToDescribedTrajectory.get(classification)!.add(TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet));\r\n    }\r\n\r\n    /**\r\n     * Remove a known named trajectory and all Trajectories associated with it.\r\n     * @param classification name to remove\r\n     * @returns whether anything was removed\r\n     */\r\n    public deleteClassification(classification: string): boolean {\r\n        return this._nameToDescribedTrajectory.delete(classification);\r\n    }\r\n\r\n    /**\r\n     * Attempt to recognize a Trajectory from among all the classifications\r\n     * already known to the classifier.\r\n     * @param trajectory Trajectory to be recognized\r\n     * @returns classification of Trajectory if recognized, null otherwise\r\n     */\r\n    public classifyTrajectory(trajectory: Trajectory): Nullable<string> {\r\n        const descriptor = TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet);\r\n\r\n        const allowableMatches: string[] = [];\r\n        this._nameToDescribedTrajectory.forEach((trajectoryClass, classification) => {\r\n            if (trajectoryClass.getMatchCost(descriptor) < this._maximumAllowableMatchCost) {\r\n                allowableMatches.push(classification);\r\n            }\r\n        });\r\n\r\n        if (allowableMatches.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        let bestIdx = 0;\r\n        let bestMatch = this._nameToDescribedTrajectory.get(allowableMatches[bestIdx])!.getMatchMinimumDistance(descriptor);\r\n        let match: number;\r\n        for (let idx = 0; idx < allowableMatches.length; ++idx) {\r\n            match = this._nameToDescribedTrajectory.get(allowableMatches[idx])!.getMatchMinimumDistance(descriptor);\r\n            if (match < bestMatch) {\r\n                bestMatch = match;\r\n                bestIdx = idx;\r\n            }\r\n        }\r\n        return allowableMatches[bestIdx];\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}