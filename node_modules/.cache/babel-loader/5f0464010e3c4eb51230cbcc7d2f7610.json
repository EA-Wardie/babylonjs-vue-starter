{"ast":null,"code":"import { DeepCopier } from \"../../Misc/deepCopier.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\n/**\n * Particle emitter emitting particles from the inside of a hemisphere.\n * It emits the particles alongside the hemisphere radius. The emission direction might be randomized.\n */\n\nvar HemisphericParticleEmitter =\n/** @class */\nfunction () {\n  /**\n   * Creates a new instance HemisphericParticleEmitter\n   * @param radius the radius of the emission hemisphere (1 by default)\n   * @param radiusRange the range of the emission hemisphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)\n   * @param directionRandomizer defines how much to randomize the particle direction [0-1]\n   */\n  function HemisphericParticleEmitter(\n  /**\n   * The radius of the emission hemisphere.\n   */\n  radius,\n  /**\n   * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\n   */\n  radiusRange,\n  /**\n   * How much to randomize the particle direction [0-1].\n   */\n  directionRandomizer) {\n    if (radius === void 0) {\n      radius = 1;\n    }\n\n    if (radiusRange === void 0) {\n      radiusRange = 1;\n    }\n\n    if (directionRandomizer === void 0) {\n      directionRandomizer = 0;\n    }\n\n    this.radius = radius;\n    this.radiusRange = radiusRange;\n    this.directionRandomizer = directionRandomizer;\n  }\n  /**\n   * Called by the particle System when the direction is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param directionToUpdate is the direction vector to update with the result\n   * @param particle is the particle we are computed the direction for\n   * @param isLocal defines if the direction should be set in local space\n   */\n\n\n  HemisphericParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate, particle, isLocal) {\n    var direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();\n    var randX = Scalar.RandomRange(0, this.directionRandomizer);\n    var randY = Scalar.RandomRange(0, this.directionRandomizer);\n    var randZ = Scalar.RandomRange(0, this.directionRandomizer);\n    direction.x += randX;\n    direction.y += randY;\n    direction.z += randZ;\n    direction.normalize();\n\n    if (isLocal) {\n      directionToUpdate.copyFrom(direction);\n      return;\n    }\n\n    Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);\n  };\n  /**\n   * Called by the particle System when the position is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param positionToUpdate is the position vector to update with the result\n   * @param particle is the particle we are computed the position for\n   * @param isLocal defines if the position should be set in local space\n   */\n\n\n  HemisphericParticleEmitter.prototype.startPositionFunction = function (worldMatrix, positionToUpdate, particle, isLocal) {\n    var randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);\n    var v = Scalar.RandomRange(0, 1.0);\n    var phi = Scalar.RandomRange(0, 2 * Math.PI);\n    var theta = Math.acos(2 * v - 1);\n    var randX = randRadius * Math.cos(phi) * Math.sin(theta);\n    var randY = randRadius * Math.cos(theta);\n    var randZ = randRadius * Math.sin(phi) * Math.sin(theta);\n\n    if (isLocal) {\n      positionToUpdate.copyFromFloats(randX, Math.abs(randY), randZ);\n      return;\n    }\n\n    Vector3.TransformCoordinatesFromFloatsToRef(randX, Math.abs(randY), randZ, worldMatrix, positionToUpdate);\n  };\n  /**\n   * Clones the current emitter and returns a copy of it\n   * @returns the new emitter\n   */\n\n\n  HemisphericParticleEmitter.prototype.clone = function () {\n    var newOne = new HemisphericParticleEmitter(this.radius, this.directionRandomizer);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  };\n  /**\n   * Called by the GPUParticleSystem to setup the update shader\n   * @param uboOrEffect defines the update shader\n   */\n\n\n  HemisphericParticleEmitter.prototype.applyToShader = function (uboOrEffect) {\n    uboOrEffect.setFloat(\"radius\", this.radius);\n    uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\n    uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\n  };\n  /**\n   * Creates the structure of the ubo for this particle emitter\n   * @param ubo ubo to create the structure for\n   */\n\n\n  HemisphericParticleEmitter.prototype.buildUniformLayout = function (ubo) {\n    ubo.addUniform(\"radius\", 1);\n    ubo.addUniform(\"radiusRange\", 1);\n    ubo.addUniform(\"directionRandomizer\", 1);\n  };\n  /**\n   * Returns a string to use to update the GPU particles update shader\n   * @returns a string containing the defines string\n   */\n\n\n  HemisphericParticleEmitter.prototype.getEffectDefines = function () {\n    return \"#define HEMISPHERICEMITTER\";\n  };\n  /**\n   * Returns the string \"HemisphericParticleEmitter\"\n   * @returns a string containing the class name\n   */\n\n\n  HemisphericParticleEmitter.prototype.getClassName = function () {\n    return \"HemisphericParticleEmitter\";\n  };\n  /**\n   * Serializes the particle system to a JSON object.\n   * @returns the JSON object\n   */\n\n\n  HemisphericParticleEmitter.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.type = this.getClassName();\n    serializationObject.radius = this.radius;\n    serializationObject.radiusRange = this.radiusRange;\n    serializationObject.directionRandomizer = this.directionRandomizer;\n    return serializationObject;\n  };\n  /**\n   * Parse properties from a JSON object\n   * @param serializationObject defines the JSON object\n   */\n\n\n  HemisphericParticleEmitter.prototype.parse = function (serializationObject) {\n    this.radius = serializationObject.radius;\n    this.radiusRange = serializationObject.radiusRange;\n    this.directionRandomizer = serializationObject.directionRandomizer;\n  };\n\n  return HemisphericParticleEmitter;\n}();\n\nexport { HemisphericParticleEmitter };","map":{"version":3,"mappings":"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","names":["DeepCopier","Vector3","Scalar","radius","radiusRange","directionRandomizer","HemisphericParticleEmitter","worldMatrix","directionToUpdate","particle","isLocal","direction","position","subtract","getTranslation","normalize","randX","RandomRange","randY","randZ","x","y","z","copyFrom","TransformNormalFromFloatsToRef","positionToUpdate","randRadius","v","phi","Math","PI","theta","acos","cos","sin","copyFromFloats","abs","TransformCoordinatesFromFloatsToRef","newOne","DeepCopy","uboOrEffect","setFloat","ubo","addUniform","serializationObject","type","getClassName"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Particles/EmitterTypes/hemisphericParticleEmitter.ts"],"sourcesContent":["import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a hemisphere.\r\n * It emits the particles alongside the hemisphere radius. The emission direction might be randomized.\r\n */\r\nexport class HemisphericParticleEmitter implements IParticleEmitterType {\r\n    /**\r\n     * Creates a new instance HemisphericParticleEmitter\r\n     * @param radius the radius of the emission hemisphere (1 by default)\r\n     * @param radiusRange the range of the emission hemisphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n     * @param directionRandomizer defines how much to randomize the particle direction [0-1]\r\n     */\r\n    constructor(\r\n        /**\r\n         * The radius of the emission hemisphere.\r\n         */\r\n        public radius = 1,\r\n        /**\r\n         * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\r\n         */\r\n        public radiusRange = 1,\r\n        /**\r\n         * How much to randomize the particle direction [0-1].\r\n         */\r\n        public directionRandomizer = 0\r\n    ) {}\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();\r\n        const randX = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randY = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randZ = Scalar.RandomRange(0, this.directionRandomizer);\r\n        direction.x += randX;\r\n        direction.y += randY;\r\n        direction.z += randZ;\r\n        direction.normalize();\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFrom(direction);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);\r\n        const v = Scalar.RandomRange(0, 1.0);\r\n        const phi = Scalar.RandomRange(0, 2 * Math.PI);\r\n        const theta = Math.acos(2 * v - 1);\r\n        const randX = randRadius * Math.cos(phi) * Math.sin(theta);\r\n        const randY = randRadius * Math.cos(theta);\r\n        const randZ = randRadius * Math.sin(phi) * Math.sin(theta);\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.copyFromFloats(randX, Math.abs(randY), randZ);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(randX, Math.abs(randY), randZ, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): HemisphericParticleEmitter {\r\n        const newOne = new HemisphericParticleEmitter(this.radius, this.directionRandomizer);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat(\"radius\", this.radius);\r\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\r\n        uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 1);\r\n        ubo.addUniform(\"radiusRange\", 1);\r\n        ubo.addUniform(\"directionRandomizer\", 1);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define HEMISPHERICEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"HemisphericParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"HemisphericParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.radius = this.radius;\r\n        serializationObject.radiusRange = this.radiusRange;\r\n        serializationObject.directionRandomizer = this.directionRandomizer;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        this.radius = serializationObject.radius;\r\n        this.radiusRange = serializationObject.radiusRange;\r\n        this.directionRandomizer = serializationObject.directionRandomizer;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}