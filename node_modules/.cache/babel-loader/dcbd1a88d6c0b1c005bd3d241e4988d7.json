{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { PhysicsImpostor } from \"../../Physics/physicsImpostor.js\";\nimport { PhysicsJoint } from \"../../Physics/physicsJoint.js\";\nimport { PhysicsEngine } from \"../../Physics/physicsEngine.js\";\nimport { Vector3, Quaternion } from \"../../Maths/math.vector.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { PhysicsRaycastResult } from \"../physicsRaycastResult.js\";\n/** @hidden */\n\nvar OimoJSPlugin =\n/** @class */\nfunction () {\n  function OimoJSPlugin(_useDeltaForWorldStep, iterations, oimoInjection) {\n    if (_useDeltaForWorldStep === void 0) {\n      _useDeltaForWorldStep = true;\n    }\n\n    if (oimoInjection === void 0) {\n      oimoInjection = OIMO;\n    }\n\n    this._useDeltaForWorldStep = _useDeltaForWorldStep;\n    this.name = \"OimoJSPlugin\";\n    this._fixedTimeStep = 1 / 60;\n    this._tmpImpostorsArray = [];\n    this._tmpPositionVector = Vector3.Zero();\n    this.BJSOIMO = oimoInjection;\n    this.world = new this.BJSOIMO.World({\n      iterations: iterations\n    });\n    this.world.clear();\n    this._raycastResult = new PhysicsRaycastResult();\n  }\n\n  OimoJSPlugin.prototype.setGravity = function (gravity) {\n    this.world.gravity.set(gravity.x, gravity.y, gravity.z);\n  };\n\n  OimoJSPlugin.prototype.setTimeStep = function (timeStep) {\n    this.world.timeStep = timeStep;\n  };\n\n  OimoJSPlugin.prototype.getTimeStep = function () {\n    return this.world.timeStep;\n  };\n\n  OimoJSPlugin.prototype.executeStep = function (delta, impostors) {\n    var _this = this;\n\n    impostors.forEach(function (impostor) {\n      impostor.beforeStep();\n    });\n    this.world.timeStep = this._useDeltaForWorldStep ? delta : this._fixedTimeStep;\n    this.world.step();\n    impostors.forEach(function (impostor) {\n      impostor.afterStep(); //update the ordered impostors array\n\n      _this._tmpImpostorsArray[impostor.uniqueId] = impostor;\n    }); //check for collisions\n\n    var contact = this.world.contacts;\n\n    while (contact !== null) {\n      if (contact.touching && !contact.body1.sleeping && !contact.body2.sleeping) {\n        contact = contact.next;\n        continue;\n      } //is this body colliding with any other? get the impostor\n\n\n      var mainImpostor = this._tmpImpostorsArray[+contact.body1.name];\n      var collidingImpostor = this._tmpImpostorsArray[+contact.body2.name];\n\n      if (!mainImpostor || !collidingImpostor) {\n        contact = contact.next;\n        continue;\n      }\n\n      mainImpostor.onCollide({\n        body: collidingImpostor.physicsBody,\n        point: null\n      });\n      collidingImpostor.onCollide({\n        body: mainImpostor.physicsBody,\n        point: null\n      });\n      contact = contact.next;\n    }\n  };\n\n  OimoJSPlugin.prototype.applyImpulse = function (impostor, force, contactPoint) {\n    var mass = impostor.physicsBody.mass;\n    impostor.physicsBody.applyImpulse(contactPoint.scale(this.world.invScale), force.scale(this.world.invScale * mass));\n  };\n\n  OimoJSPlugin.prototype.applyForce = function (impostor, force, contactPoint) {\n    Logger.Warn(\"Oimo doesn't support applying force. Using impule instead.\");\n    this.applyImpulse(impostor, force, contactPoint);\n  };\n\n  OimoJSPlugin.prototype.generatePhysicsBody = function (impostor) {\n    var _this = this; //parent-child relationship. Does this impostor has a parent impostor?\n\n\n    if (impostor.parent) {\n      if (impostor.physicsBody) {\n        this.removePhysicsBody(impostor); //TODO is that needed?\n\n        impostor.forceUpdate();\n      }\n\n      return;\n    }\n\n    if (impostor.isBodyInitRequired()) {\n      var bodyConfig_1 = {\n        name: impostor.uniqueId,\n        //Oimo must have mass, also for static objects.\n        config: [impostor.getParam(\"mass\") || 0.001, impostor.getParam(\"friction\"), impostor.getParam(\"restitution\")],\n        size: [],\n        type: [],\n        pos: [],\n        posShape: [],\n        rot: [],\n        rotShape: [],\n        move: impostor.getParam(\"mass\") !== 0,\n        density: impostor.getParam(\"mass\"),\n        friction: impostor.getParam(\"friction\"),\n        restitution: impostor.getParam(\"restitution\"),\n        //Supporting older versions of Oimo\n        world: this.world\n      };\n      var impostors_1 = [impostor];\n\n      var addToArray = function addToArray(parent) {\n        if (!parent.getChildMeshes) {\n          return;\n        }\n\n        parent.getChildMeshes().forEach(function (m) {\n          if (m.physicsImpostor) {\n            impostors_1.push(m.physicsImpostor); //m.physicsImpostor._init();\n          }\n        });\n      };\n\n      addToArray(impostor.object);\n\n      var checkWithEpsilon_1 = function checkWithEpsilon_1(value) {\n        return Math.max(value, PhysicsEngine.Epsilon);\n      };\n\n      var globalQuaternion_1 = new Quaternion();\n      impostors_1.forEach(function (i) {\n        if (!i.object.rotationQuaternion) {\n          return;\n        } //get the correct bounding box\n\n\n        var oldQuaternion = i.object.rotationQuaternion;\n        globalQuaternion_1.copyFrom(oldQuaternion);\n        i.object.rotationQuaternion.set(0, 0, 0, 1);\n        i.object.computeWorldMatrix(true);\n        var rot = globalQuaternion_1.toEulerAngles();\n        var extendSize = i.getObjectExtendSize(); // eslint-disable-next-line no-loss-of-precision\n\n        var radToDeg = 57.295779513082320876;\n\n        if (i === impostor) {\n          var center = impostor.getObjectCenter();\n          impostor.object.getAbsolutePivotPoint().subtractToRef(center, _this._tmpPositionVector);\n\n          _this._tmpPositionVector.divideInPlace(impostor.object.scaling); //Can also use Array.prototype.push.apply\n\n\n          bodyConfig_1.pos.push(center.x);\n          bodyConfig_1.pos.push(center.y);\n          bodyConfig_1.pos.push(center.z);\n          bodyConfig_1.posShape.push(0, 0, 0);\n          bodyConfig_1.rotShape.push(0, 0, 0);\n        } else {\n          var localPosition = i.object.position.clone();\n          bodyConfig_1.posShape.push(localPosition.x);\n          bodyConfig_1.posShape.push(localPosition.y);\n          bodyConfig_1.posShape.push(localPosition.z); // bodyConfig.pos.push(0, 0, 0);\n\n          bodyConfig_1.rotShape.push(rot.x * radToDeg, rot.y * radToDeg, rot.z * radToDeg);\n        }\n\n        i.object.rotationQuaternion.copyFrom(globalQuaternion_1); // register mesh\n\n        switch (i.type) {\n          case PhysicsImpostor.ParticleImpostor:\n            Logger.Warn(\"No Particle support in OIMO.js. using SphereImpostor instead\");\n          // eslint-disable-next-line no-fallthrough\n\n          case PhysicsImpostor.SphereImpostor:\n            {\n              var radiusX = extendSize.x;\n              var radiusY = extendSize.y;\n              var radiusZ = extendSize.z;\n              var size = Math.max(checkWithEpsilon_1(radiusX), checkWithEpsilon_1(radiusY), checkWithEpsilon_1(radiusZ)) / 2;\n              bodyConfig_1.type.push(\"sphere\"); //due to the way oimo works with compounds, add 3 times\n\n              bodyConfig_1.size.push(size);\n              bodyConfig_1.size.push(size);\n              bodyConfig_1.size.push(size);\n              break;\n            }\n\n          case PhysicsImpostor.CylinderImpostor:\n            {\n              var sizeX = checkWithEpsilon_1(extendSize.x) / 2;\n              var sizeY = checkWithEpsilon_1(extendSize.y);\n              bodyConfig_1.type.push(\"cylinder\");\n              bodyConfig_1.size.push(sizeX);\n              bodyConfig_1.size.push(sizeY); //due to the way oimo works with compounds, add one more value.\n\n              bodyConfig_1.size.push(sizeY);\n              break;\n            }\n\n          case PhysicsImpostor.PlaneImpostor:\n          case PhysicsImpostor.BoxImpostor:\n          default:\n            {\n              var sizeX = checkWithEpsilon_1(extendSize.x);\n              var sizeY = checkWithEpsilon_1(extendSize.y);\n              var sizeZ = checkWithEpsilon_1(extendSize.z);\n              bodyConfig_1.type.push(\"box\"); //if (i === impostor) {\n\n              bodyConfig_1.size.push(sizeX);\n              bodyConfig_1.size.push(sizeY);\n              bodyConfig_1.size.push(sizeZ); //} else {\n              //    bodyConfig.size.push(0,0,0);\n              //}\n\n              break;\n            }\n        } //actually not needed, but hey...\n\n\n        i.object.rotationQuaternion = oldQuaternion;\n      });\n      impostor.physicsBody = this.world.add(bodyConfig_1); // set the quaternion, ignoring the previously defined (euler) rotation\n\n      impostor.physicsBody.resetQuaternion(globalQuaternion_1); // update with delta 0, so the body will receive the new rotation.\n\n      impostor.physicsBody.updatePosition(0);\n    } else {\n      this._tmpPositionVector.copyFromFloats(0, 0, 0);\n    }\n\n    impostor.setDeltaPosition(this._tmpPositionVector); //this._tmpPositionVector.addInPlace(impostor.mesh.getBoundingInfo().boundingBox.center);\n    //this.setPhysicsBodyTransformation(impostor, this._tmpPositionVector, impostor.mesh.rotationQuaternion);\n  };\n\n  OimoJSPlugin.prototype.removePhysicsBody = function (impostor) {\n    //impostor.physicsBody.dispose();\n    //Same as : (older oimo versions)\n    this.world.removeRigidBody(impostor.physicsBody);\n  };\n\n  OimoJSPlugin.prototype.generateJoint = function (impostorJoint) {\n    var mainBody = impostorJoint.mainImpostor.physicsBody;\n    var connectedBody = impostorJoint.connectedImpostor.physicsBody;\n\n    if (!mainBody || !connectedBody) {\n      return;\n    }\n\n    var jointData = impostorJoint.joint.jointData;\n    var options = jointData.nativeParams || {};\n    var type;\n    var nativeJointData = {\n      body1: mainBody,\n      body2: connectedBody,\n      axe1: options.axe1 || (jointData.mainAxis ? jointData.mainAxis.asArray() : null),\n      axe2: options.axe2 || (jointData.connectedAxis ? jointData.connectedAxis.asArray() : null),\n      pos1: options.pos1 || (jointData.mainPivot ? jointData.mainPivot.asArray() : null),\n      pos2: options.pos2 || (jointData.connectedPivot ? jointData.connectedPivot.asArray() : null),\n      min: options.min,\n      max: options.max,\n      collision: options.collision || jointData.collision,\n      spring: options.spring,\n      //supporting older version of Oimo\n      world: this.world\n    };\n\n    switch (impostorJoint.joint.type) {\n      case PhysicsJoint.BallAndSocketJoint:\n        type = \"jointBall\";\n        break;\n\n      case PhysicsJoint.SpringJoint:\n        {\n          Logger.Warn(\"OIMO.js doesn't support Spring Constraint. Simulating using DistanceJoint instead\");\n          var springData = jointData;\n          nativeJointData.min = springData.length || nativeJointData.min; //Max should also be set, just make sure it is at least min\n\n          nativeJointData.max = Math.max(nativeJointData.min, nativeJointData.max);\n        }\n      // eslint-disable-next-line no-fallthrough\n\n      case PhysicsJoint.DistanceJoint:\n        type = \"jointDistance\";\n        nativeJointData.max = jointData.maxDistance;\n        break;\n\n      case PhysicsJoint.PrismaticJoint:\n        type = \"jointPrisme\";\n        break;\n\n      case PhysicsJoint.SliderJoint:\n        type = \"jointSlide\";\n        break;\n\n      case PhysicsJoint.WheelJoint:\n        type = \"jointWheel\";\n        break;\n\n      case PhysicsJoint.HingeJoint:\n      default:\n        type = \"jointHinge\";\n        break;\n    }\n\n    nativeJointData.type = type;\n    impostorJoint.joint.physicsJoint = this.world.add(nativeJointData);\n  };\n\n  OimoJSPlugin.prototype.removeJoint = function (impostorJoint) {\n    //Bug in Oimo prevents us from disposing a joint in the playground\n    //joint.joint.physicsJoint.dispose();\n    //So we will bruteforce it!\n    try {\n      this.world.removeJoint(impostorJoint.joint.physicsJoint);\n    } catch (e) {\n      Logger.Warn(e);\n    }\n  };\n\n  OimoJSPlugin.prototype.isSupported = function () {\n    return this.BJSOIMO !== undefined;\n  };\n\n  OimoJSPlugin.prototype.setTransformationFromPhysicsBody = function (impostor) {\n    if (!impostor.physicsBody.sleeping) {\n      if (impostor.physicsBody.shapes.next) {\n        var parent_1 = impostor.physicsBody.shapes;\n\n        while (parent_1.next) {\n          parent_1 = parent_1.next;\n        }\n\n        impostor.object.position.set(parent_1.position.x, parent_1.position.y, parent_1.position.z);\n      } else {\n        var pos = impostor.physicsBody.getPosition();\n        impostor.object.position.set(pos.x, pos.y, pos.z);\n      } //}\n\n\n      if (impostor.object.rotationQuaternion) {\n        var quat = impostor.physicsBody.getQuaternion();\n        impostor.object.rotationQuaternion.set(quat.x, quat.y, quat.z, quat.w);\n      }\n    }\n  };\n\n  OimoJSPlugin.prototype.setPhysicsBodyTransformation = function (impostor, newPosition, newRotation) {\n    var body = impostor.physicsBody; // disable bidirectional for compound meshes\n\n    if (impostor.physicsBody.shapes.next) {\n      return;\n    }\n\n    body.position.set(newPosition.x, newPosition.y, newPosition.z);\n    body.orientation.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\n    body.syncShapes();\n    body.awake();\n  };\n  /*private _getLastShape(body: any): any {\n      var lastShape = body.shapes;\n      while (lastShape.next) {\n          lastShape = lastShape.next;\n      }\n      return lastShape;\n  }*/\n\n\n  OimoJSPlugin.prototype.setLinearVelocity = function (impostor, velocity) {\n    impostor.physicsBody.linearVelocity.set(velocity.x, velocity.y, velocity.z);\n  };\n\n  OimoJSPlugin.prototype.setAngularVelocity = function (impostor, velocity) {\n    impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);\n  };\n\n  OimoJSPlugin.prototype.getLinearVelocity = function (impostor) {\n    var v = impostor.physicsBody.linearVelocity;\n\n    if (!v) {\n      return null;\n    }\n\n    return new Vector3(v.x, v.y, v.z);\n  };\n\n  OimoJSPlugin.prototype.getAngularVelocity = function (impostor) {\n    var v = impostor.physicsBody.angularVelocity;\n\n    if (!v) {\n      return null;\n    }\n\n    return new Vector3(v.x, v.y, v.z);\n  };\n\n  OimoJSPlugin.prototype.setBodyMass = function (impostor, mass) {\n    var staticBody = mass === 0; //this will actually set the body's density and not its mass.\n    //But this is how oimo treats the mass variable.\n\n    impostor.physicsBody.shapes.density = staticBody ? 1 : mass;\n    impostor.physicsBody.setupMass(staticBody ? 0x2 : 0x1);\n  };\n\n  OimoJSPlugin.prototype.getBodyMass = function (impostor) {\n    return impostor.physicsBody.shapes.density;\n  };\n\n  OimoJSPlugin.prototype.getBodyFriction = function (impostor) {\n    return impostor.physicsBody.shapes.friction;\n  };\n\n  OimoJSPlugin.prototype.setBodyFriction = function (impostor, friction) {\n    impostor.physicsBody.shapes.friction = friction;\n  };\n\n  OimoJSPlugin.prototype.getBodyRestitution = function (impostor) {\n    return impostor.physicsBody.shapes.restitution;\n  };\n\n  OimoJSPlugin.prototype.setBodyRestitution = function (impostor, restitution) {\n    impostor.physicsBody.shapes.restitution = restitution;\n  };\n\n  OimoJSPlugin.prototype.sleepBody = function (impostor) {\n    impostor.physicsBody.sleep();\n  };\n\n  OimoJSPlugin.prototype.wakeUpBody = function (impostor) {\n    impostor.physicsBody.awake();\n  };\n\n  OimoJSPlugin.prototype.updateDistanceJoint = function (joint, maxDistance, minDistance) {\n    joint.physicsJoint.limitMotor.upperLimit = maxDistance;\n\n    if (minDistance !== void 0) {\n      joint.physicsJoint.limitMotor.lowerLimit = minDistance;\n    }\n  };\n\n  OimoJSPlugin.prototype.setMotor = function (joint, speed, force, motorIndex) {\n    if (force !== undefined) {\n      Logger.Warn(\"OimoJS plugin currently has unexpected behavior when using setMotor with force parameter\");\n    } else {\n      force = 1e6;\n    }\n\n    speed *= -1; //TODO separate rotational and transational motors.\n\n    var motor = motorIndex ? joint.physicsJoint.rotationalLimitMotor2 : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;\n\n    if (motor) {\n      motor.setMotor(speed, force);\n    }\n  };\n\n  OimoJSPlugin.prototype.setLimit = function (joint, upperLimit, lowerLimit, motorIndex) {\n    //TODO separate rotational and transational motors.\n    var motor = motorIndex ? joint.physicsJoint.rotationalLimitMotor2 : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;\n\n    if (motor) {\n      motor.setLimit(upperLimit, lowerLimit === void 0 ? -upperLimit : lowerLimit);\n    }\n  };\n\n  OimoJSPlugin.prototype.syncMeshWithImpostor = function (mesh, impostor) {\n    var body = impostor.physicsBody;\n    mesh.position.x = body.position.x;\n    mesh.position.y = body.position.y;\n    mesh.position.z = body.position.z;\n\n    if (mesh.rotationQuaternion) {\n      mesh.rotationQuaternion.x = body.orientation.x;\n      mesh.rotationQuaternion.y = body.orientation.y;\n      mesh.rotationQuaternion.z = body.orientation.z;\n      mesh.rotationQuaternion.w = body.orientation.s;\n    }\n  };\n\n  OimoJSPlugin.prototype.getRadius = function (impostor) {\n    return impostor.physicsBody.shapes.radius;\n  };\n\n  OimoJSPlugin.prototype.getBoxSizeToRef = function (impostor, result) {\n    var shape = impostor.physicsBody.shapes;\n    result.x = shape.halfWidth * 2;\n    result.y = shape.halfHeight * 2;\n    result.z = shape.halfDepth * 2;\n  };\n\n  OimoJSPlugin.prototype.dispose = function () {\n    this.world.clear();\n  };\n  /**\n   * Does a raycast in the physics world\n   * @param from when should the ray start?\n   * @param to when should the ray end?\n   * @returns PhysicsRaycastResult\n   */\n\n\n  OimoJSPlugin.prototype.raycast = function (from, to) {\n    Logger.Warn(\"raycast is not currently supported by the Oimo physics plugin\");\n\n    this._raycastResult.reset(from, to);\n\n    return this._raycastResult;\n  };\n\n  return OimoJSPlugin;\n}();\n\nexport { OimoJSPlugin };","map":{"version":3,"mappings":"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","names":["PhysicsImpostor","PhysicsJoint","PhysicsEngine","Vector3","Quaternion","Logger","PhysicsRaycastResult","_useDeltaForWorldStep","iterations","oimoInjection","Zero","BJSOIMO","world","World","clear","_raycastResult","OimoJSPlugin","gravity","set","x","y","z","timeStep","delta","impostors","forEach","impostor","beforeStep","_fixedTimeStep","step","afterStep","_this","_tmpImpostorsArray","uniqueId","contact","contacts","touching","body1","sleeping","body2","next","mainImpostor","name","collidingImpostor","onCollide","body","physicsBody","point","force","contactPoint","mass","applyImpulse","scale","invScale","Warn","parent","removePhysicsBody","forceUpdate","isBodyInitRequired","bodyConfig_1","config","getParam","size","type","pos","posShape","rot","rotShape","move","density","friction","restitution","impostors_1","addToArray","getChildMeshes","m","physicsImpostor","push","object","checkWithEpsilon_1","value","Math","max","Epsilon","globalQuaternion_1","i","rotationQuaternion","oldQuaternion","copyFrom","computeWorldMatrix","toEulerAngles","extendSize","getObjectExtendSize","radToDeg","center","getObjectCenter","getAbsolutePivotPoint","subtractToRef","_tmpPositionVector","divideInPlace","scaling","localPosition","position","clone","ParticleImpostor","SphereImpostor","radiusX","radiusY","radiusZ","CylinderImpostor","sizeX","sizeY","PlaneImpostor","BoxImpostor","sizeZ","add","resetQuaternion","updatePosition","copyFromFloats","setDeltaPosition","removeRigidBody","impostorJoint","mainBody","connectedBody","connectedImpostor","jointData","joint","options","nativeParams","nativeJointData","axe1","mainAxis","asArray","axe2","connectedAxis","pos1","mainPivot","pos2","connectedPivot","min","collision","spring","BallAndSocketJoint","SpringJoint","springData","length","DistanceJoint","maxDistance","PrismaticJoint","SliderJoint","WheelJoint","HingeJoint","physicsJoint","removeJoint","e","undefined","shapes","parent_1","getPosition","quat","getQuaternion","w","newPosition","newRotation","orientation","syncShapes","awake","velocity","linearVelocity","angularVelocity","v","staticBody","setupMass","sleep","minDistance","limitMotor","upperLimit","lowerLimit","speed","motorIndex","motor","rotationalLimitMotor2","rotationalLimitMotor1","rotationalLimitMotor","setMotor","setLimit","mesh","s","radius","result","shape","halfWidth","halfHeight","halfDepth","from","to","reset"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Physics/Plugins/oimoJSPlugin.ts"],"sourcesContent":["import type { IPhysicsEnginePlugin, PhysicsImpostorJoint } from \"../../Physics/IPhysicsEngine\";\r\nimport type { IPhysicsEnabledObject } from \"../../Physics/physicsImpostor\";\r\nimport { PhysicsImpostor } from \"../../Physics/physicsImpostor\";\r\nimport type { IMotorEnabledJoint, DistanceJointData, SpringJointData } from \"../../Physics/physicsJoint\";\r\nimport { PhysicsJoint } from \"../../Physics/physicsJoint\";\r\nimport { PhysicsEngine } from \"../../Physics/physicsEngine\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { PhysicsRaycastResult } from \"../physicsRaycastResult\";\r\n\r\ndeclare let OIMO: any;\r\n\r\n/** @hidden */\r\nexport class OimoJSPlugin implements IPhysicsEnginePlugin {\r\n    public world: any;\r\n    public name: string = \"OimoJSPlugin\";\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public BJSOIMO: any;\r\n    private _raycastResult: PhysicsRaycastResult;\r\n    private _fixedTimeStep: number = 1 / 60;\r\n\r\n    constructor(private _useDeltaForWorldStep: boolean = true, iterations?: number, oimoInjection = OIMO) {\r\n        this.BJSOIMO = oimoInjection;\r\n        this.world = new this.BJSOIMO.World({\r\n            iterations: iterations,\r\n        });\r\n        this.world.clear();\r\n        this._raycastResult = new PhysicsRaycastResult();\r\n    }\r\n\r\n    public setGravity(gravity: Vector3) {\r\n        this.world.gravity.set(gravity.x, gravity.y, gravity.z);\r\n    }\r\n\r\n    public setTimeStep(timeStep: number) {\r\n        this.world.timeStep = timeStep;\r\n    }\r\n\r\n    public getTimeStep(): number {\r\n        return this.world.timeStep;\r\n    }\r\n\r\n    private _tmpImpostorsArray: Array<PhysicsImpostor> = [];\r\n\r\n    public executeStep(delta: number, impostors: Array<PhysicsImpostor>) {\r\n        impostors.forEach(function (impostor) {\r\n            impostor.beforeStep();\r\n        });\r\n\r\n        this.world.timeStep = this._useDeltaForWorldStep ? delta : this._fixedTimeStep;\r\n        this.world.step();\r\n\r\n        impostors.forEach((impostor) => {\r\n            impostor.afterStep();\r\n            //update the ordered impostors array\r\n            this._tmpImpostorsArray[impostor.uniqueId] = impostor;\r\n        });\r\n\r\n        //check for collisions\r\n        let contact = this.world.contacts;\r\n\r\n        while (contact !== null) {\r\n            if (contact.touching && !contact.body1.sleeping && !contact.body2.sleeping) {\r\n                contact = contact.next;\r\n                continue;\r\n            }\r\n            //is this body colliding with any other? get the impostor\r\n            const mainImpostor = this._tmpImpostorsArray[+contact.body1.name];\r\n            const collidingImpostor = this._tmpImpostorsArray[+contact.body2.name];\r\n\r\n            if (!mainImpostor || !collidingImpostor) {\r\n                contact = contact.next;\r\n                continue;\r\n            }\r\n\r\n            mainImpostor.onCollide({ body: collidingImpostor.physicsBody, point: null });\r\n            collidingImpostor.onCollide({ body: mainImpostor.physicsBody, point: null });\r\n            contact = contact.next;\r\n        }\r\n    }\r\n\r\n    public applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        const mass = impostor.physicsBody.mass;\r\n        impostor.physicsBody.applyImpulse(contactPoint.scale(this.world.invScale), force.scale(this.world.invScale * mass));\r\n    }\r\n    public applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        Logger.Warn(\"Oimo doesn't support applying force. Using impule instead.\");\r\n        this.applyImpulse(impostor, force, contactPoint);\r\n    }\r\n    public generatePhysicsBody(impostor: PhysicsImpostor) {\r\n        //parent-child relationship. Does this impostor has a parent impostor?\r\n        if (impostor.parent) {\r\n            if (impostor.physicsBody) {\r\n                this.removePhysicsBody(impostor);\r\n                //TODO is that needed?\r\n                impostor.forceUpdate();\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (impostor.isBodyInitRequired()) {\r\n            const bodyConfig: any = {\r\n                name: impostor.uniqueId,\r\n                //Oimo must have mass, also for static objects.\r\n                config: [impostor.getParam(\"mass\") || 0.001, impostor.getParam(\"friction\"), impostor.getParam(\"restitution\")],\r\n                size: [],\r\n                type: [],\r\n                pos: [],\r\n                posShape: [],\r\n                rot: [],\r\n                rotShape: [],\r\n                move: impostor.getParam(\"mass\") !== 0,\r\n                density: impostor.getParam(\"mass\"),\r\n                friction: impostor.getParam(\"friction\"),\r\n                restitution: impostor.getParam(\"restitution\"),\r\n                //Supporting older versions of Oimo\r\n                world: this.world,\r\n            };\r\n\r\n            const impostors = [impostor];\r\n            const addToArray = (parent: IPhysicsEnabledObject) => {\r\n                if (!parent.getChildMeshes) {\r\n                    return;\r\n                }\r\n                parent.getChildMeshes().forEach(function (m) {\r\n                    if (m.physicsImpostor) {\r\n                        impostors.push(m.physicsImpostor);\r\n                        //m.physicsImpostor._init();\r\n                    }\r\n                });\r\n            };\r\n            addToArray(impostor.object);\r\n\r\n            const checkWithEpsilon = (value: number): number => {\r\n                return Math.max(value, PhysicsEngine.Epsilon);\r\n            };\r\n\r\n            const globalQuaternion: Quaternion = new Quaternion();\r\n\r\n            impostors.forEach((i) => {\r\n                if (!i.object.rotationQuaternion) {\r\n                    return;\r\n                }\r\n                //get the correct bounding box\r\n                const oldQuaternion = i.object.rotationQuaternion;\r\n                globalQuaternion.copyFrom(oldQuaternion);\r\n\r\n                i.object.rotationQuaternion.set(0, 0, 0, 1);\r\n                i.object.computeWorldMatrix(true);\r\n\r\n                const rot = globalQuaternion.toEulerAngles();\r\n                const extendSize = i.getObjectExtendSize();\r\n\r\n                // eslint-disable-next-line no-loss-of-precision\r\n                const radToDeg = 57.295779513082320876;\r\n\r\n                if (i === impostor) {\r\n                    const center = impostor.getObjectCenter();\r\n\r\n                    impostor.object.getAbsolutePivotPoint().subtractToRef(center, this._tmpPositionVector);\r\n                    this._tmpPositionVector.divideInPlace(impostor.object.scaling);\r\n\r\n                    //Can also use Array.prototype.push.apply\r\n                    bodyConfig.pos.push(center.x);\r\n                    bodyConfig.pos.push(center.y);\r\n                    bodyConfig.pos.push(center.z);\r\n                    bodyConfig.posShape.push(0, 0, 0);\r\n\r\n                    bodyConfig.rotShape.push(0, 0, 0);\r\n                } else {\r\n                    const localPosition = i.object.position.clone();\r\n                    bodyConfig.posShape.push(localPosition.x);\r\n                    bodyConfig.posShape.push(localPosition.y);\r\n                    bodyConfig.posShape.push(localPosition.z);\r\n\r\n                    // bodyConfig.pos.push(0, 0, 0);\r\n\r\n                    bodyConfig.rotShape.push(rot.x * radToDeg, rot.y * radToDeg, rot.z * radToDeg);\r\n                }\r\n\r\n                i.object.rotationQuaternion.copyFrom(globalQuaternion);\r\n\r\n                // register mesh\r\n                switch (i.type) {\r\n                    case PhysicsImpostor.ParticleImpostor:\r\n                        Logger.Warn(\"No Particle support in OIMO.js. using SphereImpostor instead\");\r\n                    // eslint-disable-next-line no-fallthrough\r\n                    case PhysicsImpostor.SphereImpostor: {\r\n                        const radiusX = extendSize.x;\r\n                        const radiusY = extendSize.y;\r\n                        const radiusZ = extendSize.z;\r\n\r\n                        const size = Math.max(checkWithEpsilon(radiusX), checkWithEpsilon(radiusY), checkWithEpsilon(radiusZ)) / 2;\r\n\r\n                        bodyConfig.type.push(\"sphere\");\r\n                        //due to the way oimo works with compounds, add 3 times\r\n                        bodyConfig.size.push(size);\r\n                        bodyConfig.size.push(size);\r\n                        bodyConfig.size.push(size);\r\n                        break;\r\n                    }\r\n                    case PhysicsImpostor.CylinderImpostor: {\r\n                        const sizeX = checkWithEpsilon(extendSize.x) / 2;\r\n                        const sizeY = checkWithEpsilon(extendSize.y);\r\n                        bodyConfig.type.push(\"cylinder\");\r\n                        bodyConfig.size.push(sizeX);\r\n                        bodyConfig.size.push(sizeY);\r\n                        //due to the way oimo works with compounds, add one more value.\r\n                        bodyConfig.size.push(sizeY);\r\n                        break;\r\n                    }\r\n                    case PhysicsImpostor.PlaneImpostor:\r\n                    case PhysicsImpostor.BoxImpostor:\r\n                    default: {\r\n                        const sizeX = checkWithEpsilon(extendSize.x);\r\n                        const sizeY = checkWithEpsilon(extendSize.y);\r\n                        const sizeZ = checkWithEpsilon(extendSize.z);\r\n\r\n                        bodyConfig.type.push(\"box\");\r\n                        //if (i === impostor) {\r\n                        bodyConfig.size.push(sizeX);\r\n                        bodyConfig.size.push(sizeY);\r\n                        bodyConfig.size.push(sizeZ);\r\n                        //} else {\r\n                        //    bodyConfig.size.push(0,0,0);\r\n                        //}\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                //actually not needed, but hey...\r\n                i.object.rotationQuaternion = oldQuaternion;\r\n            });\r\n            impostor.physicsBody = this.world.add(bodyConfig);\r\n            // set the quaternion, ignoring the previously defined (euler) rotation\r\n            impostor.physicsBody.resetQuaternion(globalQuaternion);\r\n            // update with delta 0, so the body will receive the new rotation.\r\n            impostor.physicsBody.updatePosition(0);\r\n        } else {\r\n            this._tmpPositionVector.copyFromFloats(0, 0, 0);\r\n        }\r\n\r\n        impostor.setDeltaPosition(this._tmpPositionVector);\r\n\r\n        //this._tmpPositionVector.addInPlace(impostor.mesh.getBoundingInfo().boundingBox.center);\r\n        //this.setPhysicsBodyTransformation(impostor, this._tmpPositionVector, impostor.mesh.rotationQuaternion);\r\n    }\r\n\r\n    private _tmpPositionVector: Vector3 = Vector3.Zero();\r\n\r\n    public removePhysicsBody(impostor: PhysicsImpostor) {\r\n        //impostor.physicsBody.dispose();\r\n        //Same as : (older oimo versions)\r\n        this.world.removeRigidBody(impostor.physicsBody);\r\n    }\r\n\r\n    public generateJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        const mainBody = impostorJoint.mainImpostor.physicsBody;\r\n        const connectedBody = impostorJoint.connectedImpostor.physicsBody;\r\n\r\n        if (!mainBody || !connectedBody) {\r\n            return;\r\n        }\r\n        const jointData = impostorJoint.joint.jointData;\r\n        const options = jointData.nativeParams || {};\r\n        let type;\r\n        const nativeJointData: any = {\r\n            body1: mainBody,\r\n            body2: connectedBody,\r\n\r\n            axe1: options.axe1 || (jointData.mainAxis ? jointData.mainAxis.asArray() : null),\r\n            axe2: options.axe2 || (jointData.connectedAxis ? jointData.connectedAxis.asArray() : null),\r\n            pos1: options.pos1 || (jointData.mainPivot ? jointData.mainPivot.asArray() : null),\r\n            pos2: options.pos2 || (jointData.connectedPivot ? jointData.connectedPivot.asArray() : null),\r\n\r\n            min: options.min,\r\n            max: options.max,\r\n            collision: options.collision || jointData.collision,\r\n            spring: options.spring,\r\n\r\n            //supporting older version of Oimo\r\n            world: this.world,\r\n        };\r\n        switch (impostorJoint.joint.type) {\r\n            case PhysicsJoint.BallAndSocketJoint:\r\n                type = \"jointBall\";\r\n                break;\r\n            case PhysicsJoint.SpringJoint: {\r\n                Logger.Warn(\"OIMO.js doesn't support Spring Constraint. Simulating using DistanceJoint instead\");\r\n                const springData = <SpringJointData>jointData;\r\n                nativeJointData.min = springData.length || nativeJointData.min;\r\n                //Max should also be set, just make sure it is at least min\r\n                nativeJointData.max = Math.max(nativeJointData.min, nativeJointData.max);\r\n            }\r\n            // eslint-disable-next-line no-fallthrough\r\n            case PhysicsJoint.DistanceJoint:\r\n                type = \"jointDistance\";\r\n                nativeJointData.max = (<DistanceJointData>jointData).maxDistance;\r\n                break;\r\n            case PhysicsJoint.PrismaticJoint:\r\n                type = \"jointPrisme\";\r\n                break;\r\n            case PhysicsJoint.SliderJoint:\r\n                type = \"jointSlide\";\r\n                break;\r\n            case PhysicsJoint.WheelJoint:\r\n                type = \"jointWheel\";\r\n                break;\r\n            case PhysicsJoint.HingeJoint:\r\n            default:\r\n                type = \"jointHinge\";\r\n                break;\r\n        }\r\n        nativeJointData.type = type;\r\n        impostorJoint.joint.physicsJoint = this.world.add(nativeJointData);\r\n    }\r\n\r\n    public removeJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        //Bug in Oimo prevents us from disposing a joint in the playground\r\n        //joint.joint.physicsJoint.dispose();\r\n        //So we will bruteforce it!\r\n        try {\r\n            this.world.removeJoint(impostorJoint.joint.physicsJoint);\r\n        } catch (e) {\r\n            Logger.Warn(e);\r\n        }\r\n    }\r\n\r\n    public isSupported(): boolean {\r\n        return this.BJSOIMO !== undefined;\r\n    }\r\n\r\n    public setTransformationFromPhysicsBody(impostor: PhysicsImpostor) {\r\n        if (!impostor.physicsBody.sleeping) {\r\n            if (impostor.physicsBody.shapes.next) {\r\n                let parent = impostor.physicsBody.shapes;\r\n                while (parent.next) {\r\n                    parent = parent.next;\r\n                }\r\n                impostor.object.position.set(parent.position.x, parent.position.y, parent.position.z);\r\n            } else {\r\n                const pos = impostor.physicsBody.getPosition();\r\n                impostor.object.position.set(pos.x, pos.y, pos.z);\r\n            }\r\n            //}\r\n\r\n            if (impostor.object.rotationQuaternion) {\r\n                const quat = impostor.physicsBody.getQuaternion();\r\n                impostor.object.rotationQuaternion.set(quat.x, quat.y, quat.z, quat.w);\r\n            }\r\n        }\r\n    }\r\n\r\n    public setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion) {\r\n        const body = impostor.physicsBody;\r\n        // disable bidirectional for compound meshes\r\n        if (impostor.physicsBody.shapes.next) {\r\n            return;\r\n        }\r\n        body.position.set(newPosition.x, newPosition.y, newPosition.z);\r\n        body.orientation.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\r\n        body.syncShapes();\r\n        body.awake();\r\n    }\r\n\r\n    /*private _getLastShape(body: any): any {\r\n        var lastShape = body.shapes;\r\n        while (lastShape.next) {\r\n            lastShape = lastShape.next;\r\n        }\r\n        return lastShape;\r\n    }*/\r\n\r\n    public setLinearVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        impostor.physicsBody.linearVelocity.set(velocity.x, velocity.y, velocity.z);\r\n    }\r\n\r\n    public setAngularVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);\r\n    }\r\n\r\n    public getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        const v = impostor.physicsBody.linearVelocity;\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        return new Vector3(v.x, v.y, v.z);\r\n    }\r\n    public getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        const v = impostor.physicsBody.angularVelocity;\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        return new Vector3(v.x, v.y, v.z);\r\n    }\r\n\r\n    public setBodyMass(impostor: PhysicsImpostor, mass: number) {\r\n        const staticBody: boolean = mass === 0;\r\n        //this will actually set the body's density and not its mass.\r\n        //But this is how oimo treats the mass variable.\r\n        impostor.physicsBody.shapes.density = staticBody ? 1 : mass;\r\n        impostor.physicsBody.setupMass(staticBody ? 0x2 : 0x1);\r\n    }\r\n\r\n    public getBodyMass(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.shapes.density;\r\n    }\r\n\r\n    public getBodyFriction(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.shapes.friction;\r\n    }\r\n\r\n    public setBodyFriction(impostor: PhysicsImpostor, friction: number) {\r\n        impostor.physicsBody.shapes.friction = friction;\r\n    }\r\n\r\n    public getBodyRestitution(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.shapes.restitution;\r\n    }\r\n\r\n    public setBodyRestitution(impostor: PhysicsImpostor, restitution: number) {\r\n        impostor.physicsBody.shapes.restitution = restitution;\r\n    }\r\n\r\n    public sleepBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.sleep();\r\n    }\r\n\r\n    public wakeUpBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.awake();\r\n    }\r\n\r\n    public updateDistanceJoint(joint: PhysicsJoint, maxDistance: number, minDistance?: number) {\r\n        joint.physicsJoint.limitMotor.upperLimit = maxDistance;\r\n        if (minDistance !== void 0) {\r\n            joint.physicsJoint.limitMotor.lowerLimit = minDistance;\r\n        }\r\n    }\r\n\r\n    public setMotor(joint: IMotorEnabledJoint, speed: number, force?: number, motorIndex?: number) {\r\n        if (force !== undefined) {\r\n            Logger.Warn(\"OimoJS plugin currently has unexpected behavior when using setMotor with force parameter\");\r\n        } else {\r\n            force = 1e6;\r\n        }\r\n        speed *= -1;\r\n\r\n        //TODO separate rotational and transational motors.\r\n        const motor = motorIndex\r\n            ? joint.physicsJoint.rotationalLimitMotor2\r\n            : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;\r\n        if (motor) {\r\n            motor.setMotor(speed, force);\r\n        }\r\n    }\r\n\r\n    public setLimit(joint: IMotorEnabledJoint, upperLimit: number, lowerLimit?: number, motorIndex?: number) {\r\n        //TODO separate rotational and transational motors.\r\n        const motor = motorIndex\r\n            ? joint.physicsJoint.rotationalLimitMotor2\r\n            : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;\r\n        if (motor) {\r\n            motor.setLimit(upperLimit, lowerLimit === void 0 ? -upperLimit : lowerLimit);\r\n        }\r\n    }\r\n\r\n    public syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor) {\r\n        const body = impostor.physicsBody;\r\n\r\n        mesh.position.x = body.position.x;\r\n        mesh.position.y = body.position.y;\r\n        mesh.position.z = body.position.z;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            mesh.rotationQuaternion.x = body.orientation.x;\r\n            mesh.rotationQuaternion.y = body.orientation.y;\r\n            mesh.rotationQuaternion.z = body.orientation.z;\r\n            mesh.rotationQuaternion.w = body.orientation.s;\r\n        }\r\n    }\r\n\r\n    public getRadius(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.shapes.radius;\r\n    }\r\n\r\n    public getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void {\r\n        const shape = impostor.physicsBody.shapes;\r\n        result.x = shape.halfWidth * 2;\r\n        result.y = shape.halfHeight * 2;\r\n        result.z = shape.halfDepth * 2;\r\n    }\r\n\r\n    public dispose() {\r\n        this.world.clear();\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3): PhysicsRaycastResult {\r\n        Logger.Warn(\"raycast is not currently supported by the Oimo physics plugin\");\r\n\r\n        this._raycastResult.reset(from, to);\r\n\r\n        return this._raycastResult;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}