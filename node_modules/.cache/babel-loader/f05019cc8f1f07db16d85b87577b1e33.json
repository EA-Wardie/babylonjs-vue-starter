{"ast":null,"code":"import { Color4 } from \"../Maths/math.color.js\";\n/** Class used to store color4 gradient */\n\nvar ColorGradient =\n/** @class */\nfunction () {\n  /**\n   * Creates a new color4 gradient\n   * @param gradient gets or sets the gradient value (between 0 and 1)\n   * @param color1 gets or sets first associated color\n   * @param color2 gets or sets first second color\n   */\n  function ColorGradient(\n  /**\n   * Gets or sets the gradient value (between 0 and 1)\n   */\n  gradient,\n  /**\n   * Gets or sets first associated color\n   */\n  color1,\n  /**\n   * Gets or sets second associated color\n   */\n  color2) {\n    this.gradient = gradient;\n    this.color1 = color1;\n    this.color2 = color2;\n  }\n  /**\n   * Will get a color picked randomly between color1 and color2.\n   * If color2 is undefined then color1 will be used\n   * @param result defines the target Color4 to store the result in\n   */\n\n\n  ColorGradient.prototype.getColorToRef = function (result) {\n    if (!this.color2) {\n      result.copyFrom(this.color1);\n      return;\n    }\n\n    Color4.LerpToRef(this.color1, this.color2, Math.random(), result);\n  };\n\n  return ColorGradient;\n}();\n\nexport { ColorGradient };\n/** Class used to store color 3 gradient */\n\nvar Color3Gradient =\n/** @class */\nfunction () {\n  /**\n   * Creates a new color3 gradient\n   * @param gradient gets or sets the gradient value (between 0 and 1)\n   * @param color gets or sets associated color\n   */\n  function Color3Gradient(\n  /**\n   * Gets or sets the gradient value (between 0 and 1)\n   */\n  gradient,\n  /**\n   * Gets or sets the associated color\n   */\n  color) {\n    this.gradient = gradient;\n    this.color = color;\n  }\n\n  return Color3Gradient;\n}();\n\nexport { Color3Gradient };\n/** Class used to store factor gradient */\n\nvar FactorGradient =\n/** @class */\nfunction () {\n  /**\n   * Creates a new factor gradient\n   * @param gradient gets or sets the gradient value (between 0 and 1)\n   * @param factor1 gets or sets first associated factor\n   * @param factor2 gets or sets second associated factor\n   */\n  function FactorGradient(\n  /**\n   * Gets or sets the gradient value (between 0 and 1)\n   */\n  gradient,\n  /**\n   * Gets or sets first associated factor\n   */\n  factor1,\n  /**\n   * Gets or sets second associated factor\n   */\n  factor2) {\n    this.gradient = gradient;\n    this.factor1 = factor1;\n    this.factor2 = factor2;\n  }\n  /**\n   * Will get a number picked randomly between factor1 and factor2.\n   * If factor2 is undefined then factor1 will be used\n   * @returns the picked number\n   */\n\n\n  FactorGradient.prototype.getFactor = function () {\n    if (this.factor2 === undefined || this.factor2 === this.factor1) {\n      return this.factor1;\n    }\n\n    return this.factor1 + (this.factor2 - this.factor1) * Math.random();\n  };\n\n  return FactorGradient;\n}();\n\nexport { FactorGradient };\n/**\n * Helper used to simplify some generic gradient tasks\n */\n\nvar GradientHelper =\n/** @class */\nfunction () {\n  function GradientHelper() {}\n  /**\n   * Gets the current gradient from an array of IValueGradient\n   * @param ratio defines the current ratio to get\n   * @param gradients defines the array of IValueGradient\n   * @param updateFunc defines the callback function used to get the final value from the selected gradients\n   */\n\n\n  GradientHelper.GetCurrentGradient = function (ratio, gradients, updateFunc) {\n    // Use last index if over\n    if (gradients[0].gradient > ratio) {\n      updateFunc(gradients[0], gradients[0], 1.0);\n      return;\n    }\n\n    for (var gradientIndex = 0; gradientIndex < gradients.length - 1; gradientIndex++) {\n      var currentGradient = gradients[gradientIndex];\n      var nextGradient = gradients[gradientIndex + 1];\n\n      if (ratio >= currentGradient.gradient && ratio <= nextGradient.gradient) {\n        var scale = (ratio - currentGradient.gradient) / (nextGradient.gradient - currentGradient.gradient);\n        updateFunc(currentGradient, nextGradient, scale);\n        return;\n      }\n    } // Use last index if over\n\n\n    var lastIndex = gradients.length - 1;\n    updateFunc(gradients[lastIndex], gradients[lastIndex], 1.0);\n  };\n\n  return GradientHelper;\n}();\n\nexport { GradientHelper };","map":{"version":3,"mappings":"AACA,SAASA,MAAT,QAAuB,wBAAvB;AAUA;;AACA;AAAA;AAAA;AACI;;;;;;AAMA;AACI;;;AAGOC,UAJX;AAKI;;;AAGOC,QARX;AASI;;;AAGOC,QAZX,EAY0B;AARf;AAIA;AAIA;AACP;AAEJ;;;;;;;AAKOC,0CAAP,UAAqBC,MAArB,EAAmC;AAC/B,QAAI,CAAC,KAAKF,MAAV,EAAkB;AACdE,YAAM,CAACC,QAAP,CAAgB,KAAKJ,MAArB;AACA;AACH;;AAEDF,UAAM,CAACO,SAAP,CAAiB,KAAKL,MAAtB,EAA8B,KAAKC,MAAnC,EAA2CK,IAAI,CAACC,MAAL,EAA3C,EAA0DJ,MAA1D;AACH,GAPM;;AAQX;AAAC,CAnCD;;;AAqCA;;AACA;AAAA;AAAA;AACI;;;;;AAKA;AACI;;;AAGOJ,UAJX;AAKI;;;AAGOS,OARX,EAQwB;AAJb;AAIA;AACP;;AACR;AAAC,CAhBD;;;AAkBA;;AACA;AAAA;AAAA;AACI;;;;;;AAMA;AACI;;;AAGOT,UAJX;AAKI;;;AAGOU,SARX;AASI;;;AAGOC,SAZX,EAY2B;AARhB;AAIA;AAIA;AACP;AAEJ;;;;;;;AAKOC,uCAAP;AACI,QAAI,KAAKD,OAAL,KAAiBE,SAAjB,IAA8B,KAAKF,OAAL,KAAiB,KAAKD,OAAxD,EAAiE;AAC7D,aAAO,KAAKA,OAAZ;AACH;;AAED,WAAO,KAAKA,OAAL,GAAe,CAAC,KAAKC,OAAL,GAAe,KAAKD,OAArB,IAAgCH,IAAI,CAACC,MAAL,EAAtD;AACH,GANM;;AAOX;AAAC,CAlCD;;;AAoCA;;;;AAGA;AAAA;AAAA;AAAA,6BA6BC;AA5BG;;;;;;;;AAMcM,sCAAd,UAAiCC,KAAjC,EAAgDC,SAAhD,EAA6EC,UAA7E,EAA+J;AAC3J;AACA,QAAID,SAAS,CAAC,CAAD,CAAT,CAAahB,QAAb,GAAwBe,KAA5B,EAAmC;AAC/BE,gBAAU,CAACD,SAAS,CAAC,CAAD,CAAV,EAAeA,SAAS,CAAC,CAAD,CAAxB,EAA6B,GAA7B,CAAV;AACA;AACH;;AAED,SAAK,IAAIE,aAAa,GAAG,CAAzB,EAA4BA,aAAa,GAAGF,SAAS,CAACG,MAAV,GAAmB,CAA/D,EAAkED,aAAa,EAA/E,EAAmF;AAC/E,UAAME,eAAe,GAAGJ,SAAS,CAACE,aAAD,CAAjC;AACA,UAAMG,YAAY,GAAGL,SAAS,CAACE,aAAa,GAAG,CAAjB,CAA9B;;AAEA,UAAIH,KAAK,IAAIK,eAAe,CAACpB,QAAzB,IAAqCe,KAAK,IAAIM,YAAY,CAACrB,QAA/D,EAAyE;AACrE,YAAMsB,KAAK,GAAG,CAACP,KAAK,GAAGK,eAAe,CAACpB,QAAzB,KAAsCqB,YAAY,CAACrB,QAAb,GAAwBoB,eAAe,CAACpB,QAA9E,CAAd;AACAiB,kBAAU,CAACG,eAAD,EAAkBC,YAAlB,EAAgCC,KAAhC,CAAV;AACA;AACH;AACJ,KAhB0J,CAkB3J;;;AACA,QAAMC,SAAS,GAAGP,SAAS,CAACG,MAAV,GAAmB,CAArC;AACAF,cAAU,CAACD,SAAS,CAACO,SAAD,CAAV,EAAuBP,SAAS,CAACO,SAAD,CAAhC,EAA6C,GAA7C,CAAV;AACH,GArBa;;AAsBlB;AAAC,CA7BD","names":["Color4","gradient","color1","color2","ColorGradient","result","copyFrom","LerpToRef","Math","random","color","factor1","factor2","FactorGradient","undefined","GradientHelper","ratio","gradients","updateFunc","gradientIndex","length","currentGradient","nextGradient","scale","lastIndex"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/gradients.ts"],"sourcesContent":["import type { Color3 } from \"../Maths/math.color\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\n\r\n/** Interface used by value gradients (color, factor, ...) */\r\nexport interface IValueGradient {\r\n    /**\r\n     * Gets or sets the gradient value (between 0 and 1)\r\n     */\r\n    gradient: number;\r\n}\r\n\r\n/** Class used to store color4 gradient */\r\nexport class ColorGradient implements IValueGradient {\r\n    /**\r\n     * Creates a new color4 gradient\r\n     * @param gradient gets or sets the gradient value (between 0 and 1)\r\n     * @param color1 gets or sets first associated color\r\n     * @param color2 gets or sets first second color\r\n     */\r\n    public constructor(\r\n        /**\r\n         * Gets or sets the gradient value (between 0 and 1)\r\n         */\r\n        public gradient: number,\r\n        /**\r\n         * Gets or sets first associated color\r\n         */\r\n        public color1: Color4,\r\n        /**\r\n         * Gets or sets second associated color\r\n         */\r\n        public color2?: Color4\r\n    ) {}\r\n\r\n    /**\r\n     * Will get a color picked randomly between color1 and color2.\r\n     * If color2 is undefined then color1 will be used\r\n     * @param result defines the target Color4 to store the result in\r\n     */\r\n    public getColorToRef(result: Color4) {\r\n        if (!this.color2) {\r\n            result.copyFrom(this.color1);\r\n            return;\r\n        }\r\n\r\n        Color4.LerpToRef(this.color1, this.color2, Math.random(), result);\r\n    }\r\n}\r\n\r\n/** Class used to store color 3 gradient */\r\nexport class Color3Gradient implements IValueGradient {\r\n    /**\r\n     * Creates a new color3 gradient\r\n     * @param gradient gets or sets the gradient value (between 0 and 1)\r\n     * @param color gets or sets associated color\r\n     */\r\n    public constructor(\r\n        /**\r\n         * Gets or sets the gradient value (between 0 and 1)\r\n         */\r\n        public gradient: number,\r\n        /**\r\n         * Gets or sets the associated color\r\n         */\r\n        public color: Color3\r\n    ) {}\r\n}\r\n\r\n/** Class used to store factor gradient */\r\nexport class FactorGradient implements IValueGradient {\r\n    /**\r\n     * Creates a new factor gradient\r\n     * @param gradient gets or sets the gradient value (between 0 and 1)\r\n     * @param factor1 gets or sets first associated factor\r\n     * @param factor2 gets or sets second associated factor\r\n     */\r\n    public constructor(\r\n        /**\r\n         * Gets or sets the gradient value (between 0 and 1)\r\n         */\r\n        public gradient: number,\r\n        /**\r\n         * Gets or sets first associated factor\r\n         */\r\n        public factor1: number,\r\n        /**\r\n         * Gets or sets second associated factor\r\n         */\r\n        public factor2?: number\r\n    ) {}\r\n\r\n    /**\r\n     * Will get a number picked randomly between factor1 and factor2.\r\n     * If factor2 is undefined then factor1 will be used\r\n     * @returns the picked number\r\n     */\r\n    public getFactor(): number {\r\n        if (this.factor2 === undefined || this.factor2 === this.factor1) {\r\n            return this.factor1;\r\n        }\r\n\r\n        return this.factor1 + (this.factor2 - this.factor1) * Math.random();\r\n    }\r\n}\r\n\r\n/**\r\n * Helper used to simplify some generic gradient tasks\r\n */\r\nexport class GradientHelper {\r\n    /**\r\n     * Gets the current gradient from an array of IValueGradient\r\n     * @param ratio defines the current ratio to get\r\n     * @param gradients defines the array of IValueGradient\r\n     * @param updateFunc defines the callback function used to get the final value from the selected gradients\r\n     */\r\n    public static GetCurrentGradient(ratio: number, gradients: IValueGradient[], updateFunc: (current: IValueGradient, next: IValueGradient, scale: number) => void) {\r\n        // Use last index if over\r\n        if (gradients[0].gradient > ratio) {\r\n            updateFunc(gradients[0], gradients[0], 1.0);\r\n            return;\r\n        }\r\n\r\n        for (let gradientIndex = 0; gradientIndex < gradients.length - 1; gradientIndex++) {\r\n            const currentGradient = gradients[gradientIndex];\r\n            const nextGradient = gradients[gradientIndex + 1];\r\n\r\n            if (ratio >= currentGradient.gradient && ratio <= nextGradient.gradient) {\r\n                const scale = (ratio - currentGradient.gradient) / (nextGradient.gradient - currentGradient.gradient);\r\n                updateFunc(currentGradient, nextGradient, scale);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Use last index if over\r\n        const lastIndex = gradients.length - 1;\r\n        updateFunc(gradients[lastIndex], gradients[lastIndex], 1.0);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}