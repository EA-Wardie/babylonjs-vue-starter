{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport { __extends } from \"tslib\";\nimport { GLTFLoaderExtension, GLTFLoaderBase, GLTFLoader } from \"./glTFLoader.js\";\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { Material } from \"@babylonjs/core/Materials/material.js\";\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial.js\";\nimport { HemisphericLight } from \"@babylonjs/core/Lights/hemisphericLight.js\";\nimport { DirectionalLight } from \"@babylonjs/core/Lights/directionalLight.js\";\nimport { PointLight } from \"@babylonjs/core/Lights/pointLight.js\";\nimport { SpotLight } from \"@babylonjs/core/Lights/spotLight.js\";\n/** @hidden */\n\nvar GLTFMaterialsCommonExtension =\n/** @class */\nfunction (_super) {\n  __extends(GLTFMaterialsCommonExtension, _super);\n\n  function GLTFMaterialsCommonExtension() {\n    return _super.call(this, \"KHR_materials_common\") || this;\n  }\n\n  GLTFMaterialsCommonExtension.prototype.loadRuntimeExtensionsAsync = function (gltfRuntime) {\n    if (!gltfRuntime.extensions) {\n      return false;\n    }\n\n    var extension = gltfRuntime.extensions[this.name];\n\n    if (!extension) {\n      return false;\n    } // Create lights\n\n\n    var lights = extension.lights;\n\n    if (lights) {\n      for (var thing in lights) {\n        var light = lights[thing];\n\n        switch (light.type) {\n          case \"ambient\":\n            {\n              var ambientLight = new HemisphericLight(light.name, new Vector3(0, 1, 0), gltfRuntime.scene);\n              var ambient = light.ambient;\n\n              if (ambient) {\n                ambientLight.diffuse = Color3.FromArray(ambient.color || [1, 1, 1]);\n              }\n\n              break;\n            }\n\n          case \"point\":\n            {\n              var pointLight = new PointLight(light.name, new Vector3(10, 10, 10), gltfRuntime.scene);\n              var point = light.point;\n\n              if (point) {\n                pointLight.diffuse = Color3.FromArray(point.color || [1, 1, 1]);\n              }\n\n              break;\n            }\n\n          case \"directional\":\n            {\n              var dirLight = new DirectionalLight(light.name, new Vector3(0, -1, 0), gltfRuntime.scene);\n              var directional = light.directional;\n\n              if (directional) {\n                dirLight.diffuse = Color3.FromArray(directional.color || [1, 1, 1]);\n              }\n\n              break;\n            }\n\n          case \"spot\":\n            {\n              var spot = light.spot;\n\n              if (spot) {\n                var spotLight = new SpotLight(light.name, new Vector3(0, 10, 0), new Vector3(0, -1, 0), spot.fallOffAngle || Math.PI, spot.fallOffExponent || 0.0, gltfRuntime.scene);\n                spotLight.diffuse = Color3.FromArray(spot.color || [1, 1, 1]);\n              }\n\n              break;\n            }\n\n          default:\n            Tools.Warn('GLTF Material Common extension: light type \"' + light.type + \"” not supported\");\n            break;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  GLTFMaterialsCommonExtension.prototype.loadMaterialAsync = function (gltfRuntime, id, onSuccess, onError) {\n    var material = gltfRuntime.materials[id];\n\n    if (!material || !material.extensions) {\n      return false;\n    }\n\n    var extension = material.extensions[this.name];\n\n    if (!extension) {\n      return false;\n    }\n\n    var standardMaterial = new StandardMaterial(id, gltfRuntime.scene);\n    standardMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\n\n    if (extension.technique === \"CONSTANT\") {\n      standardMaterial.disableLighting = true;\n    }\n\n    standardMaterial.backFaceCulling = extension.doubleSided === undefined ? false : !extension.doubleSided;\n    standardMaterial.alpha = extension.values.transparency === undefined ? 1.0 : extension.values.transparency;\n    standardMaterial.specularPower = extension.values.shininess === undefined ? 0.0 : extension.values.shininess; // Ambient\n\n    if (typeof extension.values.ambient === \"string\") {\n      this._loadTexture(gltfRuntime, extension.values.ambient, standardMaterial, \"ambientTexture\", onError);\n    } else {\n      standardMaterial.ambientColor = Color3.FromArray(extension.values.ambient || [0, 0, 0]);\n    } // Diffuse\n\n\n    if (typeof extension.values.diffuse === \"string\") {\n      this._loadTexture(gltfRuntime, extension.values.diffuse, standardMaterial, \"diffuseTexture\", onError);\n    } else {\n      standardMaterial.diffuseColor = Color3.FromArray(extension.values.diffuse || [0, 0, 0]);\n    } // Emission\n\n\n    if (typeof extension.values.emission === \"string\") {\n      this._loadTexture(gltfRuntime, extension.values.emission, standardMaterial, \"emissiveTexture\", onError);\n    } else {\n      standardMaterial.emissiveColor = Color3.FromArray(extension.values.emission || [0, 0, 0]);\n    } // Specular\n\n\n    if (typeof extension.values.specular === \"string\") {\n      this._loadTexture(gltfRuntime, extension.values.specular, standardMaterial, \"specularTexture\", onError);\n    } else {\n      standardMaterial.specularColor = Color3.FromArray(extension.values.specular || [0, 0, 0]);\n    }\n\n    return true;\n  };\n\n  GLTFMaterialsCommonExtension.prototype._loadTexture = function (gltfRuntime, id, material, propertyPath, onError) {\n    // Create buffer from texture url\n    GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, function (buffer) {\n      // Create texture from buffer\n      GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, function (texture) {\n        return material[propertyPath] = texture;\n      });\n    }, onError);\n  };\n\n  return GLTFMaterialsCommonExtension;\n}(GLTFLoaderExtension);\n\nexport { GLTFMaterialsCommonExtension };\nGLTFLoader.RegisterExtension(new GLTFMaterialsCommonExtension());","map":{"version":3,"mappings":"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","names":["GLTFLoaderExtension","GLTFLoaderBase","GLTFLoader","Vector3","Color3","Tools","Material","StandardMaterial","HemisphericLight","DirectionalLight","PointLight","SpotLight","__extends","_super","GLTFMaterialsCommonExtension","gltfRuntime","extensions","extension","name","lights","thing","light","type","ambientLight","scene","ambient","diffuse","FromArray","color","pointLight","point","dirLight","directional","spot","spotLight","fallOffAngle","Math","PI","fallOffExponent","Warn","id","onSuccess","onError","material","materials","standardMaterial","sideOrientation","CounterClockWiseSideOrientation","technique","disableLighting","backFaceCulling","doubleSided","undefined","alpha","values","transparency","specularPower","shininess","_loadTexture","ambientColor","diffuseColor","emission","emissiveColor","specular","specularColor","propertyPath","LoadTextureBufferAsync","buffer","CreateTextureAsync","texture","RegisterExtension"],"sourceRoot":"","sources":["../../../../../../lts/loaders/generated/glTF/1.0/glTFMaterialsCommonExtension.ts"],"sourcesContent":["import { GLTFLoaderExtension, GLTFLoaderBase, GLTFLoader } from \"./glTFLoader\";\r\n\r\nimport type { IGLTFRuntime, IGLTFMaterial } from \"./glTFLoaderInterfaces\";\r\n\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { HemisphericLight } from \"core/Lights/hemisphericLight\";\r\nimport { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport { PointLight } from \"core/Lights/pointLight\";\r\nimport { SpotLight } from \"core/Lights/spotLight\";\r\n\r\ninterface IGLTFMaterialsCommonExtensionValues {\r\n    ambient?: number[] | string;\r\n    diffuse?: number[] | string;\r\n    emission?: number[] | string;\r\n    specular?: number[] | string;\r\n    shininess?: number;\r\n    transparency?: number;\r\n}\r\n\r\ninterface IGLTFMaterialsCommonExtension {\r\n    technique: string;\r\n    transparent?: number;\r\n    doubleSided?: boolean;\r\n    values: IGLTFMaterialsCommonExtensionValues;\r\n}\r\n\r\ninterface IGLTFRuntimeCommonExtension {\r\n    lights: { [key: string]: IGLTFLightCommonExtension };\r\n}\r\n\r\ninterface IGLTFLightCommonExtension {\r\n    name: string;\r\n    type: string;\r\n\r\n    ambient?: IGLTFAmbientLightCommonExtension;\r\n    point?: IGLTFPointLightCommonExtension;\r\n    directional?: IGLTFDirectionalLightCommonExtension;\r\n    spot?: IGLTFSpotLightCommonExtension;\r\n}\r\n\r\ninterface IGLTFPointLightCommonExtension {\r\n    color: number[];\r\n    constantAttenuation: number;\r\n    linearAttenuation: number;\r\n    quadraticAttenuation: number;\r\n}\r\n\r\ninterface IGLTFAmbientLightCommonExtension {\r\n    color: number[];\r\n}\r\n\r\ninterface IGLTFDirectionalLightCommonExtension {\r\n    color: number[];\r\n}\r\n\r\ninterface IGLTFSpotLightCommonExtension {\r\n    color: number[];\r\n    constantAttenuation: number;\r\n    fallOffAngle: number;\r\n    fallOffExponent: number;\r\n    linearAttenuation: number;\r\n    quadraticAttenuation: number;\r\n}\r\n\r\n/** @hidden */\r\nexport class GLTFMaterialsCommonExtension extends GLTFLoaderExtension {\r\n    constructor() {\r\n        super(\"KHR_materials_common\");\r\n    }\r\n\r\n    public loadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime): boolean {\r\n        if (!gltfRuntime.extensions) {\r\n            return false;\r\n        }\r\n\r\n        const extension: IGLTFRuntimeCommonExtension = gltfRuntime.extensions[this.name];\r\n        if (!extension) {\r\n            return false;\r\n        }\r\n\r\n        // Create lights\r\n        const lights = extension.lights;\r\n        if (lights) {\r\n            for (const thing in lights) {\r\n                const light: IGLTFLightCommonExtension = lights[thing];\r\n\r\n                switch (light.type) {\r\n                    case \"ambient\": {\r\n                        const ambientLight = new HemisphericLight(light.name, new Vector3(0, 1, 0), gltfRuntime.scene);\r\n                        const ambient = light.ambient;\r\n                        if (ambient) {\r\n                            ambientLight.diffuse = Color3.FromArray(ambient.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"point\": {\r\n                        const pointLight = new PointLight(light.name, new Vector3(10, 10, 10), gltfRuntime.scene);\r\n                        const point = light.point;\r\n                        if (point) {\r\n                            pointLight.diffuse = Color3.FromArray(point.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"directional\": {\r\n                        const dirLight = new DirectionalLight(light.name, new Vector3(0, -1, 0), gltfRuntime.scene);\r\n                        const directional = light.directional;\r\n                        if (directional) {\r\n                            dirLight.diffuse = Color3.FromArray(directional.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"spot\": {\r\n                        const spot = light.spot;\r\n                        if (spot) {\r\n                            const spotLight = new SpotLight(\r\n                                light.name,\r\n                                new Vector3(0, 10, 0),\r\n                                new Vector3(0, -1, 0),\r\n                                spot.fallOffAngle || Math.PI,\r\n                                spot.fallOffExponent || 0.0,\r\n                                gltfRuntime.scene\r\n                            );\r\n                            spotLight.diffuse = Color3.FromArray(spot.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    default:\r\n                        Tools.Warn('GLTF Material Common extension: light type \"' + light.type + \"” not supported\");\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public loadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): boolean {\r\n        const material: IGLTFMaterial = gltfRuntime.materials[id];\r\n        if (!material || !material.extensions) {\r\n            return false;\r\n        }\r\n\r\n        const extension: IGLTFMaterialsCommonExtension = material.extensions[this.name];\r\n        if (!extension) {\r\n            return false;\r\n        }\r\n\r\n        const standardMaterial = new StandardMaterial(id, gltfRuntime.scene);\r\n        standardMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n\r\n        if (extension.technique === \"CONSTANT\") {\r\n            standardMaterial.disableLighting = true;\r\n        }\r\n\r\n        standardMaterial.backFaceCulling = extension.doubleSided === undefined ? false : !extension.doubleSided;\r\n        standardMaterial.alpha = extension.values.transparency === undefined ? 1.0 : extension.values.transparency;\r\n        standardMaterial.specularPower = extension.values.shininess === undefined ? 0.0 : extension.values.shininess;\r\n\r\n        // Ambient\r\n        if (typeof extension.values.ambient === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.ambient, standardMaterial, \"ambientTexture\", onError);\r\n        } else {\r\n            standardMaterial.ambientColor = Color3.FromArray(extension.values.ambient || [0, 0, 0]);\r\n        }\r\n\r\n        // Diffuse\r\n        if (typeof extension.values.diffuse === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.diffuse, standardMaterial, \"diffuseTexture\", onError);\r\n        } else {\r\n            standardMaterial.diffuseColor = Color3.FromArray(extension.values.diffuse || [0, 0, 0]);\r\n        }\r\n\r\n        // Emission\r\n        if (typeof extension.values.emission === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.emission, standardMaterial, \"emissiveTexture\", onError);\r\n        } else {\r\n            standardMaterial.emissiveColor = Color3.FromArray(extension.values.emission || [0, 0, 0]);\r\n        }\r\n\r\n        // Specular\r\n        if (typeof extension.values.specular === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.specular, standardMaterial, \"specularTexture\", onError);\r\n        } else {\r\n            standardMaterial.specularColor = Color3.FromArray(extension.values.specular || [0, 0, 0]);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _loadTexture(gltfRuntime: IGLTFRuntime, id: string, material: StandardMaterial, propertyPath: string, onError: (message: string) => void): void {\r\n        // Create buffer from texture url\r\n        GLTFLoaderBase.LoadTextureBufferAsync(\r\n            gltfRuntime,\r\n            id,\r\n            (buffer) => {\r\n                // Create texture from buffer\r\n                GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, (texture) => ((<any>material)[propertyPath] = texture));\r\n            },\r\n            onError\r\n        );\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(new GLTFMaterialsCommonExtension());\r\n"]},"metadata":{},"sourceType":"module"}