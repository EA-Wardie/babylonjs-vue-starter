{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPoint, NodeMaterialConnectionPointDirection } from \"./nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets.js\";\nimport { UniqueIdGenerator } from \"../../Misc/uniqueIdGenerator.js\";\nimport { GetClass } from \"../../Misc/typeStore.js\";\n/**\n * Defines a block that can be used inside a node based material\n */\n\nvar NodeMaterialBlock =\n/** @class */\nfunction () {\n  /**\n   * Creates a new NodeMaterialBlock\n   * @param name defines the block name\n   * @param target defines the target of that block (Vertex by default)\n   * @param isFinalMerger defines a boolean indicating that this block is an end block (e.g. it is generating a system value). Default is false\n   * @param isInput defines a boolean indicating that this block is an input (e.g. it sends data to the shader). Default is false\n   */\n  function NodeMaterialBlock(name, target, isFinalMerger, isInput) {\n    if (target === void 0) {\n      target = NodeMaterialBlockTargets.Vertex;\n    }\n\n    if (isFinalMerger === void 0) {\n      isFinalMerger = false;\n    }\n\n    if (isInput === void 0) {\n      isInput = false;\n    }\n\n    this._isFinalMerger = false;\n    this._isInput = false;\n    this._name = \"\";\n    this._isUnique = false;\n    /** Gets or sets a boolean indicating that only one input can be connected at a time */\n\n    this.inputsAreExclusive = false;\n    /** @hidden */\n\n    this._codeVariableName = \"\";\n    /** @hidden */\n\n    this._inputs = new Array();\n    /** @hidden */\n\n    this._outputs = new Array();\n    /**\n     * Gets or sets the comments associated with this block\n     */\n\n    this.comments = \"\";\n    /** Gets or sets a boolean indicating that this input can be edited in the Inspector (false by default) */\n\n    this.visibleInInspector = false;\n    /** Gets or sets a boolean indicating that this input can be edited from a collapsed frame */\n\n    this.visibleOnFrame = false;\n    this._target = target;\n    this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;\n    this._isFinalMerger = isFinalMerger;\n    this._isInput = isInput;\n    this._name = name;\n    this.uniqueId = UniqueIdGenerator.UniqueId;\n  }\n\n  Object.defineProperty(NodeMaterialBlock.prototype, \"name\", {\n    /**\n     * Gets the name of the block\n     */\n    get: function get() {\n      return this._name;\n    },\n\n    /**\n     * Sets the name of the block. Will check if the name is valid.\n     */\n    set: function set(newName) {\n      if (!this.validateBlockName(newName)) {\n        return;\n      }\n\n      this._name = newName;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialBlock.prototype, \"isUnique\", {\n    /**\n     * Gets a boolean indicating that this block can only be used once per NodeMaterial\n     */\n    get: function get() {\n      return this._isUnique;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialBlock.prototype, \"isFinalMerger\", {\n    /**\n     * Gets a boolean indicating that this block is an end block (e.g. it is generating a system value)\n     */\n    get: function get() {\n      return this._isFinalMerger;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialBlock.prototype, \"isInput\", {\n    /**\n     * Gets a boolean indicating that this block is an input (e.g. it sends data to the shader)\n     */\n    get: function get() {\n      return this._isInput;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialBlock.prototype, \"buildId\", {\n    /**\n     * Gets or sets the build Id\n     */\n    get: function get() {\n      return this._buildId;\n    },\n    set: function set(value) {\n      this._buildId = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialBlock.prototype, \"target\", {\n    /**\n     * Gets or sets the target of the block\n     */\n    get: function get() {\n      return this._target;\n    },\n    set: function set(value) {\n      if ((this._target & value) !== 0) {\n        return;\n      }\n\n      this._target = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialBlock.prototype, \"inputs\", {\n    /**\n     * Gets the list of input points\n     */\n    get: function get() {\n      return this._inputs;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialBlock.prototype, \"outputs\", {\n    /** Gets the list of output points */\n    get: function get() {\n      return this._outputs;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Find an input by its name\n   * @param name defines the name of the input to look for\n   * @returns the input or null if not found\n   */\n\n  NodeMaterialBlock.prototype.getInputByName = function (name) {\n    var filter = this._inputs.filter(function (e) {\n      return e.name === name;\n    });\n\n    if (filter.length) {\n      return filter[0];\n    }\n\n    return null;\n  };\n  /**\n   * Find an output by its name\n   * @param name defines the name of the output to look for\n   * @returns the output or null if not found\n   */\n\n\n  NodeMaterialBlock.prototype.getOutputByName = function (name) {\n    var filter = this._outputs.filter(function (e) {\n      return e.name === name;\n    });\n\n    if (filter.length) {\n      return filter[0];\n    }\n\n    return null;\n  };\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  NodeMaterialBlock.prototype.initialize = function (state) {// Do nothing\n  };\n  /**\n   * Bind data to effect. Will only be called for blocks with isBindable === true\n   * @param effect defines the effect to bind data to\n   * @param nodeMaterial defines the hosting NodeMaterial\n   * @param mesh defines the mesh that will be rendered\n   * @param subMesh defines the submesh that will be rendered\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  NodeMaterialBlock.prototype.bind = function (effect, nodeMaterial, mesh, subMesh) {// Do nothing\n  };\n\n  NodeMaterialBlock.prototype._declareOutput = function (output, state) {\n    return \"\".concat(state._getGLType(output.type), \" \").concat(output.associatedVariableName);\n  };\n\n  NodeMaterialBlock.prototype._writeVariable = function (currentPoint) {\n    var connectionPoint = currentPoint.connectedPoint;\n\n    if (connectionPoint) {\n      return \"\".concat(currentPoint.associatedVariableName);\n    }\n\n    return \"0.\";\n  };\n\n  NodeMaterialBlock.prototype._writeFloat = function (value) {\n    var stringVersion = value.toString();\n\n    if (stringVersion.indexOf(\".\") === -1) {\n      stringVersion += \".0\";\n    }\n\n    return \"\".concat(stringVersion);\n  };\n  /**\n   * Gets the current class name e.g. \"NodeMaterialBlock\"\n   * @returns the class name\n   */\n\n\n  NodeMaterialBlock.prototype.getClassName = function () {\n    return \"NodeMaterialBlock\";\n  };\n  /**\n   * Register a new input. Must be called inside a block constructor\n   * @param name defines the connection point name\n   * @param type defines the connection point type\n   * @param isOptional defines a boolean indicating that this input can be omitted\n   * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\n   * @param point an already created connection point. If not provided, create a new one\n   * @returns the current block\n   */\n\n\n  NodeMaterialBlock.prototype.registerInput = function (name, type, isOptional, target, point) {\n    if (isOptional === void 0) {\n      isOptional = false;\n    }\n\n    point = point !== null && point !== void 0 ? point : new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Input);\n    point.type = type;\n    point.isOptional = isOptional;\n\n    if (target) {\n      point.target = target;\n    }\n\n    this._inputs.push(point);\n\n    return this;\n  };\n  /**\n   * Register a new output. Must be called inside a block constructor\n   * @param name defines the connection point name\n   * @param type defines the connection point type\n   * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\n   * @param point an already created connection point. If not provided, create a new one\n   * @returns the current block\n   */\n\n\n  NodeMaterialBlock.prototype.registerOutput = function (name, type, target, point) {\n    point = point !== null && point !== void 0 ? point : new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Output);\n    point.type = type;\n\n    if (target) {\n      point.target = target;\n    }\n\n    this._outputs.push(point);\n\n    return this;\n  };\n  /**\n   * Will return the first available input e.g. the first one which is not an uniform or an attribute\n   * @param forOutput defines an optional connection point to check compatibility with\n   * @returns the first available input or null\n   */\n\n\n  NodeMaterialBlock.prototype.getFirstAvailableInput = function (forOutput) {\n    if (forOutput === void 0) {\n      forOutput = null;\n    }\n\n    for (var _i = 0, _a = this._inputs; _i < _a.length; _i++) {\n      var input = _a[_i];\n\n      if (!input.connectedPoint) {\n        if (!forOutput || forOutput.type === input.type || input.type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\n          return input;\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Will return the first available output e.g. the first one which is not yet connected and not a varying\n   * @param forBlock defines an optional block to check compatibility with\n   * @returns the first available input or null\n   */\n\n\n  NodeMaterialBlock.prototype.getFirstAvailableOutput = function (forBlock) {\n    if (forBlock === void 0) {\n      forBlock = null;\n    }\n\n    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {\n      var output = _a[_i];\n\n      if (!forBlock || !forBlock.target || forBlock.target === NodeMaterialBlockTargets.Neutral || (forBlock.target & output.target) !== 0) {\n        return output;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets the sibling of the given output\n   * @param current defines the current output\n   * @returns the next output in the list or null\n   */\n\n\n  NodeMaterialBlock.prototype.getSiblingOutput = function (current) {\n    var index = this._outputs.indexOf(current);\n\n    if (index === -1 || index >= this._outputs.length) {\n      return null;\n    }\n\n    return this._outputs[index + 1];\n  };\n  /**\n   * Checks if the current block is an ancestor of a given block\n   * @param block defines the potential descendant block to check\n   * @returns true if block is a descendant\n   */\n\n\n  NodeMaterialBlock.prototype.isAnAncestorOf = function (block) {\n    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {\n      var output = _a[_i];\n\n      if (!output.hasEndpoints) {\n        continue;\n      }\n\n      for (var _b = 0, _c = output.endpoints; _b < _c.length; _b++) {\n        var endpoint = _c[_b];\n\n        if (endpoint.ownerBlock === block) {\n          return true;\n        }\n\n        if (endpoint.ownerBlock.isAnAncestorOf(block)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Connect current block with another block\n   * @param other defines the block to connect with\n   * @param options define the various options to help pick the right connections\n   * @param options.input\n   * @param options.output\n   * @param options.outputSwizzle\n   * @returns the current block\n   */\n\n\n  NodeMaterialBlock.prototype.connectTo = function (other, options) {\n    if (this._outputs.length === 0) {\n      return;\n    }\n\n    var output = options && options.output ? this.getOutputByName(options.output) : this.getFirstAvailableOutput(other);\n    var notFound = true;\n\n    while (notFound) {\n      var input = options && options.input ? other.getInputByName(options.input) : other.getFirstAvailableInput(output);\n\n      if (output && input && output.canConnectTo(input)) {\n        output.connectTo(input);\n        notFound = false;\n      } else if (!output) {\n        throw \"Unable to find a compatible match\";\n      } else {\n        output = this.getSiblingOutput(output);\n      }\n    }\n\n    return this;\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  NodeMaterialBlock.prototype._buildBlock = function (state) {// Empty. Must be defined by child nodes\n  };\n  /**\n   * Add uniforms, samplers and uniform buffers at compilation time\n   * @param state defines the state to update\n   * @param nodeMaterial defines the node material requesting the update\n   * @param defines defines the material defines to update\n   * @param uniformBuffers defines the list of uniform buffer names\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  NodeMaterialBlock.prototype.updateUniformsAndSamples = function (state, nodeMaterial, defines, uniformBuffers) {// Do nothing\n  };\n  /**\n   * Add potential fallbacks if shader compilation fails\n   * @param mesh defines the mesh to be rendered\n   * @param fallbacks defines the current prioritized list of fallbacks\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  NodeMaterialBlock.prototype.provideFallbacks = function (mesh, fallbacks) {// Do nothing\n  };\n  /**\n   * Initialize defines for shader compilation\n   * @param mesh defines the mesh to be rendered\n   * @param nodeMaterial defines the node material requesting the update\n   * @param defines defines the material defines to update\n   * @param useInstances specifies that instances should be used\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  NodeMaterialBlock.prototype.initializeDefines = function (mesh, nodeMaterial, defines, useInstances) {\n    if (useInstances === void 0) {\n      useInstances = false;\n    }\n  };\n  /**\n   * Update defines for shader compilation\n   * @param mesh defines the mesh to be rendered\n   * @param nodeMaterial defines the node material requesting the update\n   * @param defines defines the material defines to update\n   * @param useInstances specifies that instances should be used\n   * @param subMesh defines which submesh to render\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  NodeMaterialBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines, useInstances, subMesh) {\n    if (useInstances === void 0) {\n      useInstances = false;\n    } // Do nothing\n\n  };\n  /**\n   * Lets the block try to connect some inputs automatically\n   * @param material defines the hosting NodeMaterial\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  NodeMaterialBlock.prototype.autoConfigure = function (material) {// Do nothing\n  };\n  /**\n   * Function called when a block is declared as repeatable content generator\n   * @param vertexShaderState defines the current compilation state for the vertex shader\n   * @param fragmentShaderState defines the current compilation state for the fragment shader\n   * @param mesh defines the mesh to be rendered\n   * @param defines defines the material defines to update\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  NodeMaterialBlock.prototype.replaceRepeatableContent = function (vertexShaderState, fragmentShaderState, mesh, defines) {// Do nothing\n  };\n\n  Object.defineProperty(NodeMaterialBlock.prototype, \"willBeGeneratedIntoVertexShaderFromFragmentShader\", {\n    /** Gets a boolean indicating that the code of this block will be promoted to vertex shader even if connected to fragment output */\n    get: function get() {\n      if (this.isInput || this.isFinalMerger) {\n        return false;\n      }\n\n      if (this._outputs.some(function (o) {\n        return o.isDirectlyConnectedToVertexOutput;\n      })) {\n        return false;\n      }\n\n      if (this.target === NodeMaterialBlockTargets.Vertex) {\n        return false;\n      }\n\n      if (this.target === NodeMaterialBlockTargets.VertexAndFragment || this.target === NodeMaterialBlockTargets.Neutral) {\n        if (this._outputs.some(function (o) {\n          return o.isConnectedInVertexShader;\n        })) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Checks if the block is ready\n   * @param mesh defines the mesh to be rendered\n   * @param nodeMaterial defines the node material requesting the update\n   * @param defines defines the material defines to update\n   * @param useInstances specifies that instances should be used\n   * @returns true if the block is ready\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  NodeMaterialBlock.prototype.isReady = function (mesh, nodeMaterial, defines, useInstances) {\n    if (useInstances === void 0) {\n      useInstances = false;\n    }\n\n    return true;\n  };\n\n  NodeMaterialBlock.prototype._linkConnectionTypes = function (inputIndex0, inputIndex1, looseCoupling) {\n    if (looseCoupling === void 0) {\n      looseCoupling = false;\n    }\n\n    if (looseCoupling) {\n      this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];\n    } else {\n      this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];\n    }\n\n    this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];\n  };\n\n  NodeMaterialBlock.prototype._processBuild = function (block, state, input, activeBlocks) {\n    block.build(state, activeBlocks);\n    var localBlockIsFragment = state._vertexState != null;\n    var otherBlockWasGeneratedInVertexShader = block._buildTarget === NodeMaterialBlockTargets.Vertex && block.target !== NodeMaterialBlockTargets.VertexAndFragment;\n\n    if (localBlockIsFragment && ((block.target & block._buildTarget) === 0 || (block.target & input.target) === 0 || this.target !== NodeMaterialBlockTargets.VertexAndFragment && otherBlockWasGeneratedInVertexShader)) {\n      // context switch! We need a varying\n      if (!block.isInput && state.target !== block._buildTarget || // block was already emitted by vertex shader\n      block.isInput && block.isAttribute && !block._noContextSwitch // block is an attribute\n      ) {\n        var connectedPoint = input.connectedPoint;\n\n        if (state._vertexState._emitVaryingFromString(\"v_\" + connectedPoint.associatedVariableName, state._getGLType(connectedPoint.type))) {\n          state._vertexState.compilationString += \"\".concat(\"v_\" + connectedPoint.associatedVariableName, \" = \").concat(connectedPoint.associatedVariableName, \";\\r\\n\");\n        }\n\n        input.associatedVariableName = \"v_\" + connectedPoint.associatedVariableName;\n        input._enforceAssociatedVariableName = true;\n      }\n    }\n  };\n  /**\n   * Validates the new name for the block node.\n   * @param newName the new name to be given to the node.\n   * @returns false if the name is a reserve word, else true.\n   */\n\n\n  NodeMaterialBlock.prototype.validateBlockName = function (newName) {\n    var reservedNames = [\"position\", \"normal\", \"tangent\", \"particle_positionw\", \"uv\", \"uv2\", \"uv3\", \"uv4\", \"uv5\", \"uv6\", \"position2d\", \"particle_uv\", \"matricesIndices\", \"matricesWeights\", \"world0\", \"world1\", \"world2\", \"world3\", \"particle_color\", \"particle_texturemask\"];\n\n    for (var _i = 0, reservedNames_1 = reservedNames; _i < reservedNames_1.length; _i++) {\n      var reservedName = reservedNames_1[_i];\n\n      if (newName === reservedName) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\n   * Compile the current node and generate the shader code\n   * @param state defines the current compilation state (uniforms, samplers, current string)\n   * @param activeBlocks defines the list of active blocks (i.e. blocks to compile)\n   * @returns true if already built\n   */\n\n\n  NodeMaterialBlock.prototype.build = function (state, activeBlocks) {\n    if (this._buildId === state.sharedData.buildId) {\n      return true;\n    }\n\n    if (!this.isInput) {\n      /** Prepare outputs */\n      for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {\n        var output = _a[_i];\n\n        if (!output.associatedVariableName) {\n          output.associatedVariableName = state._getFreeVariableName(output.name);\n        }\n      }\n    } // Check if \"parent\" blocks are compiled\n\n\n    for (var _b = 0, _c = this._inputs; _b < _c.length; _b++) {\n      var input = _c[_b];\n\n      if (!input.connectedPoint) {\n        if (!input.isOptional) {\n          // Emit a warning\n          state.sharedData.checks.notConnectedNonOptionalInputs.push(input);\n        }\n\n        continue;\n      }\n\n      if (this.target !== NodeMaterialBlockTargets.Neutral) {\n        if ((input.target & this.target) === 0) {\n          continue;\n        }\n\n        if ((input.target & state.target) === 0) {\n          continue;\n        }\n      }\n\n      var block = input.connectedPoint.ownerBlock;\n\n      if (block && block !== this) {\n        this._processBuild(block, state, input, activeBlocks);\n      }\n    }\n\n    if (this._buildId === state.sharedData.buildId) {\n      return true; // Need to check again as inputs can be connected multiple time to this endpoint\n    } // Logs\n\n\n    if (state.sharedData.verbose) {\n      console.log(\"\".concat(state.target === NodeMaterialBlockTargets.Vertex ? \"Vertex shader\" : \"Fragment shader\", \": Building \").concat(this.name, \" [\").concat(this.getClassName(), \"]\"));\n    } // Checks final outputs\n\n\n    if (this.isFinalMerger) {\n      switch (state.target) {\n        case NodeMaterialBlockTargets.Vertex:\n          state.sharedData.checks.emitVertex = true;\n          break;\n\n        case NodeMaterialBlockTargets.Fragment:\n          state.sharedData.checks.emitFragment = true;\n          break;\n      }\n    }\n\n    if (!this.isInput && state.sharedData.emitComments) {\n      state.compilationString += \"\\r\\n//\".concat(this.name, \"\\r\\n\");\n    }\n\n    this._buildBlock(state);\n\n    this._buildId = state.sharedData.buildId;\n    this._buildTarget = state.target; // Compile connected blocks\n\n    for (var _d = 0, _e = this._outputs; _d < _e.length; _d++) {\n      var output = _e[_d];\n\n      if ((output.target & state.target) === 0) {\n        continue;\n      }\n\n      for (var _f = 0, _g = output.endpoints; _f < _g.length; _f++) {\n        var endpoint = _g[_f];\n        var block = endpoint.ownerBlock;\n\n        if (block && (block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1) {\n          this._processBuild(block, state, endpoint, activeBlocks);\n        }\n      }\n    }\n\n    return false;\n  };\n\n  NodeMaterialBlock.prototype._inputRename = function (name) {\n    return name;\n  };\n\n  NodeMaterialBlock.prototype._outputRename = function (name) {\n    return name;\n  };\n\n  NodeMaterialBlock.prototype._dumpPropertiesCode = function () {\n    var variableName = this._codeVariableName;\n    return \"\".concat(variableName, \".visibleInInspector = \").concat(this.visibleInInspector, \";\\r\\n\").concat(variableName, \".visibleOnFrame = \").concat(this.visibleOnFrame, \";\\r\\n\").concat(variableName, \".target = \").concat(this.target, \";\\r\\n\");\n  };\n  /**\n   * @param uniqueNames\n   * @param alreadyDumped\n   * @hidden\n   */\n\n\n  NodeMaterialBlock.prototype._dumpCode = function (uniqueNames, alreadyDumped) {\n    alreadyDumped.push(this);\n    var codeString; // Get unique name\n\n    var nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, \"\");\n    this._codeVariableName = nameAsVariableName || \"\".concat(this.getClassName(), \"_\").concat(this.uniqueId);\n\n    if (uniqueNames.indexOf(this._codeVariableName) !== -1) {\n      var index = 0;\n\n      do {\n        index++;\n        this._codeVariableName = nameAsVariableName + index;\n      } while (uniqueNames.indexOf(this._codeVariableName) !== -1);\n    }\n\n    uniqueNames.push(this._codeVariableName); // Declaration\n\n    codeString = \"\\r\\n// \".concat(this.getClassName(), \"\\r\\n\");\n\n    if (this.comments) {\n      codeString += \"// \".concat(this.comments, \"\\r\\n\");\n    }\n\n    codeString += \"var \".concat(this._codeVariableName, \" = new BABYLON.\").concat(this.getClassName(), \"(\\\"\").concat(this.name, \"\\\");\\r\\n\"); // Properties\n\n    codeString += this._dumpPropertiesCode(); // Inputs\n\n    for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {\n      var input = _a[_i];\n\n      if (!input.isConnected) {\n        continue;\n      }\n\n      var connectedOutput = input.connectedPoint;\n      var connectedBlock = connectedOutput.ownerBlock;\n\n      if (alreadyDumped.indexOf(connectedBlock) === -1) {\n        codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\n      }\n    } // Outputs\n\n\n    for (var _b = 0, _c = this.outputs; _b < _c.length; _b++) {\n      var output = _c[_b];\n\n      if (!output.hasEndpoints) {\n        continue;\n      }\n\n      for (var _d = 0, _e = output.endpoints; _d < _e.length; _d++) {\n        var endpoint = _e[_d];\n        var connectedBlock = endpoint.ownerBlock;\n\n        if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {\n          codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\n        }\n      }\n    }\n\n    return codeString;\n  };\n  /**\n   * @param alreadyDumped\n   * @hidden\n   */\n\n\n  NodeMaterialBlock.prototype._dumpCodeForOutputConnections = function (alreadyDumped) {\n    var codeString = \"\";\n\n    if (alreadyDumped.indexOf(this) !== -1) {\n      return codeString;\n    }\n\n    alreadyDumped.push(this);\n\n    for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {\n      var input = _a[_i];\n\n      if (!input.isConnected) {\n        continue;\n      }\n\n      var connectedOutput = input.connectedPoint;\n      var connectedBlock = connectedOutput.ownerBlock;\n      codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);\n      codeString += \"\".concat(connectedBlock._codeVariableName, \".\").concat(connectedBlock._outputRename(connectedOutput.name), \".connectTo(\").concat(this._codeVariableName, \".\").concat(this._inputRename(input.name), \");\\r\\n\");\n    }\n\n    return codeString;\n  };\n  /**\n   * Clone the current block to a new identical block\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a copy of the current block\n   */\n\n\n  NodeMaterialBlock.prototype.clone = function (scene, rootUrl) {\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    var serializationObject = this.serialize();\n    var blockType = GetClass(serializationObject.customType);\n\n    if (blockType) {\n      var block = new blockType();\n\n      block._deserialize(serializationObject, scene, rootUrl);\n\n      return block;\n    }\n\n    return null;\n  };\n  /**\n   * Serializes this block in a JSON representation\n   * @returns the serialized block object\n   */\n\n\n  NodeMaterialBlock.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.customType = \"BABYLON.\" + this.getClassName();\n    serializationObject.id = this.uniqueId;\n    serializationObject.name = this.name;\n    serializationObject.comments = this.comments;\n    serializationObject.visibleInInspector = this.visibleInInspector;\n    serializationObject.visibleOnFrame = this.visibleOnFrame;\n    serializationObject.target = this.target;\n    serializationObject.inputs = [];\n    serializationObject.outputs = [];\n\n    for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {\n      var input = _a[_i];\n      serializationObject.inputs.push(input.serialize());\n    }\n\n    for (var _b = 0, _c = this.outputs; _b < _c.length; _b++) {\n      var output = _c[_b];\n      serializationObject.outputs.push(output.serialize(false));\n    }\n\n    return serializationObject;\n  };\n  /**\n   * @param serializationObject\n   * @param scene\n   * @param rootUrl\n   * @hidden\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  NodeMaterialBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {\n    var _a;\n\n    this.name = serializationObject.name;\n    this.comments = serializationObject.comments;\n    this.visibleInInspector = !!serializationObject.visibleInInspector;\n    this.visibleOnFrame = !!serializationObject.visibleOnFrame;\n    this._target = (_a = serializationObject.target) !== null && _a !== void 0 ? _a : this.target;\n\n    this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);\n  };\n\n  NodeMaterialBlock.prototype._deserializePortDisplayNamesAndExposedOnFrame = function (serializationObject) {\n    var _this = this;\n\n    var serializedInputs = serializationObject.inputs;\n    var serializedOutputs = serializationObject.outputs;\n\n    if (serializedInputs) {\n      serializedInputs.forEach(function (port, i) {\n        if (port.displayName) {\n          _this.inputs[i].displayName = port.displayName;\n        }\n\n        if (port.isExposedOnFrame) {\n          _this.inputs[i].isExposedOnFrame = port.isExposedOnFrame;\n          _this.inputs[i].exposedPortPosition = port.exposedPortPosition;\n        }\n      });\n    }\n\n    if (serializedOutputs) {\n      serializedOutputs.forEach(function (port, i) {\n        if (port.displayName) {\n          _this.outputs[i].displayName = port.displayName;\n        }\n\n        if (port.isExposedOnFrame) {\n          _this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;\n          _this.outputs[i].exposedPortPosition = port.exposedPortPosition;\n        }\n      });\n    }\n  };\n  /**\n   * Release resources\n   */\n\n\n  NodeMaterialBlock.prototype.dispose = function () {\n    for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {\n      var input = _a[_i];\n      input.dispose();\n    }\n\n    for (var _b = 0, _c = this.outputs; _b < _c.length; _b++) {\n      var output = _c[_b];\n      output.dispose();\n    }\n  };\n\n  return NodeMaterialBlock;\n}();\n\nexport { NodeMaterialBlock };","map":{"version":3,"mappings":"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","names":["NodeMaterialBlockConnectionPointTypes","NodeMaterialConnectionPoint","NodeMaterialConnectionPointDirection","NodeMaterialBlockTargets","UniqueIdGenerator","GetClass","name","target","isFinalMerger","isInput","Vertex","Array","_target","_originalTargetIsNeutral","Neutral","_isFinalMerger","_isInput","_name","uniqueId","UniqueId","Object","NodeMaterialBlock","newName","validateBlockName","_isUnique","_buildId","value","_inputs","_outputs","filter","e","length","state","effect","nodeMaterial","mesh","subMesh","output","_getGLType","type","concat","associatedVariableName","currentPoint","connectionPoint","connectedPoint","stringVersion","toString","indexOf","isOptional","point","Input","push","Output","forOutput","_i","input","AutoDetect","forBlock","current","index","block","hasEndpoints","endpoints","_b","endpoint","ownerBlock","isAnAncestorOf","other","options","getOutputByName","getFirstAvailableOutput","notFound","getInputByName","getFirstAvailableInput","canConnectTo","connectTo","getSiblingOutput","defines","uniformBuffers","fallbacks","useInstances","material","vertexShaderState","fragmentShaderState","some","o","isDirectlyConnectedToVertexOutput","VertexAndFragment","isConnectedInVertexShader","inputIndex0","inputIndex1","looseCoupling","_acceptedConnectionPointType","_linkedConnectionSource","activeBlocks","build","localBlockIsFragment","_vertexState","otherBlockWasGeneratedInVertexShader","_buildTarget","isAttribute","_noContextSwitch","_emitVaryingFromString","compilationString","_enforceAssociatedVariableName","reservedNames","reservedName","sharedData","buildId","_getFreeVariableName","checks","notConnectedNonOptionalInputs","_processBuild","verbose","console","log","getClassName","emitVertex","Fragment","emitFragment","emitComments","_buildBlock","_d","_f","variableName","_codeVariableName","visibleInInspector","visibleOnFrame","uniqueNames","alreadyDumped","codeString","nameAsVariableName","replace","comments","_dumpPropertiesCode","inputs","isConnected","connectedOutput","connectedBlock","_dumpCode","outputs","_dumpCodeForOutputConnections","_outputRename","_inputRename","scene","rootUrl","serializationObject","serialize","blockType","customType","_deserialize","id","_a","_deserializePortDisplayNamesAndExposedOnFrame","serializedInputs","serializedOutputs","forEach","port","i","displayName","_this","isExposedOnFrame","exposedPortPosition","dispose"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Node/nodeMaterialBlock.ts"],"sourcesContent":["import { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"./nodeMaterialBuildState\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { NodeMaterialConnectionPoint, NodeMaterialConnectionPointDirection } from \"./nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport type { Effect } from \"../effect\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"./nodeMaterial\";\r\nimport type { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport { UniqueIdGenerator } from \"../../Misc/uniqueIdGenerator\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { GetClass } from \"../../Misc/typeStore\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\n\r\n/**\r\n * Defines a block that can be used inside a node based material\r\n */\r\nexport class NodeMaterialBlock {\r\n    private _buildId: number;\r\n    private _buildTarget: NodeMaterialBlockTargets;\r\n    protected _target: NodeMaterialBlockTargets;\r\n    private _isFinalMerger = false;\r\n    private _isInput = false;\r\n    private _name = \"\";\r\n    protected _isUnique = false;\r\n\r\n    /** Gets or sets a boolean indicating that only one input can be connected at a time */\r\n    public inputsAreExclusive = false;\r\n\r\n    /** @hidden */\r\n    public _codeVariableName = \"\";\r\n\r\n    /** @hidden */\r\n    public _inputs = new Array<NodeMaterialConnectionPoint>();\r\n    /** @hidden */\r\n    public _outputs = new Array<NodeMaterialConnectionPoint>();\r\n\r\n    /** @hidden */\r\n    public _preparationId: number;\r\n\r\n    /** @hidden */\r\n    public readonly _originalTargetIsNeutral: boolean;\r\n\r\n    /**\r\n     * Gets the name of the block\r\n     */\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /**\r\n     * Sets the name of the block. Will check if the name is valid.\r\n     */\r\n    public set name(newName: string) {\r\n        if (!this.validateBlockName(newName)) {\r\n            return;\r\n        }\r\n\r\n        this._name = newName;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the unique id of the node\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Gets or sets the comments associated with this block\r\n     */\r\n    public comments: string = \"\";\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block can only be used once per NodeMaterial\r\n     */\r\n    public get isUnique() {\r\n        return this._isUnique;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is an end block (e.g. it is generating a system value)\r\n     */\r\n    public get isFinalMerger(): boolean {\r\n        return this._isFinalMerger;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is an input (e.g. it sends data to the shader)\r\n     */\r\n    public get isInput(): boolean {\r\n        return this._isInput;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the build Id\r\n     */\r\n    public get buildId(): number {\r\n        return this._buildId;\r\n    }\r\n\r\n    public set buildId(value: number) {\r\n        this._buildId = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the target of the block\r\n     */\r\n    public get target() {\r\n        return this._target;\r\n    }\r\n\r\n    public set target(value: NodeMaterialBlockTargets) {\r\n        if ((this._target & value) !== 0) {\r\n            return;\r\n        }\r\n        this._target = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of input points\r\n     */\r\n    public get inputs(): NodeMaterialConnectionPoint[] {\r\n        return this._inputs;\r\n    }\r\n\r\n    /** Gets the list of output points */\r\n    public get outputs(): NodeMaterialConnectionPoint[] {\r\n        return this._outputs;\r\n    }\r\n\r\n    /**\r\n     * Find an input by its name\r\n     * @param name defines the name of the input to look for\r\n     * @returns the input or null if not found\r\n     */\r\n    public getInputByName(name: string) {\r\n        const filter = this._inputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Find an output by its name\r\n     * @param name defines the name of the output to look for\r\n     * @returns the output or null if not found\r\n     */\r\n    public getOutputByName(name: string) {\r\n        const filter = this._outputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating that this input can be edited in the Inspector (false by default) */\r\n    public visibleInInspector = false;\r\n\r\n    /** Gets or sets a boolean indicating that this input can be edited from a collapsed frame */\r\n    public visibleOnFrame = false;\r\n\r\n    /**\r\n     * Creates a new NodeMaterialBlock\r\n     * @param name defines the block name\r\n     * @param target defines the target of that block (Vertex by default)\r\n     * @param isFinalMerger defines a boolean indicating that this block is an end block (e.g. it is generating a system value). Default is false\r\n     * @param isInput defines a boolean indicating that this block is an input (e.g. it sends data to the shader). Default is false\r\n     */\r\n    public constructor(name: string, target = NodeMaterialBlockTargets.Vertex, isFinalMerger = false, isInput = false) {\r\n        this._target = target;\r\n        this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;\r\n        this._isFinalMerger = isFinalMerger;\r\n        this._isInput = isInput;\r\n        this._name = name;\r\n        this.uniqueId = UniqueIdGenerator.UniqueId;\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Bind data to effect. Will only be called for blocks with isBindable === true\r\n     * @param effect defines the effect to bind data to\r\n     * @param nodeMaterial defines the hosting NodeMaterial\r\n     * @param mesh defines the mesh that will be rendered\r\n     * @param subMesh defines the submesh that will be rendered\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh, subMesh?: SubMesh) {\r\n        // Do nothing\r\n    }\r\n\r\n    protected _declareOutput(output: NodeMaterialConnectionPoint, state: NodeMaterialBuildState): string {\r\n        return `${state._getGLType(output.type)} ${output.associatedVariableName}`;\r\n    }\r\n\r\n    protected _writeVariable(currentPoint: NodeMaterialConnectionPoint): string {\r\n        const connectionPoint = currentPoint.connectedPoint;\r\n\r\n        if (connectionPoint) {\r\n            return `${currentPoint.associatedVariableName}`;\r\n        }\r\n\r\n        return `0.`;\r\n    }\r\n\r\n    protected _writeFloat(value: number) {\r\n        let stringVersion = value.toString();\r\n\r\n        if (stringVersion.indexOf(\".\") === -1) {\r\n            stringVersion += \".0\";\r\n        }\r\n        return `${stringVersion}`;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeMaterialBlock\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"NodeMaterialBlock\";\r\n    }\r\n\r\n    /**\r\n     * Register a new input. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param isOptional defines a boolean indicating that this input can be omitted\r\n     * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\r\n     * @param point an already created connection point. If not provided, create a new one\r\n     * @returns the current block\r\n     */\r\n    public registerInput(\r\n        name: string,\r\n        type: NodeMaterialBlockConnectionPointTypes,\r\n        isOptional: boolean = false,\r\n        target?: NodeMaterialBlockTargets,\r\n        point?: NodeMaterialConnectionPoint\r\n    ) {\r\n        point = point ?? new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Input);\r\n        point.type = type;\r\n        point.isOptional = isOptional;\r\n        if (target) {\r\n            point.target = target;\r\n        }\r\n\r\n        this._inputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Register a new output. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\r\n     * @param point an already created connection point. If not provided, create a new one\r\n     * @returns the current block\r\n     */\r\n    public registerOutput(name: string, type: NodeMaterialBlockConnectionPointTypes, target?: NodeMaterialBlockTargets, point?: NodeMaterialConnectionPoint) {\r\n        point = point ?? new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Output);\r\n        point.type = type;\r\n        if (target) {\r\n            point.target = target;\r\n        }\r\n\r\n        this._outputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Will return the first available input e.g. the first one which is not an uniform or an attribute\r\n     * @param forOutput defines an optional connection point to check compatibility with\r\n     * @returns the first available input or null\r\n     */\r\n    public getFirstAvailableInput(forOutput: Nullable<NodeMaterialConnectionPoint> = null) {\r\n        for (const input of this._inputs) {\r\n            if (!input.connectedPoint) {\r\n                if (!forOutput || forOutput.type === input.type || input.type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n                    return input;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Will return the first available output e.g. the first one which is not yet connected and not a varying\r\n     * @param forBlock defines an optional block to check compatibility with\r\n     * @returns the first available input or null\r\n     */\r\n    public getFirstAvailableOutput(forBlock: Nullable<NodeMaterialBlock> = null) {\r\n        for (const output of this._outputs) {\r\n            if (!forBlock || !forBlock.target || forBlock.target === NodeMaterialBlockTargets.Neutral || (forBlock.target & output.target) !== 0) {\r\n                return output;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the sibling of the given output\r\n     * @param current defines the current output\r\n     * @returns the next output in the list or null\r\n     */\r\n    public getSiblingOutput(current: NodeMaterialConnectionPoint) {\r\n        const index = this._outputs.indexOf(current);\r\n\r\n        if (index === -1 || index >= this._outputs.length) {\r\n            return null;\r\n        }\r\n\r\n        return this._outputs[index + 1];\r\n    }\r\n\r\n    /**\r\n     * Checks if the current block is an ancestor of a given block\r\n     * @param block defines the potential descendant block to check\r\n     * @returns true if block is a descendant\r\n     */\r\n    public isAnAncestorOf(block: NodeMaterialBlock): boolean {\r\n        for (const output of this._outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                if (endpoint.ownerBlock === block) {\r\n                    return true;\r\n                }\r\n                if (endpoint.ownerBlock.isAnAncestorOf(block)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Connect current block with another block\r\n     * @param other defines the block to connect with\r\n     * @param options define the various options to help pick the right connections\r\n     * @param options.input\r\n     * @param options.output\r\n     * @param options.outputSwizzle\r\n     * @returns the current block\r\n     */\r\n    public connectTo(\r\n        other: NodeMaterialBlock,\r\n        options?: {\r\n            input?: string;\r\n            output?: string;\r\n            outputSwizzle?: string;\r\n        }\r\n    ) {\r\n        if (this._outputs.length === 0) {\r\n            return;\r\n        }\r\n\r\n        let output = options && options.output ? this.getOutputByName(options.output) : this.getFirstAvailableOutput(other);\r\n\r\n        let notFound = true;\r\n        while (notFound) {\r\n            const input = options && options.input ? other.getInputByName(options.input) : other.getFirstAvailableInput(output);\r\n\r\n            if (output && input && output.canConnectTo(input)) {\r\n                output.connectTo(input);\r\n                notFound = false;\r\n            } else if (!output) {\r\n                throw \"Unable to find a compatible match\";\r\n            } else {\r\n                output = this.getSiblingOutput(output);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        // Empty. Must be defined by child nodes\r\n    }\r\n\r\n    /**\r\n     * Add uniforms, samplers and uniform buffers at compilation time\r\n     * @param state defines the state to update\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param uniformBuffers defines the list of uniform buffer names\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public updateUniformsAndSamples(state: NodeMaterialBuildState, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, uniformBuffers: string[]) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Add potential fallbacks if shader compilation fails\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param fallbacks defines the current prioritized list of fallbacks\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public provideFallbacks(mesh: AbstractMesh, fallbacks: EffectFallbacks) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Initialize defines for shader compilation\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param useInstances specifies that instances should be used\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public initializeDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false) {}\r\n\r\n    /**\r\n     * Update defines for shader compilation\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param useInstances specifies that instances should be used\r\n     * @param subMesh defines which submesh to render\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false, subMesh?: SubMesh) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Lets the block try to connect some inputs automatically\r\n     * @param material defines the hosting NodeMaterial\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public autoConfigure(material: NodeMaterial) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Function called when a block is declared as repeatable content generator\r\n     * @param vertexShaderState defines the current compilation state for the vertex shader\r\n     * @param fragmentShaderState defines the current compilation state for the fragment shader\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param defines defines the material defines to update\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public replaceRepeatableContent(vertexShaderState: NodeMaterialBuildState, fragmentShaderState: NodeMaterialBuildState, mesh: AbstractMesh, defines: NodeMaterialDefines) {\r\n        // Do nothing\r\n    }\r\n\r\n    /** Gets a boolean indicating that the code of this block will be promoted to vertex shader even if connected to fragment output */\r\n    public get willBeGeneratedIntoVertexShaderFromFragmentShader(): boolean {\r\n        if (this.isInput || this.isFinalMerger) {\r\n            return false;\r\n        }\r\n\r\n        if (this._outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.target === NodeMaterialBlockTargets.Vertex) {\r\n            return false;\r\n        }\r\n\r\n        if (this.target === NodeMaterialBlockTargets.VertexAndFragment || this.target === NodeMaterialBlockTargets.Neutral) {\r\n            if (this._outputs.some((o) => o.isConnectedInVertexShader)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the block is ready\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns true if the block is ready\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isReady(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false) {\r\n        return true;\r\n    }\r\n\r\n    protected _linkConnectionTypes(inputIndex0: number, inputIndex1: number, looseCoupling = false) {\r\n        if (looseCoupling) {\r\n            this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];\r\n        } else {\r\n            this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];\r\n        }\r\n        this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];\r\n    }\r\n\r\n    private _processBuild(block: NodeMaterialBlock, state: NodeMaterialBuildState, input: NodeMaterialConnectionPoint, activeBlocks: NodeMaterialBlock[]) {\r\n        block.build(state, activeBlocks);\r\n\r\n        const localBlockIsFragment = state._vertexState != null;\r\n        const otherBlockWasGeneratedInVertexShader = block._buildTarget === NodeMaterialBlockTargets.Vertex && block.target !== NodeMaterialBlockTargets.VertexAndFragment;\r\n\r\n        if (\r\n            localBlockIsFragment &&\r\n            ((block.target & block._buildTarget) === 0 ||\r\n                (block.target & input.target) === 0 ||\r\n                (this.target !== NodeMaterialBlockTargets.VertexAndFragment && otherBlockWasGeneratedInVertexShader))\r\n        ) {\r\n            // context switch! We need a varying\r\n            if (\r\n                (!block.isInput && state.target !== block._buildTarget) || // block was already emitted by vertex shader\r\n                (block.isInput && (block as InputBlock).isAttribute && !(block as InputBlock)._noContextSwitch) // block is an attribute\r\n            ) {\r\n                const connectedPoint = input.connectedPoint!;\r\n                if (state._vertexState._emitVaryingFromString(\"v_\" + connectedPoint.associatedVariableName, state._getGLType(connectedPoint.type))) {\r\n                    state._vertexState.compilationString += `${\"v_\" + connectedPoint.associatedVariableName} = ${connectedPoint.associatedVariableName};\\r\\n`;\r\n                }\r\n                input.associatedVariableName = \"v_\" + connectedPoint.associatedVariableName;\r\n                input._enforceAssociatedVariableName = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates the new name for the block node.\r\n     * @param newName the new name to be given to the node.\r\n     * @returns false if the name is a reserve word, else true.\r\n     */\r\n    public validateBlockName(newName: string) {\r\n        const reservedNames: Array<string> = [\r\n            \"position\",\r\n            \"normal\",\r\n            \"tangent\",\r\n            \"particle_positionw\",\r\n            \"uv\",\r\n            \"uv2\",\r\n            \"uv3\",\r\n            \"uv4\",\r\n            \"uv5\",\r\n            \"uv6\",\r\n            \"position2d\",\r\n            \"particle_uv\",\r\n            \"matricesIndices\",\r\n            \"matricesWeights\",\r\n            \"world0\",\r\n            \"world1\",\r\n            \"world2\",\r\n            \"world3\",\r\n            \"particle_color\",\r\n            \"particle_texturemask\",\r\n        ];\r\n        for (const reservedName of reservedNames) {\r\n            if (newName === reservedName) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Compile the current node and generate the shader code\r\n     * @param state defines the current compilation state (uniforms, samplers, current string)\r\n     * @param activeBlocks defines the list of active blocks (i.e. blocks to compile)\r\n     * @returns true if already built\r\n     */\r\n    public build(state: NodeMaterialBuildState, activeBlocks: NodeMaterialBlock[]): boolean {\r\n        if (this._buildId === state.sharedData.buildId) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.isInput) {\r\n            /** Prepare outputs */\r\n            for (const output of this._outputs) {\r\n                if (!output.associatedVariableName) {\r\n                    output.associatedVariableName = state._getFreeVariableName(output.name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Check if \"parent\" blocks are compiled\r\n        for (const input of this._inputs) {\r\n            if (!input.connectedPoint) {\r\n                if (!input.isOptional) {\r\n                    // Emit a warning\r\n                    state.sharedData.checks.notConnectedNonOptionalInputs.push(input);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            if (this.target !== NodeMaterialBlockTargets.Neutral) {\r\n                if ((input.target & this.target!) === 0) {\r\n                    continue;\r\n                }\r\n\r\n                if ((input.target & state.target!) === 0) {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            const block = input.connectedPoint.ownerBlock;\r\n            if (block && block !== this) {\r\n                this._processBuild(block, state, input, activeBlocks);\r\n            }\r\n        }\r\n\r\n        if (this._buildId === state.sharedData.buildId) {\r\n            return true; // Need to check again as inputs can be connected multiple time to this endpoint\r\n        }\r\n\r\n        // Logs\r\n        if (state.sharedData.verbose) {\r\n            console.log(`${state.target === NodeMaterialBlockTargets.Vertex ? \"Vertex shader\" : \"Fragment shader\"}: Building ${this.name} [${this.getClassName()}]`);\r\n        }\r\n\r\n        // Checks final outputs\r\n        if (this.isFinalMerger) {\r\n            switch (state.target) {\r\n                case NodeMaterialBlockTargets.Vertex:\r\n                    state.sharedData.checks.emitVertex = true;\r\n                    break;\r\n                case NodeMaterialBlockTargets.Fragment:\r\n                    state.sharedData.checks.emitFragment = true;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if (!this.isInput && state.sharedData.emitComments) {\r\n            state.compilationString += `\\r\\n//${this.name}\\r\\n`;\r\n        }\r\n\r\n        this._buildBlock(state);\r\n\r\n        this._buildId = state.sharedData.buildId;\r\n        this._buildTarget = state.target;\r\n\r\n        // Compile connected blocks\r\n        for (const output of this._outputs) {\r\n            if ((output.target & state.target) === 0) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const block = endpoint.ownerBlock;\r\n\r\n                if (block && (block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1) {\r\n                    this._processBuild(block, state, endpoint, activeBlocks);\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    protected _inputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    protected _outputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const variableName = this._codeVariableName;\r\n        return `${variableName}.visibleInInspector = ${this.visibleInInspector};\\r\\n${variableName}.visibleOnFrame = ${this.visibleOnFrame};\\r\\n${variableName}.target = ${this.target};\\r\\n`;\r\n    }\r\n\r\n    /**\r\n     * @param uniqueNames\r\n     * @param alreadyDumped\r\n     * @hidden\r\n     */\r\n    public _dumpCode(uniqueNames: string[], alreadyDumped: NodeMaterialBlock[]) {\r\n        alreadyDumped.push(this);\r\n\r\n        let codeString: string;\r\n\r\n        // Get unique name\r\n        const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, \"\");\r\n        this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;\r\n\r\n        if (uniqueNames.indexOf(this._codeVariableName) !== -1) {\r\n            let index = 0;\r\n            do {\r\n                index++;\r\n                this._codeVariableName = nameAsVariableName + index;\r\n            } while (uniqueNames.indexOf(this._codeVariableName) !== -1);\r\n        }\r\n\r\n        uniqueNames.push(this._codeVariableName);\r\n\r\n        // Declaration\r\n        codeString = `\\r\\n// ${this.getClassName()}\\r\\n`;\r\n        if (this.comments) {\r\n            codeString += `// ${this.comments}\\r\\n`;\r\n        }\r\n        codeString += `var ${this._codeVariableName} = new BABYLON.${this.getClassName()}(\"${this.name}\");\\r\\n`;\r\n\r\n        // Properties\r\n        codeString += this._dumpPropertiesCode();\r\n\r\n        // Inputs\r\n        for (const input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            const connectedOutput = input.connectedPoint!;\r\n            const connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            if (alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Outputs\r\n        for (const output of this.outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const connectedBlock = endpoint.ownerBlock;\r\n                if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                    codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n                }\r\n            }\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * @param alreadyDumped\r\n     * @hidden\r\n     */\r\n    public _dumpCodeForOutputConnections(alreadyDumped: NodeMaterialBlock[]) {\r\n        let codeString = \"\";\r\n\r\n        if (alreadyDumped.indexOf(this) !== -1) {\r\n            return codeString;\r\n        }\r\n\r\n        alreadyDumped.push(this);\r\n\r\n        for (const input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            const connectedOutput = input.connectedPoint!;\r\n            const connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);\r\n            codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(\r\n                input.name\r\n            )});\\r\\n`;\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Clone the current block to a new identical block\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a copy of the current block\r\n     */\r\n    public clone(scene: Scene, rootUrl: string = \"\") {\r\n        const serializationObject = this.serialize();\r\n\r\n        const blockType = GetClass(serializationObject.customType);\r\n        if (blockType) {\r\n            const block: NodeMaterialBlock = new blockType();\r\n            block._deserialize(serializationObject, scene, rootUrl);\r\n\r\n            return block;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.customType = \"BABYLON.\" + this.getClassName();\r\n        serializationObject.id = this.uniqueId;\r\n        serializationObject.name = this.name;\r\n        serializationObject.comments = this.comments;\r\n        serializationObject.visibleInInspector = this.visibleInInspector;\r\n        serializationObject.visibleOnFrame = this.visibleOnFrame;\r\n        serializationObject.target = this.target;\r\n\r\n        serializationObject.inputs = [];\r\n        serializationObject.outputs = [];\r\n\r\n        for (const input of this.inputs) {\r\n            serializationObject.inputs.push(input.serialize());\r\n        }\r\n\r\n        for (const output of this.outputs) {\r\n            serializationObject.outputs.push(output.serialize(false));\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * @param serializationObject\r\n     * @param scene\r\n     * @param rootUrl\r\n     * @hidden\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        this.name = serializationObject.name;\r\n        this.comments = serializationObject.comments;\r\n        this.visibleInInspector = !!serializationObject.visibleInInspector;\r\n        this.visibleOnFrame = !!serializationObject.visibleOnFrame;\r\n        this._target = serializationObject.target ?? this.target;\r\n        this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);\r\n    }\r\n\r\n    private _deserializePortDisplayNamesAndExposedOnFrame(serializationObject: any) {\r\n        const serializedInputs = serializationObject.inputs;\r\n        const serializedOutputs = serializationObject.outputs;\r\n        if (serializedInputs) {\r\n            serializedInputs.forEach((port: any, i: number) => {\r\n                if (port.displayName) {\r\n                    this.inputs[i].displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    this.inputs[i].isExposedOnFrame = port.isExposedOnFrame;\r\n                    this.inputs[i].exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n            });\r\n        }\r\n        if (serializedOutputs) {\r\n            serializedOutputs.forEach((port: any, i: number) => {\r\n                if (port.displayName) {\r\n                    this.outputs[i].displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;\r\n                    this.outputs[i].exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        for (const input of this.inputs) {\r\n            input.dispose();\r\n        }\r\n\r\n        for (const output of this.outputs) {\r\n            output.dispose();\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}