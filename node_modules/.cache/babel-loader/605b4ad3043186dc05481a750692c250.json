{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.date.now.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector.js\";\n/**\n * A behavior that allows a transform node to stick to a surface position/orientation\n * @since 5.0.0\n */\n\nvar SurfaceMagnetismBehavior =\n/** @class */\nfunction () {\n  function SurfaceMagnetismBehavior() {\n    this._attachPointLocalOffset = new Vector3();\n    this._workingPosition = new Vector3();\n    this._workingQuaternion = new Quaternion();\n    this._lastTick = -1;\n    this._hit = false;\n    /**\n     * Distance offset from the hit point to place the target at, along the hit normal.\n     */\n\n    this.hitNormalOffset = 0.05;\n    /**\n     * Spatial mapping meshes to collide with\n     */\n\n    this.meshes = [];\n    /**\n     * Set to false if the node should strictly follow the camera without any interpolation time\n     */\n\n    this.interpolatePose = true;\n    /**\n     * Rate of interpolation of position and rotation of the attached node.\n     * Higher values will give a slower interpolation.\n     */\n\n    this.lerpTime = 250;\n    /**\n     * If true, pitch and roll are omitted.\n     */\n\n    this.keepOrientationVertical = true;\n    /**\n     * Is this behavior reacting to pointer events\n     */\n\n    this.enabled = true;\n    /**\n     * Maximum distance for the node to stick to the surface\n     */\n\n    this.maxStickingDistance = 0.8;\n  }\n\n  Object.defineProperty(SurfaceMagnetismBehavior.prototype, \"name\", {\n    /**\n     * Name of the behavior\n     */\n    get: function get() {\n      return \"SurfaceMagnetism\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Function called when the behavior needs to be initialized (after attaching it to a target)\n   */\n\n  SurfaceMagnetismBehavior.prototype.init = function () {};\n  /**\n   * Attaches the behavior to a transform node\n   * @param target defines the target where the behavior is attached to\n   * @param scene the scene\n   */\n\n\n  SurfaceMagnetismBehavior.prototype.attach = function (target, scene) {\n    this._attachedMesh = target;\n    this._scene = scene || target.getScene();\n\n    if (!this._attachedMesh.rotationQuaternion) {\n      this._attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._attachedMesh.rotation.y, this._attachedMesh.rotation.x, this._attachedMesh.rotation.z);\n    }\n\n    this.updateAttachPoint();\n\n    this._workingPosition.copyFrom(this._attachedMesh.position);\n\n    this._workingQuaternion.copyFrom(this._attachedMesh.rotationQuaternion);\n\n    this._addObservables();\n  };\n  /**\n   * Detaches the behavior\n   */\n\n\n  SurfaceMagnetismBehavior.prototype.detach = function () {\n    this._attachedMesh = null;\n\n    this._removeObservables();\n  };\n\n  SurfaceMagnetismBehavior.prototype._getTargetPose = function (pickingInfo) {\n    if (!this._attachedMesh) {\n      return null;\n    }\n\n    if (pickingInfo && pickingInfo.hit) {\n      var pickedNormal = pickingInfo.getNormal(true, true);\n      var pickedPoint = pickingInfo.pickedPoint;\n\n      if (!pickedNormal || !pickedPoint) {\n        return null;\n      }\n\n      pickedNormal.normalize();\n      var worldTarget = TmpVectors.Vector3[0];\n      worldTarget.copyFrom(pickedNormal);\n      worldTarget.scaleInPlace(this.hitNormalOffset);\n      worldTarget.addInPlace(pickedPoint);\n\n      if (this._attachedMesh.parent) {\n        TmpVectors.Matrix[0].copyFrom(this._attachedMesh.parent.getWorldMatrix()).invert();\n        Vector3.TransformNormalToRef(worldTarget, TmpVectors.Matrix[0], worldTarget);\n      }\n\n      return {\n        position: worldTarget,\n        quaternion: Quaternion.RotationYawPitchRoll(-Math.atan2(pickedNormal.x, -pickedNormal.z), this.keepOrientationVertical ? 0 : Math.atan2(pickedNormal.y, Math.sqrt(pickedNormal.z * pickedNormal.z + pickedNormal.x * pickedNormal.x)), 0)\n      };\n    }\n\n    return null;\n  };\n  /**\n   * Updates the attach point with the current geometry extents of the attached mesh\n   */\n\n\n  SurfaceMagnetismBehavior.prototype.updateAttachPoint = function () {\n    this._getAttachPointOffsetToRef(this._attachPointLocalOffset);\n  };\n  /**\n   * Finds the intersection point of the given ray onto the meshes and updates the target.\n   * Transformation will be interpolated according to `interpolatePose` and `lerpTime` properties.\n   * If no mesh of `meshes` are hit, this does nothing.\n   * @param pickInfo The input pickingInfo that will be used to intersect the meshes\n   * @returns a boolean indicating if we found a hit to stick to\n   */\n\n\n  SurfaceMagnetismBehavior.prototype.findAndUpdateTarget = function (pickInfo) {\n    this._hit = false;\n\n    if (!pickInfo.ray) {\n      return false;\n    }\n\n    var subPicking = pickInfo.ray.intersectsMeshes(this.meshes)[0];\n\n    if (this._attachedMesh && subPicking && subPicking.hit && subPicking.pickedMesh) {\n      var pose = this._getTargetPose(subPicking);\n\n      if (pose && Vector3.Distance(this._attachedMesh.position, pose.position) < this.maxStickingDistance) {\n        this._workingPosition.copyFrom(pose.position);\n\n        this._workingQuaternion.copyFrom(pose.quaternion);\n\n        this._hit = true;\n      }\n    }\n\n    return this._hit;\n  };\n\n  SurfaceMagnetismBehavior.prototype._getAttachPointOffsetToRef = function (ref) {\n    if (!this._attachedMesh) {\n      ref.setAll(0);\n      return;\n    }\n\n    var storedQuat = TmpVectors.Quaternion[0];\n    storedQuat.copyFrom(this._attachedMesh.rotationQuaternion);\n\n    this._attachedMesh.rotationQuaternion.copyFromFloats(0, 0, 0, 1);\n\n    this._attachedMesh.computeWorldMatrix();\n\n    var boundingMinMax = this._attachedMesh.getHierarchyBoundingVectors();\n\n    var center = TmpVectors.Vector3[0];\n    boundingMinMax.max.addToRef(boundingMinMax.min, center);\n    center.scaleInPlace(0.5);\n    center.z = boundingMinMax.max.z; // We max the z coordinate because we want the attach point to be on the back of the mesh\n\n    var invWorld = TmpVectors.Matrix[0];\n\n    this._attachedMesh.getWorldMatrix().invertToRef(invWorld);\n\n    Vector3.TransformCoordinatesToRef(center, invWorld, ref);\n\n    this._attachedMesh.rotationQuaternion.copyFrom(storedQuat);\n  };\n\n  SurfaceMagnetismBehavior.prototype._updateTransformToGoal = function (elapsed) {\n    if (!this._attachedMesh || !this._hit) {\n      return;\n    }\n\n    var oldParent = this._attachedMesh.parent;\n\n    this._attachedMesh.setParent(null);\n\n    var worldOffset = TmpVectors.Vector3[0];\n    Vector3.TransformNormalToRef(this._attachPointLocalOffset, this._attachedMesh.getWorldMatrix(), worldOffset);\n\n    if (!this.interpolatePose) {\n      this._attachedMesh.position.copyFrom(this._workingPosition).subtractInPlace(worldOffset);\n\n      this._attachedMesh.rotationQuaternion.copyFrom(this._workingQuaternion);\n\n      return;\n    } // position\n\n\n    var interpolatedPosition = new Vector3();\n    Vector3.SmoothToRef(this._attachedMesh.position, this._workingPosition, elapsed, this.lerpTime, interpolatedPosition);\n\n    this._attachedMesh.position.copyFrom(interpolatedPosition); // rotation\n\n\n    var currentRotation = new Quaternion();\n    currentRotation.copyFrom(this._attachedMesh.rotationQuaternion);\n    Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this._attachedMesh.rotationQuaternion);\n\n    this._attachedMesh.setParent(oldParent);\n  };\n\n  SurfaceMagnetismBehavior.prototype._addObservables = function () {\n    var _this = this;\n\n    this._pointerObserver = this._scene.onPointerObservable.add(function (pointerInfo) {\n      if (_this.enabled && pointerInfo.type == PointerEventTypes.POINTERMOVE && pointerInfo.pickInfo) {\n        _this.findAndUpdateTarget(pointerInfo.pickInfo);\n      }\n    });\n    this._lastTick = Date.now();\n    this._onBeforeRender = this._scene.onBeforeRenderObservable.add(function () {\n      var tick = Date.now();\n\n      _this._updateTransformToGoal(tick - _this._lastTick);\n\n      _this._lastTick = tick;\n    });\n  };\n\n  SurfaceMagnetismBehavior.prototype._removeObservables = function () {\n    this._scene.onPointerObservable.remove(this._pointerObserver);\n\n    this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);\n\n    this._pointerObserver = null;\n    this._onBeforeRender = null;\n  };\n\n  return SurfaceMagnetismBehavior;\n}();\n\nexport { SurfaceMagnetismBehavior };","map":{"version":3,"mappings":"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","names":["PointerEventTypes","Quaternion","TmpVectors","Vector3","Object","SurfaceMagnetismBehavior","target","scene","_attachedMesh","_scene","getScene","rotationQuaternion","RotationYawPitchRoll","rotation","y","x","z","updateAttachPoint","_workingPosition","copyFrom","position","_workingQuaternion","_addObservables","_removeObservables","pickingInfo","hit","pickedNormal","getNormal","pickedPoint","normalize","worldTarget","scaleInPlace","hitNormalOffset","addInPlace","parent","Matrix","getWorldMatrix","invert","TransformNormalToRef","quaternion","Math","atan2","keepOrientationVertical","sqrt","_getAttachPointOffsetToRef","_attachPointLocalOffset","pickInfo","_hit","ray","subPicking","intersectsMeshes","meshes","pickedMesh","pose","_getTargetPose","Distance","maxStickingDistance","ref","setAll","storedQuat","copyFromFloats","computeWorldMatrix","boundingMinMax","getHierarchyBoundingVectors","center","max","addToRef","min","invWorld","invertToRef","TransformCoordinatesToRef","elapsed","oldParent","setParent","worldOffset","interpolatePose","subtractInPlace","interpolatedPosition","SmoothToRef","lerpTime","currentRotation","_pointerObserver","onPointerObservable","add","pointerInfo","_this","enabled","type","POINTERMOVE","findAndUpdateTarget","_lastTick","Date","now","_onBeforeRender","onBeforeRenderObservable","tick","_updateTransformToGoal","remove"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Behaviors/Meshes/surfaceMagnetismBehavior.ts"],"sourcesContent":["import type { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Behavior } from \"../behavior\";\r\n\r\n/**\r\n * A behavior that allows a transform node to stick to a surface position/orientation\r\n * @since 5.0.0\r\n */\r\nexport class SurfaceMagnetismBehavior implements Behavior<Mesh> {\r\n    private _scene: Scene;\r\n    private _attachedMesh: Nullable<Mesh>;\r\n    private _attachPointLocalOffset: Vector3 = new Vector3();\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>>;\r\n    private _workingPosition: Vector3 = new Vector3();\r\n    private _workingQuaternion: Quaternion = new Quaternion();\r\n    private _lastTick: number = -1;\r\n    private _onBeforeRender: Nullable<Observer<Scene>>;\r\n    private _hit = false;\r\n\r\n    /**\r\n     * Distance offset from the hit point to place the target at, along the hit normal.\r\n     */\r\n    public hitNormalOffset: number = 0.05;\r\n\r\n    /**\r\n     * Name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"SurfaceMagnetism\";\r\n    }\r\n\r\n    /**\r\n     * Spatial mapping meshes to collide with\r\n     */\r\n    public meshes: AbstractMesh[] = [];\r\n\r\n    /**\r\n     * Function called when the behavior needs to be initialized (after attaching it to a target)\r\n     */\r\n    public init(): void {}\r\n\r\n    /**\r\n     * Set to false if the node should strictly follow the camera without any interpolation time\r\n     */\r\n    public interpolatePose = true;\r\n\r\n    /**\r\n     * Rate of interpolation of position and rotation of the attached node.\r\n     * Higher values will give a slower interpolation.\r\n     */\r\n    public lerpTime = 250;\r\n\r\n    /**\r\n     * If true, pitch and roll are omitted.\r\n     */\r\n    public keepOrientationVertical = true;\r\n\r\n    /**\r\n     * Is this behavior reacting to pointer events\r\n     */\r\n    public enabled = true;\r\n\r\n    /**\r\n     * Maximum distance for the node to stick to the surface\r\n     */\r\n    public maxStickingDistance = 0.8;\r\n\r\n    /**\r\n     * Attaches the behavior to a transform node\r\n     * @param target defines the target where the behavior is attached to\r\n     * @param scene the scene\r\n     */\r\n    public attach(target: Mesh, scene?: Scene): void {\r\n        this._attachedMesh = target;\r\n        this._scene = scene || target.getScene();\r\n        if (!this._attachedMesh.rotationQuaternion) {\r\n            this._attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._attachedMesh.rotation.y, this._attachedMesh.rotation.x, this._attachedMesh.rotation.z);\r\n        }\r\n        this.updateAttachPoint();\r\n\r\n        this._workingPosition.copyFrom(this._attachedMesh.position);\r\n        this._workingQuaternion.copyFrom(this._attachedMesh.rotationQuaternion);\r\n        this._addObservables();\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior\r\n     */\r\n    public detach(): void {\r\n        this._attachedMesh = null;\r\n        this._removeObservables();\r\n    }\r\n\r\n    private _getTargetPose(pickingInfo: PickingInfo): Nullable<{ position: Vector3; quaternion: Quaternion }> {\r\n        if (!this._attachedMesh) {\r\n            return null;\r\n        }\r\n\r\n        if (pickingInfo && pickingInfo.hit) {\r\n            const pickedNormal = pickingInfo.getNormal(true, true);\r\n            const pickedPoint = pickingInfo.pickedPoint;\r\n\r\n            if (!pickedNormal || !pickedPoint) {\r\n                return null;\r\n            }\r\n            pickedNormal.normalize();\r\n\r\n            const worldTarget = TmpVectors.Vector3[0];\r\n            worldTarget.copyFrom(pickedNormal);\r\n            worldTarget.scaleInPlace(this.hitNormalOffset);\r\n            worldTarget.addInPlace(pickedPoint);\r\n\r\n            if (this._attachedMesh.parent) {\r\n                TmpVectors.Matrix[0].copyFrom(this._attachedMesh.parent.getWorldMatrix()).invert();\r\n                Vector3.TransformNormalToRef(worldTarget, TmpVectors.Matrix[0], worldTarget);\r\n            }\r\n\r\n            return {\r\n                position: worldTarget,\r\n                quaternion: Quaternion.RotationYawPitchRoll(\r\n                    -Math.atan2(pickedNormal.x, -pickedNormal.z),\r\n                    this.keepOrientationVertical ? 0 : Math.atan2(pickedNormal.y, Math.sqrt(pickedNormal.z * pickedNormal.z + pickedNormal.x * pickedNormal.x)),\r\n                    0\r\n                ),\r\n            };\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Updates the attach point with the current geometry extents of the attached mesh\r\n     */\r\n    public updateAttachPoint() {\r\n        this._getAttachPointOffsetToRef(this._attachPointLocalOffset);\r\n    }\r\n\r\n    /**\r\n     * Finds the intersection point of the given ray onto the meshes and updates the target.\r\n     * Transformation will be interpolated according to `interpolatePose` and `lerpTime` properties.\r\n     * If no mesh of `meshes` are hit, this does nothing.\r\n     * @param pickInfo The input pickingInfo that will be used to intersect the meshes\r\n     * @returns a boolean indicating if we found a hit to stick to\r\n     */\r\n    public findAndUpdateTarget(pickInfo: PickingInfo): boolean {\r\n        this._hit = false;\r\n        if (!pickInfo.ray) {\r\n            return false;\r\n        }\r\n\r\n        const subPicking = pickInfo.ray.intersectsMeshes(this.meshes)[0];\r\n\r\n        if (this._attachedMesh && subPicking && subPicking.hit && subPicking.pickedMesh) {\r\n            const pose = this._getTargetPose(subPicking);\r\n            if (pose && Vector3.Distance(this._attachedMesh.position, pose.position) < this.maxStickingDistance) {\r\n                this._workingPosition.copyFrom(pose.position);\r\n                this._workingQuaternion.copyFrom(pose.quaternion);\r\n                this._hit = true;\r\n            }\r\n        }\r\n\r\n        return this._hit;\r\n    }\r\n\r\n    private _getAttachPointOffsetToRef(ref: Vector3) {\r\n        if (!this._attachedMesh) {\r\n            ref.setAll(0);\r\n            return;\r\n        }\r\n\r\n        const storedQuat = TmpVectors.Quaternion[0];\r\n        storedQuat.copyFrom(this._attachedMesh.rotationQuaternion!);\r\n        this._attachedMesh.rotationQuaternion!.copyFromFloats(0, 0, 0, 1);\r\n        this._attachedMesh.computeWorldMatrix();\r\n        const boundingMinMax = this._attachedMesh.getHierarchyBoundingVectors();\r\n        const center = TmpVectors.Vector3[0];\r\n        boundingMinMax.max.addToRef(boundingMinMax.min, center);\r\n        center.scaleInPlace(0.5);\r\n        center.z = boundingMinMax.max.z;\r\n        // We max the z coordinate because we want the attach point to be on the back of the mesh\r\n        const invWorld = TmpVectors.Matrix[0];\r\n        this._attachedMesh.getWorldMatrix().invertToRef(invWorld);\r\n        Vector3.TransformCoordinatesToRef(center, invWorld, ref);\r\n        this._attachedMesh.rotationQuaternion!.copyFrom(storedQuat);\r\n    }\r\n\r\n    private _updateTransformToGoal(elapsed: number) {\r\n        if (!this._attachedMesh || !this._hit) {\r\n            return;\r\n        }\r\n\r\n        const oldParent = this._attachedMesh.parent;\r\n        this._attachedMesh.setParent(null);\r\n\r\n        const worldOffset = TmpVectors.Vector3[0];\r\n        Vector3.TransformNormalToRef(this._attachPointLocalOffset, this._attachedMesh.getWorldMatrix(), worldOffset);\r\n\r\n        if (!this.interpolatePose) {\r\n            this._attachedMesh.position.copyFrom(this._workingPosition).subtractInPlace(worldOffset);\r\n            this._attachedMesh.rotationQuaternion!.copyFrom(this._workingQuaternion);\r\n            return;\r\n        }\r\n\r\n        // position\r\n        const interpolatedPosition = new Vector3();\r\n        Vector3.SmoothToRef(this._attachedMesh.position, this._workingPosition, elapsed, this.lerpTime, interpolatedPosition);\r\n        this._attachedMesh.position.copyFrom(interpolatedPosition);\r\n\r\n        // rotation\r\n        const currentRotation = new Quaternion();\r\n        currentRotation.copyFrom(this._attachedMesh.rotationQuaternion!);\r\n        Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this._attachedMesh.rotationQuaternion!);\r\n\r\n        this._attachedMesh.setParent(oldParent);\r\n    }\r\n\r\n    private _addObservables() {\r\n        this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {\r\n            if (this.enabled && pointerInfo.type == PointerEventTypes.POINTERMOVE && pointerInfo.pickInfo) {\r\n                this.findAndUpdateTarget(pointerInfo.pickInfo);\r\n            }\r\n        });\r\n\r\n        this._lastTick = Date.now();\r\n        this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {\r\n            const tick = Date.now();\r\n            this._updateTransformToGoal(tick - this._lastTick);\r\n            this._lastTick = tick;\r\n        });\r\n    }\r\n\r\n    private _removeObservables() {\r\n        this._scene.onPointerObservable.remove(this._pointerObserver);\r\n        this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);\r\n        this._pointerObserver = null;\r\n        this._onBeforeRender = null;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}