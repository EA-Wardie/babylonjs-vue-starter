{"ast":null,"code":"import \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/web.timers.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { __assign, __extends } from \"tslib\";\nimport { FactorGradient, ColorGradient, Color3Gradient, GradientHelper } from \"../Misc/gradients.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3, Matrix, TmpVectors, Vector4 } from \"../Maths/math.vector.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer.js\";\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { BoxParticleEmitter, HemisphericParticleEmitter, SphereParticleEmitter, SphereDirectedParticleEmitter, CylinderParticleEmitter, ConeParticleEmitter, PointParticleEmitter, MeshParticleEmitter, CylinderDirectedParticleEmitter } from \"../Particles/EmitterTypes/index.js\";\nimport { BaseParticleSystem } from \"./baseParticleSystem.js\";\nimport { Particle } from \"./particle.js\";\nimport { SubEmitter, SubEmitterType } from \"./subEmitter.js\";\nimport { SerializationHelper } from \"../Misc/decorators.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport \"../Shaders/particles.fragment.js\";\nimport \"../Shaders/particles.vertex.js\";\nimport { Color4, Color3, TmpColors } from \"../Maths/math.color.js\";\nimport { ThinEngine } from \"../Engines/thinEngine.js\";\nimport { ThinMaterialHelper } from \"../Materials/thinMaterialHelper.js\";\nimport \"../Engines/Extensions/engine.alpha.js\";\n/**\n * This represents a particle system in Babylon.\n * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\n * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.\n * @example https://doc.babylonjs.com/babylon101/particles\n */\n\nvar ParticleSystem =\n/** @class */\nfunction (_super) {\n  __extends(ParticleSystem, _super);\n  /**\n   * Instantiates a particle system.\n   * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\n   * @param name The name of the particle system\n   * @param capacity The max number of particles alive at the same time\n   * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene\n   * @param customEffect a custom effect used to change the way particles are rendered by default\n   * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture\n   * @param epsilon Offset used to render the particles\n   */\n\n\n  function ParticleSystem(name, capacity, sceneOrEngine, customEffect, isAnimationSheetEnabled, epsilon) {\n    if (customEffect === void 0) {\n      customEffect = null;\n    }\n\n    if (isAnimationSheetEnabled === void 0) {\n      isAnimationSheetEnabled = false;\n    }\n\n    if (epsilon === void 0) {\n      epsilon = 0.01;\n    }\n\n    var _this = _super.call(this, name) || this;\n\n    _this._emitterInverseWorldMatrix = Matrix.Identity();\n    /**\n     * @hidden\n     */\n\n    _this._inheritedVelocityOffset = new Vector3();\n    /**\n     * An event triggered when the system is disposed\n     */\n\n    _this.onDisposeObservable = new Observable();\n    /**\n     * An event triggered when the system is stopped\n     */\n\n    _this.onStoppedObservable = new Observable();\n    _this._particles = new Array();\n    _this._stockParticles = new Array();\n    _this._newPartsExcess = 0;\n    _this._vertexBuffers = {};\n    _this._scaledColorStep = new Color4(0, 0, 0, 0);\n    _this._colorDiff = new Color4(0, 0, 0, 0);\n    _this._scaledDirection = Vector3.Zero();\n    _this._scaledGravity = Vector3.Zero();\n    _this._currentRenderId = -1;\n    _this._useInstancing = false;\n    _this._started = false;\n    _this._stopped = false;\n    _this._actualFrame = 0;\n    /** @hidden */\n\n    _this._currentEmitRate1 = 0;\n    /** @hidden */\n\n    _this._currentEmitRate2 = 0;\n    /** @hidden */\n\n    _this._currentStartSize1 = 0;\n    /** @hidden */\n\n    _this._currentStartSize2 = 0;\n    _this._rawTextureWidth = 256;\n    _this._useRampGradients = false;\n    /**\n     * @hidden\n     * If the particle systems emitter should be disposed when the particle system is disposed\n     */\n\n    _this._disposeEmitterOnDispose = false;\n    /**\n     * Specifies if the particles are updated in emitter local space or world space\n     */\n\n    _this.isLocal = false;\n    /** @hidden */\n\n    _this._onBeforeDrawParticlesObservable = null; // start of sub system methods\n\n    /**\n     * \"Recycles\" one of the particle by copying it back to the \"stock\" of particles and removing it from the active list.\n     * Its lifetime will start back at 0.\n     * @param particle\n     */\n\n    _this.recycleParticle = function (particle) {\n      // move particle from activeParticle list to stock particles\n      var lastParticle = _this._particles.pop();\n\n      if (lastParticle !== particle) {\n        lastParticle.copyTo(particle);\n      }\n\n      _this._stockParticles.push(lastParticle);\n    };\n\n    _this._createParticle = function () {\n      var particle;\n\n      if (_this._stockParticles.length !== 0) {\n        particle = _this._stockParticles.pop();\n\n        particle._reset();\n      } else {\n        particle = new Particle(_this);\n      } // Attach emitters\n\n\n      if (_this._subEmitters && _this._subEmitters.length > 0) {\n        var subEmitters = _this._subEmitters[Math.floor(Math.random() * _this._subEmitters.length)];\n\n        particle._attachedSubEmitters = [];\n        subEmitters.forEach(function (subEmitter) {\n          if (subEmitter.type === SubEmitterType.ATTACHED) {\n            var newEmitter = subEmitter.clone();\n\n            particle._attachedSubEmitters.push(newEmitter);\n\n            newEmitter.particleSystem.start();\n          }\n        });\n      }\n\n      return particle;\n    };\n\n    _this._emitFromParticle = function (particle) {\n      if (!_this._subEmitters || _this._subEmitters.length === 0) {\n        return;\n      }\n\n      var templateIndex = Math.floor(Math.random() * _this._subEmitters.length);\n\n      _this._subEmitters[templateIndex].forEach(function (subEmitter) {\n        if (subEmitter.type === SubEmitterType.END) {\n          var subSystem = subEmitter.clone();\n\n          particle._inheritParticleInfoToSubEmitter(subSystem);\n\n          subSystem.particleSystem._rootParticleSystem = _this;\n\n          _this.activeSubSystems.push(subSystem.particleSystem);\n\n          subSystem.particleSystem.start();\n        }\n      });\n    };\n\n    _this._capacity = capacity;\n    _this._epsilon = epsilon;\n    _this._isAnimationSheetEnabled = isAnimationSheetEnabled;\n\n    if (!sceneOrEngine || sceneOrEngine.getClassName() === \"Scene\") {\n      _this._scene = sceneOrEngine || EngineStore.LastCreatedScene;\n      _this._engine = _this._scene.getEngine();\n      _this.uniqueId = _this._scene.getUniqueId();\n\n      _this._scene.particleSystems.push(_this);\n    } else {\n      _this._engine = sceneOrEngine;\n      _this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, _this._engine.isNDCHalfZRange);\n    }\n\n    if (_this._engine.getCaps().vertexArrayObject) {\n      _this._vertexArrayObject = null;\n    } // Setup the default processing configuration to the scene.\n\n\n    _this._attachImageProcessingConfiguration(null); // eslint-disable-next-line @typescript-eslint/naming-convention\n\n\n    _this._customWrappers = {\n      0: new DrawWrapper(_this._engine)\n    };\n    _this._customWrappers[0].effect = customEffect;\n    _this._drawWrappers = [];\n    _this._useInstancing = _this._engine.getCaps().instancedArrays;\n\n    _this._createIndexBuffer();\n\n    _this._createVertexBuffers(); // Default emitter type\n\n\n    _this.particleEmitterType = new BoxParticleEmitter();\n    var noiseTextureData = null; // Update\n\n    _this.updateFunction = function (particles) {\n      var _a;\n\n      var noiseTextureSize = null;\n\n      if (_this.noiseTexture) {\n        // We need to get texture data back to CPU\n        noiseTextureSize = _this.noiseTexture.getSize();\n        (_a = _this.noiseTexture.getContent()) === null || _a === void 0 ? void 0 : _a.then(function (data) {\n          noiseTextureData = data;\n        });\n      }\n\n      var _loop_1 = function _loop_1(index) {\n        var particle = particles[index];\n        var scaledUpdateSpeed = _this._scaledUpdateSpeed;\n        var previousAge = particle.age;\n        particle.age += scaledUpdateSpeed; // Evaluate step to death\n\n        if (particle.age > particle.lifeTime) {\n          var diff = particle.age - previousAge;\n          var oldDiff = particle.lifeTime - previousAge;\n          scaledUpdateSpeed = oldDiff * scaledUpdateSpeed / diff;\n          particle.age = particle.lifeTime;\n        }\n\n        var ratio = particle.age / particle.lifeTime; // Color\n\n        if (_this._colorGradients && _this._colorGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, _this._colorGradients, function (currentGradient, nextGradient, scale) {\n            if (currentGradient !== particle._currentColorGradient) {\n              particle._currentColor1.copyFrom(particle._currentColor2);\n\n              nextGradient.getColorToRef(particle._currentColor2);\n              particle._currentColorGradient = currentGradient;\n            }\n\n            Color4.LerpToRef(particle._currentColor1, particle._currentColor2, scale, particle.color);\n          });\n        } else {\n          particle.colorStep.scaleToRef(scaledUpdateSpeed, _this._scaledColorStep);\n          particle.color.addInPlace(_this._scaledColorStep);\n\n          if (particle.color.a < 0) {\n            particle.color.a = 0;\n          }\n        } // Angular speed\n\n\n        if (_this._angularSpeedGradients && _this._angularSpeedGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, _this._angularSpeedGradients, function (currentGradient, nextGradient, scale) {\n            if (currentGradient !== particle._currentAngularSpeedGradient) {\n              particle._currentAngularSpeed1 = particle._currentAngularSpeed2;\n              particle._currentAngularSpeed2 = nextGradient.getFactor();\n              particle._currentAngularSpeedGradient = currentGradient;\n            }\n\n            particle.angularSpeed = Scalar.Lerp(particle._currentAngularSpeed1, particle._currentAngularSpeed2, scale);\n          });\n        }\n\n        particle.angle += particle.angularSpeed * scaledUpdateSpeed; // Direction\n\n        var directionScale = scaledUpdateSpeed; /// Velocity\n\n        if (_this._velocityGradients && _this._velocityGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, _this._velocityGradients, function (currentGradient, nextGradient, scale) {\n            if (currentGradient !== particle._currentVelocityGradient) {\n              particle._currentVelocity1 = particle._currentVelocity2;\n              particle._currentVelocity2 = nextGradient.getFactor();\n              particle._currentVelocityGradient = currentGradient;\n            }\n\n            directionScale *= Scalar.Lerp(particle._currentVelocity1, particle._currentVelocity2, scale);\n          });\n        }\n\n        particle.direction.scaleToRef(directionScale, _this._scaledDirection); /// Limit velocity\n\n        if (_this._limitVelocityGradients && _this._limitVelocityGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, _this._limitVelocityGradients, function (currentGradient, nextGradient, scale) {\n            if (currentGradient !== particle._currentLimitVelocityGradient) {\n              particle._currentLimitVelocity1 = particle._currentLimitVelocity2;\n              particle._currentLimitVelocity2 = nextGradient.getFactor();\n              particle._currentLimitVelocityGradient = currentGradient;\n            }\n\n            var limitVelocity = Scalar.Lerp(particle._currentLimitVelocity1, particle._currentLimitVelocity2, scale);\n            var currentVelocity = particle.direction.length();\n\n            if (currentVelocity > limitVelocity) {\n              particle.direction.scaleInPlace(_this.limitVelocityDamping);\n            }\n          });\n        } /// Drag\n\n\n        if (_this._dragGradients && _this._dragGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, _this._dragGradients, function (currentGradient, nextGradient, scale) {\n            if (currentGradient !== particle._currentDragGradient) {\n              particle._currentDrag1 = particle._currentDrag2;\n              particle._currentDrag2 = nextGradient.getFactor();\n              particle._currentDragGradient = currentGradient;\n            }\n\n            var drag = Scalar.Lerp(particle._currentDrag1, particle._currentDrag2, scale);\n\n            _this._scaledDirection.scaleInPlace(1.0 - drag);\n          });\n        }\n\n        if (_this.isLocal && particle._localPosition) {\n          particle._localPosition.addInPlace(_this._scaledDirection);\n\n          Vector3.TransformCoordinatesToRef(particle._localPosition, _this._emitterWorldMatrix, particle.position);\n        } else {\n          particle.position.addInPlace(_this._scaledDirection);\n        } // Noise\n\n\n        if (noiseTextureData && noiseTextureSize && particle._randomNoiseCoordinates1) {\n          var fetchedColorR = _this._fetchR(particle._randomNoiseCoordinates1.x, particle._randomNoiseCoordinates1.y, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n\n          var fetchedColorG = _this._fetchR(particle._randomNoiseCoordinates1.z, particle._randomNoiseCoordinates2.x, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n\n          var fetchedColorB = _this._fetchR(particle._randomNoiseCoordinates2.y, particle._randomNoiseCoordinates2.z, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n\n          var force = TmpVectors.Vector3[0];\n          var scaledForce = TmpVectors.Vector3[1];\n          force.copyFromFloats((2 * fetchedColorR - 1) * _this.noiseStrength.x, (2 * fetchedColorG - 1) * _this.noiseStrength.y, (2 * fetchedColorB - 1) * _this.noiseStrength.z);\n          force.scaleToRef(scaledUpdateSpeed, scaledForce);\n          particle.direction.addInPlace(scaledForce);\n        } // Gravity\n\n\n        _this.gravity.scaleToRef(scaledUpdateSpeed, _this._scaledGravity);\n\n        particle.direction.addInPlace(_this._scaledGravity); // Size\n\n        if (_this._sizeGradients && _this._sizeGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, _this._sizeGradients, function (currentGradient, nextGradient, scale) {\n            if (currentGradient !== particle._currentSizeGradient) {\n              particle._currentSize1 = particle._currentSize2;\n              particle._currentSize2 = nextGradient.getFactor();\n              particle._currentSizeGradient = currentGradient;\n            }\n\n            particle.size = Scalar.Lerp(particle._currentSize1, particle._currentSize2, scale);\n          });\n        } // Remap data\n\n\n        if (_this._useRampGradients) {\n          if (_this._colorRemapGradients && _this._colorRemapGradients.length > 0) {\n            GradientHelper.GetCurrentGradient(ratio, _this._colorRemapGradients, function (currentGradient, nextGradient, scale) {\n              var min = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);\n              var max = Scalar.Lerp(currentGradient.factor2, nextGradient.factor2, scale);\n              particle.remapData.x = min;\n              particle.remapData.y = max - min;\n            });\n          }\n\n          if (_this._alphaRemapGradients && _this._alphaRemapGradients.length > 0) {\n            GradientHelper.GetCurrentGradient(ratio, _this._alphaRemapGradients, function (currentGradient, nextGradient, scale) {\n              var min = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);\n              var max = Scalar.Lerp(currentGradient.factor2, nextGradient.factor2, scale);\n              particle.remapData.z = min;\n              particle.remapData.w = max - min;\n            });\n          }\n        }\n\n        if (_this._isAnimationSheetEnabled) {\n          particle.updateCellIndex();\n        } // Update the position of the attached sub-emitters to match their attached particle\n\n\n        particle._inheritParticleInfoToSubEmitters();\n\n        if (particle.age >= particle.lifeTime) {\n          // Recycle by swapping with last particle\n          _this._emitFromParticle(particle);\n\n          if (particle._attachedSubEmitters) {\n            particle._attachedSubEmitters.forEach(function (subEmitter) {\n              subEmitter.particleSystem.disposeOnStop = true;\n              subEmitter.particleSystem.stop();\n            });\n\n            particle._attachedSubEmitters = null;\n          }\n\n          _this.recycleParticle(particle);\n\n          index--;\n          return out_index_1 = index, \"continue\";\n        }\n\n        out_index_1 = index;\n      };\n\n      var out_index_1;\n\n      for (var index = 0; index < particles.length; index++) {\n        _loop_1(index);\n\n        index = out_index_1;\n      }\n    };\n\n    return _this;\n  }\n\n  Object.defineProperty(ParticleSystem.prototype, \"onDispose\", {\n    /**\n     * Sets a callback that will be triggered when the system is disposed\n     */\n    set: function set(callback) {\n      if (this._onDisposeObserver) {\n        this.onDisposeObservable.remove(this._onDisposeObserver);\n      }\n\n      this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleSystem.prototype, \"useRampGradients\", {\n    /** Gets or sets a boolean indicating that ramp gradients must be used\n     * @see https://doc.babylonjs.com/babylon101/particles#ramp-gradients\n     */\n    get: function get() {\n      return this._useRampGradients;\n    },\n    set: function set(value) {\n      if (this._useRampGradients === value) {\n        return;\n      }\n\n      this._useRampGradients = value;\n\n      this._resetEffect();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleSystem.prototype, \"particles\", {\n    //end of Sub-emitter\n\n    /**\n     * Gets the current list of active particles\n     */\n    get: function get() {\n      return this._particles;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets the number of particles active at the same time.\n   * @returns The number of active particles.\n   */\n\n  ParticleSystem.prototype.getActiveCount = function () {\n    return this._particles.length;\n  };\n  /**\n   * Returns the string \"ParticleSystem\"\n   * @returns a string containing the class name\n   */\n\n\n  ParticleSystem.prototype.getClassName = function () {\n    return \"ParticleSystem\";\n  };\n  /**\n   * Gets a boolean indicating that the system is stopping\n   * @returns true if the system is currently stopping\n   */\n\n\n  ParticleSystem.prototype.isStopping = function () {\n    return this._stopped && this.isAlive();\n  };\n  /**\n   * Gets the custom effect used to render the particles\n   * @param blendMode Blend mode for which the effect should be retrieved\n   * @returns The effect\n   */\n\n\n  ParticleSystem.prototype.getCustomEffect = function (blendMode) {\n    var _a, _b;\n\n    if (blendMode === void 0) {\n      blendMode = 0;\n    }\n\n    return (_b = (_a = this._customWrappers[blendMode]) === null || _a === void 0 ? void 0 : _a.effect) !== null && _b !== void 0 ? _b : this._customWrappers[0].effect;\n  };\n\n  ParticleSystem.prototype._getCustomDrawWrapper = function (blendMode) {\n    var _a;\n\n    if (blendMode === void 0) {\n      blendMode = 0;\n    }\n\n    return (_a = this._customWrappers[blendMode]) !== null && _a !== void 0 ? _a : this._customWrappers[0];\n  };\n  /**\n   * Sets the custom effect used to render the particles\n   * @param effect The effect to set\n   * @param blendMode Blend mode for which the effect should be set\n   */\n\n\n  ParticleSystem.prototype.setCustomEffect = function (effect, blendMode) {\n    if (blendMode === void 0) {\n      blendMode = 0;\n    }\n\n    this._customWrappers[blendMode] = new DrawWrapper(this._engine);\n    this._customWrappers[blendMode].effect = effect;\n\n    if (this._customWrappers[blendMode].drawContext) {\n      this._customWrappers[blendMode].drawContext.useInstancing = this._useInstancing;\n    }\n  };\n\n  Object.defineProperty(ParticleSystem.prototype, \"onBeforeDrawParticlesObservable\", {\n    /**\n     * Observable that will be called just before the particles are drawn\n     */\n    get: function get() {\n      if (!this._onBeforeDrawParticlesObservable) {\n        this._onBeforeDrawParticlesObservable = new Observable();\n      }\n\n      return this._onBeforeDrawParticlesObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleSystem.prototype, \"vertexShaderName\", {\n    /**\n     * Gets the name of the particle vertex shader\n     */\n    get: function get() {\n      return \"particles\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleSystem.prototype, \"vertexBuffers\", {\n    /**\n     * Gets the vertex buffers used by the particle system\n     */\n    get: function get() {\n      return this._vertexBuffers;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleSystem.prototype, \"indexBuffer\", {\n    /**\n     * Gets the index buffer used by the particle system (or null if no index buffer is used (if _useInstancing=true))\n     */\n    get: function get() {\n      return this._indexBuffer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ParticleSystem.prototype._addFactorGradient = function (factorGradients, gradient, factor, factor2) {\n    var newGradient = new FactorGradient(gradient, factor, factor2);\n    factorGradients.push(newGradient);\n    factorGradients.sort(function (a, b) {\n      if (a.gradient < b.gradient) {\n        return -1;\n      } else if (a.gradient > b.gradient) {\n        return 1;\n      }\n\n      return 0;\n    });\n  };\n\n  ParticleSystem.prototype._removeFactorGradient = function (factorGradients, gradient) {\n    if (!factorGradients) {\n      return;\n    }\n\n    var index = 0;\n\n    for (var _i = 0, factorGradients_1 = factorGradients; _i < factorGradients_1.length; _i++) {\n      var factorGradient = factorGradients_1[_i];\n\n      if (factorGradient.gradient === gradient) {\n        factorGradients.splice(index, 1);\n        break;\n      }\n\n      index++;\n    }\n  };\n  /**\n   * Adds a new life time gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the life time factor to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n\n\n  ParticleSystem.prototype.addLifeTimeGradient = function (gradient, factor, factor2) {\n    if (!this._lifeTimeGradients) {\n      this._lifeTimeGradients = [];\n    }\n\n    this._addFactorGradient(this._lifeTimeGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\n   * Remove a specific life time gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n\n\n  ParticleSystem.prototype.removeLifeTimeGradient = function (gradient) {\n    this._removeFactorGradient(this._lifeTimeGradients, gradient);\n\n    return this;\n  };\n  /**\n   * Adds a new size gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the size factor to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n\n\n  ParticleSystem.prototype.addSizeGradient = function (gradient, factor, factor2) {\n    if (!this._sizeGradients) {\n      this._sizeGradients = [];\n    }\n\n    this._addFactorGradient(this._sizeGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\n   * Remove a specific size gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n\n\n  ParticleSystem.prototype.removeSizeGradient = function (gradient) {\n    this._removeFactorGradient(this._sizeGradients, gradient);\n\n    return this;\n  };\n  /**\n   * Adds a new color remap gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param min defines the color remap minimal range\n   * @param max defines the color remap maximal range\n   * @returns the current particle system\n   */\n\n\n  ParticleSystem.prototype.addColorRemapGradient = function (gradient, min, max) {\n    if (!this._colorRemapGradients) {\n      this._colorRemapGradients = [];\n    }\n\n    this._addFactorGradient(this._colorRemapGradients, gradient, min, max);\n\n    return this;\n  };\n  /**\n   * Remove a specific color remap gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n\n\n  ParticleSystem.prototype.removeColorRemapGradient = function (gradient) {\n    this._removeFactorGradient(this._colorRemapGradients, gradient);\n\n    return this;\n  };\n  /**\n   * Adds a new alpha remap gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param min defines the alpha remap minimal range\n   * @param max defines the alpha remap maximal range\n   * @returns the current particle system\n   */\n\n\n  ParticleSystem.prototype.addAlphaRemapGradient = function (gradient, min, max) {\n    if (!this._alphaRemapGradients) {\n      this._alphaRemapGradients = [];\n    }\n\n    this._addFactorGradient(this._alphaRemapGradients, gradient, min, max);\n\n    return this;\n  };\n  /**\n   * Remove a specific alpha remap gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n\n\n  ParticleSystem.prototype.removeAlphaRemapGradient = function (gradient) {\n    this._removeFactorGradient(this._alphaRemapGradients, gradient);\n\n    return this;\n  };\n  /**\n   * Adds a new angular speed gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the angular speed  to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n\n\n  ParticleSystem.prototype.addAngularSpeedGradient = function (gradient, factor, factor2) {\n    if (!this._angularSpeedGradients) {\n      this._angularSpeedGradients = [];\n    }\n\n    this._addFactorGradient(this._angularSpeedGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\n   * Remove a specific angular speed gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n\n\n  ParticleSystem.prototype.removeAngularSpeedGradient = function (gradient) {\n    this._removeFactorGradient(this._angularSpeedGradients, gradient);\n\n    return this;\n  };\n  /**\n   * Adds a new velocity gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the velocity to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n\n\n  ParticleSystem.prototype.addVelocityGradient = function (gradient, factor, factor2) {\n    if (!this._velocityGradients) {\n      this._velocityGradients = [];\n    }\n\n    this._addFactorGradient(this._velocityGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\n   * Remove a specific velocity gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n\n\n  ParticleSystem.prototype.removeVelocityGradient = function (gradient) {\n    this._removeFactorGradient(this._velocityGradients, gradient);\n\n    return this;\n  };\n  /**\n   * Adds a new limit velocity gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the limit velocity value to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n\n\n  ParticleSystem.prototype.addLimitVelocityGradient = function (gradient, factor, factor2) {\n    if (!this._limitVelocityGradients) {\n      this._limitVelocityGradients = [];\n    }\n\n    this._addFactorGradient(this._limitVelocityGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\n   * Remove a specific limit velocity gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n\n\n  ParticleSystem.prototype.removeLimitVelocityGradient = function (gradient) {\n    this._removeFactorGradient(this._limitVelocityGradients, gradient);\n\n    return this;\n  };\n  /**\n   * Adds a new drag gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the drag value to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n\n\n  ParticleSystem.prototype.addDragGradient = function (gradient, factor, factor2) {\n    if (!this._dragGradients) {\n      this._dragGradients = [];\n    }\n\n    this._addFactorGradient(this._dragGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\n   * Remove a specific drag gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n\n\n  ParticleSystem.prototype.removeDragGradient = function (gradient) {\n    this._removeFactorGradient(this._dragGradients, gradient);\n\n    return this;\n  };\n  /**\n   * Adds a new emit rate gradient (please note that this will only work if you set the targetStopDuration property)\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the emit rate value to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n\n\n  ParticleSystem.prototype.addEmitRateGradient = function (gradient, factor, factor2) {\n    if (!this._emitRateGradients) {\n      this._emitRateGradients = [];\n    }\n\n    this._addFactorGradient(this._emitRateGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\n   * Remove a specific emit rate gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n\n\n  ParticleSystem.prototype.removeEmitRateGradient = function (gradient) {\n    this._removeFactorGradient(this._emitRateGradients, gradient);\n\n    return this;\n  };\n  /**\n   * Adds a new start size gradient (please note that this will only work if you set the targetStopDuration property)\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the start size value to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n\n\n  ParticleSystem.prototype.addStartSizeGradient = function (gradient, factor, factor2) {\n    if (!this._startSizeGradients) {\n      this._startSizeGradients = [];\n    }\n\n    this._addFactorGradient(this._startSizeGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\n   * Remove a specific start size gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n\n\n  ParticleSystem.prototype.removeStartSizeGradient = function (gradient) {\n    this._removeFactorGradient(this._startSizeGradients, gradient);\n\n    return this;\n  };\n\n  ParticleSystem.prototype._createRampGradientTexture = function () {\n    if (!this._rampGradients || !this._rampGradients.length || this._rampGradientsTexture || !this._scene) {\n      return;\n    }\n\n    var data = new Uint8Array(this._rawTextureWidth * 4);\n    var tmpColor = TmpColors.Color3[0];\n\n    var _loop_2 = function _loop_2(x) {\n      var ratio = x / this_1._rawTextureWidth;\n      GradientHelper.GetCurrentGradient(ratio, this_1._rampGradients, function (currentGradient, nextGradient, scale) {\n        Color3.LerpToRef(currentGradient.color, nextGradient.color, scale, tmpColor);\n        data[x * 4] = tmpColor.r * 255;\n        data[x * 4 + 1] = tmpColor.g * 255;\n        data[x * 4 + 2] = tmpColor.b * 255;\n        data[x * 4 + 3] = 255;\n      });\n    };\n\n    var this_1 = this;\n\n    for (var x = 0; x < this._rawTextureWidth; x++) {\n      _loop_2(x);\n    }\n\n    this._rampGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);\n  };\n  /**\n   * Gets the current list of ramp gradients.\n   * You must use addRampGradient and removeRampGradient to update this list\n   * @returns the list of ramp gradients\n   */\n\n\n  ParticleSystem.prototype.getRampGradients = function () {\n    return this._rampGradients;\n  };\n  /** Force the system to rebuild all gradients that need to be resync */\n\n\n  ParticleSystem.prototype.forceRefreshGradients = function () {\n    this._syncRampGradientTexture();\n  };\n\n  ParticleSystem.prototype._syncRampGradientTexture = function () {\n    if (!this._rampGradients) {\n      return;\n    }\n\n    this._rampGradients.sort(function (a, b) {\n      if (a.gradient < b.gradient) {\n        return -1;\n      } else if (a.gradient > b.gradient) {\n        return 1;\n      }\n\n      return 0;\n    });\n\n    if (this._rampGradientsTexture) {\n      this._rampGradientsTexture.dispose();\n\n      this._rampGradientsTexture = null;\n    }\n\n    this._createRampGradientTexture();\n  };\n  /**\n   * Adds a new ramp gradient used to remap particle colors\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param color defines the color to affect to the specified gradient\n   * @returns the current particle system\n   */\n\n\n  ParticleSystem.prototype.addRampGradient = function (gradient, color) {\n    if (!this._rampGradients) {\n      this._rampGradients = [];\n    }\n\n    var rampGradient = new Color3Gradient(gradient, color);\n\n    this._rampGradients.push(rampGradient);\n\n    this._syncRampGradientTexture();\n\n    return this;\n  };\n  /**\n   * Remove a specific ramp gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n\n\n  ParticleSystem.prototype.removeRampGradient = function (gradient) {\n    this._removeGradientAndTexture(gradient, this._rampGradients, this._rampGradientsTexture);\n\n    this._rampGradientsTexture = null;\n\n    if (this._rampGradients && this._rampGradients.length > 0) {\n      this._createRampGradientTexture();\n    }\n\n    return this;\n  };\n  /**\n   * Adds a new color gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param color1 defines the color to affect to the specified gradient\n   * @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from\n   * @returns this particle system\n   */\n\n\n  ParticleSystem.prototype.addColorGradient = function (gradient, color1, color2) {\n    if (!this._colorGradients) {\n      this._colorGradients = [];\n    }\n\n    var colorGradient = new ColorGradient(gradient, color1, color2);\n\n    this._colorGradients.push(colorGradient);\n\n    this._colorGradients.sort(function (a, b) {\n      if (a.gradient < b.gradient) {\n        return -1;\n      } else if (a.gradient > b.gradient) {\n        return 1;\n      }\n\n      return 0;\n    });\n\n    return this;\n  };\n  /**\n   * Remove a specific color gradient\n   * @param gradient defines the gradient to remove\n   * @returns this particle system\n   */\n\n\n  ParticleSystem.prototype.removeColorGradient = function (gradient) {\n    if (!this._colorGradients) {\n      return this;\n    }\n\n    var index = 0;\n\n    for (var _i = 0, _a = this._colorGradients; _i < _a.length; _i++) {\n      var colorGradient = _a[_i];\n\n      if (colorGradient.gradient === gradient) {\n        this._colorGradients.splice(index, 1);\n\n        break;\n      }\n\n      index++;\n    }\n\n    return this;\n  };\n  /**\n   * Resets the draw wrappers cache\n   */\n\n\n  ParticleSystem.prototype.resetDrawCache = function () {\n    for (var _i = 0, _a = this._drawWrappers; _i < _a.length; _i++) {\n      var drawWrappers = _a[_i];\n\n      if (drawWrappers) {\n        for (var _b = 0, drawWrappers_1 = drawWrappers; _b < drawWrappers_1.length; _b++) {\n          var drawWrapper = drawWrappers_1[_b];\n          drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.dispose();\n        }\n      }\n    }\n\n    this._drawWrappers = [];\n  };\n\n  ParticleSystem.prototype._fetchR = function (u, v, width, height, pixels) {\n    u = Math.abs(u) * 0.5 + 0.5;\n    v = Math.abs(v) * 0.5 + 0.5;\n    var wrappedU = u * width % width | 0;\n    var wrappedV = v * height % height | 0;\n    var position = (wrappedU + wrappedV * width) * 4;\n    return pixels[position] / 255;\n  };\n\n  ParticleSystem.prototype._reset = function () {\n    this._resetEffect();\n  };\n\n  ParticleSystem.prototype._resetEffect = function () {\n    if (this._vertexBuffer) {\n      this._vertexBuffer.dispose();\n\n      this._vertexBuffer = null;\n    }\n\n    if (this._spriteBuffer) {\n      this._spriteBuffer.dispose();\n\n      this._spriteBuffer = null;\n    }\n\n    if (this._vertexArrayObject) {\n      this._engine.releaseVertexArrayObject(this._vertexArrayObject);\n\n      this._vertexArrayObject = null;\n    }\n\n    this._createVertexBuffers();\n  };\n\n  ParticleSystem.prototype._createVertexBuffers = function () {\n    this._vertexBufferSize = this._useInstancing ? 10 : 12;\n\n    if (this._isAnimationSheetEnabled) {\n      this._vertexBufferSize += 1;\n    }\n\n    if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\n      this._vertexBufferSize += 3;\n    }\n\n    if (this._useRampGradients) {\n      this._vertexBufferSize += 4;\n    }\n\n    var engine = this._engine;\n    var vertexSize = this._vertexBufferSize * (this._useInstancing ? 1 : 4);\n    this._vertexData = new Float32Array(this._capacity * vertexSize);\n    this._vertexBuffer = new Buffer(engine, this._vertexData, true, vertexSize);\n    var dataOffset = 0;\n\n    var positions = this._vertexBuffer.createVertexBuffer(VertexBuffer.PositionKind, dataOffset, 3, this._vertexBufferSize, this._useInstancing);\n\n    this._vertexBuffers[VertexBuffer.PositionKind] = positions;\n    dataOffset += 3;\n\n    var colors = this._vertexBuffer.createVertexBuffer(VertexBuffer.ColorKind, dataOffset, 4, this._vertexBufferSize, this._useInstancing);\n\n    this._vertexBuffers[VertexBuffer.ColorKind] = colors;\n    dataOffset += 4;\n\n    var options = this._vertexBuffer.createVertexBuffer(\"angle\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\n\n    this._vertexBuffers[\"angle\"] = options;\n    dataOffset += 1;\n\n    var size = this._vertexBuffer.createVertexBuffer(\"size\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\n\n    this._vertexBuffers[\"size\"] = size;\n    dataOffset += 2;\n\n    if (this._isAnimationSheetEnabled) {\n      var cellIndexBuffer = this._vertexBuffer.createVertexBuffer(\"cellIndex\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\n\n      this._vertexBuffers[\"cellIndex\"] = cellIndexBuffer;\n      dataOffset += 1;\n    }\n\n    if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\n      var directionBuffer = this._vertexBuffer.createVertexBuffer(\"direction\", dataOffset, 3, this._vertexBufferSize, this._useInstancing);\n\n      this._vertexBuffers[\"direction\"] = directionBuffer;\n      dataOffset += 3;\n    }\n\n    if (this._useRampGradients) {\n      var rampDataBuffer = this._vertexBuffer.createVertexBuffer(\"remapData\", dataOffset, 4, this._vertexBufferSize, this._useInstancing);\n\n      this._vertexBuffers[\"remapData\"] = rampDataBuffer;\n      dataOffset += 4;\n    }\n\n    var offsets;\n\n    if (this._useInstancing) {\n      var spriteData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\n      this._spriteBuffer = new Buffer(engine, spriteData, false, 2);\n      offsets = this._spriteBuffer.createVertexBuffer(\"offset\", 0, 2);\n    } else {\n      offsets = this._vertexBuffer.createVertexBuffer(\"offset\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\n      dataOffset += 2;\n    }\n\n    this._vertexBuffers[\"offset\"] = offsets;\n    this.resetDrawCache();\n  };\n\n  ParticleSystem.prototype._createIndexBuffer = function () {\n    if (this._useInstancing) {\n      return;\n    }\n\n    var indices = [];\n    var index = 0;\n\n    for (var count = 0; count < this._capacity; count++) {\n      indices.push(index);\n      indices.push(index + 1);\n      indices.push(index + 2);\n      indices.push(index);\n      indices.push(index + 2);\n      indices.push(index + 3);\n      index += 4;\n    }\n\n    this._indexBuffer = this._engine.createIndexBuffer(indices);\n  };\n  /**\n   * Gets the maximum number of particles active at the same time.\n   * @returns The max number of active particles.\n   */\n\n\n  ParticleSystem.prototype.getCapacity = function () {\n    return this._capacity;\n  };\n  /**\n   * Gets whether there are still active particles in the system.\n   * @returns True if it is alive, otherwise false.\n   */\n\n\n  ParticleSystem.prototype.isAlive = function () {\n    return this._alive;\n  };\n  /**\n   * Gets if the system has been started. (Note: this will still be true after stop is called)\n   * @returns True if it has been started, otherwise false.\n   */\n\n\n  ParticleSystem.prototype.isStarted = function () {\n    return this._started;\n  };\n\n  ParticleSystem.prototype._prepareSubEmitterInternalArray = function () {\n    var _this = this;\n\n    this._subEmitters = new Array();\n\n    if (this.subEmitters) {\n      this.subEmitters.forEach(function (subEmitter) {\n        if (subEmitter instanceof ParticleSystem) {\n          _this._subEmitters.push([new SubEmitter(subEmitter)]);\n        } else if (subEmitter instanceof SubEmitter) {\n          _this._subEmitters.push([subEmitter]);\n        } else if (subEmitter instanceof Array) {\n          _this._subEmitters.push(subEmitter);\n        }\n      });\n    }\n  };\n  /**\n   * Starts the particle system and begins to emit\n   * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)\n   */\n\n\n  ParticleSystem.prototype.start = function (delay) {\n    var _this = this;\n\n    var _a;\n\n    if (delay === void 0) {\n      delay = this.startDelay;\n    }\n\n    if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {\n      throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\n    }\n\n    if (delay) {\n      setTimeout(function () {\n        _this.start(0);\n      }, delay);\n      return;\n    } // Convert the subEmitters field to the constant type field _subEmitters\n\n\n    this._prepareSubEmitterInternalArray();\n\n    this._started = true;\n    this._stopped = false;\n    this._actualFrame = 0;\n\n    if (this._subEmitters && this._subEmitters.length != 0) {\n      this.activeSubSystems = new Array();\n    } // Reset emit gradient so it acts the same on every start\n\n\n    if (this._emitRateGradients) {\n      if (this._emitRateGradients.length > 0) {\n        this._currentEmitRateGradient = this._emitRateGradients[0];\n        this._currentEmitRate1 = this._currentEmitRateGradient.getFactor();\n        this._currentEmitRate2 = this._currentEmitRate1;\n      }\n\n      if (this._emitRateGradients.length > 1) {\n        this._currentEmitRate2 = this._emitRateGradients[1].getFactor();\n      }\n    } // Reset start size gradient so it acts the same on every start\n\n\n    if (this._startSizeGradients) {\n      if (this._startSizeGradients.length > 0) {\n        this._currentStartSizeGradient = this._startSizeGradients[0];\n        this._currentStartSize1 = this._currentStartSizeGradient.getFactor();\n        this._currentStartSize2 = this._currentStartSize1;\n      }\n\n      if (this._startSizeGradients.length > 1) {\n        this._currentStartSize2 = this._startSizeGradients[1].getFactor();\n      }\n    }\n\n    if (this.preWarmCycles) {\n      if (((_a = this.emitter) === null || _a === void 0 ? void 0 : _a.getClassName().indexOf(\"Mesh\")) !== -1) {\n        this.emitter.computeWorldMatrix(true);\n      }\n\n      var noiseTextureAsProcedural_1 = this.noiseTexture;\n\n      if (noiseTextureAsProcedural_1 && noiseTextureAsProcedural_1.onGeneratedObservable) {\n        noiseTextureAsProcedural_1.onGeneratedObservable.addOnce(function () {\n          setTimeout(function () {\n            for (var index = 0; index < _this.preWarmCycles; index++) {\n              _this.animate(true);\n\n              noiseTextureAsProcedural_1.render();\n            }\n          });\n        });\n      } else {\n        for (var index = 0; index < this.preWarmCycles; index++) {\n          this.animate(true);\n        }\n      }\n    } // Animations\n\n\n    if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {\n      this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\n    }\n  };\n  /**\n   * Stops the particle system.\n   * @param stopSubEmitters if true it will stop the current system and all created sub-Systems if false it will stop the current root system only, this param is used by the root particle system only. the default value is true.\n   */\n\n\n  ParticleSystem.prototype.stop = function (stopSubEmitters) {\n    if (stopSubEmitters === void 0) {\n      stopSubEmitters = true;\n    }\n\n    if (this._stopped) {\n      return;\n    }\n\n    this.onStoppedObservable.notifyObservers(this);\n    this._stopped = true;\n\n    if (stopSubEmitters) {\n      this._stopSubEmitters();\n    }\n  }; // animation sheet\n\n  /**\n   * Remove all active particles\n   */\n\n\n  ParticleSystem.prototype.reset = function () {\n    this._stockParticles = [];\n    this._particles = [];\n  };\n  /**\n   * @param index\n   * @param particle\n   * @param offsetX\n   * @param offsetY\n   * @hidden (for internal use only)\n   */\n\n\n  ParticleSystem.prototype._appendParticleVertex = function (index, particle, offsetX, offsetY) {\n    var offset = index * this._vertexBufferSize;\n    this._vertexData[offset++] = particle.position.x + this.worldOffset.x;\n    this._vertexData[offset++] = particle.position.y + this.worldOffset.y;\n    this._vertexData[offset++] = particle.position.z + this.worldOffset.z;\n    this._vertexData[offset++] = particle.color.r;\n    this._vertexData[offset++] = particle.color.g;\n    this._vertexData[offset++] = particle.color.b;\n    this._vertexData[offset++] = particle.color.a;\n    this._vertexData[offset++] = particle.angle;\n    this._vertexData[offset++] = particle.scale.x * particle.size;\n    this._vertexData[offset++] = particle.scale.y * particle.size;\n\n    if (this._isAnimationSheetEnabled) {\n      this._vertexData[offset++] = particle.cellIndex;\n    }\n\n    if (!this._isBillboardBased) {\n      if (particle._initialDirection) {\n        var initialDirection = particle._initialDirection;\n\n        if (this.isLocal) {\n          Vector3.TransformNormalToRef(initialDirection, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\n          initialDirection = TmpVectors.Vector3[0];\n        }\n\n        if (initialDirection.x === 0 && initialDirection.z === 0) {\n          initialDirection.x = 0.001;\n        }\n\n        this._vertexData[offset++] = initialDirection.x;\n        this._vertexData[offset++] = initialDirection.y;\n        this._vertexData[offset++] = initialDirection.z;\n      } else {\n        var direction = particle.direction;\n\n        if (this.isLocal) {\n          Vector3.TransformNormalToRef(direction, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\n          direction = TmpVectors.Vector3[0];\n        }\n\n        if (direction.x === 0 && direction.z === 0) {\n          direction.x = 0.001;\n        }\n\n        this._vertexData[offset++] = direction.x;\n        this._vertexData[offset++] = direction.y;\n        this._vertexData[offset++] = direction.z;\n      }\n    } else if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\n      this._vertexData[offset++] = particle.direction.x;\n      this._vertexData[offset++] = particle.direction.y;\n      this._vertexData[offset++] = particle.direction.z;\n    }\n\n    if (this._useRampGradients && particle.remapData) {\n      this._vertexData[offset++] = particle.remapData.x;\n      this._vertexData[offset++] = particle.remapData.y;\n      this._vertexData[offset++] = particle.remapData.z;\n      this._vertexData[offset++] = particle.remapData.w;\n    }\n\n    if (!this._useInstancing) {\n      if (this._isAnimationSheetEnabled) {\n        if (offsetX === 0) {\n          offsetX = this._epsilon;\n        } else if (offsetX === 1) {\n          offsetX = 1 - this._epsilon;\n        }\n\n        if (offsetY === 0) {\n          offsetY = this._epsilon;\n        } else if (offsetY === 1) {\n          offsetY = 1 - this._epsilon;\n        }\n      }\n\n      this._vertexData[offset++] = offsetX;\n      this._vertexData[offset++] = offsetY;\n    }\n  };\n\n  ParticleSystem.prototype._stopSubEmitters = function () {\n    if (!this.activeSubSystems) {\n      return;\n    }\n\n    this.activeSubSystems.forEach(function (subSystem) {\n      subSystem.stop(true);\n    });\n    this.activeSubSystems = new Array();\n  };\n\n  ParticleSystem.prototype._removeFromRoot = function () {\n    if (!this._rootParticleSystem) {\n      return;\n    }\n\n    var index = this._rootParticleSystem.activeSubSystems.indexOf(this);\n\n    if (index !== -1) {\n      this._rootParticleSystem.activeSubSystems.splice(index, 1);\n    }\n\n    this._rootParticleSystem = null;\n  }; // End of sub system methods\n\n\n  ParticleSystem.prototype._update = function (newParticles) {\n    var _this = this; // Update current\n\n\n    this._alive = this._particles.length > 0;\n\n    if (this.emitter.position) {\n      var emitterMesh = this.emitter;\n      this._emitterWorldMatrix = emitterMesh.getWorldMatrix();\n    } else {\n      var emitterPosition = this.emitter;\n      this._emitterWorldMatrix = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);\n    }\n\n    this._emitterWorldMatrix.invertToRef(this._emitterInverseWorldMatrix);\n\n    this.updateFunction(this._particles); // Add new ones\n\n    var particle;\n\n    var _loop_3 = function _loop_3(index) {\n      if (this_2._particles.length === this_2._capacity) {\n        return \"break\";\n      }\n\n      particle = this_2._createParticle();\n\n      this_2._particles.push(particle); // Life time\n\n\n      if (this_2.targetStopDuration && this_2._lifeTimeGradients && this_2._lifeTimeGradients.length > 0) {\n        var ratio_1 = Scalar.Clamp(this_2._actualFrame / this_2.targetStopDuration);\n        GradientHelper.GetCurrentGradient(ratio_1, this_2._lifeTimeGradients, function (currentGradient, nextGradient) {\n          var factorGradient1 = currentGradient;\n          var factorGradient2 = nextGradient;\n          var lifeTime1 = factorGradient1.getFactor();\n          var lifeTime2 = factorGradient2.getFactor();\n          var gradient = (ratio_1 - factorGradient1.gradient) / (factorGradient2.gradient - factorGradient1.gradient);\n          particle.lifeTime = Scalar.Lerp(lifeTime1, lifeTime2, gradient);\n        });\n      } else {\n        particle.lifeTime = Scalar.RandomRange(this_2.minLifeTime, this_2.maxLifeTime);\n      } // Emitter\n\n\n      var emitPower = Scalar.RandomRange(this_2.minEmitPower, this_2.maxEmitPower);\n\n      if (this_2.startPositionFunction) {\n        this_2.startPositionFunction(this_2._emitterWorldMatrix, particle.position, particle, this_2.isLocal);\n      } else {\n        this_2.particleEmitterType.startPositionFunction(this_2._emitterWorldMatrix, particle.position, particle, this_2.isLocal);\n      }\n\n      if (this_2.isLocal) {\n        if (!particle._localPosition) {\n          particle._localPosition = particle.position.clone();\n        } else {\n          particle._localPosition.copyFrom(particle.position);\n        }\n\n        Vector3.TransformCoordinatesToRef(particle._localPosition, this_2._emitterWorldMatrix, particle.position);\n      }\n\n      if (this_2.startDirectionFunction) {\n        this_2.startDirectionFunction(this_2._emitterWorldMatrix, particle.direction, particle, this_2.isLocal);\n      } else {\n        this_2.particleEmitterType.startDirectionFunction(this_2._emitterWorldMatrix, particle.direction, particle, this_2.isLocal, this_2._emitterInverseWorldMatrix);\n      }\n\n      if (emitPower === 0) {\n        if (!particle._initialDirection) {\n          particle._initialDirection = particle.direction.clone();\n        } else {\n          particle._initialDirection.copyFrom(particle.direction);\n        }\n      } else {\n        particle._initialDirection = null;\n      }\n\n      particle.direction.scaleInPlace(emitPower); // Size\n\n      if (!this_2._sizeGradients || this_2._sizeGradients.length === 0) {\n        particle.size = Scalar.RandomRange(this_2.minSize, this_2.maxSize);\n      } else {\n        particle._currentSizeGradient = this_2._sizeGradients[0];\n        particle._currentSize1 = particle._currentSizeGradient.getFactor();\n        particle.size = particle._currentSize1;\n\n        if (this_2._sizeGradients.length > 1) {\n          particle._currentSize2 = this_2._sizeGradients[1].getFactor();\n        } else {\n          particle._currentSize2 = particle._currentSize1;\n        }\n      } // Size and scale\n\n\n      particle.scale.copyFromFloats(Scalar.RandomRange(this_2.minScaleX, this_2.maxScaleX), Scalar.RandomRange(this_2.minScaleY, this_2.maxScaleY)); // Adjust scale by start size\n\n      if (this_2._startSizeGradients && this_2._startSizeGradients[0] && this_2.targetStopDuration) {\n        var ratio = this_2._actualFrame / this_2.targetStopDuration;\n        GradientHelper.GetCurrentGradient(ratio, this_2._startSizeGradients, function (currentGradient, nextGradient, scale) {\n          if (currentGradient !== _this._currentStartSizeGradient) {\n            _this._currentStartSize1 = _this._currentStartSize2;\n            _this._currentStartSize2 = nextGradient.getFactor();\n            _this._currentStartSizeGradient = currentGradient;\n          }\n\n          var value = Scalar.Lerp(_this._currentStartSize1, _this._currentStartSize2, scale);\n          particle.scale.scaleInPlace(value);\n        });\n      } // Angle\n\n\n      if (!this_2._angularSpeedGradients || this_2._angularSpeedGradients.length === 0) {\n        particle.angularSpeed = Scalar.RandomRange(this_2.minAngularSpeed, this_2.maxAngularSpeed);\n      } else {\n        particle._currentAngularSpeedGradient = this_2._angularSpeedGradients[0];\n        particle.angularSpeed = particle._currentAngularSpeedGradient.getFactor();\n        particle._currentAngularSpeed1 = particle.angularSpeed;\n\n        if (this_2._angularSpeedGradients.length > 1) {\n          particle._currentAngularSpeed2 = this_2._angularSpeedGradients[1].getFactor();\n        } else {\n          particle._currentAngularSpeed2 = particle._currentAngularSpeed1;\n        }\n      }\n\n      particle.angle = Scalar.RandomRange(this_2.minInitialRotation, this_2.maxInitialRotation); // Velocity\n\n      if (this_2._velocityGradients && this_2._velocityGradients.length > 0) {\n        particle._currentVelocityGradient = this_2._velocityGradients[0];\n        particle._currentVelocity1 = particle._currentVelocityGradient.getFactor();\n\n        if (this_2._velocityGradients.length > 1) {\n          particle._currentVelocity2 = this_2._velocityGradients[1].getFactor();\n        } else {\n          particle._currentVelocity2 = particle._currentVelocity1;\n        }\n      } // Limit velocity\n\n\n      if (this_2._limitVelocityGradients && this_2._limitVelocityGradients.length > 0) {\n        particle._currentLimitVelocityGradient = this_2._limitVelocityGradients[0];\n        particle._currentLimitVelocity1 = particle._currentLimitVelocityGradient.getFactor();\n\n        if (this_2._limitVelocityGradients.length > 1) {\n          particle._currentLimitVelocity2 = this_2._limitVelocityGradients[1].getFactor();\n        } else {\n          particle._currentLimitVelocity2 = particle._currentLimitVelocity1;\n        }\n      } // Drag\n\n\n      if (this_2._dragGradients && this_2._dragGradients.length > 0) {\n        particle._currentDragGradient = this_2._dragGradients[0];\n        particle._currentDrag1 = particle._currentDragGradient.getFactor();\n\n        if (this_2._dragGradients.length > 1) {\n          particle._currentDrag2 = this_2._dragGradients[1].getFactor();\n        } else {\n          particle._currentDrag2 = particle._currentDrag1;\n        }\n      } // Color\n\n\n      if (!this_2._colorGradients || this_2._colorGradients.length === 0) {\n        var step = Scalar.RandomRange(0, 1.0);\n        Color4.LerpToRef(this_2.color1, this_2.color2, step, particle.color);\n        this_2.colorDead.subtractToRef(particle.color, this_2._colorDiff);\n\n        this_2._colorDiff.scaleToRef(1.0 / particle.lifeTime, particle.colorStep);\n      } else {\n        particle._currentColorGradient = this_2._colorGradients[0];\n\n        particle._currentColorGradient.getColorToRef(particle.color);\n\n        particle._currentColor1.copyFrom(particle.color);\n\n        if (this_2._colorGradients.length > 1) {\n          this_2._colorGradients[1].getColorToRef(particle._currentColor2);\n        } else {\n          particle._currentColor2.copyFrom(particle.color);\n        }\n      } // Sheet\n\n\n      if (this_2._isAnimationSheetEnabled) {\n        particle._initialStartSpriteCellID = this_2.startSpriteCellID;\n        particle._initialEndSpriteCellID = this_2.endSpriteCellID;\n        particle._initialSpriteCellLoop = this_2.spriteCellLoop;\n      } // Inherited Velocity\n\n\n      particle.direction.addInPlace(this_2._inheritedVelocityOffset); // Ramp\n\n      if (this_2._useRampGradients) {\n        particle.remapData = new Vector4(0, 1, 0, 1);\n      } // Noise texture coordinates\n\n\n      if (this_2.noiseTexture) {\n        if (particle._randomNoiseCoordinates1) {\n          particle._randomNoiseCoordinates1.copyFromFloats(Math.random(), Math.random(), Math.random());\n\n          particle._randomNoiseCoordinates2.copyFromFloats(Math.random(), Math.random(), Math.random());\n        } else {\n          particle._randomNoiseCoordinates1 = new Vector3(Math.random(), Math.random(), Math.random());\n          particle._randomNoiseCoordinates2 = new Vector3(Math.random(), Math.random(), Math.random());\n        }\n      } // Update the position of the attached sub-emitters to match their attached particle\n\n\n      particle._inheritParticleInfoToSubEmitters();\n    };\n\n    var this_2 = this;\n\n    for (var index = 0; index < newParticles; index++) {\n      var state_1 = _loop_3(index);\n\n      if (state_1 === \"break\") break;\n    }\n  };\n  /**\n   * @param isAnimationSheetEnabled\n   * @param isBillboardBased\n   * @param useRampGradients\n   * @hidden\n   */\n\n\n  ParticleSystem._GetAttributeNamesOrOptions = function (isAnimationSheetEnabled, isBillboardBased, useRampGradients) {\n    if (isAnimationSheetEnabled === void 0) {\n      isAnimationSheetEnabled = false;\n    }\n\n    if (isBillboardBased === void 0) {\n      isBillboardBased = false;\n    }\n\n    if (useRampGradients === void 0) {\n      useRampGradients = false;\n    }\n\n    var attributeNamesOrOptions = [VertexBuffer.PositionKind, VertexBuffer.ColorKind, \"angle\", \"offset\", \"size\"];\n\n    if (isAnimationSheetEnabled) {\n      attributeNamesOrOptions.push(\"cellIndex\");\n    }\n\n    if (!isBillboardBased) {\n      attributeNamesOrOptions.push(\"direction\");\n    }\n\n    if (useRampGradients) {\n      attributeNamesOrOptions.push(\"remapData\");\n    }\n\n    return attributeNamesOrOptions;\n  };\n  /**\n   * @param isAnimationSheetEnabled\n   * @hidden\n   */\n\n\n  ParticleSystem._GetEffectCreationOptions = function (isAnimationSheetEnabled) {\n    if (isAnimationSheetEnabled === void 0) {\n      isAnimationSheetEnabled = false;\n    }\n\n    var effectCreationOption = [\"invView\", \"view\", \"projection\", \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"textureMask\", \"translationPivot\", \"eyePosition\"];\n\n    if (isAnimationSheetEnabled) {\n      effectCreationOption.push(\"particlesInfos\");\n    }\n\n    return effectCreationOption;\n  };\n  /**\n   * Fill the defines array according to the current settings of the particle system\n   * @param defines Array to be updated\n   * @param blendMode blend mode to take into account when updating the array\n   */\n\n\n  ParticleSystem.prototype.fillDefines = function (defines, blendMode) {\n    if (this._scene) {\n      if (this._scene.clipPlane) {\n        defines.push(\"#define CLIPPLANE\");\n      }\n\n      if (this._scene.clipPlane2) {\n        defines.push(\"#define CLIPPLANE2\");\n      }\n\n      if (this._scene.clipPlane3) {\n        defines.push(\"#define CLIPPLANE3\");\n      }\n\n      if (this._scene.clipPlane4) {\n        defines.push(\"#define CLIPPLANE4\");\n      }\n\n      if (this._scene.clipPlane5) {\n        defines.push(\"#define CLIPPLANE5\");\n      }\n\n      if (this._scene.clipPlane6) {\n        defines.push(\"#define CLIPPLANE6\");\n      }\n    }\n\n    if (this._isAnimationSheetEnabled) {\n      defines.push(\"#define ANIMATESHEET\");\n    }\n\n    if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {\n      defines.push(\"#define BLENDMULTIPLYMODE\");\n    }\n\n    if (this._useRampGradients) {\n      defines.push(\"#define RAMPGRADIENT\");\n    }\n\n    if (this._isBillboardBased) {\n      defines.push(\"#define BILLBOARD\");\n\n      switch (this.billboardMode) {\n        case ParticleSystem.BILLBOARDMODE_Y:\n          defines.push(\"#define BILLBOARDY\");\n          break;\n\n        case ParticleSystem.BILLBOARDMODE_STRETCHED:\n          defines.push(\"#define BILLBOARDSTRETCHED\");\n          break;\n\n        case ParticleSystem.BILLBOARDMODE_ALL:\n          defines.push(\"#define BILLBOARDMODE_ALL\");\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    if (this._imageProcessingConfiguration) {\n      this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);\n\n      defines.push(this._imageProcessingConfigurationDefines.toString());\n    }\n  };\n  /**\n   * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\n   * @param uniforms Uniforms array to fill\n   * @param attributes Attributes array to fill\n   * @param samplers Samplers array to fill\n   */\n\n\n  ParticleSystem.prototype.fillUniformsAttributesAndSamplerNames = function (uniforms, attributes, samplers) {\n    attributes.push.apply(attributes, ParticleSystem._GetAttributeNamesOrOptions(this._isAnimationSheetEnabled, this._isBillboardBased && this.billboardMode !== ParticleSystem.BILLBOARDMODE_STRETCHED, this._useRampGradients));\n    uniforms.push.apply(uniforms, ParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled));\n    samplers.push(\"diffuseSampler\", \"rampSampler\");\n\n    if (this._imageProcessingConfiguration) {\n      ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);\n      ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);\n    }\n  };\n  /**\n   * @param blendMode\n   * @hidden\n   */\n\n\n  ParticleSystem.prototype._getWrapper = function (blendMode) {\n    var customWrapper = this._getCustomDrawWrapper(blendMode);\n\n    if (customWrapper === null || customWrapper === void 0 ? void 0 : customWrapper.effect) {\n      return customWrapper;\n    }\n\n    var defines = [];\n    this.fillDefines(defines, blendMode); // Effect\n\n    var currentRenderPassId = this._engine._features.supportRenderPasses ? this._engine.currentRenderPassId : 0;\n    var drawWrappers = this._drawWrappers[currentRenderPassId];\n\n    if (!drawWrappers) {\n      drawWrappers = this._drawWrappers[currentRenderPassId] = [];\n    }\n\n    var drawWrapper = drawWrappers[blendMode];\n\n    if (!drawWrapper) {\n      drawWrapper = new DrawWrapper(this._engine);\n\n      if (drawWrapper.drawContext) {\n        drawWrapper.drawContext.useInstancing = this._useInstancing;\n      }\n\n      drawWrappers[blendMode] = drawWrapper;\n    }\n\n    var join = defines.join(\"\\n\");\n\n    if (drawWrapper.defines !== join) {\n      var attributesNamesOrOptions = [];\n      var effectCreationOption = [];\n      var samplers = [];\n      this.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, samplers);\n      drawWrapper.setEffect(this._engine.createEffect(\"particles\", attributesNamesOrOptions, effectCreationOption, samplers, join), join);\n    }\n\n    return drawWrapper;\n  };\n  /**\n   * Animates the particle system for the current frame by emitting new particles and or animating the living ones.\n   * @param preWarmOnly will prevent the system from updating the vertex buffer (default is false)\n   */\n\n\n  ParticleSystem.prototype.animate = function (preWarmOnly) {\n    var _this = this;\n\n    var _a;\n\n    if (preWarmOnly === void 0) {\n      preWarmOnly = false;\n    }\n\n    if (!this._started) {\n      return;\n    }\n\n    if (!preWarmOnly && this._scene) {\n      // Check\n      if (!this.isReady()) {\n        return;\n      }\n\n      if (this._currentRenderId === this._scene.getFrameId()) {\n        return;\n      }\n\n      this._currentRenderId = this._scene.getFrameId();\n    }\n\n    this._scaledUpdateSpeed = this.updateSpeed * (preWarmOnly ? this.preWarmStepOffset : ((_a = this._scene) === null || _a === void 0 ? void 0 : _a.getAnimationRatio()) || 1); // Determine the number of particles we need to create\n\n    var newParticles;\n\n    if (this.manualEmitCount > -1) {\n      newParticles = this.manualEmitCount;\n      this._newPartsExcess = 0;\n      this.manualEmitCount = 0;\n    } else {\n      var rate_1 = this.emitRate;\n\n      if (this._emitRateGradients && this._emitRateGradients.length > 0 && this.targetStopDuration) {\n        var ratio = this._actualFrame / this.targetStopDuration;\n        GradientHelper.GetCurrentGradient(ratio, this._emitRateGradients, function (currentGradient, nextGradient, scale) {\n          if (currentGradient !== _this._currentEmitRateGradient) {\n            _this._currentEmitRate1 = _this._currentEmitRate2;\n            _this._currentEmitRate2 = nextGradient.getFactor();\n            _this._currentEmitRateGradient = currentGradient;\n          }\n\n          rate_1 = Scalar.Lerp(_this._currentEmitRate1, _this._currentEmitRate2, scale);\n        });\n      }\n\n      newParticles = rate_1 * this._scaledUpdateSpeed >> 0;\n      this._newPartsExcess += rate_1 * this._scaledUpdateSpeed - newParticles;\n    }\n\n    if (this._newPartsExcess > 1.0) {\n      newParticles += this._newPartsExcess >> 0;\n      this._newPartsExcess -= this._newPartsExcess >> 0;\n    }\n\n    this._alive = false;\n\n    if (!this._stopped) {\n      this._actualFrame += this._scaledUpdateSpeed;\n\n      if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {\n        this.stop();\n      }\n    } else {\n      newParticles = 0;\n    }\n\n    this._update(newParticles); // Stopped?\n\n\n    if (this._stopped) {\n      if (!this._alive) {\n        this._started = false;\n\n        if (this.onAnimationEnd) {\n          this.onAnimationEnd();\n        }\n\n        if (this.disposeOnStop && this._scene) {\n          this._scene._toBeDisposed.push(this);\n        }\n      }\n    }\n\n    if (!preWarmOnly) {\n      // Update VBO\n      var offset = 0;\n\n      for (var index = 0; index < this._particles.length; index++) {\n        var particle = this._particles[index];\n\n        this._appendParticleVertices(offset, particle);\n\n        offset += this._useInstancing ? 1 : 4;\n      }\n\n      if (this._vertexBuffer) {\n        this._vertexBuffer.updateDirectly(this._vertexData, 0, this._particles.length);\n      }\n    }\n\n    if (this.manualEmitCount === 0 && this.disposeOnStop) {\n      this.stop();\n    }\n  };\n\n  ParticleSystem.prototype._appendParticleVertices = function (offset, particle) {\n    this._appendParticleVertex(offset++, particle, 0, 0);\n\n    if (!this._useInstancing) {\n      this._appendParticleVertex(offset++, particle, 1, 0);\n\n      this._appendParticleVertex(offset++, particle, 1, 1);\n\n      this._appendParticleVertex(offset++, particle, 0, 1);\n    }\n  };\n  /**\n   * Rebuilds the particle system.\n   */\n\n\n  ParticleSystem.prototype.rebuild = function () {\n    var _a, _b;\n\n    if (this._engine.getCaps().vertexArrayObject) {\n      this._vertexArrayObject = null;\n    }\n\n    this._createIndexBuffer();\n\n    (_a = this._spriteBuffer) === null || _a === void 0 ? void 0 : _a._rebuild();\n    (_b = this._vertexBuffer) === null || _b === void 0 ? void 0 : _b._rebuild();\n\n    for (var key in this._vertexBuffers) {\n      this._vertexBuffers[key]._rebuild();\n    }\n\n    this.resetDrawCache();\n  };\n  /**\n   * Is this system ready to be used/rendered\n   * @return true if the system is ready\n   */\n\n\n  ParticleSystem.prototype.isReady = function () {\n    if (!this.emitter || this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady() || !this.particleTexture || !this.particleTexture.isReady()) {\n      return false;\n    }\n\n    if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {\n      if (!this._getWrapper(this.blendMode).effect.isReady()) {\n        return false;\n      }\n    } else {\n      if (!this._getWrapper(ParticleSystem.BLENDMODE_MULTIPLY).effect.isReady()) {\n        return false;\n      }\n\n      if (!this._getWrapper(ParticleSystem.BLENDMODE_ADD).effect.isReady()) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  ParticleSystem.prototype._render = function (blendMode) {\n    var _a, _b;\n\n    var drawWrapper = this._getWrapper(blendMode);\n\n    var effect = drawWrapper.effect;\n    var engine = this._engine; // Render\n\n    engine.enableEffect(drawWrapper);\n    var viewMatrix = (_a = this.defaultViewMatrix) !== null && _a !== void 0 ? _a : this._scene.getViewMatrix();\n    effect.setTexture(\"diffuseSampler\", this.particleTexture);\n    effect.setMatrix(\"view\", viewMatrix);\n    effect.setMatrix(\"projection\", (_b = this.defaultProjectionMatrix) !== null && _b !== void 0 ? _b : this._scene.getProjectionMatrix());\n\n    if (this._isAnimationSheetEnabled && this.particleTexture) {\n      var baseSize = this.particleTexture.getBaseSize();\n      effect.setFloat3(\"particlesInfos\", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, this.spriteCellWidth / baseSize.width);\n    }\n\n    effect.setVector2(\"translationPivot\", this.translationPivot);\n    effect.setFloat4(\"textureMask\", this.textureMask.r, this.textureMask.g, this.textureMask.b, this.textureMask.a);\n\n    if (this._isBillboardBased && this._scene) {\n      var camera = this._scene.activeCamera;\n      effect.setVector3(\"eyePosition\", camera.globalPosition);\n    }\n\n    if (this._rampGradientsTexture) {\n      if (!this._rampGradients || !this._rampGradients.length) {\n        this._rampGradientsTexture.dispose();\n\n        this._rampGradientsTexture = null;\n      }\n\n      effect.setTexture(\"rampSampler\", this._rampGradientsTexture);\n    }\n\n    var defines = effect.defines;\n\n    if (this._scene) {\n      if (this._scene.clipPlane || this._scene.clipPlane2 || this._scene.clipPlane3 || this._scene.clipPlane4 || this._scene.clipPlane5 || this._scene.clipPlane6) {\n        ThinMaterialHelper.BindClipPlane(effect, this._scene);\n      }\n    }\n\n    if (defines.indexOf(\"#define BILLBOARDMODE_ALL\") >= 0) {\n      viewMatrix.invertToRef(TmpVectors.Matrix[0]);\n      effect.setMatrix(\"invView\", TmpVectors.Matrix[0]);\n    }\n\n    if (this._vertexArrayObject !== undefined) {\n      if (!this._vertexArrayObject) {\n        this._vertexArrayObject = this._engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);\n      }\n\n      this._engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);\n    } else {\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\n    } // image processing\n\n\n    if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\n      this._imageProcessingConfiguration.bind(effect);\n    } // Draw order\n\n\n    switch (blendMode) {\n      case ParticleSystem.BLENDMODE_ADD:\n        engine.setAlphaMode(1);\n        break;\n\n      case ParticleSystem.BLENDMODE_ONEONE:\n        engine.setAlphaMode(6);\n        break;\n\n      case ParticleSystem.BLENDMODE_STANDARD:\n        engine.setAlphaMode(2);\n        break;\n\n      case ParticleSystem.BLENDMODE_MULTIPLY:\n        engine.setAlphaMode(4);\n        break;\n    }\n\n    if (this._onBeforeDrawParticlesObservable) {\n      this._onBeforeDrawParticlesObservable.notifyObservers(effect);\n    }\n\n    if (this._useInstancing) {\n      engine.drawArraysType(7, 0, 4, this._particles.length);\n    } else {\n      engine.drawElementsType(0, 0, this._particles.length * 6);\n    }\n\n    return this._particles.length;\n  };\n  /**\n   * Renders the particle system in its current state.\n   * @returns the current number of particles\n   */\n\n\n  ParticleSystem.prototype.render = function () {\n    // Check\n    if (!this.isReady() || !this._particles.length) {\n      return 0;\n    }\n\n    var engine = this._engine;\n\n    if (engine.setState) {\n      engine.setState(false);\n\n      if (this.forceDepthWrite) {\n        engine.setDepthWrite(true);\n      }\n    }\n\n    var outparticles = 0;\n\n    if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {\n      outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY) + this._render(ParticleSystem.BLENDMODE_ADD);\n    } else {\n      outparticles = this._render(this.blendMode);\n    }\n\n    this._engine.unbindInstanceAttributes();\n\n    this._engine.setAlphaMode(0);\n\n    return outparticles;\n  };\n  /**\n   * Disposes the particle system and free the associated resources\n   * @param disposeTexture defines if the particle texture must be disposed as well (true by default)\n   */\n\n\n  ParticleSystem.prototype.dispose = function (disposeTexture) {\n    if (disposeTexture === void 0) {\n      disposeTexture = true;\n    }\n\n    this.resetDrawCache();\n\n    if (this._vertexBuffer) {\n      this._vertexBuffer.dispose();\n\n      this._vertexBuffer = null;\n    }\n\n    if (this._spriteBuffer) {\n      this._spriteBuffer.dispose();\n\n      this._spriteBuffer = null;\n    }\n\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n\n      this._indexBuffer = null;\n    }\n\n    if (this._vertexArrayObject) {\n      this._engine.releaseVertexArrayObject(this._vertexArrayObject);\n\n      this._vertexArrayObject = null;\n    }\n\n    if (disposeTexture && this.particleTexture) {\n      this.particleTexture.dispose();\n      this.particleTexture = null;\n    }\n\n    if (disposeTexture && this.noiseTexture) {\n      this.noiseTexture.dispose();\n      this.noiseTexture = null;\n    }\n\n    if (this._rampGradientsTexture) {\n      this._rampGradientsTexture.dispose();\n\n      this._rampGradientsTexture = null;\n    }\n\n    this._removeFromRoot();\n\n    if (this.subEmitters && !this._subEmitters) {\n      this._prepareSubEmitterInternalArray();\n    }\n\n    if (this._subEmitters && this._subEmitters.length) {\n      for (var index = 0; index < this._subEmitters.length; index++) {\n        for (var _i = 0, _a = this._subEmitters[index]; _i < _a.length; _i++) {\n          var subEmitter = _a[_i];\n          subEmitter.dispose();\n        }\n      }\n\n      this._subEmitters = [];\n      this.subEmitters = [];\n    }\n\n    if (this._disposeEmitterOnDispose && this.emitter && this.emitter.dispose) {\n      this.emitter.dispose(true);\n    }\n\n    if (this._onBeforeDrawParticlesObservable) {\n      this._onBeforeDrawParticlesObservable.clear();\n    } // Remove from scene\n\n\n    if (this._scene) {\n      var index = this._scene.particleSystems.indexOf(this);\n\n      if (index > -1) {\n        this._scene.particleSystems.splice(index, 1);\n      }\n\n      this._scene._activeParticleSystems.dispose();\n    } // Callback\n\n\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.onStoppedObservable.clear();\n    this.reset();\n  }; // Clone\n\n  /**\n   * Clones the particle system.\n   * @param name The name of the cloned object\n   * @param newEmitter The new emitter to use\n   * @returns the cloned particle system\n   */\n\n\n  ParticleSystem.prototype.clone = function (name, newEmitter) {\n    var custom = __assign({}, this._customWrappers);\n\n    var program = null;\n    var engine = this._engine;\n\n    if (engine.createEffectForParticles) {\n      if (this.customShader != null) {\n        program = this.customShader;\n        var defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n        var effect = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\n\n        if (!custom[0]) {\n          this.setCustomEffect(effect, 0);\n        } else {\n          custom[0].effect = effect;\n        }\n      }\n    }\n\n    var serialization = this.serialize();\n    var result = ParticleSystem.Parse(serialization, this._scene || this._engine, this._rootUrl);\n    result.name = name;\n    result.customShader = program;\n    result._customWrappers = custom;\n\n    if (newEmitter === undefined) {\n      newEmitter = this.emitter;\n    }\n\n    if (this.noiseTexture) {\n      result.noiseTexture = this.noiseTexture.clone();\n    }\n\n    result.emitter = newEmitter;\n\n    if (!this.preventAutoStart) {\n      result.start();\n    }\n\n    return result;\n  };\n  /**\n   * Serializes the particle system to a JSON object\n   * @param serializeTexture defines if the texture must be serialized as well\n   * @returns the JSON object\n   */\n\n\n  ParticleSystem.prototype.serialize = function (serializeTexture) {\n    if (serializeTexture === void 0) {\n      serializeTexture = false;\n    }\n\n    var serializationObject = {};\n\n    ParticleSystem._Serialize(serializationObject, this, serializeTexture);\n\n    serializationObject.textureMask = this.textureMask.asArray();\n    serializationObject.customShader = this.customShader;\n    serializationObject.preventAutoStart = this.preventAutoStart; // SubEmitters\n\n    if (this.subEmitters) {\n      serializationObject.subEmitters = [];\n\n      if (!this._subEmitters) {\n        this._prepareSubEmitterInternalArray();\n      }\n\n      for (var _i = 0, _a = this._subEmitters; _i < _a.length; _i++) {\n        var subs = _a[_i];\n        var cell = [];\n\n        for (var _b = 0, subs_1 = subs; _b < subs_1.length; _b++) {\n          var sub = subs_1[_b];\n          cell.push(sub.serialize(serializeTexture));\n        }\n\n        serializationObject.subEmitters.push(cell);\n      }\n    }\n\n    return serializationObject;\n  };\n  /**\n   * @param serializationObject\n   * @param particleSystem\n   * @param serializeTexture\n   * @hidden\n   */\n\n\n  ParticleSystem._Serialize = function (serializationObject, particleSystem, serializeTexture) {\n    serializationObject.name = particleSystem.name;\n    serializationObject.id = particleSystem.id;\n    serializationObject.capacity = particleSystem.getCapacity();\n    serializationObject.disposeOnStop = particleSystem.disposeOnStop;\n    serializationObject.manualEmitCount = particleSystem.manualEmitCount; // Emitter\n\n    if (particleSystem.emitter.position) {\n      var emitterMesh = particleSystem.emitter;\n      serializationObject.emitterId = emitterMesh.id;\n    } else {\n      var emitterPosition = particleSystem.emitter;\n      serializationObject.emitter = emitterPosition.asArray();\n    } // Emitter\n\n\n    if (particleSystem.particleEmitterType) {\n      serializationObject.particleEmitterType = particleSystem.particleEmitterType.serialize();\n    }\n\n    if (particleSystem.particleTexture) {\n      if (serializeTexture) {\n        serializationObject.texture = particleSystem.particleTexture.serialize();\n      } else {\n        serializationObject.textureName = particleSystem.particleTexture.name;\n        serializationObject.invertY = !!particleSystem.particleTexture._invertY;\n      }\n    }\n\n    serializationObject.isLocal = particleSystem.isLocal; // Animations\n\n    SerializationHelper.AppendSerializedAnimations(particleSystem, serializationObject);\n    serializationObject.beginAnimationOnStart = particleSystem.beginAnimationOnStart;\n    serializationObject.beginAnimationFrom = particleSystem.beginAnimationFrom;\n    serializationObject.beginAnimationTo = particleSystem.beginAnimationTo;\n    serializationObject.beginAnimationLoop = particleSystem.beginAnimationLoop; // Particle system\n\n    serializationObject.startDelay = particleSystem.startDelay;\n    serializationObject.renderingGroupId = particleSystem.renderingGroupId;\n    serializationObject.isBillboardBased = particleSystem.isBillboardBased;\n    serializationObject.billboardMode = particleSystem.billboardMode;\n    serializationObject.minAngularSpeed = particleSystem.minAngularSpeed;\n    serializationObject.maxAngularSpeed = particleSystem.maxAngularSpeed;\n    serializationObject.minSize = particleSystem.minSize;\n    serializationObject.maxSize = particleSystem.maxSize;\n    serializationObject.minScaleX = particleSystem.minScaleX;\n    serializationObject.maxScaleX = particleSystem.maxScaleX;\n    serializationObject.minScaleY = particleSystem.minScaleY;\n    serializationObject.maxScaleY = particleSystem.maxScaleY;\n    serializationObject.minEmitPower = particleSystem.minEmitPower;\n    serializationObject.maxEmitPower = particleSystem.maxEmitPower;\n    serializationObject.minLifeTime = particleSystem.minLifeTime;\n    serializationObject.maxLifeTime = particleSystem.maxLifeTime;\n    serializationObject.emitRate = particleSystem.emitRate;\n    serializationObject.gravity = particleSystem.gravity.asArray();\n    serializationObject.noiseStrength = particleSystem.noiseStrength.asArray();\n    serializationObject.color1 = particleSystem.color1.asArray();\n    serializationObject.color2 = particleSystem.color2.asArray();\n    serializationObject.colorDead = particleSystem.colorDead.asArray();\n    serializationObject.updateSpeed = particleSystem.updateSpeed;\n    serializationObject.targetStopDuration = particleSystem.targetStopDuration;\n    serializationObject.blendMode = particleSystem.blendMode;\n    serializationObject.preWarmCycles = particleSystem.preWarmCycles;\n    serializationObject.preWarmStepOffset = particleSystem.preWarmStepOffset;\n    serializationObject.minInitialRotation = particleSystem.minInitialRotation;\n    serializationObject.maxInitialRotation = particleSystem.maxInitialRotation;\n    serializationObject.startSpriteCellID = particleSystem.startSpriteCellID;\n    serializationObject.spriteCellLoop = particleSystem.spriteCellLoop;\n    serializationObject.endSpriteCellID = particleSystem.endSpriteCellID;\n    serializationObject.spriteCellChangeSpeed = particleSystem.spriteCellChangeSpeed;\n    serializationObject.spriteCellWidth = particleSystem.spriteCellWidth;\n    serializationObject.spriteCellHeight = particleSystem.spriteCellHeight;\n    serializationObject.spriteRandomStartCell = particleSystem.spriteRandomStartCell;\n    serializationObject.isAnimationSheetEnabled = particleSystem.isAnimationSheetEnabled;\n    var colorGradients = particleSystem.getColorGradients();\n\n    if (colorGradients) {\n      serializationObject.colorGradients = [];\n\n      for (var _i = 0, colorGradients_1 = colorGradients; _i < colorGradients_1.length; _i++) {\n        var colorGradient = colorGradients_1[_i];\n        var serializedGradient = {\n          gradient: colorGradient.gradient,\n          color1: colorGradient.color1.asArray()\n        };\n\n        if (colorGradient.color2) {\n          serializedGradient.color2 = colorGradient.color2.asArray();\n        } else {\n          serializedGradient.color2 = colorGradient.color1.asArray();\n        }\n\n        serializationObject.colorGradients.push(serializedGradient);\n      }\n    }\n\n    var rampGradients = particleSystem.getRampGradients();\n\n    if (rampGradients) {\n      serializationObject.rampGradients = [];\n\n      for (var _a = 0, rampGradients_1 = rampGradients; _a < rampGradients_1.length; _a++) {\n        var rampGradient = rampGradients_1[_a];\n        var serializedGradient = {\n          gradient: rampGradient.gradient,\n          color: rampGradient.color.asArray()\n        };\n        serializationObject.rampGradients.push(serializedGradient);\n      }\n\n      serializationObject.useRampGradients = particleSystem.useRampGradients;\n    }\n\n    var colorRemapGradients = particleSystem.getColorRemapGradients();\n\n    if (colorRemapGradients) {\n      serializationObject.colorRemapGradients = [];\n\n      for (var _b = 0, colorRemapGradients_1 = colorRemapGradients; _b < colorRemapGradients_1.length; _b++) {\n        var colorRemapGradient = colorRemapGradients_1[_b];\n        var serializedGradient = {\n          gradient: colorRemapGradient.gradient,\n          factor1: colorRemapGradient.factor1\n        };\n\n        if (colorRemapGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = colorRemapGradient.factor2;\n        } else {\n          serializedGradient.factor2 = colorRemapGradient.factor1;\n        }\n\n        serializationObject.colorRemapGradients.push(serializedGradient);\n      }\n    }\n\n    var alphaRemapGradients = particleSystem.getAlphaRemapGradients();\n\n    if (alphaRemapGradients) {\n      serializationObject.alphaRemapGradients = [];\n\n      for (var _c = 0, alphaRemapGradients_1 = alphaRemapGradients; _c < alphaRemapGradients_1.length; _c++) {\n        var alphaRemapGradient = alphaRemapGradients_1[_c];\n        var serializedGradient = {\n          gradient: alphaRemapGradient.gradient,\n          factor1: alphaRemapGradient.factor1\n        };\n\n        if (alphaRemapGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = alphaRemapGradient.factor2;\n        } else {\n          serializedGradient.factor2 = alphaRemapGradient.factor1;\n        }\n\n        serializationObject.alphaRemapGradients.push(serializedGradient);\n      }\n    }\n\n    var sizeGradients = particleSystem.getSizeGradients();\n\n    if (sizeGradients) {\n      serializationObject.sizeGradients = [];\n\n      for (var _d = 0, sizeGradients_1 = sizeGradients; _d < sizeGradients_1.length; _d++) {\n        var sizeGradient = sizeGradients_1[_d];\n        var serializedGradient = {\n          gradient: sizeGradient.gradient,\n          factor1: sizeGradient.factor1\n        };\n\n        if (sizeGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = sizeGradient.factor2;\n        } else {\n          serializedGradient.factor2 = sizeGradient.factor1;\n        }\n\n        serializationObject.sizeGradients.push(serializedGradient);\n      }\n    }\n\n    var angularSpeedGradients = particleSystem.getAngularSpeedGradients();\n\n    if (angularSpeedGradients) {\n      serializationObject.angularSpeedGradients = [];\n\n      for (var _e = 0, angularSpeedGradients_1 = angularSpeedGradients; _e < angularSpeedGradients_1.length; _e++) {\n        var angularSpeedGradient = angularSpeedGradients_1[_e];\n        var serializedGradient = {\n          gradient: angularSpeedGradient.gradient,\n          factor1: angularSpeedGradient.factor1\n        };\n\n        if (angularSpeedGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = angularSpeedGradient.factor2;\n        } else {\n          serializedGradient.factor2 = angularSpeedGradient.factor1;\n        }\n\n        serializationObject.angularSpeedGradients.push(serializedGradient);\n      }\n    }\n\n    var velocityGradients = particleSystem.getVelocityGradients();\n\n    if (velocityGradients) {\n      serializationObject.velocityGradients = [];\n\n      for (var _f = 0, velocityGradients_1 = velocityGradients; _f < velocityGradients_1.length; _f++) {\n        var velocityGradient = velocityGradients_1[_f];\n        var serializedGradient = {\n          gradient: velocityGradient.gradient,\n          factor1: velocityGradient.factor1\n        };\n\n        if (velocityGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = velocityGradient.factor2;\n        } else {\n          serializedGradient.factor2 = velocityGradient.factor1;\n        }\n\n        serializationObject.velocityGradients.push(serializedGradient);\n      }\n    }\n\n    var dragGradients = particleSystem.getDragGradients();\n\n    if (dragGradients) {\n      serializationObject.dragGradients = [];\n\n      for (var _g = 0, dragGradients_1 = dragGradients; _g < dragGradients_1.length; _g++) {\n        var dragGradient = dragGradients_1[_g];\n        var serializedGradient = {\n          gradient: dragGradient.gradient,\n          factor1: dragGradient.factor1\n        };\n\n        if (dragGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = dragGradient.factor2;\n        } else {\n          serializedGradient.factor2 = dragGradient.factor1;\n        }\n\n        serializationObject.dragGradients.push(serializedGradient);\n      }\n    }\n\n    var emitRateGradients = particleSystem.getEmitRateGradients();\n\n    if (emitRateGradients) {\n      serializationObject.emitRateGradients = [];\n\n      for (var _h = 0, emitRateGradients_1 = emitRateGradients; _h < emitRateGradients_1.length; _h++) {\n        var emitRateGradient = emitRateGradients_1[_h];\n        var serializedGradient = {\n          gradient: emitRateGradient.gradient,\n          factor1: emitRateGradient.factor1\n        };\n\n        if (emitRateGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = emitRateGradient.factor2;\n        } else {\n          serializedGradient.factor2 = emitRateGradient.factor1;\n        }\n\n        serializationObject.emitRateGradients.push(serializedGradient);\n      }\n    }\n\n    var startSizeGradients = particleSystem.getStartSizeGradients();\n\n    if (startSizeGradients) {\n      serializationObject.startSizeGradients = [];\n\n      for (var _j = 0, startSizeGradients_1 = startSizeGradients; _j < startSizeGradients_1.length; _j++) {\n        var startSizeGradient = startSizeGradients_1[_j];\n        var serializedGradient = {\n          gradient: startSizeGradient.gradient,\n          factor1: startSizeGradient.factor1\n        };\n\n        if (startSizeGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = startSizeGradient.factor2;\n        } else {\n          serializedGradient.factor2 = startSizeGradient.factor1;\n        }\n\n        serializationObject.startSizeGradients.push(serializedGradient);\n      }\n    }\n\n    var lifeTimeGradients = particleSystem.getLifeTimeGradients();\n\n    if (lifeTimeGradients) {\n      serializationObject.lifeTimeGradients = [];\n\n      for (var _k = 0, lifeTimeGradients_1 = lifeTimeGradients; _k < lifeTimeGradients_1.length; _k++) {\n        var lifeTimeGradient = lifeTimeGradients_1[_k];\n        var serializedGradient = {\n          gradient: lifeTimeGradient.gradient,\n          factor1: lifeTimeGradient.factor1\n        };\n\n        if (lifeTimeGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = lifeTimeGradient.factor2;\n        } else {\n          serializedGradient.factor2 = lifeTimeGradient.factor1;\n        }\n\n        serializationObject.lifeTimeGradients.push(serializedGradient);\n      }\n    }\n\n    var limitVelocityGradients = particleSystem.getLimitVelocityGradients();\n\n    if (limitVelocityGradients) {\n      serializationObject.limitVelocityGradients = [];\n\n      for (var _l = 0, limitVelocityGradients_1 = limitVelocityGradients; _l < limitVelocityGradients_1.length; _l++) {\n        var limitVelocityGradient = limitVelocityGradients_1[_l];\n        var serializedGradient = {\n          gradient: limitVelocityGradient.gradient,\n          factor1: limitVelocityGradient.factor1\n        };\n\n        if (limitVelocityGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = limitVelocityGradient.factor2;\n        } else {\n          serializedGradient.factor2 = limitVelocityGradient.factor1;\n        }\n\n        serializationObject.limitVelocityGradients.push(serializedGradient);\n      }\n\n      serializationObject.limitVelocityDamping = particleSystem.limitVelocityDamping;\n    }\n\n    if (particleSystem.noiseTexture) {\n      serializationObject.noiseTexture = particleSystem.noiseTexture.serialize();\n    }\n  };\n  /**\n   * @param parsedParticleSystem\n   * @param particleSystem\n   * @param sceneOrEngine\n   * @param rootUrl\n   * @hidden\n   */\n\n\n  ParticleSystem._Parse = function (parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl) {\n    var _a, _b, _c;\n\n    var scene;\n\n    if (sceneOrEngine instanceof ThinEngine) {\n      scene = null;\n    } else {\n      scene = sceneOrEngine;\n    }\n\n    var internalClass = GetClass(\"BABYLON.Texture\");\n\n    if (internalClass && scene) {\n      // Texture\n      if (parsedParticleSystem.texture) {\n        particleSystem.particleTexture = internalClass.Parse(parsedParticleSystem.texture, scene, rootUrl);\n      } else if (parsedParticleSystem.textureName) {\n        particleSystem.particleTexture = new internalClass(rootUrl + parsedParticleSystem.textureName, scene, false, parsedParticleSystem.invertY !== undefined ? parsedParticleSystem.invertY : true);\n        particleSystem.particleTexture.name = parsedParticleSystem.textureName;\n      }\n    } // Emitter\n\n\n    if (!parsedParticleSystem.emitterId && parsedParticleSystem.emitterId !== 0 && parsedParticleSystem.emitter === undefined) {\n      particleSystem.emitter = Vector3.Zero();\n    } else if (parsedParticleSystem.emitterId && scene) {\n      particleSystem.emitter = scene.getLastMeshById(parsedParticleSystem.emitterId);\n    } else {\n      particleSystem.emitter = Vector3.FromArray(parsedParticleSystem.emitter);\n    }\n\n    particleSystem.isLocal = !!parsedParticleSystem.isLocal; // Misc.\n\n    if (parsedParticleSystem.renderingGroupId !== undefined) {\n      particleSystem.renderingGroupId = parsedParticleSystem.renderingGroupId;\n    }\n\n    if (parsedParticleSystem.isBillboardBased !== undefined) {\n      particleSystem.isBillboardBased = parsedParticleSystem.isBillboardBased;\n    }\n\n    if (parsedParticleSystem.billboardMode !== undefined) {\n      particleSystem.billboardMode = parsedParticleSystem.billboardMode;\n    } // Animations\n\n\n    if (parsedParticleSystem.animations) {\n      for (var animationIndex = 0; animationIndex < parsedParticleSystem.animations.length; animationIndex++) {\n        var parsedAnimation = parsedParticleSystem.animations[animationIndex];\n        var internalClass_1 = GetClass(\"BABYLON.Animation\");\n\n        if (internalClass_1) {\n          particleSystem.animations.push(internalClass_1.Parse(parsedAnimation));\n        }\n      }\n\n      particleSystem.beginAnimationOnStart = parsedParticleSystem.beginAnimationOnStart;\n      particleSystem.beginAnimationFrom = parsedParticleSystem.beginAnimationFrom;\n      particleSystem.beginAnimationTo = parsedParticleSystem.beginAnimationTo;\n      particleSystem.beginAnimationLoop = parsedParticleSystem.beginAnimationLoop;\n    }\n\n    if (parsedParticleSystem.autoAnimate && scene) {\n      scene.beginAnimation(particleSystem, parsedParticleSystem.autoAnimateFrom, parsedParticleSystem.autoAnimateTo, parsedParticleSystem.autoAnimateLoop, parsedParticleSystem.autoAnimateSpeed || 1.0);\n    } // Particle system\n\n\n    particleSystem.startDelay = parsedParticleSystem.startDelay | 0;\n    particleSystem.minAngularSpeed = parsedParticleSystem.minAngularSpeed;\n    particleSystem.maxAngularSpeed = parsedParticleSystem.maxAngularSpeed;\n    particleSystem.minSize = parsedParticleSystem.minSize;\n    particleSystem.maxSize = parsedParticleSystem.maxSize;\n\n    if (parsedParticleSystem.minScaleX) {\n      particleSystem.minScaleX = parsedParticleSystem.minScaleX;\n      particleSystem.maxScaleX = parsedParticleSystem.maxScaleX;\n      particleSystem.minScaleY = parsedParticleSystem.minScaleY;\n      particleSystem.maxScaleY = parsedParticleSystem.maxScaleY;\n    }\n\n    if (parsedParticleSystem.preWarmCycles !== undefined) {\n      particleSystem.preWarmCycles = parsedParticleSystem.preWarmCycles;\n      particleSystem.preWarmStepOffset = parsedParticleSystem.preWarmStepOffset;\n    }\n\n    if (parsedParticleSystem.minInitialRotation !== undefined) {\n      particleSystem.minInitialRotation = parsedParticleSystem.minInitialRotation;\n      particleSystem.maxInitialRotation = parsedParticleSystem.maxInitialRotation;\n    }\n\n    particleSystem.minLifeTime = parsedParticleSystem.minLifeTime;\n    particleSystem.maxLifeTime = parsedParticleSystem.maxLifeTime;\n    particleSystem.minEmitPower = parsedParticleSystem.minEmitPower;\n    particleSystem.maxEmitPower = parsedParticleSystem.maxEmitPower;\n    particleSystem.emitRate = parsedParticleSystem.emitRate;\n    particleSystem.gravity = Vector3.FromArray(parsedParticleSystem.gravity);\n\n    if (parsedParticleSystem.noiseStrength) {\n      particleSystem.noiseStrength = Vector3.FromArray(parsedParticleSystem.noiseStrength);\n    }\n\n    particleSystem.color1 = Color4.FromArray(parsedParticleSystem.color1);\n    particleSystem.color2 = Color4.FromArray(parsedParticleSystem.color2);\n    particleSystem.colorDead = Color4.FromArray(parsedParticleSystem.colorDead);\n    particleSystem.updateSpeed = parsedParticleSystem.updateSpeed;\n    particleSystem.targetStopDuration = parsedParticleSystem.targetStopDuration;\n    particleSystem.blendMode = parsedParticleSystem.blendMode;\n\n    if (parsedParticleSystem.colorGradients) {\n      for (var _i = 0, _d = parsedParticleSystem.colorGradients; _i < _d.length; _i++) {\n        var colorGradient = _d[_i];\n        particleSystem.addColorGradient(colorGradient.gradient, Color4.FromArray(colorGradient.color1), colorGradient.color2 ? Color4.FromArray(colorGradient.color2) : undefined);\n      }\n    }\n\n    if (parsedParticleSystem.rampGradients) {\n      for (var _e = 0, _f = parsedParticleSystem.rampGradients; _e < _f.length; _e++) {\n        var rampGradient = _f[_e];\n        particleSystem.addRampGradient(rampGradient.gradient, Color3.FromArray(rampGradient.color));\n      }\n\n      particleSystem.useRampGradients = parsedParticleSystem.useRampGradients;\n    }\n\n    if (parsedParticleSystem.colorRemapGradients) {\n      for (var _g = 0, _h = parsedParticleSystem.colorRemapGradients; _g < _h.length; _g++) {\n        var colorRemapGradient = _h[_g];\n        particleSystem.addColorRemapGradient(colorRemapGradient.gradient, colorRemapGradient.factor1 !== undefined ? colorRemapGradient.factor1 : colorRemapGradient.factor, colorRemapGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.alphaRemapGradients) {\n      for (var _j = 0, _k = parsedParticleSystem.alphaRemapGradients; _j < _k.length; _j++) {\n        var alphaRemapGradient = _k[_j];\n        particleSystem.addAlphaRemapGradient(alphaRemapGradient.gradient, alphaRemapGradient.factor1 !== undefined ? alphaRemapGradient.factor1 : alphaRemapGradient.factor, alphaRemapGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.sizeGradients) {\n      for (var _l = 0, _m = parsedParticleSystem.sizeGradients; _l < _m.length; _l++) {\n        var sizeGradient = _m[_l];\n        particleSystem.addSizeGradient(sizeGradient.gradient, sizeGradient.factor1 !== undefined ? sizeGradient.factor1 : sizeGradient.factor, sizeGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.angularSpeedGradients) {\n      for (var _o = 0, _p = parsedParticleSystem.angularSpeedGradients; _o < _p.length; _o++) {\n        var angularSpeedGradient = _p[_o];\n        particleSystem.addAngularSpeedGradient(angularSpeedGradient.gradient, angularSpeedGradient.factor1 !== undefined ? angularSpeedGradient.factor1 : angularSpeedGradient.factor, angularSpeedGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.velocityGradients) {\n      for (var _q = 0, _r = parsedParticleSystem.velocityGradients; _q < _r.length; _q++) {\n        var velocityGradient = _r[_q];\n        particleSystem.addVelocityGradient(velocityGradient.gradient, velocityGradient.factor1 !== undefined ? velocityGradient.factor1 : velocityGradient.factor, velocityGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.dragGradients) {\n      for (var _s = 0, _t = parsedParticleSystem.dragGradients; _s < _t.length; _s++) {\n        var dragGradient = _t[_s];\n        particleSystem.addDragGradient(dragGradient.gradient, dragGradient.factor1 !== undefined ? dragGradient.factor1 : dragGradient.factor, dragGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.emitRateGradients) {\n      for (var _u = 0, _v = parsedParticleSystem.emitRateGradients; _u < _v.length; _u++) {\n        var emitRateGradient = _v[_u];\n        particleSystem.addEmitRateGradient(emitRateGradient.gradient, emitRateGradient.factor1 !== undefined ? emitRateGradient.factor1 : emitRateGradient.factor, emitRateGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.startSizeGradients) {\n      for (var _w = 0, _x = parsedParticleSystem.startSizeGradients; _w < _x.length; _w++) {\n        var startSizeGradient = _x[_w];\n        particleSystem.addStartSizeGradient(startSizeGradient.gradient, startSizeGradient.factor1 !== undefined ? startSizeGradient.factor1 : startSizeGradient.factor, startSizeGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.lifeTimeGradients) {\n      for (var _y = 0, _z = parsedParticleSystem.lifeTimeGradients; _y < _z.length; _y++) {\n        var lifeTimeGradient = _z[_y];\n        particleSystem.addLifeTimeGradient(lifeTimeGradient.gradient, lifeTimeGradient.factor1 !== undefined ? lifeTimeGradient.factor1 : lifeTimeGradient.factor, lifeTimeGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.limitVelocityGradients) {\n      for (var _0 = 0, _1 = parsedParticleSystem.limitVelocityGradients; _0 < _1.length; _0++) {\n        var limitVelocityGradient = _1[_0];\n        particleSystem.addLimitVelocityGradient(limitVelocityGradient.gradient, limitVelocityGradient.factor1 !== undefined ? limitVelocityGradient.factor1 : limitVelocityGradient.factor, limitVelocityGradient.factor2);\n      }\n\n      particleSystem.limitVelocityDamping = parsedParticleSystem.limitVelocityDamping;\n    }\n\n    if (parsedParticleSystem.noiseTexture && scene) {\n      var internalClass_2 = GetClass(\"BABYLON.ProceduralTexture\");\n      particleSystem.noiseTexture = internalClass_2.Parse(parsedParticleSystem.noiseTexture, scene, rootUrl);\n    } // Emitter\n\n\n    var emitterType;\n\n    if (parsedParticleSystem.particleEmitterType) {\n      switch (parsedParticleSystem.particleEmitterType.type) {\n        case \"SphereParticleEmitter\":\n          emitterType = new SphereParticleEmitter();\n          break;\n\n        case \"SphereDirectedParticleEmitter\":\n          emitterType = new SphereDirectedParticleEmitter();\n          break;\n\n        case \"ConeEmitter\":\n        case \"ConeParticleEmitter\":\n          emitterType = new ConeParticleEmitter();\n          break;\n\n        case \"CylinderParticleEmitter\":\n          emitterType = new CylinderParticleEmitter();\n          break;\n\n        case \"CylinderDirectedParticleEmitter\":\n          emitterType = new CylinderDirectedParticleEmitter();\n          break;\n\n        case \"HemisphericParticleEmitter\":\n          emitterType = new HemisphericParticleEmitter();\n          break;\n\n        case \"PointParticleEmitter\":\n          emitterType = new PointParticleEmitter();\n          break;\n\n        case \"MeshParticleEmitter\":\n          emitterType = new MeshParticleEmitter();\n          break;\n\n        case \"BoxEmitter\":\n        case \"BoxParticleEmitter\":\n        default:\n          emitterType = new BoxParticleEmitter();\n          break;\n      }\n\n      emitterType.parse(parsedParticleSystem.particleEmitterType, scene);\n    } else {\n      emitterType = new BoxParticleEmitter();\n      emitterType.parse(parsedParticleSystem, scene);\n    }\n\n    particleSystem.particleEmitterType = emitterType; // Animation sheet\n\n    particleSystem.startSpriteCellID = parsedParticleSystem.startSpriteCellID;\n    particleSystem.endSpriteCellID = parsedParticleSystem.endSpriteCellID;\n    particleSystem.spriteCellLoop = (_a = parsedParticleSystem.spriteCellLoop) !== null && _a !== void 0 ? _a : true;\n    particleSystem.spriteCellWidth = parsedParticleSystem.spriteCellWidth;\n    particleSystem.spriteCellHeight = parsedParticleSystem.spriteCellHeight;\n    particleSystem.spriteCellChangeSpeed = parsedParticleSystem.spriteCellChangeSpeed;\n    particleSystem.spriteRandomStartCell = parsedParticleSystem.spriteRandomStartCell;\n    particleSystem.disposeOnStop = (_b = parsedParticleSystem.disposeOnStop) !== null && _b !== void 0 ? _b : false;\n    particleSystem.manualEmitCount = (_c = parsedParticleSystem.manualEmitCount) !== null && _c !== void 0 ? _c : -1;\n  };\n  /**\n   * Parses a JSON object to create a particle system.\n   * @param parsedParticleSystem The JSON object to parse\n   * @param sceneOrEngine The scene or the engine to create the particle system in\n   * @param rootUrl The root url to use to load external dependencies like texture\n   * @param doNotStart Ignore the preventAutoStart attribute and does not start\n   * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n   * @returns the Parsed particle system\n   */\n\n\n  ParticleSystem.Parse = function (parsedParticleSystem, sceneOrEngine, rootUrl, doNotStart, capacity) {\n    if (doNotStart === void 0) {\n      doNotStart = false;\n    }\n\n    var name = parsedParticleSystem.name;\n    var custom = null;\n    var program = null;\n    var engine;\n    var scene;\n\n    if (sceneOrEngine instanceof ThinEngine) {\n      engine = sceneOrEngine;\n    } else {\n      scene = sceneOrEngine;\n      engine = scene.getEngine();\n    }\n\n    if (parsedParticleSystem.customShader && engine.createEffectForParticles) {\n      program = parsedParticleSystem.customShader;\n      var defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n      custom = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\n    }\n\n    var particleSystem = new ParticleSystem(name, capacity || parsedParticleSystem.capacity, sceneOrEngine, custom, parsedParticleSystem.isAnimationSheetEnabled);\n    particleSystem.customShader = program;\n    particleSystem._rootUrl = rootUrl;\n\n    if (parsedParticleSystem.id) {\n      particleSystem.id = parsedParticleSystem.id;\n    } // SubEmitters\n\n\n    if (parsedParticleSystem.subEmitters) {\n      particleSystem.subEmitters = [];\n\n      for (var _i = 0, _a = parsedParticleSystem.subEmitters; _i < _a.length; _i++) {\n        var cell = _a[_i];\n        var cellArray = [];\n\n        for (var _b = 0, cell_1 = cell; _b < cell_1.length; _b++) {\n          var sub = cell_1[_b];\n          cellArray.push(SubEmitter.Parse(sub, sceneOrEngine, rootUrl));\n        }\n\n        particleSystem.subEmitters.push(cellArray);\n      }\n    }\n\n    ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);\n\n    if (parsedParticleSystem.textureMask) {\n      particleSystem.textureMask = Color4.FromArray(parsedParticleSystem.textureMask);\n    } // Auto start\n\n\n    if (parsedParticleSystem.preventAutoStart) {\n      particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\n    }\n\n    if (!doNotStart && !particleSystem.preventAutoStart) {\n      particleSystem.start();\n    }\n\n    return particleSystem;\n  };\n  /**\n   * Billboard mode will only apply to Y axis\n   */\n\n\n  ParticleSystem.BILLBOARDMODE_Y = 2;\n  /**\n   * Billboard mode will apply to all axes\n   */\n\n  ParticleSystem.BILLBOARDMODE_ALL = 7;\n  /**\n   * Special billboard mode where the particle will be biilboard to the camera but rotated to align with direction\n   */\n\n  ParticleSystem.BILLBOARDMODE_STRETCHED = 8;\n  return ParticleSystem;\n}(BaseParticleSystem);\n\nexport { ParticleSystem };\nSubEmitter._ParseParticleSystem = ParticleSystem.Parse;","map":{"version":3,"mappings":"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","names":["FactorGradient","ColorGradient","Color3Gradient","GradientHelper","Observable","Vector3","Matrix","TmpVectors","Vector4","Scalar","VertexBuffer","Buffer","ImageProcessingConfiguration","RawTexture","EngineStore","BoxParticleEmitter","HemisphericParticleEmitter","SphereParticleEmitter","SphereDirectedParticleEmitter","CylinderParticleEmitter","ConeParticleEmitter","PointParticleEmitter","MeshParticleEmitter","CylinderDirectedParticleEmitter","BaseParticleSystem","Particle","SubEmitter","SubEmitterType","SerializationHelper","GetClass","DrawWrapper","Color4","Color3","TmpColors","ThinEngine","ThinMaterialHelper","__extends","name","capacity","sceneOrEngine","customEffect","isAnimationSheetEnabled","epsilon","_super","_this","Identity","Array","Zero","particle","lastParticle","_particles","pop","copyTo","_stockParticles","push","length","_reset","_subEmitters","subEmitters","Math","floor","random","_attachedSubEmitters","forEach","subEmitter","type","ATTACHED","newEmitter","clone","particleSystem","start","templateIndex","END","subSystem","_inheritParticleInfoToSubEmitter","_rootParticleSystem","activeSubSystems","_capacity","_epsilon","_isAnimationSheetEnabled","getClassName","_scene","LastCreatedScene","_engine","getEngine","uniqueId","getUniqueId","particleSystems","defaultProjectionMatrix","PerspectiveFovLH","isNDCHalfZRange","getCaps","vertexArrayObject","_vertexArrayObject","_attachImageProcessingConfiguration","_customWrappers","effect","_drawWrappers","_useInstancing","instancedArrays","_createIndexBuffer","_createVertexBuffers","particleEmitterType","noiseTextureData","updateFunction","particles","noiseTextureSize","noiseTexture","getSize","getContent","_a","then","data","index","scaledUpdateSpeed","_scaledUpdateSpeed","previousAge","age","lifeTime","diff","oldDiff","ratio","_colorGradients","GetCurrentGradient","currentGradient","nextGradient","scale","_currentColorGradient","_currentColor1","copyFrom","_currentColor2","getColorToRef","LerpToRef","color","colorStep","scaleToRef","_scaledColorStep","addInPlace","a","_angularSpeedGradients","_currentAngularSpeedGradient","_currentAngularSpeed1","_currentAngularSpeed2","getFactor","angularSpeed","Lerp","angle","directionScale","_velocityGradients","_currentVelocityGradient","_currentVelocity1","_currentVelocity2","direction","_scaledDirection","_limitVelocityGradients","_currentLimitVelocityGradient","_currentLimitVelocity1","_currentLimitVelocity2","limitVelocity","currentVelocity","scaleInPlace","limitVelocityDamping","_dragGradients","_currentDragGradient","_currentDrag1","_currentDrag2","drag","isLocal","_localPosition","TransformCoordinatesToRef","_emitterWorldMatrix","position","_randomNoiseCoordinates1","fetchedColorR","_fetchR","x","y","width","height","fetchedColorG","z","_randomNoiseCoordinates2","fetchedColorB","force","scaledForce","copyFromFloats","noiseStrength","gravity","_scaledGravity","_sizeGradients","_currentSizeGradient","_currentSize1","_currentSize2","size","_useRampGradients","_colorRemapGradients","min","factor1","max","factor2","remapData","_alphaRemapGradients","w","updateCellIndex","_inheritParticleInfoToSubEmitters","_emitFromParticle","disposeOnStop","stop","recycleParticle","Object","ParticleSystem","callback","_onDisposeObserver","onDisposeObservable","remove","add","value","_resetEffect","_stopped","isAlive","blendMode","_b","drawContext","useInstancing","_onBeforeDrawParticlesObservable","_vertexBuffers","_indexBuffer","factorGradients","gradient","factor","newGradient","sort","b","_i","factorGradient","splice","_lifeTimeGradients","_addFactorGradient","_removeFactorGradient","_emitRateGradients","_startSizeGradients","_rampGradients","_rampGradientsTexture","Uint8Array","_rawTextureWidth","tmpColor","this_1","r","g","CreateRGBATexture","_syncRampGradientTexture","dispose","_createRampGradientTexture","rampGradient","_removeGradientAndTexture","color1","color2","colorGradient","drawWrappers","drawWrapper","u","v","pixels","abs","wrappedU","wrappedV","_vertexBuffer","_spriteBuffer","releaseVertexArrayObject","_vertexBufferSize","_isBillboardBased","billboardMode","BILLBOARDMODE_STRETCHED","engine","vertexSize","_vertexData","Float32Array","dataOffset","positions","createVertexBuffer","PositionKind","colors","ColorKind","options","cellIndexBuffer","directionBuffer","rampDataBuffer","offsets","spriteData","resetDrawCache","indices","count","createIndexBuffer","_alive","_started","delay","startDelay","targetStopDuration","_hasTargetStopDurationDependantGradient","setTimeout","_prepareSubEmitterInternalArray","_actualFrame","_currentEmitRateGradient","_currentEmitRate1","_currentEmitRate2","_currentStartSizeGradient","_currentStartSize1","_currentStartSize2","preWarmCycles","emitter","indexOf","computeWorldMatrix","noiseTextureAsProcedural_1","onGeneratedObservable","addOnce","animate","render","beginAnimationOnStart","animations","beginAnimation","beginAnimationFrom","beginAnimationTo","beginAnimationLoop","stopSubEmitters","onStoppedObservable","notifyObservers","_stopSubEmitters","offsetX","offsetY","offset","worldOffset","cellIndex","_initialDirection","initialDirection","TransformNormalToRef","newParticles","emitterMesh","getWorldMatrix","emitterPosition","Translation","invertToRef","_emitterInverseWorldMatrix","this_2","_createParticle","ratio_1","Clamp","factorGradient1","factorGradient2","lifeTime1","lifeTime2","RandomRange","minLifeTime","maxLifeTime","emitPower","minEmitPower","maxEmitPower","startPositionFunction","startDirectionFunction","minSize","maxSize","minScaleX","maxScaleX","minScaleY","maxScaleY","minAngularSpeed","maxAngularSpeed","minInitialRotation","maxInitialRotation","step","colorDead","subtractToRef","_colorDiff","_initialStartSpriteCellID","startSpriteCellID","_initialEndSpriteCellID","endSpriteCellID","_initialSpriteCellLoop","spriteCellLoop","_inheritedVelocityOffset","isBillboardBased","useRampGradients","attributeNamesOrOptions","effectCreationOption","defines","clipPlane","clipPlane2","clipPlane3","clipPlane4","clipPlane5","clipPlane6","BLENDMODE_MULTIPLY","BILLBOARDMODE_Y","BILLBOARDMODE_ALL","_imageProcessingConfiguration","prepareDefines","_imageProcessingConfigurationDefines","toString","uniforms","attributes","samplers","apply","_GetAttributeNamesOrOptions","_GetEffectCreationOptions","PrepareUniforms","PrepareSamplers","customWrapper","_getCustomDrawWrapper","fillDefines","currentRenderPassId","_features","supportRenderPasses","join","attributesNamesOrOptions","fillUniformsAttributesAndSamplerNames","setEffect","createEffect","preWarmOnly","isReady","_currentRenderId","getFrameId","updateSpeed","preWarmStepOffset","getAnimationRatio","manualEmitCount","_newPartsExcess","rate_1","emitRate","_update","onAnimationEnd","_toBeDisposed","_appendParticleVertices","updateDirectly","_appendParticleVertex","_rebuild","key","particleTexture","BLENDMODE_MULTIPLYADD","_getWrapper","BLENDMODE_ADD","enableEffect","viewMatrix","defaultViewMatrix","getViewMatrix","setTexture","setMatrix","getProjectionMatrix","baseSize","getBaseSize","setFloat3","spriteCellWidth","spriteCellHeight","setVector2","translationPivot","setFloat4","textureMask","camera","activeCamera","setVector3","globalPosition","BindClipPlane","undefined","recordVertexArrayObject","bindVertexArrayObject","bindBuffers","applyByPostProcess","bind","setAlphaMode","BLENDMODE_ONEONE","BLENDMODE_STANDARD","drawArraysType","drawElementsType","setState","forceDepthWrite","setDepthWrite","outparticles","_render","unbindInstanceAttributes","disposeTexture","_releaseBuffer","_removeFromRoot","_disposeEmitterOnDispose","clear","_activeParticleSystems","reset","custom","program","createEffectForParticles","customShader","shaderOptions","shaderPath","fragmentElement","setCustomEffect","serialization","serialize","result","Parse","_rootUrl","preventAutoStart","serializeTexture","serializationObject","_Serialize","asArray","subs","cell","sub","id","getCapacity","emitterId","texture","textureName","invertY","_invertY","AppendSerializedAnimations","renderingGroupId","spriteCellChangeSpeed","spriteRandomStartCell","colorGradients","getColorGradients","serializedGradient","rampGradients","getRampGradients","colorRemapGradients","getColorRemapGradients","colorRemapGradient","alphaRemapGradients","getAlphaRemapGradients","_c","alphaRemapGradient","sizeGradients","getSizeGradients","_d","sizeGradient","angularSpeedGradients","getAngularSpeedGradients","_e","angularSpeedGradient","velocityGradients","getVelocityGradients","_f","velocityGradient","dragGradients","getDragGradients","_g","dragGradient","emitRateGradients","getEmitRateGradients","_h","emitRateGradient","startSizeGradients","getStartSizeGradients","_j","startSizeGradient","lifeTimeGradients","getLifeTimeGradients","_k","lifeTimeGradient","limitVelocityGradients","getLimitVelocityGradients","_l","limitVelocityGradient","parsedParticleSystem","rootUrl","scene","internalClass","getLastMeshById","FromArray","animationIndex","parsedAnimation","internalClass_1","autoAnimate","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","addColorGradient","addRampGradient","addColorRemapGradient","addAlphaRemapGradient","addSizeGradient","_o","addAngularSpeedGradient","_q","addVelocityGradient","_s","addDragGradient","_u","addEmitRateGradient","_w","addStartSizeGradient","_y","addLifeTimeGradient","_0","addLimitVelocityGradient","internalClass_2","emitterType","parse","doNotStart","cellArray","_Parse","_ParseParticleSystem"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Particles/particleSystem.ts"],"sourcesContent":["/* eslint-disable import/no-internal-modules */\r\nimport type { Immutable, Nullable } from \"../types\";\r\nimport { FactorGradient, ColorGradient, Color3Gradient, GradientHelper } from \"../Misc/gradients\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3, Matrix, TmpVectors, Vector4 } from \"../Maths/math.vector\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer\";\r\n\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport type { IParticleEmitterType } from \"../Particles/EmitterTypes/index\";\r\nimport {\r\n    BoxParticleEmitter,\r\n    HemisphericParticleEmitter,\r\n    SphereParticleEmitter,\r\n    SphereDirectedParticleEmitter,\r\n    CylinderParticleEmitter,\r\n    ConeParticleEmitter,\r\n    PointParticleEmitter,\r\n    MeshParticleEmitter,\r\n    CylinderDirectedParticleEmitter,\r\n} from \"../Particles/EmitterTypes/index\";\r\nimport type { IParticleSystem } from \"./IParticleSystem\";\r\nimport { BaseParticleSystem } from \"./baseParticleSystem\";\r\nimport { Particle } from \"./particle\";\r\nimport { SubEmitter, SubEmitterType } from \"./subEmitter\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { SerializationHelper } from \"../Misc/decorators\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\n\r\nimport \"../Shaders/particles.fragment\";\r\nimport \"../Shaders/particles.vertex\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { Color4, Color3, TmpColors } from \"../Maths/math.color\";\r\nimport type { ISize } from \"../Maths/math.size\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { ThinMaterialHelper } from \"../Materials/thinMaterialHelper\";\r\n\r\nimport \"../Engines/Extensions/engine.alpha\";\r\n\r\ndeclare type AbstractMesh = import(\"../Meshes/abstractMesh\").AbstractMesh;\r\ndeclare type ProceduralTexture = import(\"../Materials/Textures/Procedurals/proceduralTexture\").ProceduralTexture;\r\ndeclare type Scene = import(\"../scene\").Scene;\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\n\r\n/**\r\n * This represents a particle system in Babylon.\r\n * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.\r\n * @example https://doc.babylonjs.com/babylon101/particles\r\n */\r\nexport class ParticleSystem extends BaseParticleSystem implements IDisposable, IAnimatable, IParticleSystem {\r\n    /**\r\n     * Billboard mode will only apply to Y axis\r\n     */\r\n    public static readonly BILLBOARDMODE_Y = Constants.PARTICLES_BILLBOARDMODE_Y;\r\n    /**\r\n     * Billboard mode will apply to all axes\r\n     */\r\n    public static readonly BILLBOARDMODE_ALL = Constants.PARTICLES_BILLBOARDMODE_ALL;\r\n    /**\r\n     * Special billboard mode where the particle will be biilboard to the camera but rotated to align with direction\r\n     */\r\n    public static readonly BILLBOARDMODE_STRETCHED = Constants.PARTICLES_BILLBOARDMODE_STRETCHED;\r\n\r\n    /**\r\n     * This function can be defined to provide custom update for active particles.\r\n     * This function will be called instead of regular update (age, position, color, etc.).\r\n     * Do not forget that this function will be called on every frame so try to keep it simple and fast :)\r\n     */\r\n    public updateFunction: (particles: Particle[]) => void;\r\n\r\n    private _emitterWorldMatrix: Matrix;\r\n    private _emitterInverseWorldMatrix: Matrix = Matrix.Identity();\r\n\r\n    /**\r\n     * This function can be defined to specify initial direction for every new particle.\r\n     * It by default use the emitterType defined function\r\n     */\r\n    public startDirectionFunction: (worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean) => void;\r\n    /**\r\n     * This function can be defined to specify initial position for every new particle.\r\n     * It by default use the emitterType defined function\r\n     */\r\n    public startPositionFunction: (worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean) => void;\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _inheritedVelocityOffset = new Vector3();\r\n    /**\r\n     * An event triggered when the system is disposed\r\n     */\r\n    public onDisposeObservable = new Observable<IParticleSystem>();\r\n    /**\r\n     * An event triggered when the system is stopped\r\n     */\r\n    public onStoppedObservable = new Observable<IParticleSystem>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<IParticleSystem>>;\r\n    /**\r\n     * Sets a callback that will be triggered when the system is disposed\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    private _particles = new Array<Particle>();\r\n    private _epsilon: number;\r\n    private _capacity: number;\r\n    private _stockParticles = new Array<Particle>();\r\n    private _newPartsExcess = 0;\r\n    private _vertexData: Float32Array;\r\n    private _vertexBuffer: Nullable<Buffer>;\r\n    private _vertexBuffers: { [key: string]: VertexBuffer } = {};\r\n    private _spriteBuffer: Nullable<Buffer>;\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _drawWrappers: DrawWrapper[][]; // first index is render pass id, second index is blend mode\r\n    private _customWrappers: { [blendMode: number]: Nullable<DrawWrapper> };\r\n    private _scaledColorStep = new Color4(0, 0, 0, 0);\r\n    private _colorDiff = new Color4(0, 0, 0, 0);\r\n    private _scaledDirection = Vector3.Zero();\r\n    private _scaledGravity = Vector3.Zero();\r\n    private _currentRenderId = -1;\r\n    private _alive: boolean;\r\n    private _useInstancing = false;\r\n    private _vertexArrayObject: Nullable<WebGLVertexArrayObject>;\r\n\r\n    private _started = false;\r\n    private _stopped = false;\r\n    private _actualFrame = 0;\r\n    private _scaledUpdateSpeed: number;\r\n    private _vertexBufferSize: number;\r\n\r\n    /** @hidden */\r\n    public _currentEmitRateGradient: Nullable<FactorGradient>;\r\n    /** @hidden */\r\n    public _currentEmitRate1 = 0;\r\n    /** @hidden */\r\n    public _currentEmitRate2 = 0;\r\n\r\n    /** @hidden */\r\n    public _currentStartSizeGradient: Nullable<FactorGradient>;\r\n    /** @hidden */\r\n    public _currentStartSize1 = 0;\r\n    /** @hidden */\r\n    public _currentStartSize2 = 0;\r\n\r\n    private readonly _rawTextureWidth = 256;\r\n    private _rampGradientsTexture: Nullable<RawTexture>;\r\n    private _useRampGradients = false;\r\n\r\n    /** Gets or sets a matrix to use to compute projection */\r\n    public defaultProjectionMatrix: Matrix;\r\n\r\n    /** Gets or sets a matrix to use to compute view */\r\n    public defaultViewMatrix: Matrix;\r\n\r\n    /** Gets or sets a boolean indicating that ramp gradients must be used\r\n     * @see https://doc.babylonjs.com/babylon101/particles#ramp-gradients\r\n     */\r\n    public get useRampGradients(): boolean {\r\n        return this._useRampGradients;\r\n    }\r\n\r\n    public set useRampGradients(value: boolean) {\r\n        if (this._useRampGradients === value) {\r\n            return;\r\n        }\r\n\r\n        this._useRampGradients = value;\r\n\r\n        this._resetEffect();\r\n    }\r\n\r\n    // Sub-emitters\r\n    /**\r\n     * The Sub-emitters templates that will be used to generate the sub particle system to be associated with the system, this property is used by the root particle system only.\r\n     * When a particle is spawned, an array will be chosen at random and all the emitters in that array will be attached to the particle.  (Default: [])\r\n     */\r\n    public subEmitters: Array<ParticleSystem | SubEmitter | Array<SubEmitter>>;\r\n    // the subEmitters field above converted to a constant type\r\n    private _subEmitters: Array<Array<SubEmitter>>;\r\n    /**\r\n     * @hidden\r\n     * If the particle systems emitter should be disposed when the particle system is disposed\r\n     */\r\n    public _disposeEmitterOnDispose = false;\r\n    /**\r\n     * The current active Sub-systems, this property is used by the root particle system only.\r\n     */\r\n    public activeSubSystems: Array<ParticleSystem>;\r\n\r\n    /**\r\n     * Specifies if the particles are updated in emitter local space or world space\r\n     */\r\n    public isLocal = false;\r\n\r\n    private _rootParticleSystem: Nullable<ParticleSystem>;\r\n    //end of Sub-emitter\r\n\r\n    /**\r\n     * Gets the current list of active particles\r\n     */\r\n    public get particles(): Particle[] {\r\n        return this._particles;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of particles active at the same time.\r\n     * @returns The number of active particles.\r\n     */\r\n    public getActiveCount() {\r\n        return this._particles.length;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"ParticleSystem\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ParticleSystem\";\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the system is stopping\r\n     * @returns true if the system is currently stopping\r\n     */\r\n    public isStopping() {\r\n        return this._stopped && this.isAlive();\r\n    }\r\n\r\n    /**\r\n     * Gets the custom effect used to render the particles\r\n     * @param blendMode Blend mode for which the effect should be retrieved\r\n     * @returns The effect\r\n     */\r\n    public getCustomEffect(blendMode: number = 0): Nullable<Effect> {\r\n        return this._customWrappers[blendMode]?.effect ?? this._customWrappers[0]!.effect;\r\n    }\r\n\r\n    private _getCustomDrawWrapper(blendMode: number = 0): Nullable<DrawWrapper> {\r\n        return this._customWrappers[blendMode] ?? this._customWrappers[0];\r\n    }\r\n\r\n    /**\r\n     * Sets the custom effect used to render the particles\r\n     * @param effect The effect to set\r\n     * @param blendMode Blend mode for which the effect should be set\r\n     */\r\n    public setCustomEffect(effect: Nullable<Effect>, blendMode: number = 0) {\r\n        this._customWrappers[blendMode] = new DrawWrapper(this._engine);\r\n        this._customWrappers[blendMode]!.effect = effect;\r\n        if (this._customWrappers[blendMode]!.drawContext) {\r\n            this._customWrappers[blendMode]!.drawContext!.useInstancing = this._useInstancing;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    private _onBeforeDrawParticlesObservable: Nullable<Observable<Nullable<Effect>>> = null;\r\n\r\n    /**\r\n     * Observable that will be called just before the particles are drawn\r\n     */\r\n    public get onBeforeDrawParticlesObservable(): Observable<Nullable<Effect>> {\r\n        if (!this._onBeforeDrawParticlesObservable) {\r\n            this._onBeforeDrawParticlesObservable = new Observable<Nullable<Effect>>();\r\n        }\r\n\r\n        return this._onBeforeDrawParticlesObservable;\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the particle vertex shader\r\n     */\r\n    public get vertexShaderName(): string {\r\n        return \"particles\";\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex buffers used by the particle system\r\n     */\r\n    public get vertexBuffers(): Immutable<{ [key: string]: VertexBuffer }> {\r\n        return this._vertexBuffers;\r\n    }\r\n\r\n    /**\r\n     * Gets the index buffer used by the particle system (or null if no index buffer is used (if _useInstancing=true))\r\n     */\r\n    public get indexBuffer(): Nullable<DataBuffer> {\r\n        return this._indexBuffer;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a particle system.\r\n     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n     * @param name The name of the particle system\r\n     * @param capacity The max number of particles alive at the same time\r\n     * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene\r\n     * @param customEffect a custom effect used to change the way particles are rendered by default\r\n     * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture\r\n     * @param epsilon Offset used to render the particles\r\n     */\r\n    constructor(\r\n        name: string,\r\n        capacity: number,\r\n        sceneOrEngine: Scene | ThinEngine,\r\n        customEffect: Nullable<Effect> = null,\r\n        isAnimationSheetEnabled: boolean = false,\r\n        epsilon: number = 0.01\r\n    ) {\r\n        super(name);\r\n\r\n        this._capacity = capacity;\r\n\r\n        this._epsilon = epsilon;\r\n        this._isAnimationSheetEnabled = isAnimationSheetEnabled;\r\n\r\n        if (!sceneOrEngine || sceneOrEngine.getClassName() === \"Scene\") {\r\n            this._scene = (sceneOrEngine as Scene) || EngineStore.LastCreatedScene;\r\n            this._engine = this._scene.getEngine();\r\n            this.uniqueId = this._scene.getUniqueId();\r\n            this._scene.particleSystems.push(this);\r\n        } else {\r\n            this._engine = sceneOrEngine as ThinEngine;\r\n            this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, this._engine.isNDCHalfZRange);\r\n        }\r\n\r\n        if (this._engine.getCaps().vertexArrayObject) {\r\n            this._vertexArrayObject = null;\r\n        }\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        this._customWrappers = { 0: new DrawWrapper(this._engine) };\r\n        this._customWrappers[0]!.effect = customEffect;\r\n\r\n        this._drawWrappers = [];\r\n        this._useInstancing = this._engine.getCaps().instancedArrays;\r\n\r\n        this._createIndexBuffer();\r\n        this._createVertexBuffers();\r\n\r\n        // Default emitter type\r\n        this.particleEmitterType = new BoxParticleEmitter();\r\n        let noiseTextureData: Nullable<Uint8Array> = null;\r\n\r\n        // Update\r\n        this.updateFunction = (particles: Particle[]): void => {\r\n            let noiseTextureSize: Nullable<ISize> = null;\r\n\r\n            if (this.noiseTexture) {\r\n                // We need to get texture data back to CPU\r\n                noiseTextureSize = this.noiseTexture.getSize();\r\n                this.noiseTexture.getContent()?.then((data) => {\r\n                    noiseTextureData = data as Uint8Array;\r\n                });\r\n            }\r\n\r\n            for (let index = 0; index < particles.length; index++) {\r\n                const particle = particles[index];\r\n\r\n                let scaledUpdateSpeed = this._scaledUpdateSpeed;\r\n                const previousAge = particle.age;\r\n                particle.age += scaledUpdateSpeed;\r\n\r\n                // Evaluate step to death\r\n                if (particle.age > particle.lifeTime) {\r\n                    const diff = particle.age - previousAge;\r\n                    const oldDiff = particle.lifeTime - previousAge;\r\n\r\n                    scaledUpdateSpeed = (oldDiff * scaledUpdateSpeed) / diff;\r\n\r\n                    particle.age = particle.lifeTime;\r\n                }\r\n\r\n                const ratio = particle.age / particle.lifeTime;\r\n\r\n                // Color\r\n                if (this._colorGradients && this._colorGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._colorGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentColorGradient) {\r\n                            particle._currentColor1.copyFrom(particle._currentColor2);\r\n                            (<ColorGradient>nextGradient).getColorToRef(particle._currentColor2);\r\n                            particle._currentColorGradient = <ColorGradient>currentGradient;\r\n                        }\r\n                        Color4.LerpToRef(particle._currentColor1, particle._currentColor2, scale, particle.color);\r\n                    });\r\n                } else {\r\n                    particle.colorStep.scaleToRef(scaledUpdateSpeed, this._scaledColorStep);\r\n                    particle.color.addInPlace(this._scaledColorStep);\r\n\r\n                    if (particle.color.a < 0) {\r\n                        particle.color.a = 0;\r\n                    }\r\n                }\r\n\r\n                // Angular speed\r\n                if (this._angularSpeedGradients && this._angularSpeedGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._angularSpeedGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentAngularSpeedGradient) {\r\n                            particle._currentAngularSpeed1 = particle._currentAngularSpeed2;\r\n                            particle._currentAngularSpeed2 = (<FactorGradient>nextGradient).getFactor();\r\n                            particle._currentAngularSpeedGradient = <FactorGradient>currentGradient;\r\n                        }\r\n                        particle.angularSpeed = Scalar.Lerp(particle._currentAngularSpeed1, particle._currentAngularSpeed2, scale);\r\n                    });\r\n                }\r\n                particle.angle += particle.angularSpeed * scaledUpdateSpeed;\r\n\r\n                // Direction\r\n                let directionScale = scaledUpdateSpeed;\r\n\r\n                /// Velocity\r\n                if (this._velocityGradients && this._velocityGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._velocityGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentVelocityGradient) {\r\n                            particle._currentVelocity1 = particle._currentVelocity2;\r\n                            particle._currentVelocity2 = (<FactorGradient>nextGradient).getFactor();\r\n                            particle._currentVelocityGradient = <FactorGradient>currentGradient;\r\n                        }\r\n                        directionScale *= Scalar.Lerp(particle._currentVelocity1, particle._currentVelocity2, scale);\r\n                    });\r\n                }\r\n\r\n                particle.direction.scaleToRef(directionScale, this._scaledDirection);\r\n\r\n                /// Limit velocity\r\n                if (this._limitVelocityGradients && this._limitVelocityGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._limitVelocityGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentLimitVelocityGradient) {\r\n                            particle._currentLimitVelocity1 = particle._currentLimitVelocity2;\r\n                            particle._currentLimitVelocity2 = (<FactorGradient>nextGradient).getFactor();\r\n                            particle._currentLimitVelocityGradient = <FactorGradient>currentGradient;\r\n                        }\r\n\r\n                        const limitVelocity = Scalar.Lerp(particle._currentLimitVelocity1, particle._currentLimitVelocity2, scale);\r\n                        const currentVelocity = particle.direction.length();\r\n\r\n                        if (currentVelocity > limitVelocity) {\r\n                            particle.direction.scaleInPlace(this.limitVelocityDamping);\r\n                        }\r\n                    });\r\n                }\r\n\r\n                /// Drag\r\n                if (this._dragGradients && this._dragGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._dragGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentDragGradient) {\r\n                            particle._currentDrag1 = particle._currentDrag2;\r\n                            particle._currentDrag2 = (<FactorGradient>nextGradient).getFactor();\r\n                            particle._currentDragGradient = <FactorGradient>currentGradient;\r\n                        }\r\n\r\n                        const drag = Scalar.Lerp(particle._currentDrag1, particle._currentDrag2, scale);\r\n\r\n                        this._scaledDirection.scaleInPlace(1.0 - drag);\r\n                    });\r\n                }\r\n\r\n                if (this.isLocal && particle._localPosition) {\r\n                    particle._localPosition!.addInPlace(this._scaledDirection);\r\n                    Vector3.TransformCoordinatesToRef(particle._localPosition!, this._emitterWorldMatrix, particle.position);\r\n                } else {\r\n                    particle.position.addInPlace(this._scaledDirection);\r\n                }\r\n\r\n                // Noise\r\n                if (noiseTextureData && noiseTextureSize && particle._randomNoiseCoordinates1) {\r\n                    const fetchedColorR = this._fetchR(\r\n                        particle._randomNoiseCoordinates1.x,\r\n                        particle._randomNoiseCoordinates1.y,\r\n                        noiseTextureSize.width,\r\n                        noiseTextureSize.height,\r\n                        noiseTextureData\r\n                    );\r\n                    const fetchedColorG = this._fetchR(\r\n                        particle._randomNoiseCoordinates1.z,\r\n                        particle._randomNoiseCoordinates2.x,\r\n                        noiseTextureSize.width,\r\n                        noiseTextureSize.height,\r\n                        noiseTextureData\r\n                    );\r\n                    const fetchedColorB = this._fetchR(\r\n                        particle._randomNoiseCoordinates2.y,\r\n                        particle._randomNoiseCoordinates2.z,\r\n                        noiseTextureSize.width,\r\n                        noiseTextureSize.height,\r\n                        noiseTextureData\r\n                    );\r\n\r\n                    const force = TmpVectors.Vector3[0];\r\n                    const scaledForce = TmpVectors.Vector3[1];\r\n\r\n                    force.copyFromFloats(\r\n                        (2 * fetchedColorR - 1) * this.noiseStrength.x,\r\n                        (2 * fetchedColorG - 1) * this.noiseStrength.y,\r\n                        (2 * fetchedColorB - 1) * this.noiseStrength.z\r\n                    );\r\n\r\n                    force.scaleToRef(scaledUpdateSpeed, scaledForce);\r\n                    particle.direction.addInPlace(scaledForce);\r\n                }\r\n\r\n                // Gravity\r\n                this.gravity.scaleToRef(scaledUpdateSpeed, this._scaledGravity);\r\n                particle.direction.addInPlace(this._scaledGravity);\r\n\r\n                // Size\r\n                if (this._sizeGradients && this._sizeGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._sizeGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentSizeGradient) {\r\n                            particle._currentSize1 = particle._currentSize2;\r\n                            particle._currentSize2 = (<FactorGradient>nextGradient).getFactor();\r\n                            particle._currentSizeGradient = <FactorGradient>currentGradient;\r\n                        }\r\n                        particle.size = Scalar.Lerp(particle._currentSize1, particle._currentSize2, scale);\r\n                    });\r\n                }\r\n\r\n                // Remap data\r\n                if (this._useRampGradients) {\r\n                    if (this._colorRemapGradients && this._colorRemapGradients.length > 0) {\r\n                        GradientHelper.GetCurrentGradient(ratio, this._colorRemapGradients, (currentGradient, nextGradient, scale) => {\r\n                            const min = Scalar.Lerp((<FactorGradient>currentGradient).factor1, (<FactorGradient>nextGradient).factor1, scale);\r\n                            const max = Scalar.Lerp((<FactorGradient>currentGradient).factor2!, (<FactorGradient>nextGradient).factor2!, scale);\r\n\r\n                            particle.remapData.x = min;\r\n                            particle.remapData.y = max - min;\r\n                        });\r\n                    }\r\n\r\n                    if (this._alphaRemapGradients && this._alphaRemapGradients.length > 0) {\r\n                        GradientHelper.GetCurrentGradient(ratio, this._alphaRemapGradients, (currentGradient, nextGradient, scale) => {\r\n                            const min = Scalar.Lerp((<FactorGradient>currentGradient).factor1, (<FactorGradient>nextGradient).factor1, scale);\r\n                            const max = Scalar.Lerp((<FactorGradient>currentGradient).factor2!, (<FactorGradient>nextGradient).factor2!, scale);\r\n\r\n                            particle.remapData.z = min;\r\n                            particle.remapData.w = max - min;\r\n                        });\r\n                    }\r\n                }\r\n\r\n                if (this._isAnimationSheetEnabled) {\r\n                    particle.updateCellIndex();\r\n                }\r\n\r\n                // Update the position of the attached sub-emitters to match their attached particle\r\n                particle._inheritParticleInfoToSubEmitters();\r\n\r\n                if (particle.age >= particle.lifeTime) {\r\n                    // Recycle by swapping with last particle\r\n                    this._emitFromParticle(particle);\r\n                    if (particle._attachedSubEmitters) {\r\n                        particle._attachedSubEmitters.forEach((subEmitter) => {\r\n                            subEmitter.particleSystem.disposeOnStop = true;\r\n                            subEmitter.particleSystem.stop();\r\n                        });\r\n                        particle._attachedSubEmitters = null;\r\n                    }\r\n                    this.recycleParticle(particle);\r\n                    index--;\r\n                    continue;\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    private _addFactorGradient(factorGradients: FactorGradient[], gradient: number, factor: number, factor2?: number) {\r\n        const newGradient = new FactorGradient(gradient, factor, factor2);\r\n        factorGradients.push(newGradient);\r\n\r\n        factorGradients.sort((a, b) => {\r\n            if (a.gradient < b.gradient) {\r\n                return -1;\r\n            } else if (a.gradient > b.gradient) {\r\n                return 1;\r\n            }\r\n\r\n            return 0;\r\n        });\r\n    }\r\n\r\n    private _removeFactorGradient(factorGradients: Nullable<FactorGradient[]>, gradient: number) {\r\n        if (!factorGradients) {\r\n            return;\r\n        }\r\n\r\n        let index = 0;\r\n        for (const factorGradient of factorGradients) {\r\n            if (factorGradient.gradient === gradient) {\r\n                factorGradients.splice(index, 1);\r\n                break;\r\n            }\r\n            index++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a new life time gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the life time factor to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addLifeTimeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._lifeTimeGradients) {\r\n            this._lifeTimeGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._lifeTimeGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific life time gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeLifeTimeGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._lifeTimeGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new size gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the size factor to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addSizeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._sizeGradients) {\r\n            this._sizeGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._sizeGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific size gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeSizeGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._sizeGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new color remap gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param min defines the color remap minimal range\r\n     * @param max defines the color remap maximal range\r\n     * @returns the current particle system\r\n     */\r\n    public addColorRemapGradient(gradient: number, min: number, max: number): IParticleSystem {\r\n        if (!this._colorRemapGradients) {\r\n            this._colorRemapGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._colorRemapGradients, gradient, min, max);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific color remap gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeColorRemapGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._colorRemapGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new alpha remap gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param min defines the alpha remap minimal range\r\n     * @param max defines the alpha remap maximal range\r\n     * @returns the current particle system\r\n     */\r\n    public addAlphaRemapGradient(gradient: number, min: number, max: number): IParticleSystem {\r\n        if (!this._alphaRemapGradients) {\r\n            this._alphaRemapGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._alphaRemapGradients, gradient, min, max);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific alpha remap gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeAlphaRemapGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._alphaRemapGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new angular speed gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the angular speed  to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addAngularSpeedGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._angularSpeedGradients) {\r\n            this._angularSpeedGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._angularSpeedGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific angular speed gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeAngularSpeedGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._angularSpeedGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new velocity gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the velocity to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addVelocityGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._velocityGradients) {\r\n            this._velocityGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._velocityGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific velocity gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeVelocityGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._velocityGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new limit velocity gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the limit velocity value to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addLimitVelocityGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._limitVelocityGradients) {\r\n            this._limitVelocityGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._limitVelocityGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific limit velocity gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeLimitVelocityGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._limitVelocityGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new drag gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the drag value to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addDragGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._dragGradients) {\r\n            this._dragGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._dragGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific drag gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeDragGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._dragGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new emit rate gradient (please note that this will only work if you set the targetStopDuration property)\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the emit rate value to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addEmitRateGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._emitRateGradients) {\r\n            this._emitRateGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._emitRateGradients, gradient, factor, factor2);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific emit rate gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeEmitRateGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._emitRateGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new start size gradient (please note that this will only work if you set the targetStopDuration property)\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the start size value to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addStartSizeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._startSizeGradients) {\r\n            this._startSizeGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._startSizeGradients, gradient, factor, factor2);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific start size gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeStartSizeGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._startSizeGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _createRampGradientTexture() {\r\n        if (!this._rampGradients || !this._rampGradients.length || this._rampGradientsTexture || !this._scene) {\r\n            return;\r\n        }\r\n\r\n        const data = new Uint8Array(this._rawTextureWidth * 4);\r\n        const tmpColor = TmpColors.Color3[0];\r\n\r\n        for (let x = 0; x < this._rawTextureWidth; x++) {\r\n            const ratio = x / this._rawTextureWidth;\r\n\r\n            GradientHelper.GetCurrentGradient(ratio, this._rampGradients, (currentGradient, nextGradient, scale) => {\r\n                Color3.LerpToRef((<Color3Gradient>currentGradient).color, (<Color3Gradient>nextGradient).color, scale, tmpColor);\r\n                data[x * 4] = tmpColor.r * 255;\r\n                data[x * 4 + 1] = tmpColor.g * 255;\r\n                data[x * 4 + 2] = tmpColor.b * 255;\r\n                data[x * 4 + 3] = 255;\r\n            });\r\n        }\r\n\r\n        this._rampGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE);\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of ramp gradients.\r\n     * You must use addRampGradient and removeRampGradient to update this list\r\n     * @returns the list of ramp gradients\r\n     */\r\n    public getRampGradients(): Nullable<Array<Color3Gradient>> {\r\n        return this._rampGradients;\r\n    }\r\n\r\n    /** Force the system to rebuild all gradients that need to be resync */\r\n    public forceRefreshGradients() {\r\n        this._syncRampGradientTexture();\r\n    }\r\n\r\n    private _syncRampGradientTexture() {\r\n        if (!this._rampGradients) {\r\n            return;\r\n        }\r\n\r\n        this._rampGradients.sort((a, b) => {\r\n            if (a.gradient < b.gradient) {\r\n                return -1;\r\n            } else if (a.gradient > b.gradient) {\r\n                return 1;\r\n            }\r\n\r\n            return 0;\r\n        });\r\n\r\n        if (this._rampGradientsTexture) {\r\n            this._rampGradientsTexture.dispose();\r\n            this._rampGradientsTexture = null;\r\n        }\r\n\r\n        this._createRampGradientTexture();\r\n    }\r\n\r\n    /**\r\n     * Adds a new ramp gradient used to remap particle colors\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param color defines the color to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addRampGradient(gradient: number, color: Color3): ParticleSystem {\r\n        if (!this._rampGradients) {\r\n            this._rampGradients = [];\r\n        }\r\n\r\n        const rampGradient = new Color3Gradient(gradient, color);\r\n        this._rampGradients.push(rampGradient);\r\n\r\n        this._syncRampGradientTexture();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific ramp gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeRampGradient(gradient: number): ParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._rampGradients, this._rampGradientsTexture);\r\n        this._rampGradientsTexture = null;\r\n\r\n        if (this._rampGradients && this._rampGradients.length > 0) {\r\n            this._createRampGradientTexture();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new color gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param color1 defines the color to affect to the specified gradient\r\n     * @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from\r\n     * @returns this particle system\r\n     */\r\n    public addColorGradient(gradient: number, color1: Color4, color2?: Color4): IParticleSystem {\r\n        if (!this._colorGradients) {\r\n            this._colorGradients = [];\r\n        }\r\n\r\n        const colorGradient = new ColorGradient(gradient, color1, color2);\r\n        this._colorGradients.push(colorGradient);\r\n\r\n        this._colorGradients.sort((a, b) => {\r\n            if (a.gradient < b.gradient) {\r\n                return -1;\r\n            } else if (a.gradient > b.gradient) {\r\n                return 1;\r\n            }\r\n\r\n            return 0;\r\n        });\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific color gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns this particle system\r\n     */\r\n    public removeColorGradient(gradient: number): IParticleSystem {\r\n        if (!this._colorGradients) {\r\n            return this;\r\n        }\r\n\r\n        let index = 0;\r\n        for (const colorGradient of this._colorGradients) {\r\n            if (colorGradient.gradient === gradient) {\r\n                this._colorGradients.splice(index, 1);\r\n                break;\r\n            }\r\n            index++;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache\r\n     */\r\n    public resetDrawCache(): void {\r\n        for (const drawWrappers of this._drawWrappers) {\r\n            if (drawWrappers) {\r\n                for (const drawWrapper of drawWrappers) {\r\n                    drawWrapper?.dispose();\r\n                }\r\n            }\r\n        }\r\n\r\n        this._drawWrappers = [];\r\n    }\r\n\r\n    private _fetchR(u: number, v: number, width: number, height: number, pixels: Uint8Array): number {\r\n        u = Math.abs(u) * 0.5 + 0.5;\r\n        v = Math.abs(v) * 0.5 + 0.5;\r\n\r\n        const wrappedU = (u * width) % width | 0;\r\n        const wrappedV = (v * height) % height | 0;\r\n\r\n        const position = (wrappedU + wrappedV * width) * 4;\r\n        return pixels[position] / 255;\r\n    }\r\n\r\n    protected _reset() {\r\n        this._resetEffect();\r\n    }\r\n\r\n    private _resetEffect() {\r\n        if (this._vertexBuffer) {\r\n            this._vertexBuffer.dispose();\r\n            this._vertexBuffer = null;\r\n        }\r\n\r\n        if (this._spriteBuffer) {\r\n            this._spriteBuffer.dispose();\r\n            this._spriteBuffer = null;\r\n        }\r\n\r\n        if (this._vertexArrayObject) {\r\n            this._engine.releaseVertexArrayObject(this._vertexArrayObject);\r\n            this._vertexArrayObject = null;\r\n        }\r\n\r\n        this._createVertexBuffers();\r\n    }\r\n\r\n    private _createVertexBuffers() {\r\n        this._vertexBufferSize = this._useInstancing ? 10 : 12;\r\n        if (this._isAnimationSheetEnabled) {\r\n            this._vertexBufferSize += 1;\r\n        }\r\n\r\n        if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\r\n            this._vertexBufferSize += 3;\r\n        }\r\n\r\n        if (this._useRampGradients) {\r\n            this._vertexBufferSize += 4;\r\n        }\r\n\r\n        const engine = this._engine;\r\n        const vertexSize = this._vertexBufferSize * (this._useInstancing ? 1 : 4);\r\n        this._vertexData = new Float32Array(this._capacity * vertexSize);\r\n        this._vertexBuffer = new Buffer(engine, this._vertexData, true, vertexSize);\r\n\r\n        let dataOffset = 0;\r\n        const positions = this._vertexBuffer.createVertexBuffer(VertexBuffer.PositionKind, dataOffset, 3, this._vertexBufferSize, this._useInstancing);\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = positions;\r\n        dataOffset += 3;\r\n\r\n        const colors = this._vertexBuffer.createVertexBuffer(VertexBuffer.ColorKind, dataOffset, 4, this._vertexBufferSize, this._useInstancing);\r\n        this._vertexBuffers[VertexBuffer.ColorKind] = colors;\r\n        dataOffset += 4;\r\n\r\n        const options = this._vertexBuffer.createVertexBuffer(\"angle\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\r\n        this._vertexBuffers[\"angle\"] = options;\r\n        dataOffset += 1;\r\n\r\n        const size = this._vertexBuffer.createVertexBuffer(\"size\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\r\n        this._vertexBuffers[\"size\"] = size;\r\n        dataOffset += 2;\r\n\r\n        if (this._isAnimationSheetEnabled) {\r\n            const cellIndexBuffer = this._vertexBuffer.createVertexBuffer(\"cellIndex\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\r\n            this._vertexBuffers[\"cellIndex\"] = cellIndexBuffer;\r\n            dataOffset += 1;\r\n        }\r\n\r\n        if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\r\n            const directionBuffer = this._vertexBuffer.createVertexBuffer(\"direction\", dataOffset, 3, this._vertexBufferSize, this._useInstancing);\r\n            this._vertexBuffers[\"direction\"] = directionBuffer;\r\n            dataOffset += 3;\r\n        }\r\n\r\n        if (this._useRampGradients) {\r\n            const rampDataBuffer = this._vertexBuffer.createVertexBuffer(\"remapData\", dataOffset, 4, this._vertexBufferSize, this._useInstancing);\r\n            this._vertexBuffers[\"remapData\"] = rampDataBuffer;\r\n            dataOffset += 4;\r\n        }\r\n\r\n        let offsets: VertexBuffer;\r\n        if (this._useInstancing) {\r\n            const spriteData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\r\n            this._spriteBuffer = new Buffer(engine, spriteData, false, 2);\r\n            offsets = this._spriteBuffer.createVertexBuffer(\"offset\", 0, 2);\r\n        } else {\r\n            offsets = this._vertexBuffer.createVertexBuffer(\"offset\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\r\n            dataOffset += 2;\r\n        }\r\n        this._vertexBuffers[\"offset\"] = offsets;\r\n\r\n        this.resetDrawCache();\r\n    }\r\n\r\n    private _createIndexBuffer() {\r\n        if (this._useInstancing) {\r\n            return;\r\n        }\r\n        const indices = [];\r\n        let index = 0;\r\n        for (let count = 0; count < this._capacity; count++) {\r\n            indices.push(index);\r\n            indices.push(index + 1);\r\n            indices.push(index + 2);\r\n            indices.push(index);\r\n            indices.push(index + 2);\r\n            indices.push(index + 3);\r\n            index += 4;\r\n        }\r\n\r\n        this._indexBuffer = this._engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /**\r\n     * Gets the maximum number of particles active at the same time.\r\n     * @returns The max number of active particles.\r\n     */\r\n    public getCapacity(): number {\r\n        return this._capacity;\r\n    }\r\n\r\n    /**\r\n     * Gets whether there are still active particles in the system.\r\n     * @returns True if it is alive, otherwise false.\r\n     */\r\n    public isAlive(): boolean {\r\n        return this._alive;\r\n    }\r\n\r\n    /**\r\n     * Gets if the system has been started. (Note: this will still be true after stop is called)\r\n     * @returns True if it has been started, otherwise false.\r\n     */\r\n    public isStarted(): boolean {\r\n        return this._started;\r\n    }\r\n\r\n    private _prepareSubEmitterInternalArray() {\r\n        this._subEmitters = new Array<Array<SubEmitter>>();\r\n        if (this.subEmitters) {\r\n            this.subEmitters.forEach((subEmitter) => {\r\n                if (subEmitter instanceof ParticleSystem) {\r\n                    this._subEmitters.push([new SubEmitter(subEmitter)]);\r\n                } else if (subEmitter instanceof SubEmitter) {\r\n                    this._subEmitters.push([subEmitter]);\r\n                } else if (subEmitter instanceof Array) {\r\n                    this._subEmitters.push(subEmitter);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts the particle system and begins to emit\r\n     * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)\r\n     */\r\n    public start(delay = this.startDelay): void {\r\n        if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {\r\n            throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\r\n        }\r\n        if (delay) {\r\n            setTimeout(() => {\r\n                this.start(0);\r\n            }, delay);\r\n            return;\r\n        }\r\n        // Convert the subEmitters field to the constant type field _subEmitters\r\n        this._prepareSubEmitterInternalArray();\r\n\r\n        this._started = true;\r\n        this._stopped = false;\r\n        this._actualFrame = 0;\r\n        if (this._subEmitters && this._subEmitters.length != 0) {\r\n            this.activeSubSystems = new Array<ParticleSystem>();\r\n        }\r\n\r\n        // Reset emit gradient so it acts the same on every start\r\n        if (this._emitRateGradients) {\r\n            if (this._emitRateGradients.length > 0) {\r\n                this._currentEmitRateGradient = this._emitRateGradients[0];\r\n                this._currentEmitRate1 = this._currentEmitRateGradient.getFactor();\r\n                this._currentEmitRate2 = this._currentEmitRate1;\r\n            }\r\n            if (this._emitRateGradients.length > 1) {\r\n                this._currentEmitRate2 = this._emitRateGradients[1].getFactor();\r\n            }\r\n        }\r\n        // Reset start size gradient so it acts the same on every start\r\n        if (this._startSizeGradients) {\r\n            if (this._startSizeGradients.length > 0) {\r\n                this._currentStartSizeGradient = this._startSizeGradients[0];\r\n                this._currentStartSize1 = this._currentStartSizeGradient.getFactor();\r\n                this._currentStartSize2 = this._currentStartSize1;\r\n            }\r\n            if (this._startSizeGradients.length > 1) {\r\n                this._currentStartSize2 = this._startSizeGradients[1].getFactor();\r\n            }\r\n        }\r\n\r\n        if (this.preWarmCycles) {\r\n            if (this.emitter?.getClassName().indexOf(\"Mesh\") !== -1) {\r\n                (this.emitter as any).computeWorldMatrix(true);\r\n            }\r\n\r\n            const noiseTextureAsProcedural = this.noiseTexture as ProceduralTexture;\r\n\r\n            if (noiseTextureAsProcedural && noiseTextureAsProcedural.onGeneratedObservable) {\r\n                noiseTextureAsProcedural.onGeneratedObservable.addOnce(() => {\r\n                    setTimeout(() => {\r\n                        for (let index = 0; index < this.preWarmCycles; index++) {\r\n                            this.animate(true);\r\n                            noiseTextureAsProcedural.render();\r\n                        }\r\n                    });\r\n                });\r\n            } else {\r\n                for (let index = 0; index < this.preWarmCycles; index++) {\r\n                    this.animate(true);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Animations\r\n        if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {\r\n            this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops the particle system.\r\n     * @param stopSubEmitters if true it will stop the current system and all created sub-Systems if false it will stop the current root system only, this param is used by the root particle system only. the default value is true.\r\n     */\r\n    public stop(stopSubEmitters = true): void {\r\n        if (this._stopped) {\r\n            return;\r\n        }\r\n\r\n        this.onStoppedObservable.notifyObservers(this);\r\n\r\n        this._stopped = true;\r\n\r\n        if (stopSubEmitters) {\r\n            this._stopSubEmitters();\r\n        }\r\n    }\r\n\r\n    // animation sheet\r\n\r\n    /**\r\n     * Remove all active particles\r\n     */\r\n    public reset(): void {\r\n        this._stockParticles = [];\r\n        this._particles = [];\r\n    }\r\n\r\n    /**\r\n     * @param index\r\n     * @param particle\r\n     * @param offsetX\r\n     * @param offsetY\r\n     * @hidden (for internal use only)\r\n     */\r\n    public _appendParticleVertex(index: number, particle: Particle, offsetX: number, offsetY: number): void {\r\n        let offset = index * this._vertexBufferSize;\r\n\r\n        this._vertexData[offset++] = particle.position.x + this.worldOffset.x;\r\n        this._vertexData[offset++] = particle.position.y + this.worldOffset.y;\r\n        this._vertexData[offset++] = particle.position.z + this.worldOffset.z;\r\n        this._vertexData[offset++] = particle.color.r;\r\n        this._vertexData[offset++] = particle.color.g;\r\n        this._vertexData[offset++] = particle.color.b;\r\n        this._vertexData[offset++] = particle.color.a;\r\n        this._vertexData[offset++] = particle.angle;\r\n\r\n        this._vertexData[offset++] = particle.scale.x * particle.size;\r\n        this._vertexData[offset++] = particle.scale.y * particle.size;\r\n\r\n        if (this._isAnimationSheetEnabled) {\r\n            this._vertexData[offset++] = particle.cellIndex;\r\n        }\r\n\r\n        if (!this._isBillboardBased) {\r\n            if (particle._initialDirection) {\r\n                let initialDirection = particle._initialDirection;\r\n                if (this.isLocal) {\r\n                    Vector3.TransformNormalToRef(initialDirection, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\r\n                    initialDirection = TmpVectors.Vector3[0];\r\n                }\r\n                if (initialDirection.x === 0 && initialDirection.z === 0) {\r\n                    initialDirection.x = 0.001;\r\n                }\r\n\r\n                this._vertexData[offset++] = initialDirection.x;\r\n                this._vertexData[offset++] = initialDirection.y;\r\n                this._vertexData[offset++] = initialDirection.z;\r\n            } else {\r\n                let direction = particle.direction;\r\n                if (this.isLocal) {\r\n                    Vector3.TransformNormalToRef(direction, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\r\n                    direction = TmpVectors.Vector3[0];\r\n                }\r\n\r\n                if (direction.x === 0 && direction.z === 0) {\r\n                    direction.x = 0.001;\r\n                }\r\n                this._vertexData[offset++] = direction.x;\r\n                this._vertexData[offset++] = direction.y;\r\n                this._vertexData[offset++] = direction.z;\r\n            }\r\n        } else if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\r\n            this._vertexData[offset++] = particle.direction.x;\r\n            this._vertexData[offset++] = particle.direction.y;\r\n            this._vertexData[offset++] = particle.direction.z;\r\n        }\r\n\r\n        if (this._useRampGradients && particle.remapData) {\r\n            this._vertexData[offset++] = particle.remapData.x;\r\n            this._vertexData[offset++] = particle.remapData.y;\r\n            this._vertexData[offset++] = particle.remapData.z;\r\n            this._vertexData[offset++] = particle.remapData.w;\r\n        }\r\n\r\n        if (!this._useInstancing) {\r\n            if (this._isAnimationSheetEnabled) {\r\n                if (offsetX === 0) {\r\n                    offsetX = this._epsilon;\r\n                } else if (offsetX === 1) {\r\n                    offsetX = 1 - this._epsilon;\r\n                }\r\n\r\n                if (offsetY === 0) {\r\n                    offsetY = this._epsilon;\r\n                } else if (offsetY === 1) {\r\n                    offsetY = 1 - this._epsilon;\r\n                }\r\n            }\r\n\r\n            this._vertexData[offset++] = offsetX;\r\n            this._vertexData[offset++] = offsetY;\r\n        }\r\n    }\r\n\r\n    // start of sub system methods\r\n\r\n    /**\r\n     * \"Recycles\" one of the particle by copying it back to the \"stock\" of particles and removing it from the active list.\r\n     * Its lifetime will start back at 0.\r\n     * @param particle\r\n     */\r\n    public recycleParticle: (particle: Particle) => void = (particle) => {\r\n        // move particle from activeParticle list to stock particles\r\n        const lastParticle = <Particle>this._particles.pop();\r\n        if (lastParticle !== particle) {\r\n            lastParticle.copyTo(particle);\r\n        }\r\n        this._stockParticles.push(lastParticle);\r\n    };\r\n\r\n    private _stopSubEmitters(): void {\r\n        if (!this.activeSubSystems) {\r\n            return;\r\n        }\r\n        this.activeSubSystems.forEach((subSystem) => {\r\n            subSystem.stop(true);\r\n        });\r\n        this.activeSubSystems = new Array<ParticleSystem>();\r\n    }\r\n\r\n    private _createParticle: () => Particle = () => {\r\n        let particle: Particle;\r\n        if (this._stockParticles.length !== 0) {\r\n            particle = <Particle>this._stockParticles.pop();\r\n            particle._reset();\r\n        } else {\r\n            particle = new Particle(this);\r\n        }\r\n\r\n        // Attach emitters\r\n        if (this._subEmitters && this._subEmitters.length > 0) {\r\n            const subEmitters = this._subEmitters[Math.floor(Math.random() * this._subEmitters.length)];\r\n            particle._attachedSubEmitters = [];\r\n            subEmitters.forEach((subEmitter) => {\r\n                if (subEmitter.type === SubEmitterType.ATTACHED) {\r\n                    const newEmitter = subEmitter.clone();\r\n                    (<Array<SubEmitter>>particle._attachedSubEmitters).push(newEmitter);\r\n                    newEmitter.particleSystem.start();\r\n                }\r\n            });\r\n        }\r\n        return particle;\r\n    };\r\n\r\n    private _removeFromRoot(): void {\r\n        if (!this._rootParticleSystem) {\r\n            return;\r\n        }\r\n\r\n        const index = this._rootParticleSystem.activeSubSystems.indexOf(this);\r\n        if (index !== -1) {\r\n            this._rootParticleSystem.activeSubSystems.splice(index, 1);\r\n        }\r\n\r\n        this._rootParticleSystem = null;\r\n    }\r\n\r\n    private _emitFromParticle: (particle: Particle) => void = (particle) => {\r\n        if (!this._subEmitters || this._subEmitters.length === 0) {\r\n            return;\r\n        }\r\n        const templateIndex = Math.floor(Math.random() * this._subEmitters.length);\r\n\r\n        this._subEmitters[templateIndex].forEach((subEmitter) => {\r\n            if (subEmitter.type === SubEmitterType.END) {\r\n                const subSystem = subEmitter.clone();\r\n                particle._inheritParticleInfoToSubEmitter(subSystem);\r\n                subSystem.particleSystem._rootParticleSystem = this;\r\n                this.activeSubSystems.push(subSystem.particleSystem);\r\n                subSystem.particleSystem.start();\r\n            }\r\n        });\r\n    };\r\n\r\n    // End of sub system methods\r\n\r\n    private _update(newParticles: number): void {\r\n        // Update current\r\n        this._alive = this._particles.length > 0;\r\n\r\n        if ((<AbstractMesh>this.emitter).position) {\r\n            const emitterMesh = <AbstractMesh>this.emitter;\r\n            this._emitterWorldMatrix = emitterMesh.getWorldMatrix();\r\n        } else {\r\n            const emitterPosition = <Vector3>this.emitter;\r\n            this._emitterWorldMatrix = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);\r\n        }\r\n\r\n        this._emitterWorldMatrix.invertToRef(this._emitterInverseWorldMatrix);\r\n        this.updateFunction(this._particles);\r\n\r\n        // Add new ones\r\n        let particle: Particle;\r\n        for (let index = 0; index < newParticles; index++) {\r\n            if (this._particles.length === this._capacity) {\r\n                break;\r\n            }\r\n\r\n            particle = this._createParticle();\r\n\r\n            this._particles.push(particle);\r\n\r\n            // Life time\r\n            if (this.targetStopDuration && this._lifeTimeGradients && this._lifeTimeGradients.length > 0) {\r\n                const ratio = Scalar.Clamp(this._actualFrame / this.targetStopDuration);\r\n                GradientHelper.GetCurrentGradient(ratio, this._lifeTimeGradients, (currentGradient, nextGradient) => {\r\n                    const factorGradient1 = <FactorGradient>currentGradient;\r\n                    const factorGradient2 = <FactorGradient>nextGradient;\r\n                    const lifeTime1 = factorGradient1.getFactor();\r\n                    const lifeTime2 = factorGradient2.getFactor();\r\n                    const gradient = (ratio - factorGradient1.gradient) / (factorGradient2.gradient - factorGradient1.gradient);\r\n                    particle.lifeTime = Scalar.Lerp(lifeTime1, lifeTime2, gradient);\r\n                });\r\n            } else {\r\n                particle.lifeTime = Scalar.RandomRange(this.minLifeTime, this.maxLifeTime);\r\n            }\r\n\r\n            // Emitter\r\n            const emitPower = Scalar.RandomRange(this.minEmitPower, this.maxEmitPower);\r\n\r\n            if (this.startPositionFunction) {\r\n                this.startPositionFunction(this._emitterWorldMatrix, particle.position, particle, this.isLocal);\r\n            } else {\r\n                this.particleEmitterType.startPositionFunction(this._emitterWorldMatrix, particle.position, particle, this.isLocal);\r\n            }\r\n\r\n            if (this.isLocal) {\r\n                if (!particle._localPosition) {\r\n                    particle._localPosition = particle.position.clone();\r\n                } else {\r\n                    particle._localPosition.copyFrom(particle.position);\r\n                }\r\n                Vector3.TransformCoordinatesToRef(particle._localPosition!, this._emitterWorldMatrix, particle.position);\r\n            }\r\n\r\n            if (this.startDirectionFunction) {\r\n                this.startDirectionFunction(this._emitterWorldMatrix, particle.direction, particle, this.isLocal);\r\n            } else {\r\n                this.particleEmitterType.startDirectionFunction(this._emitterWorldMatrix, particle.direction, particle, this.isLocal, this._emitterInverseWorldMatrix);\r\n            }\r\n\r\n            if (emitPower === 0) {\r\n                if (!particle._initialDirection) {\r\n                    particle._initialDirection = particle.direction.clone();\r\n                } else {\r\n                    particle._initialDirection.copyFrom(particle.direction);\r\n                }\r\n            } else {\r\n                particle._initialDirection = null;\r\n            }\r\n\r\n            particle.direction.scaleInPlace(emitPower);\r\n\r\n            // Size\r\n            if (!this._sizeGradients || this._sizeGradients.length === 0) {\r\n                particle.size = Scalar.RandomRange(this.minSize, this.maxSize);\r\n            } else {\r\n                particle._currentSizeGradient = this._sizeGradients[0];\r\n                particle._currentSize1 = particle._currentSizeGradient.getFactor();\r\n                particle.size = particle._currentSize1;\r\n\r\n                if (this._sizeGradients.length > 1) {\r\n                    particle._currentSize2 = this._sizeGradients[1].getFactor();\r\n                } else {\r\n                    particle._currentSize2 = particle._currentSize1;\r\n                }\r\n            }\r\n            // Size and scale\r\n            particle.scale.copyFromFloats(Scalar.RandomRange(this.minScaleX, this.maxScaleX), Scalar.RandomRange(this.minScaleY, this.maxScaleY));\r\n\r\n            // Adjust scale by start size\r\n            if (this._startSizeGradients && this._startSizeGradients[0] && this.targetStopDuration) {\r\n                const ratio = this._actualFrame / this.targetStopDuration;\r\n                GradientHelper.GetCurrentGradient(ratio, this._startSizeGradients, (currentGradient, nextGradient, scale) => {\r\n                    if (currentGradient !== this._currentStartSizeGradient) {\r\n                        this._currentStartSize1 = this._currentStartSize2;\r\n                        this._currentStartSize2 = (<FactorGradient>nextGradient).getFactor();\r\n                        this._currentStartSizeGradient = <FactorGradient>currentGradient;\r\n                    }\r\n\r\n                    const value = Scalar.Lerp(this._currentStartSize1, this._currentStartSize2, scale);\r\n                    particle.scale.scaleInPlace(value);\r\n                });\r\n            }\r\n\r\n            // Angle\r\n            if (!this._angularSpeedGradients || this._angularSpeedGradients.length === 0) {\r\n                particle.angularSpeed = Scalar.RandomRange(this.minAngularSpeed, this.maxAngularSpeed);\r\n            } else {\r\n                particle._currentAngularSpeedGradient = this._angularSpeedGradients[0];\r\n                particle.angularSpeed = particle._currentAngularSpeedGradient.getFactor();\r\n                particle._currentAngularSpeed1 = particle.angularSpeed;\r\n\r\n                if (this._angularSpeedGradients.length > 1) {\r\n                    particle._currentAngularSpeed2 = this._angularSpeedGradients[1].getFactor();\r\n                } else {\r\n                    particle._currentAngularSpeed2 = particle._currentAngularSpeed1;\r\n                }\r\n            }\r\n            particle.angle = Scalar.RandomRange(this.minInitialRotation, this.maxInitialRotation);\r\n\r\n            // Velocity\r\n            if (this._velocityGradients && this._velocityGradients.length > 0) {\r\n                particle._currentVelocityGradient = this._velocityGradients[0];\r\n                particle._currentVelocity1 = particle._currentVelocityGradient.getFactor();\r\n\r\n                if (this._velocityGradients.length > 1) {\r\n                    particle._currentVelocity2 = this._velocityGradients[1].getFactor();\r\n                } else {\r\n                    particle._currentVelocity2 = particle._currentVelocity1;\r\n                }\r\n            }\r\n\r\n            // Limit velocity\r\n            if (this._limitVelocityGradients && this._limitVelocityGradients.length > 0) {\r\n                particle._currentLimitVelocityGradient = this._limitVelocityGradients[0];\r\n                particle._currentLimitVelocity1 = particle._currentLimitVelocityGradient.getFactor();\r\n\r\n                if (this._limitVelocityGradients.length > 1) {\r\n                    particle._currentLimitVelocity2 = this._limitVelocityGradients[1].getFactor();\r\n                } else {\r\n                    particle._currentLimitVelocity2 = particle._currentLimitVelocity1;\r\n                }\r\n            }\r\n\r\n            // Drag\r\n            if (this._dragGradients && this._dragGradients.length > 0) {\r\n                particle._currentDragGradient = this._dragGradients[0];\r\n                particle._currentDrag1 = particle._currentDragGradient.getFactor();\r\n\r\n                if (this._dragGradients.length > 1) {\r\n                    particle._currentDrag2 = this._dragGradients[1].getFactor();\r\n                } else {\r\n                    particle._currentDrag2 = particle._currentDrag1;\r\n                }\r\n            }\r\n\r\n            // Color\r\n            if (!this._colorGradients || this._colorGradients.length === 0) {\r\n                const step = Scalar.RandomRange(0, 1.0);\r\n\r\n                Color4.LerpToRef(this.color1, this.color2, step, particle.color);\r\n\r\n                this.colorDead.subtractToRef(particle.color, this._colorDiff);\r\n                this._colorDiff.scaleToRef(1.0 / particle.lifeTime, particle.colorStep);\r\n            } else {\r\n                particle._currentColorGradient = this._colorGradients[0];\r\n                particle._currentColorGradient.getColorToRef(particle.color);\r\n                particle._currentColor1.copyFrom(particle.color);\r\n\r\n                if (this._colorGradients.length > 1) {\r\n                    this._colorGradients[1].getColorToRef(particle._currentColor2);\r\n                } else {\r\n                    particle._currentColor2.copyFrom(particle.color);\r\n                }\r\n            }\r\n\r\n            // Sheet\r\n            if (this._isAnimationSheetEnabled) {\r\n                particle._initialStartSpriteCellID = this.startSpriteCellID;\r\n                particle._initialEndSpriteCellID = this.endSpriteCellID;\r\n                particle._initialSpriteCellLoop = this.spriteCellLoop;\r\n            }\r\n\r\n            // Inherited Velocity\r\n            particle.direction.addInPlace(this._inheritedVelocityOffset);\r\n\r\n            // Ramp\r\n            if (this._useRampGradients) {\r\n                particle.remapData = new Vector4(0, 1, 0, 1);\r\n            }\r\n\r\n            // Noise texture coordinates\r\n            if (this.noiseTexture) {\r\n                if (particle._randomNoiseCoordinates1) {\r\n                    particle._randomNoiseCoordinates1.copyFromFloats(Math.random(), Math.random(), Math.random());\r\n                    particle._randomNoiseCoordinates2.copyFromFloats(Math.random(), Math.random(), Math.random());\r\n                } else {\r\n                    particle._randomNoiseCoordinates1 = new Vector3(Math.random(), Math.random(), Math.random());\r\n                    particle._randomNoiseCoordinates2 = new Vector3(Math.random(), Math.random(), Math.random());\r\n                }\r\n            }\r\n\r\n            // Update the position of the attached sub-emitters to match their attached particle\r\n            particle._inheritParticleInfoToSubEmitters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param isAnimationSheetEnabled\r\n     * @param isBillboardBased\r\n     * @param useRampGradients\r\n     * @hidden\r\n     */\r\n    public static _GetAttributeNamesOrOptions(isAnimationSheetEnabled = false, isBillboardBased = false, useRampGradients = false): string[] {\r\n        const attributeNamesOrOptions = [VertexBuffer.PositionKind, VertexBuffer.ColorKind, \"angle\", \"offset\", \"size\"];\r\n\r\n        if (isAnimationSheetEnabled) {\r\n            attributeNamesOrOptions.push(\"cellIndex\");\r\n        }\r\n\r\n        if (!isBillboardBased) {\r\n            attributeNamesOrOptions.push(\"direction\");\r\n        }\r\n\r\n        if (useRampGradients) {\r\n            attributeNamesOrOptions.push(\"remapData\");\r\n        }\r\n\r\n        return attributeNamesOrOptions;\r\n    }\r\n\r\n    /**\r\n     * @param isAnimationSheetEnabled\r\n     * @hidden\r\n     */\r\n    public static _GetEffectCreationOptions(isAnimationSheetEnabled = false): string[] {\r\n        const effectCreationOption = [\r\n            \"invView\",\r\n            \"view\",\r\n            \"projection\",\r\n            \"vClipPlane\",\r\n            \"vClipPlane2\",\r\n            \"vClipPlane3\",\r\n            \"vClipPlane4\",\r\n            \"vClipPlane5\",\r\n            \"vClipPlane6\",\r\n            \"textureMask\",\r\n            \"translationPivot\",\r\n            \"eyePosition\",\r\n        ];\r\n\r\n        if (isAnimationSheetEnabled) {\r\n            effectCreationOption.push(\"particlesInfos\");\r\n        }\r\n\r\n        return effectCreationOption;\r\n    }\r\n\r\n    /**\r\n     * Fill the defines array according to the current settings of the particle system\r\n     * @param defines Array to be updated\r\n     * @param blendMode blend mode to take into account when updating the array\r\n     */\r\n    public fillDefines(defines: Array<string>, blendMode: number) {\r\n        if (this._scene) {\r\n            if (this._scene.clipPlane) {\r\n                defines.push(\"#define CLIPPLANE\");\r\n            }\r\n\r\n            if (this._scene.clipPlane2) {\r\n                defines.push(\"#define CLIPPLANE2\");\r\n            }\r\n\r\n            if (this._scene.clipPlane3) {\r\n                defines.push(\"#define CLIPPLANE3\");\r\n            }\r\n\r\n            if (this._scene.clipPlane4) {\r\n                defines.push(\"#define CLIPPLANE4\");\r\n            }\r\n\r\n            if (this._scene.clipPlane5) {\r\n                defines.push(\"#define CLIPPLANE5\");\r\n            }\r\n\r\n            if (this._scene.clipPlane6) {\r\n                defines.push(\"#define CLIPPLANE6\");\r\n            }\r\n        }\r\n\r\n        if (this._isAnimationSheetEnabled) {\r\n            defines.push(\"#define ANIMATESHEET\");\r\n        }\r\n\r\n        if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {\r\n            defines.push(\"#define BLENDMULTIPLYMODE\");\r\n        }\r\n\r\n        if (this._useRampGradients) {\r\n            defines.push(\"#define RAMPGRADIENT\");\r\n        }\r\n\r\n        if (this._isBillboardBased) {\r\n            defines.push(\"#define BILLBOARD\");\r\n\r\n            switch (this.billboardMode) {\r\n                case ParticleSystem.BILLBOARDMODE_Y:\r\n                    defines.push(\"#define BILLBOARDY\");\r\n                    break;\r\n                case ParticleSystem.BILLBOARDMODE_STRETCHED:\r\n                    defines.push(\"#define BILLBOARDSTRETCHED\");\r\n                    break;\r\n                case ParticleSystem.BILLBOARDMODE_ALL:\r\n                    defines.push(\"#define BILLBOARDMODE_ALL\");\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);\r\n            defines.push(this._imageProcessingConfigurationDefines.toString());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\r\n     * @param uniforms Uniforms array to fill\r\n     * @param attributes Attributes array to fill\r\n     * @param samplers Samplers array to fill\r\n     */\r\n    public fillUniformsAttributesAndSamplerNames(uniforms: Array<string>, attributes: Array<string>, samplers: Array<string>) {\r\n        attributes.push(\r\n            ...ParticleSystem._GetAttributeNamesOrOptions(\r\n                this._isAnimationSheetEnabled,\r\n                this._isBillboardBased && this.billboardMode !== ParticleSystem.BILLBOARDMODE_STRETCHED,\r\n                this._useRampGradients\r\n            )\r\n        );\r\n\r\n        uniforms.push(...ParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled));\r\n\r\n        samplers.push(\"diffuseSampler\", \"rampSampler\");\r\n\r\n        if (this._imageProcessingConfiguration) {\r\n            ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);\r\n            ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param blendMode\r\n     * @hidden\r\n     */\r\n    private _getWrapper(blendMode: number): DrawWrapper {\r\n        const customWrapper = this._getCustomDrawWrapper(blendMode);\r\n\r\n        if (customWrapper?.effect) {\r\n            return customWrapper;\r\n        }\r\n\r\n        const defines: Array<string> = [];\r\n\r\n        this.fillDefines(defines, blendMode);\r\n\r\n        // Effect\r\n        const currentRenderPassId = this._engine._features.supportRenderPasses ? (this._engine as Engine).currentRenderPassId : Constants.RENDERPASS_MAIN;\r\n        let drawWrappers = this._drawWrappers[currentRenderPassId];\r\n        if (!drawWrappers) {\r\n            drawWrappers = this._drawWrappers[currentRenderPassId] = [];\r\n        }\r\n        let drawWrapper = drawWrappers[blendMode];\r\n        if (!drawWrapper) {\r\n            drawWrapper = new DrawWrapper(this._engine);\r\n            if (drawWrapper.drawContext) {\r\n                drawWrapper.drawContext.useInstancing = this._useInstancing;\r\n            }\r\n            drawWrappers[blendMode] = drawWrapper;\r\n        }\r\n\r\n        const join = defines.join(\"\\n\");\r\n        if (drawWrapper.defines !== join) {\r\n            const attributesNamesOrOptions: Array<string> = [];\r\n            const effectCreationOption: Array<string> = [];\r\n            const samplers: Array<string> = [];\r\n\r\n            this.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, samplers);\r\n\r\n            drawWrapper.setEffect(this._engine.createEffect(\"particles\", attributesNamesOrOptions, effectCreationOption, samplers, join), join);\r\n        }\r\n\r\n        return drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * Animates the particle system for the current frame by emitting new particles and or animating the living ones.\r\n     * @param preWarmOnly will prevent the system from updating the vertex buffer (default is false)\r\n     */\r\n    public animate(preWarmOnly = false): void {\r\n        if (!this._started) {\r\n            return;\r\n        }\r\n\r\n        if (!preWarmOnly && this._scene) {\r\n            // Check\r\n            if (!this.isReady()) {\r\n                return;\r\n            }\r\n\r\n            if (this._currentRenderId === this._scene.getFrameId()) {\r\n                return;\r\n            }\r\n            this._currentRenderId = this._scene.getFrameId();\r\n        }\r\n\r\n        this._scaledUpdateSpeed = this.updateSpeed * (preWarmOnly ? this.preWarmStepOffset : this._scene?.getAnimationRatio() || 1);\r\n\r\n        // Determine the number of particles we need to create\r\n        let newParticles;\r\n\r\n        if (this.manualEmitCount > -1) {\r\n            newParticles = this.manualEmitCount;\r\n            this._newPartsExcess = 0;\r\n            this.manualEmitCount = 0;\r\n        } else {\r\n            let rate = this.emitRate;\r\n\r\n            if (this._emitRateGradients && this._emitRateGradients.length > 0 && this.targetStopDuration) {\r\n                const ratio = this._actualFrame / this.targetStopDuration;\r\n                GradientHelper.GetCurrentGradient(ratio, this._emitRateGradients, (currentGradient, nextGradient, scale) => {\r\n                    if (currentGradient !== this._currentEmitRateGradient) {\r\n                        this._currentEmitRate1 = this._currentEmitRate2;\r\n                        this._currentEmitRate2 = (<FactorGradient>nextGradient).getFactor();\r\n                        this._currentEmitRateGradient = <FactorGradient>currentGradient;\r\n                    }\r\n\r\n                    rate = Scalar.Lerp(this._currentEmitRate1, this._currentEmitRate2, scale);\r\n                });\r\n            }\r\n\r\n            newParticles = (rate * this._scaledUpdateSpeed) >> 0;\r\n            this._newPartsExcess += rate * this._scaledUpdateSpeed - newParticles;\r\n        }\r\n\r\n        if (this._newPartsExcess > 1.0) {\r\n            newParticles += this._newPartsExcess >> 0;\r\n            this._newPartsExcess -= this._newPartsExcess >> 0;\r\n        }\r\n\r\n        this._alive = false;\r\n\r\n        if (!this._stopped) {\r\n            this._actualFrame += this._scaledUpdateSpeed;\r\n\r\n            if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {\r\n                this.stop();\r\n            }\r\n        } else {\r\n            newParticles = 0;\r\n        }\r\n        this._update(newParticles);\r\n\r\n        // Stopped?\r\n        if (this._stopped) {\r\n            if (!this._alive) {\r\n                this._started = false;\r\n                if (this.onAnimationEnd) {\r\n                    this.onAnimationEnd();\r\n                }\r\n                if (this.disposeOnStop && this._scene) {\r\n                    this._scene._toBeDisposed.push(this);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!preWarmOnly) {\r\n            // Update VBO\r\n            let offset = 0;\r\n            for (let index = 0; index < this._particles.length; index++) {\r\n                const particle = this._particles[index];\r\n                this._appendParticleVertices(offset, particle);\r\n                offset += this._useInstancing ? 1 : 4;\r\n            }\r\n\r\n            if (this._vertexBuffer) {\r\n                this._vertexBuffer.updateDirectly(this._vertexData, 0, this._particles.length);\r\n            }\r\n        }\r\n\r\n        if (this.manualEmitCount === 0 && this.disposeOnStop) {\r\n            this.stop();\r\n        }\r\n    }\r\n\r\n    private _appendParticleVertices(offset: number, particle: Particle) {\r\n        this._appendParticleVertex(offset++, particle, 0, 0);\r\n        if (!this._useInstancing) {\r\n            this._appendParticleVertex(offset++, particle, 1, 0);\r\n            this._appendParticleVertex(offset++, particle, 1, 1);\r\n            this._appendParticleVertex(offset++, particle, 0, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the particle system.\r\n     */\r\n    public rebuild(): void {\r\n        if (this._engine.getCaps().vertexArrayObject) {\r\n            this._vertexArrayObject = null;\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n\r\n        this._spriteBuffer?._rebuild();\r\n\r\n        this._vertexBuffer?._rebuild();\r\n\r\n        for (const key in this._vertexBuffers) {\r\n            this._vertexBuffers[key]._rebuild();\r\n        }\r\n\r\n        this.resetDrawCache();\r\n    }\r\n\r\n    /**\r\n     * Is this system ready to be used/rendered\r\n     * @return true if the system is ready\r\n     */\r\n    public isReady(): boolean {\r\n        if (!this.emitter || (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady()) || !this.particleTexture || !this.particleTexture.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {\r\n            if (!this._getWrapper(this.blendMode).effect!.isReady()) {\r\n                return false;\r\n            }\r\n        } else {\r\n            if (!this._getWrapper(ParticleSystem.BLENDMODE_MULTIPLY).effect!.isReady()) {\r\n                return false;\r\n            }\r\n            if (!this._getWrapper(ParticleSystem.BLENDMODE_ADD).effect!.isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _render(blendMode: number) {\r\n        const drawWrapper = this._getWrapper(blendMode);\r\n        const effect = drawWrapper.effect!;\r\n\r\n        const engine = this._engine;\r\n\r\n        // Render\r\n        engine.enableEffect(drawWrapper);\r\n\r\n        const viewMatrix = this.defaultViewMatrix ?? this._scene!.getViewMatrix();\r\n        effect.setTexture(\"diffuseSampler\", this.particleTexture);\r\n        effect.setMatrix(\"view\", viewMatrix);\r\n        effect.setMatrix(\"projection\", this.defaultProjectionMatrix ?? this._scene!.getProjectionMatrix());\r\n\r\n        if (this._isAnimationSheetEnabled && this.particleTexture) {\r\n            const baseSize = this.particleTexture.getBaseSize();\r\n            effect.setFloat3(\"particlesInfos\", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, this.spriteCellWidth / baseSize.width);\r\n        }\r\n\r\n        effect.setVector2(\"translationPivot\", this.translationPivot);\r\n        effect.setFloat4(\"textureMask\", this.textureMask.r, this.textureMask.g, this.textureMask.b, this.textureMask.a);\r\n\r\n        if (this._isBillboardBased && this._scene) {\r\n            const camera = this._scene.activeCamera!;\r\n            effect.setVector3(\"eyePosition\", camera.globalPosition);\r\n        }\r\n\r\n        if (this._rampGradientsTexture) {\r\n            if (!this._rampGradients || !this._rampGradients.length) {\r\n                this._rampGradientsTexture.dispose();\r\n                this._rampGradientsTexture = null;\r\n            }\r\n            effect.setTexture(\"rampSampler\", this._rampGradientsTexture);\r\n        }\r\n\r\n        const defines = effect.defines;\r\n\r\n        if (this._scene) {\r\n            if (this._scene.clipPlane || this._scene.clipPlane2 || this._scene.clipPlane3 || this._scene.clipPlane4 || this._scene.clipPlane5 || this._scene.clipPlane6) {\r\n                ThinMaterialHelper.BindClipPlane(effect, this._scene);\r\n            }\r\n        }\r\n\r\n        if (defines.indexOf(\"#define BILLBOARDMODE_ALL\") >= 0) {\r\n            viewMatrix.invertToRef(TmpVectors.Matrix[0]);\r\n            effect.setMatrix(\"invView\", TmpVectors.Matrix[0]);\r\n        }\r\n\r\n        if (this._vertexArrayObject !== undefined) {\r\n            if (!this._vertexArrayObject) {\r\n                this._vertexArrayObject = this._engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);\r\n            }\r\n\r\n            this._engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);\r\n        } else {\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\r\n        }\r\n\r\n        // image processing\r\n        if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\r\n            this._imageProcessingConfiguration.bind(effect);\r\n        }\r\n\r\n        // Draw order\r\n        switch (blendMode) {\r\n            case ParticleSystem.BLENDMODE_ADD:\r\n                engine.setAlphaMode(Constants.ALPHA_ADD);\r\n                break;\r\n            case ParticleSystem.BLENDMODE_ONEONE:\r\n                engine.setAlphaMode(Constants.ALPHA_ONEONE);\r\n                break;\r\n            case ParticleSystem.BLENDMODE_STANDARD:\r\n                engine.setAlphaMode(Constants.ALPHA_COMBINE);\r\n                break;\r\n            case ParticleSystem.BLENDMODE_MULTIPLY:\r\n                engine.setAlphaMode(Constants.ALPHA_MULTIPLY);\r\n                break;\r\n        }\r\n\r\n        if (this._onBeforeDrawParticlesObservable) {\r\n            this._onBeforeDrawParticlesObservable.notifyObservers(effect);\r\n        }\r\n\r\n        if (this._useInstancing) {\r\n            engine.drawArraysType(Constants.MATERIAL_TriangleStripDrawMode, 0, 4, this._particles.length);\r\n        } else {\r\n            engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, this._particles.length * 6);\r\n        }\r\n\r\n        return this._particles.length;\r\n    }\r\n\r\n    /**\r\n     * Renders the particle system in its current state.\r\n     * @returns the current number of particles\r\n     */\r\n    public render(): number {\r\n        // Check\r\n        if (!this.isReady() || !this._particles.length) {\r\n            return 0;\r\n        }\r\n\r\n        const engine = this._engine as any;\r\n        if (engine.setState) {\r\n            engine.setState(false);\r\n\r\n            if (this.forceDepthWrite) {\r\n                engine.setDepthWrite(true);\r\n            }\r\n        }\r\n\r\n        let outparticles = 0;\r\n\r\n        if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {\r\n            outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY) + this._render(ParticleSystem.BLENDMODE_ADD);\r\n        } else {\r\n            outparticles = this._render(this.blendMode);\r\n        }\r\n\r\n        this._engine.unbindInstanceAttributes();\r\n        this._engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n\r\n        return outparticles;\r\n    }\r\n\r\n    /**\r\n     * Disposes the particle system and free the associated resources\r\n     * @param disposeTexture defines if the particle texture must be disposed as well (true by default)\r\n     */\r\n    public dispose(disposeTexture = true): void {\r\n        this.resetDrawCache();\r\n\r\n        if (this._vertexBuffer) {\r\n            this._vertexBuffer.dispose();\r\n            this._vertexBuffer = null;\r\n        }\r\n\r\n        if (this._spriteBuffer) {\r\n            this._spriteBuffer.dispose();\r\n            this._spriteBuffer = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        if (this._vertexArrayObject) {\r\n            this._engine.releaseVertexArrayObject(this._vertexArrayObject);\r\n            this._vertexArrayObject = null;\r\n        }\r\n\r\n        if (disposeTexture && this.particleTexture) {\r\n            this.particleTexture.dispose();\r\n            this.particleTexture = null;\r\n        }\r\n\r\n        if (disposeTexture && this.noiseTexture) {\r\n            this.noiseTexture.dispose();\r\n            this.noiseTexture = null;\r\n        }\r\n\r\n        if (this._rampGradientsTexture) {\r\n            this._rampGradientsTexture.dispose();\r\n            this._rampGradientsTexture = null;\r\n        }\r\n\r\n        this._removeFromRoot();\r\n\r\n        if (this.subEmitters && !this._subEmitters) {\r\n            this._prepareSubEmitterInternalArray();\r\n        }\r\n\r\n        if (this._subEmitters && this._subEmitters.length) {\r\n            for (let index = 0; index < this._subEmitters.length; index++) {\r\n                for (const subEmitter of this._subEmitters[index]) {\r\n                    subEmitter.dispose();\r\n                }\r\n            }\r\n\r\n            this._subEmitters = [];\r\n            this.subEmitters = [];\r\n        }\r\n\r\n        if (this._disposeEmitterOnDispose && this.emitter && (this.emitter as AbstractMesh).dispose) {\r\n            (<AbstractMesh>this.emitter).dispose(true);\r\n        }\r\n\r\n        if (this._onBeforeDrawParticlesObservable) {\r\n            this._onBeforeDrawParticlesObservable.clear();\r\n        }\r\n\r\n        // Remove from scene\r\n        if (this._scene) {\r\n            const index = this._scene.particleSystems.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene.particleSystems.splice(index, 1);\r\n            }\r\n\r\n            this._scene._activeParticleSystems.dispose();\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n        this.onStoppedObservable.clear();\r\n\r\n        this.reset();\r\n    }\r\n\r\n    // Clone\r\n    /**\r\n     * Clones the particle system.\r\n     * @param name The name of the cloned object\r\n     * @param newEmitter The new emitter to use\r\n     * @returns the cloned particle system\r\n     */\r\n    public clone(name: string, newEmitter: any): ParticleSystem {\r\n        const custom = { ...this._customWrappers };\r\n        let program: any = null;\r\n        const engine = this._engine as Engine;\r\n        if (engine.createEffectForParticles) {\r\n            if (this.customShader != null) {\r\n                program = this.customShader;\r\n                const defines: string = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\r\n                const effect = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\r\n                if (!custom[0]) {\r\n                    this.setCustomEffect(effect, 0);\r\n                } else {\r\n                    custom[0].effect = effect;\r\n                }\r\n            }\r\n        }\r\n\r\n        const serialization = this.serialize();\r\n        const result = ParticleSystem.Parse(serialization, this._scene || this._engine, this._rootUrl);\r\n        result.name = name;\r\n        result.customShader = program;\r\n        result._customWrappers = custom;\r\n\r\n        if (newEmitter === undefined) {\r\n            newEmitter = this.emitter;\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            result.noiseTexture = this.noiseTexture.clone();\r\n        }\r\n\r\n        result.emitter = newEmitter;\r\n        if (!this.preventAutoStart) {\r\n            result.start();\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object\r\n     * @param serializeTexture defines if the texture must be serialized as well\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(serializeTexture = false): any {\r\n        const serializationObject: any = {};\r\n\r\n        ParticleSystem._Serialize(serializationObject, this, serializeTexture);\r\n\r\n        serializationObject.textureMask = this.textureMask.asArray();\r\n        serializationObject.customShader = this.customShader;\r\n        serializationObject.preventAutoStart = this.preventAutoStart;\r\n\r\n        // SubEmitters\r\n        if (this.subEmitters) {\r\n            serializationObject.subEmitters = [];\r\n\r\n            if (!this._subEmitters) {\r\n                this._prepareSubEmitterInternalArray();\r\n            }\r\n\r\n            for (const subs of this._subEmitters) {\r\n                const cell = [];\r\n                for (const sub of subs) {\r\n                    cell.push(sub.serialize(serializeTexture));\r\n                }\r\n\r\n                serializationObject.subEmitters.push(cell);\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * @param serializationObject\r\n     * @param particleSystem\r\n     * @param serializeTexture\r\n     * @hidden\r\n     */\r\n    public static _Serialize(serializationObject: any, particleSystem: IParticleSystem, serializeTexture: boolean) {\r\n        serializationObject.name = particleSystem.name;\r\n        serializationObject.id = particleSystem.id;\r\n\r\n        serializationObject.capacity = particleSystem.getCapacity();\r\n\r\n        serializationObject.disposeOnStop = particleSystem.disposeOnStop;\r\n        serializationObject.manualEmitCount = particleSystem.manualEmitCount;\r\n\r\n        // Emitter\r\n        if ((<AbstractMesh>particleSystem.emitter).position) {\r\n            const emitterMesh = <AbstractMesh>particleSystem.emitter;\r\n            serializationObject.emitterId = emitterMesh.id;\r\n        } else {\r\n            const emitterPosition = <Vector3>particleSystem.emitter;\r\n            serializationObject.emitter = emitterPosition.asArray();\r\n        }\r\n\r\n        // Emitter\r\n        if (particleSystem.particleEmitterType) {\r\n            serializationObject.particleEmitterType = particleSystem.particleEmitterType.serialize();\r\n        }\r\n\r\n        if (particleSystem.particleTexture) {\r\n            if (serializeTexture) {\r\n                serializationObject.texture = particleSystem.particleTexture.serialize();\r\n            } else {\r\n                serializationObject.textureName = particleSystem.particleTexture.name;\r\n                serializationObject.invertY = !!(particleSystem.particleTexture as any)._invertY;\r\n            }\r\n        }\r\n\r\n        serializationObject.isLocal = particleSystem.isLocal;\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(particleSystem, serializationObject);\r\n        serializationObject.beginAnimationOnStart = particleSystem.beginAnimationOnStart;\r\n        serializationObject.beginAnimationFrom = particleSystem.beginAnimationFrom;\r\n        serializationObject.beginAnimationTo = particleSystem.beginAnimationTo;\r\n        serializationObject.beginAnimationLoop = particleSystem.beginAnimationLoop;\r\n\r\n        // Particle system\r\n        serializationObject.startDelay = particleSystem.startDelay;\r\n        serializationObject.renderingGroupId = particleSystem.renderingGroupId;\r\n        serializationObject.isBillboardBased = particleSystem.isBillboardBased;\r\n        serializationObject.billboardMode = particleSystem.billboardMode;\r\n        serializationObject.minAngularSpeed = particleSystem.minAngularSpeed;\r\n        serializationObject.maxAngularSpeed = particleSystem.maxAngularSpeed;\r\n        serializationObject.minSize = particleSystem.minSize;\r\n        serializationObject.maxSize = particleSystem.maxSize;\r\n        serializationObject.minScaleX = particleSystem.minScaleX;\r\n        serializationObject.maxScaleX = particleSystem.maxScaleX;\r\n        serializationObject.minScaleY = particleSystem.minScaleY;\r\n        serializationObject.maxScaleY = particleSystem.maxScaleY;\r\n        serializationObject.minEmitPower = particleSystem.minEmitPower;\r\n        serializationObject.maxEmitPower = particleSystem.maxEmitPower;\r\n        serializationObject.minLifeTime = particleSystem.minLifeTime;\r\n        serializationObject.maxLifeTime = particleSystem.maxLifeTime;\r\n        serializationObject.emitRate = particleSystem.emitRate;\r\n        serializationObject.gravity = particleSystem.gravity.asArray();\r\n        serializationObject.noiseStrength = particleSystem.noiseStrength.asArray();\r\n        serializationObject.color1 = particleSystem.color1.asArray();\r\n        serializationObject.color2 = particleSystem.color2.asArray();\r\n        serializationObject.colorDead = particleSystem.colorDead.asArray();\r\n        serializationObject.updateSpeed = particleSystem.updateSpeed;\r\n        serializationObject.targetStopDuration = particleSystem.targetStopDuration;\r\n        serializationObject.blendMode = particleSystem.blendMode;\r\n        serializationObject.preWarmCycles = particleSystem.preWarmCycles;\r\n        serializationObject.preWarmStepOffset = particleSystem.preWarmStepOffset;\r\n        serializationObject.minInitialRotation = particleSystem.minInitialRotation;\r\n        serializationObject.maxInitialRotation = particleSystem.maxInitialRotation;\r\n        serializationObject.startSpriteCellID = particleSystem.startSpriteCellID;\r\n        serializationObject.spriteCellLoop = particleSystem.spriteCellLoop;\r\n        serializationObject.endSpriteCellID = particleSystem.endSpriteCellID;\r\n        serializationObject.spriteCellChangeSpeed = particleSystem.spriteCellChangeSpeed;\r\n        serializationObject.spriteCellWidth = particleSystem.spriteCellWidth;\r\n        serializationObject.spriteCellHeight = particleSystem.spriteCellHeight;\r\n        serializationObject.spriteRandomStartCell = particleSystem.spriteRandomStartCell;\r\n        serializationObject.isAnimationSheetEnabled = particleSystem.isAnimationSheetEnabled;\r\n\r\n        const colorGradients = particleSystem.getColorGradients();\r\n        if (colorGradients) {\r\n            serializationObject.colorGradients = [];\r\n            for (const colorGradient of colorGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: colorGradient.gradient,\r\n                    color1: colorGradient.color1.asArray(),\r\n                };\r\n\r\n                if (colorGradient.color2) {\r\n                    serializedGradient.color2 = colorGradient.color2.asArray();\r\n                } else {\r\n                    serializedGradient.color2 = colorGradient.color1.asArray();\r\n                }\r\n\r\n                serializationObject.colorGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const rampGradients = particleSystem.getRampGradients();\r\n        if (rampGradients) {\r\n            serializationObject.rampGradients = [];\r\n            for (const rampGradient of rampGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: rampGradient.gradient,\r\n                    color: rampGradient.color.asArray(),\r\n                };\r\n\r\n                serializationObject.rampGradients.push(serializedGradient);\r\n            }\r\n            serializationObject.useRampGradients = particleSystem.useRampGradients;\r\n        }\r\n\r\n        const colorRemapGradients = particleSystem.getColorRemapGradients();\r\n        if (colorRemapGradients) {\r\n            serializationObject.colorRemapGradients = [];\r\n            for (const colorRemapGradient of colorRemapGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: colorRemapGradient.gradient,\r\n                    factor1: colorRemapGradient.factor1,\r\n                };\r\n\r\n                if (colorRemapGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = colorRemapGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = colorRemapGradient.factor1;\r\n                }\r\n\r\n                serializationObject.colorRemapGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const alphaRemapGradients = particleSystem.getAlphaRemapGradients();\r\n        if (alphaRemapGradients) {\r\n            serializationObject.alphaRemapGradients = [];\r\n            for (const alphaRemapGradient of alphaRemapGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: alphaRemapGradient.gradient,\r\n                    factor1: alphaRemapGradient.factor1,\r\n                };\r\n\r\n                if (alphaRemapGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = alphaRemapGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = alphaRemapGradient.factor1;\r\n                }\r\n\r\n                serializationObject.alphaRemapGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const sizeGradients = particleSystem.getSizeGradients();\r\n        if (sizeGradients) {\r\n            serializationObject.sizeGradients = [];\r\n            for (const sizeGradient of sizeGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: sizeGradient.gradient,\r\n                    factor1: sizeGradient.factor1,\r\n                };\r\n\r\n                if (sizeGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = sizeGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = sizeGradient.factor1;\r\n                }\r\n\r\n                serializationObject.sizeGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const angularSpeedGradients = particleSystem.getAngularSpeedGradients();\r\n        if (angularSpeedGradients) {\r\n            serializationObject.angularSpeedGradients = [];\r\n            for (const angularSpeedGradient of angularSpeedGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: angularSpeedGradient.gradient,\r\n                    factor1: angularSpeedGradient.factor1,\r\n                };\r\n\r\n                if (angularSpeedGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = angularSpeedGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = angularSpeedGradient.factor1;\r\n                }\r\n\r\n                serializationObject.angularSpeedGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const velocityGradients = particleSystem.getVelocityGradients();\r\n        if (velocityGradients) {\r\n            serializationObject.velocityGradients = [];\r\n            for (const velocityGradient of velocityGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: velocityGradient.gradient,\r\n                    factor1: velocityGradient.factor1,\r\n                };\r\n\r\n                if (velocityGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = velocityGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = velocityGradient.factor1;\r\n                }\r\n\r\n                serializationObject.velocityGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const dragGradients = particleSystem.getDragGradients();\r\n        if (dragGradients) {\r\n            serializationObject.dragGradients = [];\r\n            for (const dragGradient of dragGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: dragGradient.gradient,\r\n                    factor1: dragGradient.factor1,\r\n                };\r\n\r\n                if (dragGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = dragGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = dragGradient.factor1;\r\n                }\r\n\r\n                serializationObject.dragGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const emitRateGradients = particleSystem.getEmitRateGradients();\r\n        if (emitRateGradients) {\r\n            serializationObject.emitRateGradients = [];\r\n            for (const emitRateGradient of emitRateGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: emitRateGradient.gradient,\r\n                    factor1: emitRateGradient.factor1,\r\n                };\r\n\r\n                if (emitRateGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = emitRateGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = emitRateGradient.factor1;\r\n                }\r\n\r\n                serializationObject.emitRateGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const startSizeGradients = particleSystem.getStartSizeGradients();\r\n        if (startSizeGradients) {\r\n            serializationObject.startSizeGradients = [];\r\n            for (const startSizeGradient of startSizeGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: startSizeGradient.gradient,\r\n                    factor1: startSizeGradient.factor1,\r\n                };\r\n\r\n                if (startSizeGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = startSizeGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = startSizeGradient.factor1;\r\n                }\r\n\r\n                serializationObject.startSizeGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const lifeTimeGradients = particleSystem.getLifeTimeGradients();\r\n        if (lifeTimeGradients) {\r\n            serializationObject.lifeTimeGradients = [];\r\n            for (const lifeTimeGradient of lifeTimeGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: lifeTimeGradient.gradient,\r\n                    factor1: lifeTimeGradient.factor1,\r\n                };\r\n\r\n                if (lifeTimeGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = lifeTimeGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = lifeTimeGradient.factor1;\r\n                }\r\n\r\n                serializationObject.lifeTimeGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const limitVelocityGradients = particleSystem.getLimitVelocityGradients();\r\n        if (limitVelocityGradients) {\r\n            serializationObject.limitVelocityGradients = [];\r\n            for (const limitVelocityGradient of limitVelocityGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: limitVelocityGradient.gradient,\r\n                    factor1: limitVelocityGradient.factor1,\r\n                };\r\n\r\n                if (limitVelocityGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = limitVelocityGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = limitVelocityGradient.factor1;\r\n                }\r\n\r\n                serializationObject.limitVelocityGradients.push(serializedGradient);\r\n            }\r\n\r\n            serializationObject.limitVelocityDamping = particleSystem.limitVelocityDamping;\r\n        }\r\n\r\n        if (particleSystem.noiseTexture) {\r\n            serializationObject.noiseTexture = particleSystem.noiseTexture.serialize();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param parsedParticleSystem\r\n     * @param particleSystem\r\n     * @param sceneOrEngine\r\n     * @param rootUrl\r\n     * @hidden\r\n     */\r\n    public static _Parse(parsedParticleSystem: any, particleSystem: IParticleSystem, sceneOrEngine: Scene | ThinEngine, rootUrl: string) {\r\n        let scene: Nullable<Scene>;\r\n\r\n        if (sceneOrEngine instanceof ThinEngine) {\r\n            scene = null;\r\n        } else {\r\n            scene = sceneOrEngine as Scene;\r\n        }\r\n\r\n        const internalClass = GetClass(\"BABYLON.Texture\");\r\n        if (internalClass && scene) {\r\n            // Texture\r\n            if (parsedParticleSystem.texture) {\r\n                particleSystem.particleTexture = internalClass.Parse(parsedParticleSystem.texture, scene, rootUrl) as BaseTexture;\r\n            } else if (parsedParticleSystem.textureName) {\r\n                particleSystem.particleTexture = new internalClass(\r\n                    rootUrl + parsedParticleSystem.textureName,\r\n                    scene,\r\n                    false,\r\n                    parsedParticleSystem.invertY !== undefined ? parsedParticleSystem.invertY : true\r\n                );\r\n                particleSystem.particleTexture!.name = parsedParticleSystem.textureName;\r\n            }\r\n        }\r\n\r\n        // Emitter\r\n        if (!parsedParticleSystem.emitterId && parsedParticleSystem.emitterId !== 0 && parsedParticleSystem.emitter === undefined) {\r\n            particleSystem.emitter = Vector3.Zero();\r\n        } else if (parsedParticleSystem.emitterId && scene) {\r\n            particleSystem.emitter = scene.getLastMeshById(parsedParticleSystem.emitterId);\r\n        } else {\r\n            particleSystem.emitter = Vector3.FromArray(parsedParticleSystem.emitter);\r\n        }\r\n\r\n        particleSystem.isLocal = !!parsedParticleSystem.isLocal;\r\n\r\n        // Misc.\r\n        if (parsedParticleSystem.renderingGroupId !== undefined) {\r\n            particleSystem.renderingGroupId = parsedParticleSystem.renderingGroupId;\r\n        }\r\n\r\n        if (parsedParticleSystem.isBillboardBased !== undefined) {\r\n            particleSystem.isBillboardBased = parsedParticleSystem.isBillboardBased;\r\n        }\r\n\r\n        if (parsedParticleSystem.billboardMode !== undefined) {\r\n            particleSystem.billboardMode = parsedParticleSystem.billboardMode;\r\n        }\r\n\r\n        // Animations\r\n        if (parsedParticleSystem.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedParticleSystem.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedParticleSystem.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    particleSystem.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n            particleSystem.beginAnimationOnStart = parsedParticleSystem.beginAnimationOnStart;\r\n            particleSystem.beginAnimationFrom = parsedParticleSystem.beginAnimationFrom;\r\n            particleSystem.beginAnimationTo = parsedParticleSystem.beginAnimationTo;\r\n            particleSystem.beginAnimationLoop = parsedParticleSystem.beginAnimationLoop;\r\n        }\r\n\r\n        if (parsedParticleSystem.autoAnimate && scene) {\r\n            scene.beginAnimation(\r\n                particleSystem,\r\n                parsedParticleSystem.autoAnimateFrom,\r\n                parsedParticleSystem.autoAnimateTo,\r\n                parsedParticleSystem.autoAnimateLoop,\r\n                parsedParticleSystem.autoAnimateSpeed || 1.0\r\n            );\r\n        }\r\n\r\n        // Particle system\r\n        particleSystem.startDelay = parsedParticleSystem.startDelay | 0;\r\n        particleSystem.minAngularSpeed = parsedParticleSystem.minAngularSpeed;\r\n        particleSystem.maxAngularSpeed = parsedParticleSystem.maxAngularSpeed;\r\n        particleSystem.minSize = parsedParticleSystem.minSize;\r\n        particleSystem.maxSize = parsedParticleSystem.maxSize;\r\n\r\n        if (parsedParticleSystem.minScaleX) {\r\n            particleSystem.minScaleX = parsedParticleSystem.minScaleX;\r\n            particleSystem.maxScaleX = parsedParticleSystem.maxScaleX;\r\n            particleSystem.minScaleY = parsedParticleSystem.minScaleY;\r\n            particleSystem.maxScaleY = parsedParticleSystem.maxScaleY;\r\n        }\r\n\r\n        if (parsedParticleSystem.preWarmCycles !== undefined) {\r\n            particleSystem.preWarmCycles = parsedParticleSystem.preWarmCycles;\r\n            particleSystem.preWarmStepOffset = parsedParticleSystem.preWarmStepOffset;\r\n        }\r\n\r\n        if (parsedParticleSystem.minInitialRotation !== undefined) {\r\n            particleSystem.minInitialRotation = parsedParticleSystem.minInitialRotation;\r\n            particleSystem.maxInitialRotation = parsedParticleSystem.maxInitialRotation;\r\n        }\r\n\r\n        particleSystem.minLifeTime = parsedParticleSystem.minLifeTime;\r\n        particleSystem.maxLifeTime = parsedParticleSystem.maxLifeTime;\r\n        particleSystem.minEmitPower = parsedParticleSystem.minEmitPower;\r\n        particleSystem.maxEmitPower = parsedParticleSystem.maxEmitPower;\r\n        particleSystem.emitRate = parsedParticleSystem.emitRate;\r\n        particleSystem.gravity = Vector3.FromArray(parsedParticleSystem.gravity);\r\n        if (parsedParticleSystem.noiseStrength) {\r\n            particleSystem.noiseStrength = Vector3.FromArray(parsedParticleSystem.noiseStrength);\r\n        }\r\n        particleSystem.color1 = Color4.FromArray(parsedParticleSystem.color1);\r\n        particleSystem.color2 = Color4.FromArray(parsedParticleSystem.color2);\r\n        particleSystem.colorDead = Color4.FromArray(parsedParticleSystem.colorDead);\r\n        particleSystem.updateSpeed = parsedParticleSystem.updateSpeed;\r\n        particleSystem.targetStopDuration = parsedParticleSystem.targetStopDuration;\r\n        particleSystem.blendMode = parsedParticleSystem.blendMode;\r\n\r\n        if (parsedParticleSystem.colorGradients) {\r\n            for (const colorGradient of parsedParticleSystem.colorGradients) {\r\n                particleSystem.addColorGradient(\r\n                    colorGradient.gradient,\r\n                    Color4.FromArray(colorGradient.color1),\r\n                    colorGradient.color2 ? Color4.FromArray(colorGradient.color2) : undefined\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.rampGradients) {\r\n            for (const rampGradient of parsedParticleSystem.rampGradients) {\r\n                particleSystem.addRampGradient(rampGradient.gradient, Color3.FromArray(rampGradient.color));\r\n            }\r\n            particleSystem.useRampGradients = parsedParticleSystem.useRampGradients;\r\n        }\r\n\r\n        if (parsedParticleSystem.colorRemapGradients) {\r\n            for (const colorRemapGradient of parsedParticleSystem.colorRemapGradients) {\r\n                particleSystem.addColorRemapGradient(\r\n                    colorRemapGradient.gradient,\r\n                    colorRemapGradient.factor1 !== undefined ? colorRemapGradient.factor1 : colorRemapGradient.factor,\r\n                    colorRemapGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.alphaRemapGradients) {\r\n            for (const alphaRemapGradient of parsedParticleSystem.alphaRemapGradients) {\r\n                particleSystem.addAlphaRemapGradient(\r\n                    alphaRemapGradient.gradient,\r\n                    alphaRemapGradient.factor1 !== undefined ? alphaRemapGradient.factor1 : alphaRemapGradient.factor,\r\n                    alphaRemapGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.sizeGradients) {\r\n            for (const sizeGradient of parsedParticleSystem.sizeGradients) {\r\n                particleSystem.addSizeGradient(sizeGradient.gradient, sizeGradient.factor1 !== undefined ? sizeGradient.factor1 : sizeGradient.factor, sizeGradient.factor2);\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.angularSpeedGradients) {\r\n            for (const angularSpeedGradient of parsedParticleSystem.angularSpeedGradients) {\r\n                particleSystem.addAngularSpeedGradient(\r\n                    angularSpeedGradient.gradient,\r\n                    angularSpeedGradient.factor1 !== undefined ? angularSpeedGradient.factor1 : angularSpeedGradient.factor,\r\n                    angularSpeedGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.velocityGradients) {\r\n            for (const velocityGradient of parsedParticleSystem.velocityGradients) {\r\n                particleSystem.addVelocityGradient(\r\n                    velocityGradient.gradient,\r\n                    velocityGradient.factor1 !== undefined ? velocityGradient.factor1 : velocityGradient.factor,\r\n                    velocityGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.dragGradients) {\r\n            for (const dragGradient of parsedParticleSystem.dragGradients) {\r\n                particleSystem.addDragGradient(dragGradient.gradient, dragGradient.factor1 !== undefined ? dragGradient.factor1 : dragGradient.factor, dragGradient.factor2);\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.emitRateGradients) {\r\n            for (const emitRateGradient of parsedParticleSystem.emitRateGradients) {\r\n                particleSystem.addEmitRateGradient(\r\n                    emitRateGradient.gradient,\r\n                    emitRateGradient.factor1 !== undefined ? emitRateGradient.factor1 : emitRateGradient.factor,\r\n                    emitRateGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.startSizeGradients) {\r\n            for (const startSizeGradient of parsedParticleSystem.startSizeGradients) {\r\n                particleSystem.addStartSizeGradient(\r\n                    startSizeGradient.gradient,\r\n                    startSizeGradient.factor1 !== undefined ? startSizeGradient.factor1 : startSizeGradient.factor,\r\n                    startSizeGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.lifeTimeGradients) {\r\n            for (const lifeTimeGradient of parsedParticleSystem.lifeTimeGradients) {\r\n                particleSystem.addLifeTimeGradient(\r\n                    lifeTimeGradient.gradient,\r\n                    lifeTimeGradient.factor1 !== undefined ? lifeTimeGradient.factor1 : lifeTimeGradient.factor,\r\n                    lifeTimeGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.limitVelocityGradients) {\r\n            for (const limitVelocityGradient of parsedParticleSystem.limitVelocityGradients) {\r\n                particleSystem.addLimitVelocityGradient(\r\n                    limitVelocityGradient.gradient,\r\n                    limitVelocityGradient.factor1 !== undefined ? limitVelocityGradient.factor1 : limitVelocityGradient.factor,\r\n                    limitVelocityGradient.factor2\r\n                );\r\n            }\r\n            particleSystem.limitVelocityDamping = parsedParticleSystem.limitVelocityDamping;\r\n        }\r\n\r\n        if (parsedParticleSystem.noiseTexture && scene) {\r\n            const internalClass = GetClass(\"BABYLON.ProceduralTexture\");\r\n            particleSystem.noiseTexture = internalClass.Parse(parsedParticleSystem.noiseTexture, scene, rootUrl);\r\n        }\r\n\r\n        // Emitter\r\n        let emitterType: IParticleEmitterType;\r\n        if (parsedParticleSystem.particleEmitterType) {\r\n            switch (parsedParticleSystem.particleEmitterType.type) {\r\n                case \"SphereParticleEmitter\":\r\n                    emitterType = new SphereParticleEmitter();\r\n                    break;\r\n                case \"SphereDirectedParticleEmitter\":\r\n                    emitterType = new SphereDirectedParticleEmitter();\r\n                    break;\r\n                case \"ConeEmitter\":\r\n                case \"ConeParticleEmitter\":\r\n                    emitterType = new ConeParticleEmitter();\r\n                    break;\r\n                case \"CylinderParticleEmitter\":\r\n                    emitterType = new CylinderParticleEmitter();\r\n                    break;\r\n                case \"CylinderDirectedParticleEmitter\":\r\n                    emitterType = new CylinderDirectedParticleEmitter();\r\n                    break;\r\n                case \"HemisphericParticleEmitter\":\r\n                    emitterType = new HemisphericParticleEmitter();\r\n                    break;\r\n                case \"PointParticleEmitter\":\r\n                    emitterType = new PointParticleEmitter();\r\n                    break;\r\n                case \"MeshParticleEmitter\":\r\n                    emitterType = new MeshParticleEmitter();\r\n                    break;\r\n                case \"BoxEmitter\":\r\n                case \"BoxParticleEmitter\":\r\n                default:\r\n                    emitterType = new BoxParticleEmitter();\r\n                    break;\r\n            }\r\n\r\n            emitterType.parse(parsedParticleSystem.particleEmitterType, scene);\r\n        } else {\r\n            emitterType = new BoxParticleEmitter();\r\n            emitterType.parse(parsedParticleSystem, scene);\r\n        }\r\n        particleSystem.particleEmitterType = emitterType;\r\n\r\n        // Animation sheet\r\n        particleSystem.startSpriteCellID = parsedParticleSystem.startSpriteCellID;\r\n        particleSystem.endSpriteCellID = parsedParticleSystem.endSpriteCellID;\r\n        particleSystem.spriteCellLoop = parsedParticleSystem.spriteCellLoop ?? true;\r\n        particleSystem.spriteCellWidth = parsedParticleSystem.spriteCellWidth;\r\n        particleSystem.spriteCellHeight = parsedParticleSystem.spriteCellHeight;\r\n        particleSystem.spriteCellChangeSpeed = parsedParticleSystem.spriteCellChangeSpeed;\r\n        particleSystem.spriteRandomStartCell = parsedParticleSystem.spriteRandomStartCell;\r\n\r\n        particleSystem.disposeOnStop = parsedParticleSystem.disposeOnStop ?? false;\r\n        particleSystem.manualEmitCount = parsedParticleSystem.manualEmitCount ?? -1;\r\n    }\r\n\r\n    /**\r\n     * Parses a JSON object to create a particle system.\r\n     * @param parsedParticleSystem The JSON object to parse\r\n     * @param sceneOrEngine The scene or the engine to create the particle system in\r\n     * @param rootUrl The root url to use to load external dependencies like texture\r\n     * @param doNotStart Ignore the preventAutoStart attribute and does not start\r\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\r\n     * @returns the Parsed particle system\r\n     */\r\n    public static Parse(parsedParticleSystem: any, sceneOrEngine: Scene | ThinEngine, rootUrl: string, doNotStart = false, capacity?: number): ParticleSystem {\r\n        const name = parsedParticleSystem.name;\r\n        let custom: Nullable<Effect> = null;\r\n        let program: any = null;\r\n        let engine: ThinEngine;\r\n        let scene: Nullable<Scene>;\r\n\r\n        if (sceneOrEngine instanceof ThinEngine) {\r\n            engine = sceneOrEngine;\r\n        } else {\r\n            scene = sceneOrEngine as Scene;\r\n            engine = scene.getEngine();\r\n        }\r\n\r\n        if (parsedParticleSystem.customShader && (engine as any).createEffectForParticles) {\r\n            program = parsedParticleSystem.customShader;\r\n            const defines: string = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\r\n            custom = (engine as any).createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\r\n        }\r\n        const particleSystem = new ParticleSystem(name, capacity || parsedParticleSystem.capacity, sceneOrEngine, custom, parsedParticleSystem.isAnimationSheetEnabled);\r\n        particleSystem.customShader = program;\r\n        particleSystem._rootUrl = rootUrl;\r\n\r\n        if (parsedParticleSystem.id) {\r\n            particleSystem.id = parsedParticleSystem.id;\r\n        }\r\n\r\n        // SubEmitters\r\n        if (parsedParticleSystem.subEmitters) {\r\n            particleSystem.subEmitters = [];\r\n            for (const cell of parsedParticleSystem.subEmitters) {\r\n                const cellArray = [];\r\n                for (const sub of cell) {\r\n                    cellArray.push(SubEmitter.Parse(sub, sceneOrEngine, rootUrl));\r\n                }\r\n\r\n                particleSystem.subEmitters.push(cellArray);\r\n            }\r\n        }\r\n\r\n        ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);\r\n\r\n        if (parsedParticleSystem.textureMask) {\r\n            particleSystem.textureMask = Color4.FromArray(parsedParticleSystem.textureMask);\r\n        }\r\n\r\n        // Auto start\r\n        if (parsedParticleSystem.preventAutoStart) {\r\n            particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\r\n        }\r\n\r\n        if (!doNotStart && !particleSystem.preventAutoStart) {\r\n            particleSystem.start();\r\n        }\r\n\r\n        return particleSystem;\r\n    }\r\n}\r\n\r\nSubEmitter._ParseParticleSystem = ParticleSystem.Parse;\r\n"]},"metadata":{},"sourceType":"module"}