{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport { Tools } from \"../../../Misc/tools.js\";\nimport { SceneComponentConstants } from \"../../../sceneComponent.js\";\n/**\n * Defines the Procedural Texture scene component responsible to manage any Procedural Texture\n * in a given scene.\n */\n\nvar ProceduralTextureSceneComponent =\n/** @class */\nfunction () {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  function ProceduralTextureSceneComponent(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_PROCEDURALTEXTURE;\n    this.scene = scene;\n    this.scene.proceduralTextures = new Array();\n  }\n  /**\n   * Registers the component in a given scene\n   */\n\n\n  ProceduralTextureSceneComponent.prototype.register = function () {\n    this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE, this, this._beforeClear);\n  };\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n\n\n  ProceduralTextureSceneComponent.prototype.rebuild = function () {// Nothing to do here.\n  };\n  /**\n   * Disposes the component and the associated resources.\n   */\n\n\n  ProceduralTextureSceneComponent.prototype.dispose = function () {// Nothing to do here.\n  };\n\n  ProceduralTextureSceneComponent.prototype._beforeClear = function () {\n    if (this.scene.proceduralTexturesEnabled) {\n      Tools.StartPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\n\n      for (var proceduralIndex = 0; proceduralIndex < this.scene.proceduralTextures.length; proceduralIndex++) {\n        var proceduralTexture = this.scene.proceduralTextures[proceduralIndex];\n\n        if (proceduralTexture._shouldRender()) {\n          proceduralTexture.render();\n        }\n      }\n\n      Tools.EndPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\n    }\n  };\n\n  return ProceduralTextureSceneComponent;\n}();\n\nexport { ProceduralTextureSceneComponent };","map":{"version":3,"mappings":";AAAA,SAASA,KAAT,QAAsB,wBAAtB;AAGA,SAASC,uBAAT,QAAwC,4BAAxC;AAaA;;;;;AAIA;AAAA;AAAA;AAWI;;;;AAIA,2CAAYC,KAAZ,EAAwB;AAdxB;;;AAGgB,gBAAOD,uBAAuB,CAACE,sBAA/B;AAYZ,SAAKD,KAAL,GAAaA,KAAb;AACA,SAAKA,KAAL,CAAWE,kBAAX,GAAgC,IAAIC,KAAJ,EAAhC;AACH;AAED;;;;;AAGOC,uDAAP;AACI,SAAKJ,KAAL,CAAWK,iBAAX,CAA6BC,YAA7B,CAA0CP,uBAAuB,CAACQ,kCAAlE,EAAsG,IAAtG,EAA4G,KAAKC,YAAjH;AACH,GAFM;AAIP;;;;;;AAIOJ,sDAAP,aACI;AACH,GAFM;AAIP;;;;;AAGOA,sDAAP,aACI;AACH,GAFM;;AAICA,2DAAR;AACI,QAAI,KAAKJ,KAAL,CAAWS,yBAAf,EAA0C;AACtCX,WAAK,CAACY,uBAAN,CAA8B,qBAA9B,EAAqD,KAAKV,KAAL,CAAWE,kBAAX,CAA8BS,MAA9B,GAAuC,CAA5F;;AACA,WAAK,IAAIC,eAAe,GAAG,CAA3B,EAA8BA,eAAe,GAAG,KAAKZ,KAAL,CAAWE,kBAAX,CAA8BS,MAA9E,EAAsFC,eAAe,EAArG,EAAyG;AACrG,YAAMC,iBAAiB,GAAG,KAAKb,KAAL,CAAWE,kBAAX,CAA8BU,eAA9B,CAA1B;;AACA,YAAIC,iBAAiB,CAACC,aAAlB,EAAJ,EAAuC;AACnCD,2BAAiB,CAACE,MAAlB;AACH;AACJ;;AACDjB,WAAK,CAACkB,qBAAN,CAA4B,qBAA5B,EAAmD,KAAKhB,KAAL,CAAWE,kBAAX,CAA8BS,MAA9B,GAAuC,CAA1F;AACH;AACJ,GAXO;;AAYZ;AAAC,CAtDD","names":["Tools","SceneComponentConstants","scene","NAME_PROCEDURALTEXTURE","proceduralTextures","Array","ProceduralTextureSceneComponent","_beforeClearStage","registerStep","STEP_BEFORECLEAR_PROCEDURALTEXTURE","_beforeClear","proceduralTexturesEnabled","StartPerformanceCounter","length","proceduralIndex","proceduralTexture","_shouldRender","render","EndPerformanceCounter"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Materials/Textures/Procedurals/proceduralTextureSceneComponent.ts"],"sourcesContent":["import { Tools } from \"../../../Misc/tools\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { ISceneComponent } from \"../../../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\r\n\r\nimport type { ProceduralTexture } from \"./proceduralTexture\";\r\n\r\ndeclare module \"../../../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * The list of procedural textures added to the scene\r\n         * @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures\r\n         */\r\n        proceduralTextures: Array<ProceduralTexture>;\r\n    }\r\n}\r\n/**\r\n * Defines the Procedural Texture scene component responsible to manage any Procedural Texture\r\n * in a given scene.\r\n */\r\nexport class ProceduralTextureSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_PROCEDURALTEXTURE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this.scene.proceduralTextures = new Array<ProceduralTexture>();\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE, this, this._beforeClear);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    private _beforeClear(): void {\r\n        if (this.scene.proceduralTexturesEnabled) {\r\n            Tools.StartPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\r\n            for (let proceduralIndex = 0; proceduralIndex < this.scene.proceduralTextures.length; proceduralIndex++) {\r\n                const proceduralTexture = this.scene.proceduralTextures[proceduralIndex];\r\n                if (proceduralTexture._shouldRender()) {\r\n                    proceduralTexture.render();\r\n                }\r\n            }\r\n            Tools.EndPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}